import * as re from "react";
import pe, { useLayoutEffect as sI, useEffect as kc, useState as Pa, useRef as Va, useCallback as Pi } from "react";
function Gh(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in t)) {
          const s = Object.getOwnPropertyDescriptor(r, a);
          s && Object.defineProperty(t, a, s.get ? s : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
var _p = function(t, e) {
  return _p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      Object.prototype.hasOwnProperty.call(r, a) && (n[a] = r[a]);
  }, _p(t, e);
};
function oI(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  _p(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var _e = function() {
  return _e = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, _e.apply(this, arguments);
};
function ul(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function ot(t, e, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function i(u) {
      try {
        l(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      u.done ? s(u.value) : a(u.value).then(i, c);
    }
    l((r = r.apply(t, e || [])).next());
  });
}
function tt(t, e) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, o;
  return o = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function i(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (n = 0)), n; )
      try {
        if (r = 1, a && (s = l[0] & 2 ? a.return : l[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, l[1])).done)
          return s;
        switch (a = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return n.label++, { value: l[1], done: !1 };
          case 5:
            n.label++, a = l[1], l = [0];
            continue;
          case 7:
            l = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              n = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              n.label = l[1];
              break;
            }
            if (l[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = l;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(l);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        l = e.call(t, n);
      } catch (u) {
        l = [6, u], a = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function Jg(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Or(t) {
  return this instanceof Or ? (this.v = t, this) : new Or(t);
}
function r0(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), a, s = [];
  return a = {}, o("next"), o("throw"), o("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function o(f) {
    r[f] && (a[f] = function(p) {
      return new Promise(function(h, m) {
        s.push([f, p, h, m]) > 1 || i(f, p);
      });
    });
  }
  function i(f, p) {
    try {
      c(r[f](p));
    } catch (h) {
      d(s[0][3], h);
    }
  }
  function c(f) {
    f.value instanceof Or ? Promise.resolve(f.value.v).then(l, u) : d(s[0][2], f);
  }
  function l(f) {
    i("next", f);
  }
  function u(f) {
    i("throw", f);
  }
  function d(f, p) {
    f(p), s.shift(), s.length && i(s[0][0], s[0][1]);
  }
}
function a0(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Jg == "function" ? Jg(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = t[s] && function(o) {
      return new Promise(function(i, c) {
        o = t[s](o), a(i, c, o.done, o.value);
      });
    };
  }
  function a(s, o, i, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: i });
    }, o);
  }
}
const iI = "Logging", uI = "NoHubcallbackProvidedException";
var Ar;
(function(t) {
  t.DEBUG = "DEBUG", t.ERROR = "ERROR", t.INFO = "INFO", t.WARN = "WARN", t.VERBOSE = "VERBOSE", t.NONE = "NONE";
})(Ar || (Ar = {}));
const Qg = {
  VERBOSE: 1,
  DEBUG: 2,
  INFO: 3,
  WARN: 4,
  ERROR: 5,
  NONE: 6
};
class $s {
  /**
   * @constructor
   * @param {string} name - Name of the logger
   */
  constructor(e, n = Ar.WARN) {
    this.name = e, this.level = n, this._pluggables = [];
  }
  _padding(e) {
    return e < 10 ? "0" + e : "" + e;
  }
  _ts() {
    const e = /* @__PURE__ */ new Date();
    return [this._padding(e.getMinutes()), this._padding(e.getSeconds())].join(":") + "." + e.getMilliseconds();
  }
  configure(e) {
    return e ? (this._config = e, this._config) : this._config;
  }
  /**
   * Write log
   * @method
   * @memeberof Logger
   * @param {LogType|string} type - log type, default INFO
   * @param {string|object} msg - Logging message or object
   */
  _log(e, ...n) {
    let r = this.level;
    $s.LOG_LEVEL && (r = $s.LOG_LEVEL), typeof window < "u" && window.LOG_LEVEL && (r = window.LOG_LEVEL);
    const a = Qg[r];
    if (!(Qg[e] >= a))
      return;
    let o = console.log.bind(console);
    e === Ar.ERROR && console.error && (o = console.error.bind(console)), e === Ar.WARN && console.warn && (o = console.warn.bind(console));
    const i = `[${e}] ${this._ts()} ${this.name}`;
    let c = "";
    if (n.length === 1 && typeof n[0] == "string")
      c = `${i} - ${n[0]}`, o(c);
    else if (n.length === 1)
      c = `${i} ${n[0]}`, o(i, n[0]);
    else if (typeof n[0] == "string") {
      let l = n.slice(1);
      l.length === 1 && (l = l[0]), c = `${i} - ${n[0]} ${l}`, o(`${i} - ${n[0]}`, l);
    } else
      c = `${i} ${n}`, o(i, n);
    for (const l of this._pluggables) {
      const u = { message: c, timestamp: Date.now() };
      l.pushLogs([u]);
    }
  }
  /**
   * Write General log. Default to INFO
   * @method
   * @memeberof Logger
   * @param {string|object} msg - Logging message or object
   */
  log(...e) {
    this._log(Ar.INFO, ...e);
  }
  /**
   * Write INFO log
   * @method
   * @memeberof Logger
   * @param {string|object} msg - Logging message or object
   */
  info(...e) {
    this._log(Ar.INFO, ...e);
  }
  /**
   * Write WARN log
   * @method
   * @memeberof Logger
   * @param {string|object} msg - Logging message or object
   */
  warn(...e) {
    this._log(Ar.WARN, ...e);
  }
  /**
   * Write ERROR log
   * @method
   * @memeberof Logger
   * @param {string|object} msg - Logging message or object
   */
  error(...e) {
    this._log(Ar.ERROR, ...e);
  }
  /**
   * Write DEBUG log
   * @method
   * @memeberof Logger
   * @param {string|object} msg - Logging message or object
   */
  debug(...e) {
    this._log(Ar.DEBUG, ...e);
  }
  /**
   * Write VERBOSE log
   * @method
   * @memeberof Logger
   * @param {string|object} msg - Logging message or object
   */
  verbose(...e) {
    this._log(Ar.VERBOSE, ...e);
  }
  addPluggable(e) {
    e && e.getCategoryName() === iI && (this._pluggables.push(e), e.configure(this._config));
  }
  listPluggables() {
    return this._pluggables;
  }
}
$s.LOG_LEVEL = null;
class qi extends Error {
  /**
   *  Constructs an AmplifyError.
   *
   * @param message text that describes the main problem.
   * @param underlyingError the underlying cause of the error.
   * @param recoverySuggestion suggestion to recover from the error.
   *
   */
  constructor({ message: e, name: n, recoverySuggestion: r, underlyingError: a }) {
    super(e), this.name = n, this.underlyingError = a, this.recoverySuggestion = r, this.constructor = qi, Object.setPrototypeOf(this, qi.prototype);
  }
}
const s0 = typeof Symbol < "u" ? Symbol("amplify_default") : "@@amplify_default", si = new $s("Hub");
class cI {
  constructor(e) {
    this.listeners = /* @__PURE__ */ new Map(), this.protectedChannels = [
      "core",
      "auth",
      "api",
      "analytics",
      "interactions",
      "pubsub",
      "storage",
      "ui",
      "xr"
    ], this.name = e;
  }
  /**
   * Used internally to remove a Hub listener.
   *
   * @remarks
   * This private method is for internal use only. Instead of calling Hub.remove, call the result of Hub.listen.
   */
  _remove(e, n) {
    const r = this.listeners.get(e);
    if (!r) {
      si.warn(`No listeners for ${e}`);
      return;
    }
    this.listeners.set(e, [
      ...r.filter(({ callback: a }) => a !== n)
    ]);
  }
  dispatch(e, n, r, a) {
    typeof e == "string" && this.protectedChannels.indexOf(e) > -1 && (a === s0 || si.warn(`WARNING: ${e} is protected and dispatching on it can have unintended consequences`));
    const s = {
      channel: e,
      payload: { ...n },
      source: r,
      patternInfo: []
    };
    try {
      this._toListeners(s);
    } catch (o) {
      si.error(o);
    }
  }
  listen(e, n, r = "noname") {
    let a;
    if (typeof n != "function")
      throw new qi({
        name: uI,
        message: "No callback supplied to Hub"
      });
    a = n;
    let s = this.listeners.get(e);
    return s || (s = [], this.listeners.set(e, s)), s.push({
      name: r,
      callback: a
    }), () => {
      this._remove(e, a);
    };
  }
  _toListeners(e) {
    const { channel: n, payload: r } = e, a = this.listeners.get(n);
    a && a.forEach((s) => {
      si.debug(`Dispatching to ${n} with `, r);
      try {
        s.callback(e);
      } catch (o) {
        si.error(o);
      }
    });
  }
}
const lI = new cI("__default__"), dI = new $s("parseAWSExports"), fI = {
  API_KEY: "apiKey",
  AWS_IAM: "iam",
  AMAZON_COGNITO_USER_POOLS: "userPool",
  OPENID_CONNECT: "oidc",
  NONE: "none",
  AWS_LAMBDA: "lambda",
  // `LAMBDA` is an incorrect value that was added during the v6 rewrite.
  // Keeping it as a valid value until v7 to prevent breaking customers who might
  // be relying on it as a workaround.
  // ref: https://github.com/aws-amplify/amplify-js/pull/12922
  // TODO: @v7 remove next line
  LAMBDA: "lambda"
}, pI = (t = {}) => {
  if (!Object.prototype.hasOwnProperty.call(t, "aws_project_region"))
    throw new qi({
      name: "InvalidParameterException",
      message: "Invalid config parameter.",
      recoverySuggestion: "Ensure passing the config object imported from  `amplifyconfiguration.json`."
    });
  const { aws_appsync_apiKey: e, aws_appsync_authenticationType: n, aws_appsync_graphqlEndpoint: r, aws_appsync_region: a, aws_bots_config: s, aws_cognito_identity_pool_id: o, aws_cognito_sign_up_verification_method: i, aws_cognito_mfa_configuration: c, aws_cognito_mfa_types: l, aws_cognito_password_protection_settings: u, aws_cognito_verification_mechanisms: d, aws_cognito_signup_attributes: f, aws_cognito_social_providers: p, aws_cognito_username_attributes: h, aws_mandatory_sign_in: m, aws_mobile_analytics_app_id: g, aws_mobile_analytics_app_region: v, aws_user_files_s3_bucket: b, aws_user_files_s3_bucket_region: w, aws_user_files_s3_dangerously_connect_to_http_endpoint_for_testing: S, aws_user_pools_id: I, aws_user_pools_web_client_id: E, geo: T, oauth: R, predictions: $, aws_cloud_logic_custom: D, Notifications: M, modelIntrospection: z } = t, F = {};
  g && (F.Analytics = {
    Pinpoint: {
      appId: g,
      region: v
    }
  });
  const { InAppMessaging: V, Push: H } = M ?? {};
  if (V?.AWSPinpoint || H?.AWSPinpoint) {
    if (V?.AWSPinpoint) {
      const { appId: ne, region: oe } = V.AWSPinpoint;
      F.Notifications = {
        InAppMessaging: {
          Pinpoint: {
            appId: ne,
            region: oe
          }
        }
      };
    }
    if (H?.AWSPinpoint) {
      const { appId: ne, region: oe } = H.AWSPinpoint;
      F.Notifications = {
        ...F.Notifications,
        PushNotification: {
          Pinpoint: {
            appId: ne,
            region: oe
          }
        }
      };
    }
  }
  if (Array.isArray(s) && (F.Interactions = {
    LexV1: Object.fromEntries(s.map((ne) => [ne.name, ne]))
  }), r) {
    const ne = fI[n];
    ne || dI.debug(`Invalid authentication type ${n}. Falling back to IAM.`), F.API = {
      GraphQL: {
        endpoint: r,
        apiKey: e,
        region: a,
        defaultAuthMode: ne ?? "iam"
      }
    }, z && (F.API.GraphQL.modelIntrospection = z);
  }
  const U = c ? {
    status: c && c.toLowerCase(),
    totpEnabled: l?.includes("TOTP") ?? !1,
    smsEnabled: l?.includes("SMS") ?? !1
  } : void 0, Z = u ? {
    minLength: u.passwordPolicyMinLength,
    requireLowercase: u.passwordPolicyCharacters?.includes("REQUIRES_LOWERCASE") ?? !1,
    requireUppercase: u.passwordPolicyCharacters?.includes("REQUIRES_UPPERCASE") ?? !1,
    requireNumbers: u.passwordPolicyCharacters?.includes("REQUIRES_NUMBERS") ?? !1,
    requireSpecialCharacters: u.passwordPolicyCharacters?.includes("REQUIRES_SYMBOLS") ?? !1
  } : void 0, X = Array.from(/* @__PURE__ */ new Set([
    ...d ?? [],
    ...f ?? []
  ])).reduce((ne, oe) => ({
    ...ne,
    // All user attributes generated by the CLI are required
    [oe.toLowerCase()]: { required: !0 }
  }), {}), se = h?.includes("EMAIL") ?? !1, te = h?.includes("PHONE_NUMBER") ?? !1;
  (o || I) && (F.Auth = {
    Cognito: {
      identityPoolId: o,
      allowGuestAccess: m !== "enable",
      signUpVerificationMethod: i,
      userAttributes: X,
      userPoolClientId: E,
      userPoolId: I,
      mfa: U,
      passwordFormat: Z,
      loginWith: {
        username: !(se || te),
        email: se,
        phone: te
      }
    }
  });
  const ue = R ? Object.keys(R).length > 0 : !1, ee = p ? p.length > 0 : !1;
  if (F.Auth && ue && (F.Auth.Cognito.loginWith = {
    ...F.Auth.Cognito.loginWith,
    oauth: {
      ...hI(R),
      ...ee && {
        providers: mI(p)
      }
    }
  }), b && (F.Storage = {
    S3: {
      bucket: b,
      region: w,
      dangerouslyConnectToHttpEndpointForTesting: S
    }
  }), T) {
    const { amazon_location_service: ne } = T;
    F.Geo = ne ? {
      LocationService: {
        ...ne,
        searchIndices: ne.search_indices,
        region: ne.region
      }
    } : { ...T };
  }
  if (D && (F.API = {
    ...F.API,
    REST: D.reduce((ne, oe) => {
      const { name: ge, endpoint: be, region: fe, service: we } = oe;
      return {
        ...ne,
        [ge]: {
          endpoint: be,
          ...we ? { service: we } : void 0,
          ...fe ? { region: fe } : void 0
        }
      };
    }, {})
  }), $) {
    const { VoiceId: ne } = $?.convert?.speechGenerator?.defaults ?? {};
    F.Predictions = ne ? {
      ...$,
      convert: {
        ...$.convert,
        speechGenerator: {
          ...$.convert.speechGenerator,
          defaults: { voiceId: ne }
        }
      }
    } : $;
  }
  return F;
}, ey = (t) => t?.split(",") ?? [], hI = ({ domain: t, scope: e, redirectSignIn: n, redirectSignOut: r, responseType: a }) => ({
  domain: t,
  scopes: e,
  redirectSignIn: ey(n),
  redirectSignOut: ey(r),
  responseType: a
}), mI = (t) => t.map((e) => {
  const n = e.toLowerCase();
  return n.charAt(0).toUpperCase() + n.slice(1);
}), gI = (t) => t && t["nonRetryable"], ec = new $s("retryUtil");
async function yI(t, e, n, r) {
  if (typeof t != "function")
    throw Error("functionToRetry must be a function");
  return new Promise(async (a, s) => {
    let o = 0, i = !1, c, l = () => {
    }, u;
    for (r && r.then(() => {
      i = !0, clearTimeout(c), l();
    }); !i; ) {
      o++, ec.debug(`${t.name} attempt #${o} with this vars: ${JSON.stringify(e)}`);
      try {
        a(await t(...e));
        return;
      } catch (d) {
        if (u = d, ec.debug(`error on ${t.name}`, d), gI(d)) {
          ec.debug(`${t.name} non retryable error`, d), s(d);
          return;
        }
        const f = n(o, e, d);
        if (ec.debug(`${t.name} retrying in ${f} ms`), f === !1 || i) {
          s(d);
          return;
        } else
          await new Promise((p) => {
            l = p, c = setTimeout(l, f);
          });
      }
    }
    s(u);
  });
}
const o0 = (t) => {
  const e = Reflect.ownKeys(t);
  for (const n of e) {
    const r = t[n];
    (r && typeof r == "object" || typeof r == "function") && o0(r);
  }
  return Object.freeze(t);
};
class vI {
  /**
   * Configure Auth category
   *
   * @internal
   *
   * @param authResourcesConfig - Resources configurations required by Auth providers.
   * @param authOptions - Client options used by library
   *
   * @returns void
   */
  configure(e, n) {
    this.authConfig = e, this.authOptions = n;
  }
  /**
   * Fetch the auth tokens, and the temporary AWS credentials and identity if they are configured. By default it
   * does not refresh the auth tokens or credentials if they are loaded in storage already. You can force a refresh
   * with `{ forceRefresh: true }` input.
   *
   * @param options - Options configuring the fetch behavior.
   *
   * @returns Promise of current auth session {@link AuthSession}.
   */
  async fetchAuthSession(e = {}) {
    let n, r;
    const a = await this.getTokens(e);
    return a ? (r = a.accessToken?.payload?.sub, n = await this.authOptions?.credentialsProvider?.getCredentialsAndIdentityId({
      authConfig: this.authConfig,
      tokens: a,
      authenticated: !0,
      forceRefresh: e.forceRefresh
    })) : n = await this.authOptions?.credentialsProvider?.getCredentialsAndIdentityId({
      authConfig: this.authConfig,
      authenticated: !1,
      forceRefresh: e.forceRefresh
    }), {
      tokens: a,
      credentials: n?.credentials,
      identityId: n?.identityId,
      userSub: r
    };
  }
  async clearCredentials() {
    await this.authOptions?.credentialsProvider?.clearCredentialsAndIdentityId();
  }
  async getTokens(e) {
    return await this.authOptions?.tokenProvider?.getTokens(e) ?? void 0;
  }
}
const bI = Symbol("oauth-listener");
class wI {
  constructor() {
    this.oAuthListener = void 0, this.resourcesConfig = {}, this.libraryOptions = {}, this.Auth = new vI();
  }
  /**
   * Configures Amplify for use with your back-end resources.
   *
   * @remarks
   * This API does not perform any merging of either `resourcesConfig` or `libraryOptions`. The most recently
   * provided values will be used after configuration.
   *
   * @remarks
   * `configure` can be used to specify additional library options where available for supported categories.
   *
   * @param resourceConfig - Back-end resource configuration. Typically provided via the `aws-exports.js` file.
   * @param libraryOptions - Additional options for customizing the behavior of the library.
   */
  configure(e, n) {
    let r;
    Object.keys(e).some((a) => a.startsWith("aws_")) ? r = pI(e) : r = e, this.resourcesConfig = r, n && (this.libraryOptions = n), this.resourcesConfig = o0(this.resourcesConfig), this.Auth.configure(this.resourcesConfig.Auth, this.libraryOptions.Auth), lI.dispatch("core", {
      event: "configure",
      data: this.resourcesConfig
    }, "Configure", s0), this.notifyOAuthListener();
  }
  /**
   * Provides access to the current back-end resource configuration for the Library.
   *
   * @returns Returns the immutable back-end resource configuration.
   */
  getConfig() {
    return this.resourcesConfig;
  }
  /** @internal */
  [bI](e) {
    this.resourcesConfig.Auth?.Cognito.loginWith?.oauth ? e(this.resourcesConfig.Auth?.Cognito) : this.oAuthListener = e;
  }
  notifyOAuthListener() {
    !this.resourcesConfig.Auth?.Cognito.loginWith?.oauth || !this.oAuthListener || (this.oAuthListener(this.resourcesConfig.Auth?.Cognito), this.oAuthListener = void 0);
  }
}
const SI = new wI(), _I = (t, e) => t.Auth.fetchAuthSession(e), i0 = (t) => _I(SI, t), _u = (t) => new TextEncoder().encode(t), Bi = (t) => typeof t == "string" ? _u(t) : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(t), qh = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number")
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  return new TextDecoder("utf-8").decode(t);
}, u0 = 5 * 60 * 1e3;
function xI(t = u0) {
  return (r) => {
    const a = 2 ** r * 100 + 100 * Math.random();
    return a > t ? !1 : a;
  };
}
var sn;
(function(t) {
  t.WebUnknown = "0", t.React = "1", t.NextJs = "2", t.Angular = "3", t.VueJs = "4", t.Nuxt = "5", t.Svelte = "6", t.ServerSideUnknown = "100", t.ReactSSR = "101", t.NextJsSSR = "102", t.AngularSSR = "103", t.VueJsSSR = "104", t.NuxtSSR = "105", t.SvelteSSR = "106", t.ReactNative = "201", t.Expo = "202";
})(sn || (sn = {}));
var ty;
(function(t) {
  t.API = "api", t.Auth = "auth", t.Analytics = "analytics", t.DataStore = "datastore", t.Geo = "geo", t.InAppMessaging = "inappmessaging", t.Interactions = "interactions", t.Predictions = "predictions", t.PubSub = "pubsub", t.PushNotification = "pushnotification", t.Storage = "storage";
})(ty || (ty = {}));
var ny;
(function(t) {
  t.Record = "1", t.IdentifyUser = "2";
})(ny || (ny = {}));
var ry;
(function(t) {
  t.GraphQl = "1", t.Get = "2", t.Post = "3", t.Put = "4", t.Patch = "5", t.Del = "6", t.Head = "7";
})(ry || (ry = {}));
var ay;
(function(t) {
  t.SignUp = "1", t.ConfirmSignUp = "2", t.ResendSignUpCode = "3", t.SignIn = "4", t.FetchMFAPreference = "6", t.UpdateMFAPreference = "7", t.SetUpTOTP = "10", t.VerifyTOTPSetup = "11", t.ConfirmSignIn = "12", t.DeleteUserAttributes = "15", t.DeleteUser = "16", t.UpdateUserAttributes = "17", t.FetchUserAttributes = "18", t.ConfirmUserAttribute = "22", t.SignOut = "26", t.UpdatePassword = "27", t.ResetPassword = "28", t.ConfirmResetPassword = "29", t.FederatedSignIn = "30", t.RememberDevice = "32", t.ForgetDevice = "33", t.FetchDevices = "34", t.SendUserAttributeVerificationCode = "35", t.SignInWithRedirect = "36";
})(ay || (ay = {}));
var sy;
(function(t) {
  t.Subscribe = "1", t.GraphQl = "2";
})(sy || (sy = {}));
var oy;
(function(t) {
  t.SearchByText = "0", t.SearchByCoordinates = "1", t.SearchForSuggestions = "2", t.SearchByPlaceId = "3", t.SaveGeofences = "4", t.GetGeofence = "5", t.ListGeofences = "6", t.DeleteGeofences = "7";
})(oy || (oy = {}));
var iy;
(function(t) {
  t.SyncMessages = "1", t.IdentifyUser = "2", t.NotifyMessageInteraction = "3";
})(iy || (iy = {}));
var uy;
(function(t) {
  t.None = "0";
})(uy || (uy = {}));
var cy;
(function(t) {
  t.Convert = "1", t.Identify = "2", t.Interpret = "3";
})(cy || (cy = {}));
var ly;
(function(t) {
  t.Subscribe = "1";
})(ly || (ly = {}));
var dy;
(function(t) {
  t.InitializePushNotifications = "1", t.IdentifyUser = "2";
})(dy || (dy = {}));
var fy;
(function(t) {
  t.UploadData = "1", t.DownloadData = "2", t.List = "3", t.Copy = "4", t.Remove = "5", t.GetProperties = "6", t.GetUrl = "7";
})(fy || (fy = {}));
const II = "6.0.20", cl = () => typeof global < "u", Fo = () => typeof window < "u", c0 = () => typeof document < "u", Kh = () => typeof process < "u", Ki = (t, e) => !!Object.keys(t).find((n) => n.startsWith(e));
function kI() {
  const t = (r) => r.startsWith("_react") || r.startsWith("__react"), e = (r) => Object.keys(r).find(t), n = () => Array.from(document.querySelectorAll("[id]"));
  return c0() && n().some(e);
}
function EI() {
  return Kh() && typeof process.env < "u" && !!Object.keys(process.env).find((t) => t.includes("react"));
}
function TI() {
  return Fo() && Ki(window, "__VUE");
}
function CI() {
  return cl() && Ki(global, "__VUE");
}
function NI() {
  return Fo() && Ki(window, "__SVELTE");
}
function AI() {
  return Kh() && typeof process.env < "u" && !!Object.keys(process.env).find((t) => t.includes("svelte"));
}
function RI() {
  return Fo() && window.next && typeof window.next == "object";
}
function $I() {
  return cl() && (Ki(global, "__next") || Ki(global, "__NEXT"));
}
function DI() {
  return Fo() && (window.__NUXT__ !== void 0 || window.$nuxt !== void 0);
}
function OI() {
  return cl() && typeof global.__NUXT_PATHS__ < "u";
}
function FI() {
  const t = !!(c0() && document.querySelector("[ng-version]")), e = !!(Fo() && typeof window.ng < "u");
  return t || e;
}
function MI() {
  return Kh() && typeof process.env == "object" && process.env.npm_lifecycle_script?.startsWith("ng ") || !1;
}
function PI() {
  return typeof navigator < "u" && typeof navigator.product < "u" && navigator.product === "ReactNative";
}
function BI() {
  return cl() && typeof global.expo < "u";
}
function LI() {
  return Fo();
}
const WI = [
  // First, detect mobile
  { platform: sn.Expo, detectionMethod: BI },
  { platform: sn.ReactNative, detectionMethod: PI },
  // Next, detect web frameworks
  { platform: sn.NextJs, detectionMethod: RI },
  { platform: sn.Nuxt, detectionMethod: DI },
  { platform: sn.Angular, detectionMethod: FI },
  { platform: sn.React, detectionMethod: kI },
  { platform: sn.VueJs, detectionMethod: TI },
  { platform: sn.Svelte, detectionMethod: NI },
  { platform: sn.WebUnknown, detectionMethod: LI },
  // Last, detect ssr frameworks
  { platform: sn.NextJsSSR, detectionMethod: $I },
  { platform: sn.NuxtSSR, detectionMethod: OI },
  { platform: sn.ReactSSR, detectionMethod: EI },
  { platform: sn.VueJsSSR, detectionMethod: CI },
  { platform: sn.AngularSSR, detectionMethod: MI },
  { platform: sn.SvelteSSR, detectionMethod: AI }
];
function zI() {
  return WI.find((t) => t.detectionMethod())?.platform || sn.ServerSideUnknown;
}
let Li;
const Bf = [];
let xp = !1;
const VI = 10, HI = 10, jI = 1e3, l0 = () => {
  if (!Li) {
    if (Li = zI(), xp)
      for (; Bf.length; )
        Bf.pop()?.();
    else
      Bf.forEach((t) => {
        t();
      });
    py(sn.ServerSideUnknown, VI), py(sn.WebUnknown, HI);
  }
  return Li;
};
function UI() {
  Li = void 0;
}
function py(t, e) {
  Li === t && !xp && setTimeout(() => {
    UI(), xp = !0, setTimeout(l0, jI);
  }, e);
}
const GI = {}, qI = (t, e) => GI[t]?.[e]?.additionalDetails, KI = "aws-amplify", XI = ({ category: t, action: e } = {}) => {
  const n = [[KI, II]];
  if (t && n.push([t, e]), n.push(["framework", l0()]), t && e) {
    const r = qI(t, e);
    r && r.forEach((a) => {
      n.push(a);
    });
  }
  return n;
}, YI = (t) => XI(t).map(([r, a]) => r && a ? `${r}/${a}` : r).join(" "), ZI = (t, e, n = u0, r) => yI(t, e, xI(n), r);
var $n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Vs(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function _a(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var a = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, a.get ? a : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var d0 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ip = function(t, e) {
  return Ip = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (n[a] = r[a]);
  }, Ip(t, e);
};
function JI(t, e) {
  Ip(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var kp = function() {
  return kp = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, kp.apply(this, arguments);
};
function QI(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function ek(t, e, n, r) {
  var a = arguments.length, s = a < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var i = t.length - 1; i >= 0; i--)
      (o = t[i]) && (s = (a < 3 ? o(s) : a > 3 ? o(e, n, s) : o(e, n)) || s);
  return a > 3 && s && Object.defineProperty(e, n, s), s;
}
function tk(t, e) {
  return function(n, r) {
    e(n, r, t);
  };
}
function nk(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function rk(t, e, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function i(u) {
      try {
        l(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      u.done ? s(u.value) : a(u.value).then(i, c);
    }
    l((r = r.apply(t, e || [])).next());
  });
}
function ak(t, e) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, o;
  return o = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function i(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, a && (s = l[0] & 2 ? a.return : l[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, l[1])).done)
          return s;
        switch (a = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return n.label++, { value: l[1], done: !1 };
          case 5:
            n.label++, a = l[1], l = [0];
            continue;
          case 7:
            l = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              n = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              n.label = l[1];
              break;
            }
            if (l[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = l;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(l);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        l = e.call(t, n);
      } catch (u) {
        l = [6, u], a = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function sk(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}
function ok(t, e) {
  for (var n in t)
    n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n]);
}
function Ep(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function f0(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), a, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (i) {
    o = { error: i };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function ik() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(f0(arguments[e]));
  return t;
}
function uk() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), a = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, i = s.length; o < i; o++, a++)
      r[a] = s[o];
  return r;
}
function Xi(t) {
  return this instanceof Xi ? (this.v = t, this) : new Xi(t);
}
function ck(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), a, s = [];
  return a = {}, o("next"), o("throw"), o("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function o(f) {
    r[f] && (a[f] = function(p) {
      return new Promise(function(h, m) {
        s.push([f, p, h, m]) > 1 || i(f, p);
      });
    });
  }
  function i(f, p) {
    try {
      c(r[f](p));
    } catch (h) {
      d(s[0][3], h);
    }
  }
  function c(f) {
    f.value instanceof Xi ? Promise.resolve(f.value.v).then(l, u) : d(s[0][2], f);
  }
  function l(f) {
    i("next", f);
  }
  function u(f) {
    i("throw", f);
  }
  function d(f, p) {
    f(p), s.shift(), s.length && i(s[0][0], s[0][1]);
  }
}
function lk(t) {
  var e, n;
  return e = {}, r("next"), r("throw", function(a) {
    throw a;
  }), r("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function r(a, s) {
    e[a] = t[a] ? function(o) {
      return (n = !n) ? { value: Xi(t[a](o)), done: a === "return" } : s ? s(o) : o;
    } : s;
  }
}
function dk(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Ep == "function" ? Ep(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = t[s] && function(o) {
      return new Promise(function(i, c) {
        o = t[s](o), a(i, c, o.done, o.value);
      });
    };
  }
  function a(s, o, i, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: i });
    }, o);
  }
}
function fk(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function pk(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return e.default = t, e;
}
function hk(t) {
  return t && t.__esModule ? t : { default: t };
}
function mk(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function gk(t, e, n) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, n), n;
}
const yk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return kp;
  },
  __asyncDelegator: lk,
  __asyncGenerator: ck,
  __asyncValues: dk,
  __await: Xi,
  __awaiter: rk,
  __classPrivateFieldGet: mk,
  __classPrivateFieldSet: gk,
  __createBinding: sk,
  __decorate: ek,
  __exportStar: ok,
  __extends: JI,
  __generator: ak,
  __importDefault: hk,
  __importStar: pk,
  __makeTemplateObject: fk,
  __metadata: nk,
  __param: tk,
  __read: f0,
  __rest: QI,
  __spread: ik,
  __spreadArrays: uk,
  __values: Ep
}, Symbol.toStringTag, { value: "Module" })), p0 = /* @__PURE__ */ _a(yk);
var oi = {}, ur = {}, hy;
function h0() {
  return hy || (hy = 1, Object.defineProperty(ur, "__esModule", { value: !0 }), ur.MAX_HASHABLE_LENGTH = ur.INIT = ur.KEY = ur.DIGEST_LENGTH = ur.BLOCK_SIZE = void 0, ur.BLOCK_SIZE = 64, ur.DIGEST_LENGTH = 32, ur.KEY = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), ur.INIT = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], ur.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1), ur;
}
var ii = {}, my;
function vk() {
  if (my)
    return ii;
  my = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.RawSha256 = void 0;
  var t = h0(), e = (
    /** @class */
    function() {
      function n() {
        this.state = Int32Array.from(t.INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1;
      }
      return n.prototype.update = function(r) {
        if (this.finished)
          throw new Error("Attempted to update an already finished hash.");
        var a = 0, s = r.byteLength;
        if (this.bytesHashed += s, this.bytesHashed * 8 > t.MAX_HASHABLE_LENGTH)
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        for (; s > 0; )
          this.buffer[this.bufferLength++] = r[a++], s--, this.bufferLength === t.BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0);
      }, n.prototype.digest = function() {
        if (!this.finished) {
          var r = this.bytesHashed * 8, a = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength), s = this.bufferLength;
          if (a.setUint8(this.bufferLength++, 128), s % t.BLOCK_SIZE >= t.BLOCK_SIZE - 8) {
            for (var o = this.bufferLength; o < t.BLOCK_SIZE; o++)
              a.setUint8(o, 0);
            this.hashBuffer(), this.bufferLength = 0;
          }
          for (var o = this.bufferLength; o < t.BLOCK_SIZE - 8; o++)
            a.setUint8(o, 0);
          a.setUint32(t.BLOCK_SIZE - 8, Math.floor(r / 4294967296), !0), a.setUint32(t.BLOCK_SIZE - 4, r), this.hashBuffer(), this.finished = !0;
        }
        for (var i = new Uint8Array(t.DIGEST_LENGTH), o = 0; o < 8; o++)
          i[o * 4] = this.state[o] >>> 24 & 255, i[o * 4 + 1] = this.state[o] >>> 16 & 255, i[o * 4 + 2] = this.state[o] >>> 8 & 255, i[o * 4 + 3] = this.state[o] >>> 0 & 255;
        return i;
      }, n.prototype.hashBuffer = function() {
        for (var r = this, a = r.buffer, s = r.state, o = s[0], i = s[1], c = s[2], l = s[3], u = s[4], d = s[5], f = s[6], p = s[7], h = 0; h < t.BLOCK_SIZE; h++) {
          if (h < 16)
            this.temp[h] = (a[h * 4] & 255) << 24 | (a[h * 4 + 1] & 255) << 16 | (a[h * 4 + 2] & 255) << 8 | a[h * 4 + 3] & 255;
          else {
            var m = this.temp[h - 2], g = (m >>> 17 | m << 15) ^ (m >>> 19 | m << 13) ^ m >>> 10;
            m = this.temp[h - 15];
            var v = (m >>> 7 | m << 25) ^ (m >>> 18 | m << 14) ^ m >>> 3;
            this.temp[h] = (g + this.temp[h - 7] | 0) + (v + this.temp[h - 16] | 0);
          }
          var b = (((u >>> 6 | u << 26) ^ (u >>> 11 | u << 21) ^ (u >>> 25 | u << 7)) + (u & d ^ ~u & f) | 0) + (p + (t.KEY[h] + this.temp[h] | 0) | 0) | 0, w = ((o >>> 2 | o << 30) ^ (o >>> 13 | o << 19) ^ (o >>> 22 | o << 10)) + (o & i ^ o & c ^ i & c) | 0;
          p = f, f = d, d = u, u = l + b | 0, l = c, c = i, i = o, o = b + w | 0;
        }
        s[0] += o, s[1] += i, s[2] += c, s[3] += l, s[4] += u, s[5] += d, s[6] += f, s[7] += p;
      }, n;
    }()
  );
  return ii.RawSha256 = e, ii;
}
var Lf = {}, ui = {};
const bk = (t) => {
  const e = [];
  for (let n = 0, r = t.length; n < r; n++) {
    const a = t.charCodeAt(n);
    if (a < 128)
      e.push(a);
    else if (a < 2048)
      e.push(a >> 6 | 192, a & 63 | 128);
    else if (n + 1 < t.length && (a & 64512) === 55296 && (t.charCodeAt(n + 1) & 64512) === 56320) {
      const s = 65536 + ((a & 1023) << 10) + (t.charCodeAt(++n) & 1023);
      e.push(s >> 18 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, s & 63 | 128);
    } else
      e.push(a >> 12 | 224, a >> 6 & 63 | 128, a & 63 | 128);
  }
  return Uint8Array.from(e);
}, wk = (t) => {
  let e = "";
  for (let n = 0, r = t.length; n < r; n++) {
    const a = t[n];
    if (a < 128)
      e += String.fromCharCode(a);
    else if (192 <= a && a < 224) {
      const s = t[++n];
      e += String.fromCharCode((a & 31) << 6 | s & 63);
    } else if (240 <= a && a < 365) {
      const o = "%" + [a, t[++n], t[++n], t[++n]].map((i) => i.toString(16)).join("%");
      e += decodeURIComponent(o);
    } else
      e += String.fromCharCode((a & 15) << 12 | (t[++n] & 63) << 6 | t[++n] & 63);
  }
  return e;
};
function Sk(t) {
  return new TextEncoder().encode(t);
}
function _k(t) {
  return new TextDecoder("utf-8").decode(t);
}
const xk = (t) => typeof TextEncoder == "function" ? Sk(t) : bk(t), Ik = (t) => typeof TextDecoder == "function" ? _k(t) : wk(t), kk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromUtf8: xk,
  toUtf8: Ik
}, Symbol.toStringTag, { value: "Module" })), m0 = /* @__PURE__ */ _a(kk);
var gy;
function Ek() {
  if (gy)
    return ui;
  gy = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.convertToBuffer = void 0;
  var t = m0, e = typeof Buffer < "u" && Buffer.from ? function(r) {
    return Buffer.from(r, "utf8");
  } : t.fromUtf8;
  function n(r) {
    return r instanceof Uint8Array ? r : typeof r == "string" ? e(r) : ArrayBuffer.isView(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(r);
  }
  return ui.convertToBuffer = n, ui;
}
var ci = {}, yy;
function Tk() {
  if (yy)
    return ci;
  yy = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.isEmptyData = void 0;
  function t(e) {
    return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
  }
  return ci.isEmptyData = t, ci;
}
var li = {}, vy;
function Ck() {
  if (vy)
    return li;
  vy = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.numToUint8 = void 0;
  function t(e) {
    return new Uint8Array([
      (e & 4278190080) >> 24,
      (e & 16711680) >> 16,
      (e & 65280) >> 8,
      e & 255
    ]);
  }
  return li.numToUint8 = t, li;
}
var di = {}, by;
function Nk() {
  if (by)
    return di;
  by = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.uint32ArrayFrom = void 0;
  function t(e) {
    if (!Uint32Array.from) {
      for (var n = new Uint32Array(e.length), r = 0; r < e.length; )
        n[r] = e[r], r += 1;
      return n;
    }
    return Uint32Array.from(e);
  }
  return di.uint32ArrayFrom = t, di;
}
var wy;
function xu() {
  return wy || (wy = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.uint32ArrayFrom = t.numToUint8 = t.isEmptyData = t.convertToBuffer = void 0;
    var e = Ek();
    Object.defineProperty(t, "convertToBuffer", { enumerable: !0, get: function() {
      return e.convertToBuffer;
    } });
    var n = Tk();
    Object.defineProperty(t, "isEmptyData", { enumerable: !0, get: function() {
      return n.isEmptyData;
    } });
    var r = Ck();
    Object.defineProperty(t, "numToUint8", { enumerable: !0, get: function() {
      return r.numToUint8;
    } });
    var a = Nk();
    Object.defineProperty(t, "uint32ArrayFrom", { enumerable: !0, get: function() {
      return a.uint32ArrayFrom;
    } });
  }(Lf)), Lf;
}
var Sy;
function Ak() {
  if (Sy)
    return oi;
  Sy = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.Sha256 = void 0;
  var t = p0, e = h0(), n = vk(), r = xu(), a = (
    /** @class */
    function() {
      function o(i) {
        this.secret = i, this.hash = new n.RawSha256(), this.reset();
      }
      return o.prototype.update = function(i) {
        if (!((0, r.isEmptyData)(i) || this.error))
          try {
            this.hash.update((0, r.convertToBuffer)(i));
          } catch (c) {
            this.error = c;
          }
      }, o.prototype.digestSync = function() {
        if (this.error)
          throw this.error;
        return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest();
      }, o.prototype.digest = function() {
        return t.__awaiter(this, void 0, void 0, function() {
          return t.__generator(this, function(i) {
            return [2, this.digestSync()];
          });
        });
      }, o.prototype.reset = function() {
        if (this.hash = new n.RawSha256(), this.secret) {
          this.outer = new n.RawSha256();
          var i = s(this.secret), c = new Uint8Array(e.BLOCK_SIZE);
          c.set(i);
          for (var l = 0; l < e.BLOCK_SIZE; l++)
            i[l] ^= 54, c[l] ^= 92;
          this.hash.update(i), this.outer.update(c);
          for (var l = 0; l < i.byteLength; l++)
            i[l] = 0;
        }
      }, o;
    }()
  );
  oi.Sha256 = a;
  function s(o) {
    var i = (0, r.convertToBuffer)(o);
    if (i.byteLength > e.BLOCK_SIZE) {
      var c = new n.RawSha256();
      c.update(i), i = c.digest();
    }
    var l = new Uint8Array(e.BLOCK_SIZE);
    return l.set(i), l;
  }
  return oi;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = p0;
  e.__exportStar(Ak(), t);
})(d0);
var Tp = { exports: {} }, Wf = {}, tc = { exports: {} }, zf = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _y;
function Rk() {
  if (_y)
    return zf;
  _y = 1;
  var t = pe;
  function e(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, a = t.useEffect, s = t.useLayoutEffect, o = t.useDebugValue;
  function i(d, f) {
    var p = f(), h = r({ inst: { value: p, getSnapshot: f } }), m = h[0].inst, g = h[1];
    return s(function() {
      m.value = p, m.getSnapshot = f, c(m) && g({ inst: m });
    }, [d, p, f]), a(function() {
      return c(m) && g({ inst: m }), d(function() {
        c(m) && g({ inst: m });
      });
    }, [d]), o(p), p;
  }
  function c(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var p = f();
      return !n(d, p);
    } catch {
      return !0;
    }
  }
  function l(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : i;
  return zf.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : u, zf;
}
var Vf = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xy;
function $k() {
  return xy || (xy = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = pe, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(w) {
      {
        for (var S = arguments.length, I = new Array(S > 1 ? S - 1 : 0), E = 1; E < S; E++)
          I[E - 1] = arguments[E];
        r("error", w, I);
      }
    }
    function r(w, S, I) {
      {
        var E = e.ReactDebugCurrentFrame, T = E.getStackAddendum();
        T !== "" && (S += "%s", I = I.concat([T]));
        var R = I.map(function($) {
          return String($);
        });
        R.unshift("Warning: " + S), Function.prototype.apply.call(console[w], console, R);
      }
    }
    function a(w, S) {
      return w === S && (w !== 0 || 1 / w === 1 / S) || w !== w && S !== S;
    }
    var s = typeof Object.is == "function" ? Object.is : a, o = t.useState, i = t.useEffect, c = t.useLayoutEffect, l = t.useDebugValue, u = !1, d = !1;
    function f(w, S, I) {
      u || t.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var E = S();
      if (!d) {
        var T = S();
        s(E, T) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var R = o({
        inst: {
          value: E,
          getSnapshot: S
        }
      }), $ = R[0].inst, D = R[1];
      return c(function() {
        $.value = E, $.getSnapshot = S, p($) && D({
          inst: $
        });
      }, [w, E, S]), i(function() {
        p($) && D({
          inst: $
        });
        var M = function() {
          p($) && D({
            inst: $
          });
        };
        return w(M);
      }, [w]), l(E), E;
    }
    function p(w) {
      var S = w.getSnapshot, I = w.value;
      try {
        var E = S();
        return !s(I, E);
      } catch {
        return !0;
      }
    }
    function h(w, S, I) {
      return S();
    }
    var m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !m, v = g ? h : f, b = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : v;
    Vf.useSyncExternalStore = b, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Vf;
}
var Iy;
function g0() {
  return Iy || (Iy = 1, process.env.NODE_ENV === "production" ? tc.exports = Rk() : tc.exports = $k()), tc.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ky;
function Dk() {
  if (ky)
    return Wf;
  ky = 1;
  var t = pe, e = g0();
  function n(l, u) {
    return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, a = e.useSyncExternalStore, s = t.useRef, o = t.useEffect, i = t.useMemo, c = t.useDebugValue;
  return Wf.useSyncExternalStoreWithSelector = function(l, u, d, f, p) {
    var h = s(null);
    if (h.current === null) {
      var m = { hasValue: !1, value: null };
      h.current = m;
    } else
      m = h.current;
    h = i(function() {
      function v(E) {
        if (!b) {
          if (b = !0, w = E, E = f(E), p !== void 0 && m.hasValue) {
            var T = m.value;
            if (p(T, E))
              return S = T;
          }
          return S = E;
        }
        if (T = S, r(w, E))
          return T;
        var R = f(E);
        return p !== void 0 && p(T, R) ? T : (w = E, S = R);
      }
      var b = !1, w, S, I = d === void 0 ? null : d;
      return [function() {
        return v(u());
      }, I === null ? void 0 : function() {
        return v(I());
      }];
    }, [u, d, f, p]);
    var g = a(l, h[0], h[1]);
    return o(function() {
      m.hasValue = !0, m.value = g;
    }, [g]), c(g), g;
  }, Wf;
}
var Hf = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ey;
function Ok() {
  return Ey || (Ey = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = pe, e = g0();
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, a = e.useSyncExternalStore, s = t.useRef, o = t.useEffect, i = t.useMemo, c = t.useDebugValue;
    function l(u, d, f, p, h) {
      var m = s(null), g;
      m.current === null ? (g = {
        hasValue: !1,
        value: null
      }, m.current = g) : g = m.current;
      var v = i(function() {
        var I = !1, E, T, R = function(z) {
          if (!I) {
            I = !0, E = z;
            var F = p(z);
            if (h !== void 0 && g.hasValue) {
              var V = g.value;
              if (h(V, F))
                return T = V, V;
            }
            return T = F, F;
          }
          var H = E, U = T;
          if (r(H, z))
            return U;
          var Z = p(z);
          return h !== void 0 && h(U, Z) ? U : (E = z, T = Z, Z);
        }, $ = f === void 0 ? null : f, D = function() {
          return R(d());
        }, M = $ === null ? void 0 : function() {
          return R($());
        };
        return [D, M];
      }, [d, f, p, h]), b = v[0], w = v[1], S = a(u, b, w);
      return o(function() {
        g.hasValue = !0, g.value = S;
      }, [S]), c(S), S;
    }
    Hf.useSyncExternalStoreWithSelector = l, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Hf;
}
process.env.NODE_ENV === "production" ? Tp.exports = Dk() : Tp.exports = Ok();
var y0 = Tp.exports;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var me = function() {
  return me = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, me.apply(this, arguments);
};
function Xh(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function it(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function mt(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), a, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (i) {
    o = { error: i };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function Bt(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = e.length, s; r < a; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
var kt;
(function(t) {
  t.Start = "xstate.start", t.Stop = "xstate.stop", t.Raise = "xstate.raise", t.Send = "xstate.send", t.Cancel = "xstate.cancel", t.NullEvent = "", t.Assign = "xstate.assign", t.After = "xstate.after", t.DoneState = "done.state", t.DoneInvoke = "done.invoke", t.Log = "xstate.log", t.Init = "xstate.init", t.Invoke = "xstate.invoke", t.ErrorExecution = "error.execution", t.ErrorCommunication = "error.communication", t.ErrorPlatform = "error.platform", t.ErrorCustom = "xstate.error", t.Update = "xstate.update", t.Pure = "xstate.pure", t.Choose = "xstate.choose";
})(kt || (kt = {}));
var Io;
(function(t) {
  t.Parent = "#_parent", t.Internal = "#_internal";
})(Io || (Io = {}));
var Cp = kt.Start, Yh = kt.Stop, Iu = kt.Raise, ll = kt.Send, v0 = kt.Cancel, Fk = kt.NullEvent, Zh = kt.Assign;
kt.After;
kt.DoneState;
var b0 = kt.Log, Mk = kt.Init, Np = kt.Invoke;
kt.ErrorExecution;
var Ty = kt.ErrorPlatform, Pk = kt.ErrorCustom, w0 = kt.Update, Bk = kt.Choose, Lk = kt.Pure, S0 = ".", Cy = {}, Ap = "xstate.guard", Wk = "", Xt = process.env.NODE_ENV === "production", nc;
function Jh(t, e, n) {
  n === void 0 && (n = S0);
  var r = Wi(t, n), a = Wi(e, n);
  return pt(a) ? pt(r) ? a === r : !1 : pt(r) ? r in a : Object.keys(r).every(function(s) {
    return s in a ? Jh(r[s], a[s]) : !1;
  });
}
function _0(t) {
  try {
    return pt(t) || typeof t == "number" ? "".concat(t) : t.type;
  } catch {
    throw new Error("Events must be strings or objects with a string event.type property.");
  }
}
function Rp(t, e) {
  try {
    return Mo(t) ? t : t.toString().split(e);
  } catch {
    throw new Error("'".concat(t, "' is not a valid state path."));
  }
}
function zk(t) {
  return typeof t == "object" && "value" in t && "context" in t && "event" in t && "_event" in t;
}
function Wi(t, e) {
  if (zk(t))
    return t.value;
  if (Mo(t))
    return Ec(t);
  if (typeof t != "string")
    return t;
  var n = Rp(t, e);
  return Ec(n);
}
function Ec(t) {
  if (t.length === 1)
    return t[0];
  for (var e = {}, n = e, r = 0; r < t.length - 1; r++)
    r === t.length - 2 ? n[t[r]] = t[r + 1] : (n[t[r]] = {}, n = n[t[r]]);
  return e;
}
function Ei(t, e) {
  for (var n = {}, r = Object.keys(t), a = 0; a < r.length; a++) {
    var s = r[a];
    n[s] = e(t[s], s, t, a);
  }
  return n;
}
function Ny(t, e, n) {
  var r, a, s = {};
  try {
    for (var o = it(Object.keys(t)), i = o.next(); !i.done; i = o.next()) {
      var c = i.value, l = t[c];
      n(l) && (s[c] = e(l, c, t));
    }
  } catch (u) {
    r = {
      error: u
    };
  } finally {
    try {
      i && !i.done && (a = o.return) && a.call(o);
    } finally {
      if (r)
        throw r.error;
    }
  }
  return s;
}
var Vk = function(t) {
  return function(e) {
    var n, r, a = e;
    try {
      for (var s = it(t), o = s.next(); !o.done; o = s.next()) {
        var i = o.value;
        a = a[i];
      }
    } catch (c) {
      n = {
        error: c
      };
    } finally {
      try {
        o && !o.done && (r = s.return) && r.call(s);
      } finally {
        if (n)
          throw n.error;
      }
    }
    return a;
  };
};
function Hk(t, e) {
  return function(n) {
    var r, a, s = n;
    try {
      for (var o = it(t), i = o.next(); !i.done; i = o.next()) {
        var c = i.value;
        s = s[e][c];
      }
    } catch (l) {
      r = {
        error: l
      };
    } finally {
      try {
        i && !i.done && (a = o.return) && a.call(o);
      } finally {
        if (r)
          throw r.error;
      }
    }
    return s;
  };
}
function mc(t) {
  if (!t)
    return [[]];
  if (pt(t))
    return [[t]];
  var e = Gt(Object.keys(t).map(function(n) {
    var r = t[n];
    return typeof r != "string" && (!r || !Object.keys(r).length) ? [[n]] : mc(t[n]).map(function(a) {
      return [n].concat(a);
    });
  }));
  return e;
}
function Gt(t) {
  var e;
  return (e = []).concat.apply(e, Bt([], mt(t), !1));
}
function x0(t) {
  return Mo(t) ? t : [t];
}
function $r(t) {
  return t === void 0 ? [] : x0(t);
}
function Tc(t, e, n) {
  var r, a;
  if (gt(t))
    return t(e, n.data);
  var s = {};
  try {
    for (var o = it(Object.keys(t)), i = o.next(); !i.done; i = o.next()) {
      var c = i.value, l = t[c];
      gt(l) ? s[c] = l(e, n.data) : s[c] = l;
    }
  } catch (u) {
    r = {
      error: u
    };
  } finally {
    try {
      i && !i.done && (a = o.return) && a.call(o);
    } finally {
      if (r)
        throw r.error;
    }
  }
  return s;
}
function jk(t) {
  return /^(done|error)\./.test(t);
}
function Ay(t) {
  return !!(t instanceof Promise || t !== null && (gt(t) || typeof t == "object") && gt(t.then));
}
function Uk(t) {
  return t !== null && typeof t == "object" && "transition" in t && typeof t.transition == "function";
}
function Gk(t, e) {
  var n, r, a = mt([[], []], 2), s = a[0], o = a[1];
  try {
    for (var i = it(t), c = i.next(); !c.done; c = i.next()) {
      var l = c.value;
      e(l) ? s.push(l) : o.push(l);
    }
  } catch (u) {
    n = {
      error: u
    };
  } finally {
    try {
      c && !c.done && (r = i.return) && r.call(i);
    } finally {
      if (n)
        throw n.error;
    }
  }
  return [s, o];
}
function I0(t, e) {
  return Ei(t.states, function(n, r) {
    if (n) {
      var a = (pt(e) ? void 0 : e[r]) || (n ? n.current : void 0);
      if (a)
        return {
          current: a,
          states: I0(n, a)
        };
    }
  });
}
function qk(t, e) {
  return {
    current: e,
    states: I0(t, e)
  };
}
function Ry(t, e, n, r) {
  Xt || mn(!!t, "Attempting to update undefined context");
  var a = t && n.reduce(function(s, o) {
    var i, c, l = o.assignment, u = {
      state: r,
      action: o,
      _event: e
    }, d = {};
    if (gt(l))
      d = l(s, e.data, u);
    else
      try {
        for (var f = it(Object.keys(l)), p = f.next(); !p.done; p = f.next()) {
          var h = p.value, m = l[h];
          d[h] = gt(m) ? m(s, e.data, u) : m;
        }
      } catch (g) {
        i = {
          error: g
        };
      } finally {
        try {
          p && !p.done && (c = f.return) && c.call(f);
        } finally {
          if (i)
            throw i.error;
        }
      }
    return Object.assign({}, s, d);
  }, t);
  return a;
}
var mn = function() {
};
Xt || (mn = function(t, e) {
  var n = t instanceof Error ? t : void 0;
  if (!(!n && t) && console !== void 0) {
    var r = ["Warning: ".concat(e)];
    n && r.push(n), console.warn.apply(console, r);
  }
});
function Mo(t) {
  return Array.isArray(t);
}
function gt(t) {
  return typeof t == "function";
}
function pt(t) {
  return typeof t == "string";
}
function k0(t, e) {
  if (t)
    return pt(t) ? {
      type: Ap,
      name: t,
      predicate: e ? e[t] : void 0
    } : gt(t) ? {
      type: Ap,
      name: t.name,
      predicate: t
    } : t;
}
function Kk(t) {
  try {
    return "subscribe" in t && gt(t.subscribe);
  } catch {
    return !1;
  }
}
var Oa = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
nc = {}, nc[Oa] = function() {
  return this;
}, nc[Symbol.observable] = function() {
  return this;
};
function ma(t) {
  return !!t && "__xstatenode" in t;
}
function Xk(t) {
  return !!t && typeof t.send == "function";
}
var Yk = /* @__PURE__ */ function() {
  var t = 0;
  return function() {
    return t++, t.toString(16);
  };
}();
function dl(t, e) {
  return pt(t) || typeof t == "number" ? me({
    type: t
  }, e) : t;
}
function _n(t, e) {
  if (!pt(t) && "$$type" in t && t.$$type === "scxml")
    return t;
  var n = dl(t);
  return me({
    name: n.type,
    data: n,
    $$type: "scxml",
    type: "external"
  }, e);
}
function no(t, e) {
  var n = x0(e).map(function(r) {
    return typeof r > "u" || typeof r == "string" || ma(r) ? {
      target: r,
      event: t
    } : me(me({}, r), {
      event: t
    });
  });
  return n;
}
function Zk(t) {
  if (!(t === void 0 || t === Wk))
    return $r(t);
}
function Jk(t, e, n) {
  if (!Xt) {
    var r = t.stack ? " Stacktrace was '".concat(t.stack, "'") : "";
    if (t === e)
      console.error("Missing onError handler for invocation '".concat(n, "', error was '").concat(t, "'.").concat(r));
    else {
      var a = e.stack ? " Stacktrace was '".concat(e.stack, "'") : "";
      console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '".concat(n, "'. ") + "Original error: '".concat(t, "'. ").concat(r, " Current error is '").concat(e, "'.").concat(a));
    }
  }
}
function E0(t, e, n, r, a) {
  var s = t.options.guards, o = {
    state: a,
    cond: e,
    _event: r
  };
  if (e.type === Ap)
    return (s?.[e.name] || e.predicate)(n, r.data, o);
  var i = s?.[e.type];
  if (!i)
    throw new Error("Guard '".concat(e.type, "' is not implemented on machine '").concat(t.id, "'."));
  return i(n, r.data, o);
}
function T0(t) {
  return typeof t == "string" ? {
    type: t
  } : t;
}
function zi(t, e, n) {
  var r = function() {
  }, a = typeof t == "object", s = a ? t : null;
  return {
    next: ((a ? t.next : t) || r).bind(s),
    error: ((a ? t.error : e) || r).bind(s),
    complete: ((a ? t.complete : n) || r).bind(s)
  };
}
function rc(t, e) {
  return "".concat(t, ":invocation[").concat(e, "]");
}
function $p(t) {
  return (t.type === Iu || t.type === ll && t.to === Io.Internal) && typeof t.delay != "number";
}
var yo = /* @__PURE__ */ _n({
  type: Mk
});
function Dp(t, e) {
  return e && e[t] || void 0;
}
function Yi(t, e) {
  var n;
  if (pt(t) || typeof t == "number") {
    var r = Dp(t, e);
    gt(r) ? n = {
      type: t,
      exec: r
    } : r ? n = r : n = {
      type: t,
      exec: void 0
    };
  } else if (gt(t))
    n = {
      // Convert action to string if unnamed
      type: t.name || t.toString(),
      exec: t
    };
  else {
    var r = Dp(t.type, e);
    if (gt(r))
      n = me(me({}, t), {
        exec: r
      });
    else if (r) {
      var a = r.type || t.type;
      n = me(me(me({}, r), t), {
        type: a
      });
    } else
      n = t;
  }
  return n;
}
var Fa = function(t, e) {
  if (!t)
    return [];
  var n = Mo(t) ? t : [t];
  return n.map(function(r) {
    return Yi(r, e);
  });
};
function Qh(t) {
  var e = Yi(t);
  return me(me({
    id: pt(t) ? t : e.id
  }, e), {
    type: e.type
  });
}
function Qk(t, e) {
  return {
    type: Iu,
    event: typeof t == "function" ? t : dl(t),
    delay: e ? e.delay : void 0,
    id: e?.id
  };
}
function eE(t, e, n, r) {
  var a = {
    _event: n
  }, s = _n(gt(t.event) ? t.event(e, n.data, a) : t.event), o;
  if (pt(t.delay)) {
    var i = r && r[t.delay];
    o = gt(i) ? i(e, n.data, a) : i;
  } else
    o = gt(t.delay) ? t.delay(e, n.data, a) : t.delay;
  return me(me({}, t), {
    type: Iu,
    _event: s,
    delay: o
  });
}
function Ti(t, e) {
  return {
    to: e ? e.to : void 0,
    type: ll,
    event: gt(t) ? t : dl(t),
    delay: e ? e.delay : void 0,
    // TODO: don't auto-generate IDs here like that
    // there is too big chance of the ID collision
    id: e && e.id !== void 0 ? e.id : gt(t) ? t.name : _0(t)
  };
}
function tE(t, e, n, r) {
  var a = {
    _event: n
  }, s = _n(gt(t.event) ? t.event(e, n.data, a) : t.event), o;
  if (pt(t.delay)) {
    var i = r && r[t.delay];
    o = gt(i) ? i(e, n.data, a) : i;
  } else
    o = gt(t.delay) ? t.delay(e, n.data, a) : t.delay;
  var c = gt(t.to) ? t.to(e, n.data, a) : t.to;
  return me(me({}, t), {
    to: c,
    _event: s,
    event: s.data,
    delay: o
  });
}
var nE = function(t, e, n) {
  return me(me({}, t), {
    value: pt(t.expr) ? t.expr : t.expr(e, n.data, {
      _event: n
    })
  });
}, Ci = function(t) {
  return {
    type: v0,
    sendId: t
  };
};
function rE(t) {
  var e = Qh(t);
  return {
    type: kt.Start,
    activity: e,
    exec: void 0
  };
}
function aE(t) {
  var e = gt(t) ? t : Qh(t);
  return {
    type: kt.Stop,
    activity: e,
    exec: void 0
  };
}
function sE(t, e, n) {
  var r = gt(t.activity) ? t.activity(e, n.data) : t.activity, a = typeof r == "string" ? {
    id: r
  } : r, s = {
    type: kt.Stop,
    activity: a
  };
  return s;
}
var oE = function(t) {
  return {
    type: Zh,
    assignment: t
  };
};
function iE(t, e) {
  var n = e ? "#".concat(e) : "";
  return "".concat(kt.After, "(").concat(t, ")").concat(n);
}
function ac(t, e) {
  var n = "".concat(kt.DoneState, ".").concat(t), r = {
    type: n,
    data: e
  };
  return r.toString = function() {
    return n;
  }, r;
}
function gc(t, e) {
  var n = "".concat(kt.DoneInvoke, ".").concat(t), r = {
    type: n,
    data: e
  };
  return r.toString = function() {
    return n;
  }, r;
}
function Ni(t, e) {
  var n = "".concat(kt.ErrorPlatform, ".").concat(t), r = {
    type: n,
    data: e
  };
  return r.toString = function() {
    return n;
  }, r;
}
var uE = function(t) {
  var e, n, r = [];
  try {
    for (var a = it(t), s = a.next(); !s.done; s = a.next())
      for (var o = s.value, i = 0; i < o.actions.length; ) {
        if (o.actions[i].type === Zh) {
          r.push(o.actions[i]), o.actions.splice(i, 1);
          continue;
        }
        i++;
      }
  } catch (c) {
    e = {
      error: c
    };
  } finally {
    try {
      s && !s.done && (n = a.return) && n.call(a);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return r;
};
function Cc(t, e, n, r, a, s, o) {
  o === void 0 && (o = !1);
  var i = o ? [] : uE(a), c = i.length ? Ry(n, r, i, e) : n, l = o ? [n] : void 0, u = [];
  function d(h, m) {
    var g;
    switch (m.type) {
      case Iu: {
        var v = eE(m, c, r, t.options.delays);
        return s && typeof v.delay == "number" && s(v, c, r), v;
      }
      case ll:
        var b = tE(m, c, r, t.options.delays);
        if (!Xt) {
          var w = m.delay;
          mn(
            !pt(w) || typeof b.delay == "number",
            // tslint:disable-next-line:max-line-length
            "No delay reference for delay expression '".concat(w, "' was found on machine '").concat(t.id, "'")
          );
        }
        return s && b.to !== Io.Internal && (h === "entry" ? u.push(b) : s(b, c, r)), b;
      case b0: {
        var S = nE(m, c, r);
        return s?.(S, c, r), S;
      }
      case Bk: {
        var I = m, E = (g = I.conds.find(function(Z) {
          var q = k0(Z.cond, t.options.guards);
          return !q || E0(t, q, c, r, s ? void 0 : e);
        })) === null || g === void 0 ? void 0 : g.actions;
        if (!E)
          return [];
        var T = mt(Cc(t, e, c, r, [{
          type: h,
          actions: Fa($r(E), t.options.actions)
        }], s, o), 2), R = T[0], $ = T[1];
        return c = $, l?.push(c), R;
      }
      case Lk: {
        var E = m.get(c, r.data);
        if (!E)
          return [];
        var D = mt(Cc(t, e, c, r, [{
          type: h,
          actions: Fa($r(E), t.options.actions)
        }], s, o), 2), M = D[0], z = D[1];
        return c = z, l?.push(c), M;
      }
      case Yh: {
        var S = sE(m, c, r);
        return s?.(S, n, r), S;
      }
      case Zh: {
        c = Ry(c, r, [m], s ? void 0 : e), l?.push(c);
        break;
      }
      default:
        var F = Yi(m, t.options.actions), V = F.exec;
        if (s)
          s(F, c, r);
        else if (V && l) {
          var H = l.length - 1, U = me(me({}, F), {
            exec: function(Z) {
              for (var q = [], X = 1; X < arguments.length; X++)
                q[X - 1] = arguments[X];
              V.apply(void 0, Bt([l[H]], mt(q), !1));
            }
          });
          F = U;
        }
        return F;
    }
  }
  function f(h) {
    var m, g, v = [];
    try {
      for (var b = it(h.actions), w = b.next(); !w.done; w = b.next()) {
        var S = w.value, I = d(h.type, S);
        I && (v = v.concat(I));
      }
    } catch (E) {
      m = {
        error: E
      };
    } finally {
      try {
        w && !w.done && (g = b.return) && g.call(b);
      } finally {
        if (m)
          throw m.error;
      }
    }
    return u.forEach(function(E) {
      s(E, c, r);
    }), u.length = 0, v;
  }
  var p = Gt(a.map(f));
  return [p, c];
}
var Nc = [], io = function(t, e) {
  Nc.push(t);
  var n = e(t);
  return Nc.pop(), n;
}, cE = function(t) {
  return t(Nc[Nc.length - 1]);
};
function C0(t) {
  var e;
  return e = {
    id: t,
    send: function() {
    },
    subscribe: function() {
      return {
        unsubscribe: function() {
        }
      };
    },
    getSnapshot: function() {
    },
    toJSON: function() {
      return {
        id: t
      };
    }
  }, e[Oa] = function() {
    return this;
  }, e;
}
function lE(t, e, n, r) {
  var a, s = T0(t.src), o = (a = e?.options.services) === null || a === void 0 ? void 0 : a[s.type], i = t.data ? Tc(t.data, n, r) : void 0, c = o ? em(o, t.id, i) : C0(t.id);
  return c.meta = t, c;
}
function em(t, e, n) {
  var r = C0(e);
  if (r.deferred = !0, ma(t)) {
    var a = r.state = io(void 0, function() {
      return (n ? t.withContext(n) : t).initialState;
    });
    r.getSnapshot = function() {
      return a;
    };
  }
  return r;
}
function dE(t) {
  try {
    return typeof t.send == "function";
  } catch {
    return !1;
  }
}
function fE(t) {
  return dE(t) && "id" in t;
}
function pE(t) {
  var e;
  return me((e = {
    subscribe: function() {
      return {
        unsubscribe: function() {
        }
      };
    },
    id: "anonymous",
    getSnapshot: function() {
    }
  }, e[Oa] = function() {
    return this;
  }, e), t);
}
var Ac = function(t) {
  return t.type === "atomic" || t.type === "final";
};
function N0(t) {
  return Object.keys(t.states).map(function(e) {
    return t.states[e];
  });
}
function Zi(t) {
  return N0(t).filter(function(e) {
    return e.type !== "history";
  });
}
function A0(t) {
  var e = [t];
  return Ac(t) ? e : e.concat(Gt(Zi(t).map(A0)));
}
function Ai(t, e) {
  var n, r, a, s, o, i, c, l, u = new Set(t), d = Op(u), f = new Set(e);
  try {
    for (var p = it(f), h = p.next(); !h.done; h = p.next())
      for (var m = h.value, g = m.parent; g && !f.has(g); )
        f.add(g), g = g.parent;
  } catch ($) {
    n = {
      error: $
    };
  } finally {
    try {
      h && !h.done && (r = p.return) && r.call(p);
    } finally {
      if (n)
        throw n.error;
    }
  }
  var v = Op(f);
  try {
    for (var b = it(f), w = b.next(); !w.done; w = b.next()) {
      var m = w.value;
      if (m.type === "compound" && (!v.get(m) || !v.get(m).length))
        d.get(m) ? d.get(m).forEach(function(D) {
          return f.add(D);
        }) : m.initialStateNodes.forEach(function(D) {
          return f.add(D);
        });
      else if (m.type === "parallel")
        try {
          for (var S = (o = void 0, it(Zi(m))), I = S.next(); !I.done; I = S.next()) {
            var E = I.value;
            f.has(E) || (f.add(E), d.get(E) ? d.get(E).forEach(function(D) {
              return f.add(D);
            }) : E.initialStateNodes.forEach(function(D) {
              return f.add(D);
            }));
          }
        } catch (D) {
          o = {
            error: D
          };
        } finally {
          try {
            I && !I.done && (i = S.return) && i.call(S);
          } finally {
            if (o)
              throw o.error;
          }
        }
    }
  } catch ($) {
    a = {
      error: $
    };
  } finally {
    try {
      w && !w.done && (s = b.return) && s.call(b);
    } finally {
      if (a)
        throw a.error;
    }
  }
  try {
    for (var T = it(f), R = T.next(); !R.done; R = T.next())
      for (var m = R.value, g = m.parent; g && !f.has(g); )
        f.add(g), g = g.parent;
  } catch ($) {
    c = {
      error: $
    };
  } finally {
    try {
      R && !R.done && (l = T.return) && l.call(T);
    } finally {
      if (c)
        throw c.error;
    }
  }
  return f;
}
function R0(t, e) {
  var n = e.get(t);
  if (!n)
    return {};
  if (t.type === "compound") {
    var r = n[0];
    if (r) {
      if (Ac(r))
        return r.key;
    } else
      return {};
  }
  var a = {};
  return n.forEach(function(s) {
    a[s.key] = R0(s, e);
  }), a;
}
function Op(t) {
  var e, n, r = /* @__PURE__ */ new Map();
  try {
    for (var a = it(t), s = a.next(); !s.done; s = a.next()) {
      var o = s.value;
      r.has(o) || r.set(o, []), o.parent && (r.has(o.parent) || r.set(o.parent, []), r.get(o.parent).push(o));
    }
  } catch (i) {
    e = {
      error: i
    };
  } finally {
    try {
      s && !s.done && (n = a.return) && n.call(a);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return r;
}
function hE(t, e) {
  var n = Ai([t], e);
  return R0(t, Op(n));
}
function Ri(t, e) {
  return Array.isArray(t) ? t.some(function(n) {
    return n === e;
  }) : t instanceof Set ? t.has(e) : !1;
}
function mE(t) {
  return Bt([], mt(new Set(Gt(Bt([], mt(t.map(function(e) {
    return e.ownEvents;
  })), !1)))), !1);
}
function yc(t, e) {
  return e.type === "compound" ? Zi(e).some(function(n) {
    return n.type === "final" && Ri(t, n);
  }) : e.type === "parallel" ? Zi(e).every(function(n) {
    return yc(t, n);
  }) : !1;
}
function gE(t) {
  return t === void 0 && (t = []), t.reduce(function(e, n) {
    return n.meta !== void 0 && (e[n.id] = n.meta), e;
  }, {});
}
function $y(t) {
  return new Set(Gt(t.map(function(e) {
    return e.tags;
  })));
}
function $0(t, e) {
  if (t === e)
    return !0;
  if (t === void 0 || e === void 0)
    return !1;
  if (pt(t) || pt(e))
    return t === e;
  var n = Object.keys(t), r = Object.keys(e);
  return n.length === r.length && n.every(function(a) {
    return $0(t[a], e[a]);
  });
}
function yE(t) {
  return typeof t != "object" || t === null ? !1 : "value" in t && "_event" in t;
}
function vE(t, e) {
  var n = t.exec, r = me(me({}, t), {
    exec: n !== void 0 ? function() {
      return n(e.context, e.event, {
        action: t,
        state: e,
        _event: e._event
      });
    } : void 0
  });
  return r;
}
var Dr = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      var n = this, r;
      this.actions = [], this.activities = Cy, this.meta = {}, this.events = [], this.value = e.value, this.context = e.context, this._event = e._event, this._sessionid = e._sessionid, this.event = this._event.data, this.historyValue = e.historyValue, this.history = e.history, this.actions = e.actions || [], this.activities = e.activities || Cy, this.meta = gE(e.configuration), this.events = e.events || [], this.matches = this.matches.bind(this), this.toStrings = this.toStrings.bind(this), this.configuration = e.configuration, this.transitions = e.transitions, this.children = e.children, this.done = !!e.done, this.tags = (r = Array.isArray(e.tags) ? new Set(e.tags) : e.tags) !== null && r !== void 0 ? r : /* @__PURE__ */ new Set(), this.machine = e.machine, Object.defineProperty(this, "nextEvents", {
        get: function() {
          return mE(n.configuration);
        }
      });
    }
    return t.from = function(e, n) {
      if (e instanceof t)
        return e.context !== n ? new t({
          value: e.value,
          context: n,
          _event: e._event,
          _sessionid: null,
          historyValue: e.historyValue,
          history: e.history,
          actions: [],
          activities: e.activities,
          meta: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {}
        }) : e;
      var r = yo;
      return new t({
        value: e,
        context: n,
        _event: r,
        _sessionid: null,
        historyValue: void 0,
        history: void 0,
        actions: [],
        activities: void 0,
        meta: void 0,
        events: [],
        configuration: [],
        transitions: [],
        children: {}
      });
    }, t.create = function(e) {
      return new t(e);
    }, t.inert = function(e, n) {
      if (e instanceof t) {
        if (!e.actions.length)
          return e;
        var r = yo;
        return new t({
          value: e.value,
          context: n,
          _event: r,
          _sessionid: null,
          historyValue: e.historyValue,
          history: e.history,
          activities: e.activities,
          configuration: e.configuration,
          transitions: [],
          children: {}
        });
      }
      return t.from(e, n);
    }, t.prototype.toStrings = function(e, n) {
      var r = this;
      if (e === void 0 && (e = this.value), n === void 0 && (n = "."), pt(e))
        return [e];
      var a = Object.keys(e);
      return a.concat.apply(a, Bt([], mt(a.map(function(s) {
        return r.toStrings(e[s], n).map(function(o) {
          return s + n + o;
        });
      })), !1));
    }, t.prototype.toJSON = function() {
      var e = this;
      e.configuration, e.transitions;
      var n = e.tags;
      e.machine;
      var r = Xh(e, ["configuration", "transitions", "tags", "machine"]);
      return me(me({}, r), {
        tags: Array.from(n)
      });
    }, t.prototype.matches = function(e) {
      return Jh(e, this.value);
    }, t.prototype.hasTag = function(e) {
      return this.tags.has(e);
    }, t.prototype.can = function(e) {
      var n;
      Xt && mn(!!this.machine, "state.can(...) used outside of a machine-created State object; this will always return false.");
      var r = (n = this.machine) === null || n === void 0 ? void 0 : n.getTransitionData(this, e);
      return !!r?.transitions.length && // Check that at least one transition is not forbidden
      r.transitions.some(function(a) {
        return a.target !== void 0 || a.actions.length;
      });
    }, t;
  }()
), bE = {
  deferEvents: !1
}, Dy = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.processingEvent = !1, this.queue = [], this.initialized = !1, this.options = me(me({}, bE), e);
    }
    return t.prototype.initialize = function(e) {
      if (this.initialized = !0, e) {
        if (!this.options.deferEvents) {
          this.schedule(e);
          return;
        }
        this.process(e);
      }
      this.flushEvents();
    }, t.prototype.schedule = function(e) {
      if (!this.initialized || this.processingEvent) {
        this.queue.push(e);
        return;
      }
      if (this.queue.length !== 0)
        throw new Error("Event queue should be empty when it is not processing events");
      this.process(e), this.flushEvents();
    }, t.prototype.clear = function() {
      this.queue = [];
    }, t.prototype.flushEvents = function() {
      for (var e = this.queue.shift(); e; )
        this.process(e), e = this.queue.shift();
    }, t.prototype.process = function(e) {
      this.processingEvent = !0;
      try {
        e();
      } catch (n) {
        throw this.clear(), n;
      } finally {
        this.processingEvent = !1;
      }
    }, t;
  }()
), jf = /* @__PURE__ */ new Map(), wE = 0, fi = {
  bookId: function() {
    return "x:".concat(wE++);
  },
  register: function(t, e) {
    return jf.set(t, e), t;
  },
  get: function(t) {
    return jf.get(t);
  },
  free: function(t) {
    jf.delete(t);
  }
};
function tm() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  Xt || console.warn("XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues");
}
function SE() {
  var t = tm();
  if (t && "__xstate__" in t)
    return t.__xstate__;
}
function _E(t) {
  if (tm()) {
    var e = SE();
    e && e.register(t);
  }
}
function xE(t, e) {
  e === void 0 && (e = {});
  var n = t.initialState, r = /* @__PURE__ */ new Set(), a = [], s = !1, o = function() {
    if (!s) {
      for (s = !0; a.length > 0; ) {
        var l = a.shift();
        n = t.transition(n, l, c), r.forEach(function(u) {
          return u.next(n);
        });
      }
      s = !1;
    }
  }, i = pE({
    id: e.id,
    send: function(l) {
      a.push(l), o();
    },
    getSnapshot: function() {
      return n;
    },
    subscribe: function(l, u, d) {
      var f = zi(l, u, d);
      return r.add(f), f.next(n), {
        unsubscribe: function() {
          r.delete(f);
        }
      };
    }
  }), c = {
    parent: e.parent,
    self: i,
    id: e.id || "anonymous",
    observers: r
  };
  return n = t.start ? t.start(c) : n, i;
}
var Fp = {
  sync: !1,
  autoForward: !1
}, Qt;
(function(t) {
  t[t.NotStarted = 0] = "NotStarted", t[t.Running = 1] = "Running", t[t.Stopped = 2] = "Stopped";
})(Qt || (Qt = {}));
var IE = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, n) {
      n === void 0 && (n = t.defaultOptions);
      var r = this;
      this.machine = e, this.delayedEventsMap = {}, this.listeners = /* @__PURE__ */ new Set(), this.contextListeners = /* @__PURE__ */ new Set(), this.stopListeners = /* @__PURE__ */ new Set(), this.doneListeners = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Set(), this.sendListeners = /* @__PURE__ */ new Set(), this.initialized = !1, this.status = Qt.NotStarted, this.children = /* @__PURE__ */ new Map(), this.forwardTo = /* @__PURE__ */ new Set(), this._outgoingQueue = [], this.init = this.start, this.send = function(u, d) {
        if (Mo(u))
          return r.batch(u), r.state;
        var f = _n(dl(u, d));
        if (r.status === Qt.Stopped)
          return Xt || mn(!1, 'Event "'.concat(f.name, '" was sent to stopped service "').concat(r.machine.id, `". This service has already reached its final state, and will not transition.
Event: `).concat(JSON.stringify(f.data))), r.state;
        if (r.status !== Qt.Running && !r.options.deferEvents)
          throw new Error('Event "'.concat(f.name, '" was sent to uninitialized service "').concat(
            r.machine.id,
            `". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.
Event: `
          ).concat(JSON.stringify(f.data)));
        return r.scheduler.schedule(function() {
          r.forward(f);
          var p = r._nextState(f);
          r.update(p, f);
        }), r._state;
      }, this.sendTo = function(u, d, f) {
        var p = r.parent && (d === Io.Parent || r.parent.id === d), h = p ? r.parent : pt(d) ? d === Io.Internal ? r : r.children.get(d) || fi.get(d) : Xk(d) ? d : void 0;
        if (!h) {
          if (!p)
            throw new Error("Unable to send event to child '".concat(d, "' from service '").concat(r.id, "'."));
          Xt || mn(!1, "Service '".concat(r.id, "' has no parent: unable to send event ").concat(u.type));
          return;
        }
        if ("machine" in h) {
          if (r.status !== Qt.Stopped || r.parent !== h || // we need to send events to the parent from exit handlers of a machine that reached its final state
          r.state.done) {
            var m = me(me({}, u), {
              name: u.name === Pk ? "".concat(Ni(r.id)) : u.name,
              origin: r.sessionId
            });
            !f && r.machine.config.predictableActionArguments ? r._outgoingQueue.push([h, m]) : h.send(m);
          }
        } else
          !f && r.machine.config.predictableActionArguments ? r._outgoingQueue.push([h, u.data]) : h.send(u.data);
      }, this._exec = function(u, d, f, p) {
        p === void 0 && (p = r.machine.options.actions);
        var h = u.exec || Dp(u.type, p), m = gt(h) ? h : h ? h.exec : u.exec;
        if (m)
          try {
            return m(d, f.data, r.machine.config.predictableActionArguments ? {
              action: u,
              _event: f
            } : {
              action: u,
              state: r.state,
              _event: f
            });
          } catch (V) {
            throw r.parent && r.parent.send({
              type: "xstate.error",
              data: V
            }), V;
          }
        switch (u.type) {
          case Iu: {
            var g = u;
            r.defer(g);
            break;
          }
          case ll:
            var v = u;
            if (typeof v.delay == "number") {
              r.defer(v);
              return;
            } else
              v.to ? r.sendTo(v._event, v.to, f === yo) : r.send(v._event);
            break;
          case v0:
            r.cancel(u.sendId);
            break;
          case Cp: {
            if (r.status !== Qt.Running)
              return;
            var b = u.activity;
            if (
              // in v4 with `predictableActionArguments` invokes are called eagerly when the `this.state` still points to the previous state
              !r.machine.config.predictableActionArguments && !r.state.activities[b.id || b.type]
            )
              break;
            if (b.type === kt.Invoke) {
              var w = T0(b.src), S = r.machine.options.services ? r.machine.options.services[w.type] : void 0, I = b.id, E = b.data;
              Xt || mn(
                !("forward" in b),
                // tslint:disable-next-line:max-line-length
                "`forward` property is deprecated (found in invocation of '".concat(b.src, "' in in machine '").concat(r.machine.id, "'). ") + "Please use `autoForward` instead."
              );
              var T = "autoForward" in b ? b.autoForward : !!b.forward;
              if (!S) {
                Xt || mn(!1, "No service found for invocation '".concat(b.src, "' in machine '").concat(r.machine.id, "'."));
                return;
              }
              var R = E ? Tc(E, d, f) : void 0;
              if (typeof S == "string")
                return;
              var $ = gt(S) ? S(d, f.data, {
                data: R,
                src: w,
                meta: b.meta
              }) : S;
              if (!$)
                return;
              var D = void 0;
              ma($) && ($ = R ? $.withContext(R) : $, D = {
                autoForward: T
              }), r.spawn($, I, D);
            } else
              r.spawnActivity(b);
            break;
          }
          case Yh: {
            r.stopChild(u.activity.id);
            break;
          }
          case b0:
            var M = u, z = M.label, F = M.value;
            z ? r.logger(z, F) : r.logger(F);
            break;
          default:
            Xt || mn(!1, "No implementation found for action type '".concat(u.type, "'"));
            break;
        }
      };
      var a = me(me({}, t.defaultOptions), n), s = a.clock, o = a.logger, i = a.parent, c = a.id, l = c !== void 0 ? c : e.id;
      this.id = l, this.logger = o, this.clock = s, this.parent = i, this.options = a, this.scheduler = new Dy({
        deferEvents: this.options.deferEvents
      }), this.sessionId = fi.bookId();
    }
    return Object.defineProperty(t.prototype, "initialState", {
      get: function() {
        var e = this;
        return this._initialState ? this._initialState : io(this, function() {
          return e._initialState = e.machine.initialState, e._initialState;
        });
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "state", {
      /**
       * @deprecated Use `.getSnapshot()` instead.
       */
      get: function() {
        return Xt || mn(this.status !== Qt.NotStarted, "Attempted to read state from uninitialized service '".concat(this.id, "'. Make sure the service is started first.")), this._state;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.execute = function(e, n) {
      var r, a;
      try {
        for (var s = it(e.actions), o = s.next(); !o.done; o = s.next()) {
          var i = o.value;
          this.exec(i, e, n);
        }
      } catch (c) {
        r = {
          error: c
        };
      } finally {
        try {
          o && !o.done && (a = s.return) && a.call(s);
        } finally {
          if (r)
            throw r.error;
        }
      }
    }, t.prototype.update = function(e, n) {
      var r, a, s, o, i, c, l, u, d = this;
      if (e._sessionid = this.sessionId, this._state = e, (!this.machine.config.predictableActionArguments || // this is currently required to execute initial actions as the `initialState` gets cached
      // we can't just recompute it (and execute actions while doing so) because we try to preserve identity of actors created within initial assigns
      n === yo) && this.options.execute)
        this.execute(this.state);
      else
        for (var f = void 0; f = this._outgoingQueue.shift(); )
          f[0].send(f[1]);
      if (this.children.forEach(function($) {
        d.state.children[$.id] = $;
      }), this.devTools && this.devTools.send(n.data, e), e.event)
        try {
          for (var p = it(this.eventListeners), h = p.next(); !h.done; h = p.next()) {
            var m = h.value;
            m(e.event);
          }
        } catch ($) {
          r = {
            error: $
          };
        } finally {
          try {
            h && !h.done && (a = p.return) && a.call(p);
          } finally {
            if (r)
              throw r.error;
          }
        }
      try {
        for (var g = it(this.listeners), v = g.next(); !v.done; v = g.next()) {
          var m = v.value;
          m(e, e.event);
        }
      } catch ($) {
        s = {
          error: $
        };
      } finally {
        try {
          v && !v.done && (o = g.return) && o.call(g);
        } finally {
          if (s)
            throw s.error;
        }
      }
      try {
        for (var b = it(this.contextListeners), w = b.next(); !w.done; w = b.next()) {
          var S = w.value;
          S(this.state.context, this.state.history ? this.state.history.context : void 0);
        }
      } catch ($) {
        i = {
          error: $
        };
      } finally {
        try {
          w && !w.done && (c = b.return) && c.call(b);
        } finally {
          if (i)
            throw i.error;
        }
      }
      if (this.state.done) {
        var I = e.configuration.find(function($) {
          return $.type === "final" && $.parent === d.machine;
        }), E = I && I.doneData ? Tc(I.doneData, e.context, n) : void 0;
        this._doneEvent = gc(this.id, E);
        try {
          for (var T = it(this.doneListeners), R = T.next(); !R.done; R = T.next()) {
            var m = R.value;
            m(this._doneEvent);
          }
        } catch ($) {
          l = {
            error: $
          };
        } finally {
          try {
            R && !R.done && (u = T.return) && u.call(T);
          } finally {
            if (l)
              throw l.error;
          }
        }
        this._stop(), this._stopChildren(), fi.free(this.sessionId);
      }
    }, t.prototype.onTransition = function(e) {
      return this.listeners.add(e), this.status === Qt.Running && e(this.state, this.state.event), this;
    }, t.prototype.subscribe = function(e, n, r) {
      var a = this, s = zi(e, n, r);
      this.listeners.add(s.next), this.status !== Qt.NotStarted && s.next(this.state);
      var o = function() {
        a.doneListeners.delete(o), a.stopListeners.delete(o), s.complete();
      };
      return this.status === Qt.Stopped ? s.complete() : (this.onDone(o), this.onStop(o)), {
        unsubscribe: function() {
          a.listeners.delete(s.next), a.doneListeners.delete(o), a.stopListeners.delete(o);
        }
      };
    }, t.prototype.onEvent = function(e) {
      return this.eventListeners.add(e), this;
    }, t.prototype.onSend = function(e) {
      return this.sendListeners.add(e), this;
    }, t.prototype.onChange = function(e) {
      return this.contextListeners.add(e), this;
    }, t.prototype.onStop = function(e) {
      return this.stopListeners.add(e), this;
    }, t.prototype.onDone = function(e) {
      return this.status === Qt.Stopped && this._doneEvent ? e(this._doneEvent) : this.doneListeners.add(e), this;
    }, t.prototype.off = function(e) {
      return this.listeners.delete(e), this.eventListeners.delete(e), this.sendListeners.delete(e), this.stopListeners.delete(e), this.doneListeners.delete(e), this.contextListeners.delete(e), this;
    }, t.prototype.start = function(e) {
      var n = this;
      if (this.status === Qt.Running)
        return this;
      this.machine._init(), fi.register(this.sessionId, this), this.initialized = !0, this.status = Qt.Running;
      var r = e === void 0 ? this.initialState : io(this, function() {
        return yE(e) ? n.machine.resolveState(e) : n.machine.resolveState(Dr.from(e, n.machine.context));
      });
      return this.options.devTools && this.attachDev(), this.scheduler.initialize(function() {
        n.update(r, yo);
      }), this;
    }, t.prototype._stopChildren = function() {
      this.children.forEach(function(e) {
        gt(e.stop) && e.stop();
      }), this.children.clear();
    }, t.prototype._stop = function() {
      var e, n, r, a, s, o, i, c, l, u;
      try {
        for (var d = it(this.listeners), f = d.next(); !f.done; f = d.next()) {
          var p = f.value;
          this.listeners.delete(p);
        }
      } catch (T) {
        e = {
          error: T
        };
      } finally {
        try {
          f && !f.done && (n = d.return) && n.call(d);
        } finally {
          if (e)
            throw e.error;
        }
      }
      try {
        for (var h = it(this.stopListeners), m = h.next(); !m.done; m = h.next()) {
          var p = m.value;
          p(), this.stopListeners.delete(p);
        }
      } catch (T) {
        r = {
          error: T
        };
      } finally {
        try {
          m && !m.done && (a = h.return) && a.call(h);
        } finally {
          if (r)
            throw r.error;
        }
      }
      try {
        for (var g = it(this.contextListeners), v = g.next(); !v.done; v = g.next()) {
          var p = v.value;
          this.contextListeners.delete(p);
        }
      } catch (T) {
        s = {
          error: T
        };
      } finally {
        try {
          v && !v.done && (o = g.return) && o.call(g);
        } finally {
          if (s)
            throw s.error;
        }
      }
      try {
        for (var b = it(this.doneListeners), w = b.next(); !w.done; w = b.next()) {
          var p = w.value;
          this.doneListeners.delete(p);
        }
      } catch (T) {
        i = {
          error: T
        };
      } finally {
        try {
          w && !w.done && (c = b.return) && c.call(b);
        } finally {
          if (i)
            throw i.error;
        }
      }
      if (!this.initialized)
        return this;
      this.initialized = !1, this.status = Qt.Stopped, this._initialState = void 0;
      try {
        for (var S = it(Object.keys(this.delayedEventsMap)), I = S.next(); !I.done; I = S.next()) {
          var E = I.value;
          this.clock.clearTimeout(this.delayedEventsMap[E]);
        }
      } catch (T) {
        l = {
          error: T
        };
      } finally {
        try {
          I && !I.done && (u = S.return) && u.call(S);
        } finally {
          if (l)
            throw l.error;
        }
      }
      this.scheduler.clear(), this.scheduler = new Dy({
        deferEvents: this.options.deferEvents
      });
    }, t.prototype.stop = function() {
      var e = this, n = this.scheduler;
      return this._stop(), n.schedule(function() {
        var r;
        if (!(!((r = e._state) === null || r === void 0) && r.done)) {
          var a = _n({
            type: "xstate.stop"
          }), s = io(e, function() {
            var o = Gt(Bt([], mt(e.state.configuration), !1).sort(function(d, f) {
              return f.order - d.order;
            }).map(function(d) {
              return Fa(d.onExit, e.machine.options.actions);
            })), i = mt(Cc(e.machine, e.state, e.state.context, a, [{
              type: "exit",
              actions: o
            }], e.machine.config.predictableActionArguments ? e._exec : void 0, e.machine.config.predictableActionArguments || e.machine.config.preserveActionOrder), 2), c = i[0], l = i[1], u = new Dr({
              value: e.state.value,
              context: l,
              _event: a,
              _sessionid: e.sessionId,
              historyValue: void 0,
              history: e.state,
              actions: c.filter(function(d) {
                return !$p(d);
              }),
              activities: {},
              events: [],
              configuration: [],
              transitions: [],
              children: {},
              done: e.state.done,
              tags: e.state.tags,
              machine: e.machine
            });
            return u.changed = !0, u;
          });
          e.update(s, a), e._stopChildren(), fi.free(e.sessionId);
        }
      }), this;
    }, t.prototype.batch = function(e) {
      var n = this;
      if (this.status === Qt.NotStarted && this.options.deferEvents)
        Xt || mn(!1, "".concat(e.length, ' event(s) were sent to uninitialized service "').concat(this.machine.id, `" and are deferred. Make sure .start() is called for this service.
Event: `).concat(JSON.stringify(event)));
      else if (this.status !== Qt.Running)
        throw new Error(
          // tslint:disable-next-line:max-line-length
          "".concat(e.length, ' event(s) were sent to uninitialized service "').concat(this.machine.id, '". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.')
        );
      if (e.length) {
        var r = !!this.machine.config.predictableActionArguments && this._exec;
        this.scheduler.schedule(function() {
          var a, s, o = n.state, i = !1, c = [], l = function(p) {
            var h = _n(p);
            n.forward(h), o = io(n, function() {
              return n.machine.transition(o, h, void 0, r || void 0);
            }), c.push.apply(c, Bt([], mt(n.machine.config.predictableActionArguments ? o.actions : o.actions.map(function(m) {
              return vE(m, o);
            })), !1)), i = i || !!o.changed;
          };
          try {
            for (var u = it(e), d = u.next(); !d.done; d = u.next()) {
              var f = d.value;
              l(f);
            }
          } catch (p) {
            a = {
              error: p
            };
          } finally {
            try {
              d && !d.done && (s = u.return) && s.call(u);
            } finally {
              if (a)
                throw a.error;
            }
          }
          o.changed = i, o.actions = c, n.update(o, _n(e[e.length - 1]));
        });
      }
    }, t.prototype.sender = function(e) {
      return this.send.bind(this, e);
    }, t.prototype._nextState = function(e, n) {
      var r = this;
      n === void 0 && (n = !!this.machine.config.predictableActionArguments && this._exec);
      var a = _n(e);
      if (a.name.indexOf(Ty) === 0 && !this.state.nextEvents.some(function(o) {
        return o.indexOf(Ty) === 0;
      }))
        throw a.data.data;
      var s = io(this, function() {
        return r.machine.transition(r.state, a, void 0, n || void 0);
      });
      return s;
    }, t.prototype.nextState = function(e) {
      return this._nextState(e, !1);
    }, t.prototype.forward = function(e) {
      var n, r;
      try {
        for (var a = it(this.forwardTo), s = a.next(); !s.done; s = a.next()) {
          var o = s.value, i = this.children.get(o);
          if (!i)
            throw new Error("Unable to forward event '".concat(e, "' from interpreter '").concat(this.id, "' to nonexistant child '").concat(o, "'."));
          i.send(e);
        }
      } catch (c) {
        n = {
          error: c
        };
      } finally {
        try {
          s && !s.done && (r = a.return) && r.call(a);
        } finally {
          if (n)
            throw n.error;
        }
      }
    }, t.prototype.defer = function(e) {
      var n = this, r = this.clock.setTimeout(function() {
        "to" in e && e.to ? n.sendTo(e._event, e.to, !0) : n.send(e._event);
      }, e.delay);
      e.id && (this.delayedEventsMap[e.id] = r);
    }, t.prototype.cancel = function(e) {
      this.clock.clearTimeout(this.delayedEventsMap[e]), delete this.delayedEventsMap[e];
    }, t.prototype.exec = function(e, n, r) {
      r === void 0 && (r = this.machine.options.actions), this._exec(e, n.context, n._event, r);
    }, t.prototype.removeChild = function(e) {
      var n;
      this.children.delete(e), this.forwardTo.delete(e), (n = this.state) === null || n === void 0 || delete n.children[e];
    }, t.prototype.stopChild = function(e) {
      var n = this.children.get(e);
      n && (this.removeChild(e), gt(n.stop) && n.stop());
    }, t.prototype.spawn = function(e, n, r) {
      if (this.status !== Qt.Running)
        return em(e, n);
      if (Ay(e))
        return this.spawnPromise(Promise.resolve(e), n);
      if (gt(e))
        return this.spawnCallback(e, n);
      if (fE(e))
        return this.spawnActor(e, n);
      if (Kk(e))
        return this.spawnObservable(e, n);
      if (ma(e))
        return this.spawnMachine(e, me(me({}, r), {
          id: n
        }));
      if (Uk(e))
        return this.spawnBehavior(e, n);
      throw new Error('Unable to spawn entity "'.concat(n, '" of type "').concat(typeof e, '".'));
    }, t.prototype.spawnMachine = function(e, n) {
      var r = this;
      n === void 0 && (n = {});
      var a = new t(e, me(me({}, this.options), {
        parent: this,
        id: n.id || e.id
      })), s = me(me({}, Fp), n);
      s.sync && a.onTransition(function(i) {
        r.send(w0, {
          state: i,
          id: a.id
        });
      });
      var o = a;
      return this.children.set(a.id, o), s.autoForward && this.forwardTo.add(a.id), a.onDone(function(i) {
        r.removeChild(a.id), r.send(_n(i, {
          origin: a.id
        }));
      }).start(), o;
    }, t.prototype.spawnBehavior = function(e, n) {
      var r = xE(e, {
        id: n,
        parent: this
      });
      return this.children.set(n, r), r;
    }, t.prototype.spawnPromise = function(e, n) {
      var r, a = this, s = !1, o;
      e.then(function(c) {
        s || (o = c, a.removeChild(n), a.send(_n(gc(n, c), {
          origin: n
        })));
      }, function(c) {
        if (!s) {
          a.removeChild(n);
          var l = Ni(n, c);
          try {
            a.send(_n(l, {
              origin: n
            }));
          } catch (u) {
            Jk(c, u, n), a.devTools && a.devTools.send(l, a.state), a.machine.strict && a.stop();
          }
        }
      });
      var i = (r = {
        id: n,
        send: function() {
        },
        subscribe: function(c, l, u) {
          var d = zi(c, l, u), f = !1;
          return e.then(function(p) {
            f || (d.next(p), !f && d.complete());
          }, function(p) {
            f || d.error(p);
          }), {
            unsubscribe: function() {
              return f = !0;
            }
          };
        },
        stop: function() {
          s = !0;
        },
        toJSON: function() {
          return {
            id: n
          };
        },
        getSnapshot: function() {
          return o;
        }
      }, r[Oa] = function() {
        return this;
      }, r);
      return this.children.set(n, i), i;
    }, t.prototype.spawnCallback = function(e, n) {
      var r, a = this, s = !1, o = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), c, l = function(f) {
        c = f, i.forEach(function(p) {
          return p(f);
        }), !s && a.send(_n(f, {
          origin: n
        }));
      }, u;
      try {
        u = e(l, function(f) {
          o.add(f);
        });
      } catch (f) {
        this.send(Ni(n, f));
      }
      if (Ay(u))
        return this.spawnPromise(u, n);
      var d = (r = {
        id: n,
        send: function(f) {
          return o.forEach(function(p) {
            return p(f);
          });
        },
        subscribe: function(f) {
          var p = zi(f);
          return i.add(p.next), {
            unsubscribe: function() {
              i.delete(p.next);
            }
          };
        },
        stop: function() {
          s = !0, gt(u) && u();
        },
        toJSON: function() {
          return {
            id: n
          };
        },
        getSnapshot: function() {
          return c;
        }
      }, r[Oa] = function() {
        return this;
      }, r);
      return this.children.set(n, d), d;
    }, t.prototype.spawnObservable = function(e, n) {
      var r, a = this, s, o = e.subscribe(function(c) {
        s = c, a.send(_n(c, {
          origin: n
        }));
      }, function(c) {
        a.removeChild(n), a.send(_n(Ni(n, c), {
          origin: n
        }));
      }, function() {
        a.removeChild(n), a.send(_n(gc(n), {
          origin: n
        }));
      }), i = (r = {
        id: n,
        send: function() {
        },
        subscribe: function(c, l, u) {
          return e.subscribe(c, l, u);
        },
        stop: function() {
          return o.unsubscribe();
        },
        getSnapshot: function() {
          return s;
        },
        toJSON: function() {
          return {
            id: n
          };
        }
      }, r[Oa] = function() {
        return this;
      }, r);
      return this.children.set(n, i), i;
    }, t.prototype.spawnActor = function(e, n) {
      return this.children.set(n, e), e;
    }, t.prototype.spawnActivity = function(e) {
      var n = this.machine.options && this.machine.options.activities ? this.machine.options.activities[e.type] : void 0;
      if (!n) {
        Xt || mn(!1, "No implementation found for activity '".concat(e.type, "'"));
        return;
      }
      var r = n(this.state.context, e);
      this.spawnEffect(e.id, r);
    }, t.prototype.spawnEffect = function(e, n) {
      var r;
      this.children.set(e, (r = {
        id: e,
        send: function() {
        },
        subscribe: function() {
          return {
            unsubscribe: function() {
            }
          };
        },
        stop: n || void 0,
        getSnapshot: function() {
        },
        toJSON: function() {
          return {
            id: e
          };
        }
      }, r[Oa] = function() {
        return this;
      }, r));
    }, t.prototype.attachDev = function() {
      var e = tm();
      if (this.options.devTools && e) {
        if (e.__REDUX_DEVTOOLS_EXTENSION__) {
          var n = typeof this.options.devTools == "object" ? this.options.devTools : void 0;
          this.devTools = e.__REDUX_DEVTOOLS_EXTENSION__.connect(me(me({
            name: this.id,
            autoPause: !0,
            stateSanitizer: function(r) {
              return {
                value: r.value,
                context: r.context,
                actions: r.actions
              };
            }
          }, n), {
            features: me({
              jump: !1,
              skip: !1
            }, n ? n.features : void 0)
          }), this.machine), this.devTools.init(this.state);
        }
        _E(this);
      }
    }, t.prototype.toJSON = function() {
      return {
        id: this.id
      };
    }, t.prototype[Oa] = function() {
      return this;
    }, t.prototype.getSnapshot = function() {
      return this.status === Qt.NotStarted ? this.initialState : this._state;
    }, t.defaultOptions = {
      execute: !0,
      deferEvents: !0,
      clock: {
        setTimeout: function(e, n) {
          return setTimeout(e, n);
        },
        clearTimeout: function(e) {
          return clearTimeout(e);
        }
      },
      logger: /* @__PURE__ */ console.log.bind(console),
      devTools: !1
    }, t.interpret = D0, t;
  }()
), kE = function(t) {
  return pt(t) ? me(me({}, Fp), {
    name: t
  }) : me(me(me({}, Fp), {
    name: Yk()
  }), t);
};
function EE(t, e) {
  var n = kE(e);
  return cE(function(r) {
    if (!Xt) {
      var a = ma(t) || gt(t);
      mn(!!r || a, 'Attempted to spawn an Actor (ID: "'.concat(ma(t) ? t.id : "undefined", '") outside of a service. This will have no effect.'));
    }
    return r ? r.spawn(t, n.name, n) : em(t, n.name);
  });
}
function D0(t, e) {
  var n = new IE(t, e);
  return n;
}
function TE(t) {
  if (typeof t == "string") {
    var e = {
      type: t
    };
    return e.toString = function() {
      return t;
    }, e;
  }
  return t;
}
function sc(t) {
  return me(me({
    type: Np
  }, t), {
    toJSON: function() {
      t.onDone, t.onError;
      var e = Xh(t, ["onDone", "onError"]);
      return me(me({}, e), {
        type: Np,
        src: TE(t.src)
      });
    }
  });
}
var uo = "", Mp = "#", pi = "*", ro = {}, ao = function(t) {
  return t[0] === Mp;
}, CE = function() {
  return {
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {}
  };
}, NE = function(t, e, n) {
  var r = n.slice(0, -1).some(function(s) {
    return !("cond" in s) && !("in" in s) && (pt(s.target) || ma(s.target));
  }), a = e === uo ? "the transient event" : "event '".concat(e, "'");
  mn(!r, "One or more transitions for ".concat(a, " on state '").concat(t.id, "' are unreachable. ") + "Make sure that the default transition is the last one defined.");
}, AE = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, n, r, a) {
      r === void 0 && (r = "context" in e ? e.context : void 0);
      var s = this, o;
      this.config = e, this._context = r, this.order = -1, this.__xstatenode = !0, this.__cache = {
        events: void 0,
        relativeValue: /* @__PURE__ */ new Map(),
        initialStateValue: void 0,
        initialState: void 0,
        on: void 0,
        transitions: void 0,
        candidates: {},
        delayedTransitions: void 0
      }, this.idMap = {}, this.tags = [], this.options = Object.assign(CE(), n), this.parent = a?.parent, this.key = this.config.key || a?.key || this.config.id || "(machine)", this.machine = this.parent ? this.parent.machine : this, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : S0), this.id = this.config.id || Bt([this.machine.key], mt(this.path), !1).join(this.delimiter), this.version = this.parent ? this.parent.version : this.config.version, this.type = this.config.type || (this.config.parallel ? "parallel" : this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.schema = this.parent ? this.machine.schema : (o = this.config.schema) !== null && o !== void 0 ? o : {}, this.description = this.config.description, Xt || mn(!("parallel" in this.config), 'The "parallel" property is deprecated and will be removed in version 4.1. '.concat(this.config.parallel ? "Replace with `type: 'parallel'`" : "Use `type: '".concat(this.type, "'`"), " in the config for state node '").concat(this.id, "' instead.")), this.initial = this.config.initial, this.states = this.config.states ? Ei(this.config.states, function(l, u) {
        var d, f = new t(l, {}, void 0, {
          parent: s,
          key: u
        });
        return Object.assign(s.idMap, me((d = {}, d[f.id] = f, d), f.idMap)), f;
      }) : ro;
      var i = 0;
      function c(l) {
        var u, d;
        l.order = i++;
        try {
          for (var f = it(N0(l)), p = f.next(); !p.done; p = f.next()) {
            var h = p.value;
            c(h);
          }
        } catch (m) {
          u = {
            error: m
          };
        } finally {
          try {
            p && !p.done && (d = f.return) && d.call(f);
          } finally {
            if (u)
              throw u.error;
          }
        }
      }
      c(this), this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this._transient = !!this.config.always || (this.config.on ? Array.isArray(this.config.on) ? this.config.on.some(function(l) {
        var u = l.event;
        return u === uo;
      }) : uo in this.config.on : !1), this.strict = !!this.config.strict, this.onEntry = $r(this.config.entry || this.config.onEntry).map(function(l) {
        return Yi(l);
      }), this.onExit = $r(this.config.exit || this.config.onExit).map(function(l) {
        return Yi(l);
      }), this.meta = this.config.meta, this.doneData = this.type === "final" ? this.config.data : void 0, this.invoke = $r(this.config.invoke).map(function(l, u) {
        var d, f;
        if (ma(l)) {
          var p = rc(s.id, u);
          return s.machine.options.services = me((d = {}, d[p] = l, d), s.machine.options.services), sc({
            src: p,
            id: p
          });
        } else if (pt(l.src)) {
          var p = l.id || rc(s.id, u);
          return sc(me(me({}, l), {
            id: p,
            src: l.src
          }));
        } else if (ma(l.src) || gt(l.src)) {
          var p = l.id || rc(s.id, u);
          return s.machine.options.services = me((f = {}, f[p] = l.src, f), s.machine.options.services), sc(me(me({
            id: p
          }, l), {
            src: p
          }));
        } else {
          var h = l.src;
          return sc(me(me({
            id: rc(s.id, u)
          }, l), {
            src: h
          }));
        }
      }), this.activities = $r(this.config.activities).concat(this.invoke).map(function(l) {
        return Qh(l);
      }), this.transition = this.transition.bind(this), this.tags = $r(this.config.tags);
    }
    return t.prototype._init = function() {
      this.__cache.transitions || A0(this).forEach(function(e) {
        return e.on;
      });
    }, t.prototype.withConfig = function(e, n) {
      var r = this.options, a = r.actions, s = r.activities, o = r.guards, i = r.services, c = r.delays;
      return new t(this.config, {
        actions: me(me({}, a), e.actions),
        activities: me(me({}, s), e.activities),
        guards: me(me({}, o), e.guards),
        services: me(me({}, i), e.services),
        delays: me(me({}, c), e.delays)
      }, n ?? this.context);
    }, t.prototype.withContext = function(e) {
      return new t(this.config, this.options, e);
    }, Object.defineProperty(t.prototype, "context", {
      get: function() {
        return gt(this._context) ? this._context() : this._context;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "definition", {
      /**
       * The well-structured state node definition.
       */
      get: function() {
        return {
          id: this.id,
          key: this.key,
          version: this.version,
          context: this.context,
          type: this.type,
          initial: this.initial,
          history: this.history,
          states: Ei(this.states, function(e) {
            return e.definition;
          }),
          on: this.on,
          transitions: this.transitions,
          entry: this.onEntry,
          exit: this.onExit,
          activities: this.activities || [],
          meta: this.meta,
          order: this.order || -1,
          data: this.doneData,
          invoke: this.invoke,
          description: this.description,
          tags: this.tags
        };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.toJSON = function() {
      return this.definition;
    }, Object.defineProperty(t.prototype, "on", {
      /**
       * The mapping of events to transitions.
       */
      get: function() {
        if (this.__cache.on)
          return this.__cache.on;
        var e = this.transitions;
        return this.__cache.on = e.reduce(function(n, r) {
          return n[r.eventType] = n[r.eventType] || [], n[r.eventType].push(r), n;
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "after", {
      get: function() {
        return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "transitions", {
      /**
       * All the transitions that can be taken from this state node.
       */
      get: function() {
        return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getCandidates = function(e) {
      if (this.__cache.candidates[e])
        return this.__cache.candidates[e];
      var n = e === uo, r = this.transitions.filter(function(a) {
        var s = a.eventType === e;
        return n ? s : s || a.eventType === pi;
      });
      return this.__cache.candidates[e] = r, r;
    }, t.prototype.getDelayedTransitions = function() {
      var e = this, n = this.config.after;
      if (!n)
        return [];
      var r = function(s, o) {
        var i = gt(s) ? "".concat(e.id, ":delay[").concat(o, "]") : s, c = iE(i, e.id);
        return e.onEntry.push(Ti(c, {
          delay: s
        })), e.onExit.push(Ci(c)), c;
      }, a = Mo(n) ? n.map(function(s, o) {
        var i = r(s.delay, o);
        return me(me({}, s), {
          event: i
        });
      }) : Gt(Object.keys(n).map(function(s, o) {
        var i = n[s], c = pt(i) ? {
          target: i
        } : i, l = isNaN(+s) ? s : +s, u = r(l, o);
        return $r(c).map(function(d) {
          return me(me({}, d), {
            event: u,
            delay: l
          });
        });
      }));
      return a.map(function(s) {
        var o = s.delay;
        return me(me({}, e.formatTransition(s)), {
          delay: o
        });
      });
    }, t.prototype.getStateNodes = function(e) {
      var n, r = this;
      if (!e)
        return [];
      var a = e instanceof Dr ? e.value : Wi(e, this.delimiter);
      if (pt(a)) {
        var s = this.getStateNode(a).initial;
        return s !== void 0 ? this.getStateNodes((n = {}, n[a] = s, n)) : [this, this.states[a]];
      }
      var o = Object.keys(a), i = [this];
      return i.push.apply(i, Bt([], mt(Gt(o.map(function(c) {
        return r.getStateNode(c).getStateNodes(a[c]);
      }))), !1)), i;
    }, t.prototype.handles = function(e) {
      var n = _0(e);
      return this.events.includes(n);
    }, t.prototype.resolveState = function(e) {
      var n = e instanceof Dr ? e : Dr.create(e), r = Array.from(Ai([], this.getStateNodes(n.value)));
      return new Dr(me(me({}, n), {
        value: this.resolve(n.value),
        configuration: r,
        done: yc(r, this),
        tags: $y(r),
        machine: this.machine
      }));
    }, t.prototype.transitionLeafNode = function(e, n, r) {
      var a = this.getStateNode(e), s = a.next(n, r);
      return !s || !s.transitions.length ? this.next(n, r) : s;
    }, t.prototype.transitionCompoundNode = function(e, n, r) {
      var a = Object.keys(e), s = this.getStateNode(a[0]), o = s._transition(e[a[0]], n, r);
      return !o || !o.transitions.length ? this.next(n, r) : o;
    }, t.prototype.transitionParallelNode = function(e, n, r) {
      var a, s, o = {};
      try {
        for (var i = it(Object.keys(e)), c = i.next(); !c.done; c = i.next()) {
          var l = c.value, u = e[l];
          if (u) {
            var d = this.getStateNode(l), f = d._transition(u, n, r);
            f && (o[l] = f);
          }
        }
      } catch (v) {
        a = {
          error: v
        };
      } finally {
        try {
          c && !c.done && (s = i.return) && s.call(i);
        } finally {
          if (a)
            throw a.error;
        }
      }
      var p = Object.keys(o).map(function(v) {
        return o[v];
      }), h = Gt(p.map(function(v) {
        return v.transitions;
      })), m = p.some(function(v) {
        return v.transitions.length > 0;
      });
      if (!m)
        return this.next(n, r);
      var g = Gt(Object.keys(o).map(function(v) {
        return o[v].configuration;
      }));
      return {
        transitions: h,
        exitSet: Gt(p.map(function(v) {
          return v.exitSet;
        })),
        configuration: g,
        source: n,
        actions: Gt(Object.keys(o).map(function(v) {
          return o[v].actions;
        }))
      };
    }, t.prototype._transition = function(e, n, r) {
      return pt(e) ? this.transitionLeafNode(e, n, r) : Object.keys(e).length === 1 ? this.transitionCompoundNode(e, n, r) : this.transitionParallelNode(e, n, r);
    }, t.prototype.getTransitionData = function(e, n) {
      return this._transition(e.value, e, _n(n));
    }, t.prototype.next = function(e, n) {
      var r, a, s = this, o = n.name, i = [], c = [], l;
      try {
        for (var u = it(this.getCandidates(o)), d = u.next(); !d.done; d = u.next()) {
          var f = d.value, p = f.cond, h = f.in, m = e.context, g = h ? pt(h) && ao(h) ? (
            // Check if in state by ID
            e.matches(Wi(this.getStateNodeById(h).path, this.delimiter))
          ) : (
            // Check if in state by relative grandparent
            Jh(Wi(h, this.delimiter), Vk(this.path.slice(0, -2))(e.value))
          ) : !0, v = !1;
          try {
            v = !p || E0(this.machine, p, m, n, e);
          } catch (S) {
            throw new Error("Unable to evaluate guard '".concat(p.name || p.type, "' in transition for event '").concat(o, "' in state node '").concat(this.id, `':
`).concat(S.message));
          }
          if (v && g) {
            f.target !== void 0 && (c = f.target), i.push.apply(i, Bt([], mt(f.actions), !1)), l = f;
            break;
          }
        }
      } catch (S) {
        r = {
          error: S
        };
      } finally {
        try {
          d && !d.done && (a = u.return) && a.call(u);
        } finally {
          if (r)
            throw r.error;
        }
      }
      if (l) {
        if (!c.length)
          return {
            transitions: [l],
            exitSet: [],
            configuration: e.value ? [this] : [],
            source: e,
            actions: i
          };
        var b = Gt(c.map(function(S) {
          return s.getRelativeStateNodes(S, e.historyValue);
        })), w = !!l.internal;
        return {
          transitions: [l],
          exitSet: w ? [] : Gt(c.map(function(S) {
            return s.getPotentiallyReenteringNodes(S);
          })),
          configuration: b,
          source: e,
          actions: i
        };
      }
    }, t.prototype.getPotentiallyReenteringNodes = function(e) {
      if (this.order < e.order)
        return [this];
      for (var n = [], r = this, a = e; r && r !== a; )
        n.push(r), r = r.parent;
      return r !== a ? [] : (n.push(a), n);
    }, t.prototype.getActions = function(e, n, r, a, s, o, i) {
      var c, l, u, d, f = this, p = o ? Ai([], this.getStateNodes(o.value)) : [], h = /* @__PURE__ */ new Set();
      try {
        for (var m = it(Array.from(e).sort(function(M, z) {
          return M.order - z.order;
        })), g = m.next(); !g.done; g = m.next()) {
          var v = g.value;
          (!Ri(p, v) || Ri(r.exitSet, v) || v.parent && h.has(v.parent)) && h.add(v);
        }
      } catch (M) {
        c = {
          error: M
        };
      } finally {
        try {
          g && !g.done && (l = m.return) && l.call(m);
        } finally {
          if (c)
            throw c.error;
        }
      }
      try {
        for (var b = it(p), w = b.next(); !w.done; w = b.next()) {
          var v = w.value;
          (!Ri(e, v) || Ri(r.exitSet, v.parent)) && r.exitSet.push(v);
        }
      } catch (M) {
        u = {
          error: M
        };
      } finally {
        try {
          w && !w.done && (d = b.return) && d.call(b);
        } finally {
          if (u)
            throw u.error;
        }
      }
      r.exitSet.sort(function(M, z) {
        return z.order - M.order;
      });
      var S = Array.from(h).sort(function(M, z) {
        return M.order - z.order;
      }), I = new Set(r.exitSet), E = Gt(S.map(function(M) {
        var z = [];
        if (M.type !== "final")
          return z;
        var F = M.parent;
        if (!F.parent)
          return z;
        z.push(
          ac(M.id, M.doneData),
          // TODO: deprecate - final states should not emit done events for their own state.
          ac(F.id, M.doneData ? Tc(M.doneData, a, s) : void 0)
        );
        var V = F.parent;
        return V.type === "parallel" && Zi(V).every(function(H) {
          return yc(r.configuration, H);
        }) && z.push(ac(V.id)), z;
      })), T = S.map(function(M) {
        var z = M.onEntry, F = M.activities.map(function(V) {
          return rE(V);
        });
        return {
          type: "entry",
          actions: Fa(i ? Bt(Bt([], mt(z), !1), mt(F), !1) : Bt(Bt([], mt(F), !1), mt(z), !1), f.machine.options.actions)
        };
      }).concat({
        type: "state_done",
        actions: E.map(function(M) {
          return Qk(M);
        })
      }), R = Array.from(I).map(function(M) {
        return {
          type: "exit",
          actions: Fa(Bt(Bt([], mt(M.onExit), !1), mt(M.activities.map(function(z) {
            return aE(z);
          })), !1), f.machine.options.actions)
        };
      }), $ = R.concat({
        type: "transition",
        actions: Fa(r.actions, this.machine.options.actions)
      }).concat(T);
      if (n) {
        var D = Fa(Gt(Bt([], mt(e), !1).sort(function(M, z) {
          return z.order - M.order;
        }).map(function(M) {
          return M.onExit;
        })), this.machine.options.actions).filter(function(M) {
          return !$p(M);
        });
        return $.concat({
          type: "stop",
          actions: D
        });
      }
      return $;
    }, t.prototype.transition = function(e, n, r, a) {
      e === void 0 && (e = this.initialState);
      var s = _n(n), o;
      if (e instanceof Dr)
        o = r === void 0 ? e : this.resolveState(Dr.from(e, r));
      else {
        var i = pt(e) ? this.resolve(Ec(this.getResolvedPath(e))) : this.resolve(e), c = r ?? this.machine.context;
        o = this.resolveState(Dr.from(i, c));
      }
      if (!Xt && s.name === pi)
        throw new Error("An event cannot have the wildcard type ('".concat(pi, "')"));
      if (this.strict && !this.events.includes(s.name) && !jk(s.name))
        throw new Error("Machine '".concat(this.id, "' does not accept event '").concat(s.name, "'"));
      var l = this._transition(o.value, o, s) || {
        transitions: [],
        configuration: [],
        exitSet: [],
        source: o,
        actions: []
      }, u = Ai([], this.getStateNodes(o.value)), d = l.configuration.length ? Ai(u, l.configuration) : u;
      return l.configuration = Bt([], mt(d), !1), this.resolveTransition(l, o, o.context, a, s);
    }, t.prototype.resolveRaisedTransition = function(e, n, r, a) {
      var s, o = e.actions;
      return e = this.transition(e, n, void 0, a), e._event = r, e.event = r.data, (s = e.actions).unshift.apply(s, Bt([], mt(o), !1)), e;
    }, t.prototype.resolveTransition = function(e, n, r, a, s) {
      var o, i, c, l, u = this;
      s === void 0 && (s = yo);
      var d = e.configuration, f = !n || e.transitions.length > 0, p = f ? e.configuration : n ? n.configuration : [], h = yc(p, this), m = f ? hE(this.machine, d) : void 0, g = n ? n.historyValue ? n.historyValue : e.source ? this.machine.historyValue(n.value) : void 0 : void 0, v = this.getActions(new Set(p), h, e, r, s, n, a), b = n ? me({}, n.activities) : {};
      try {
        for (var w = it(v), S = w.next(); !S.done; S = w.next()) {
          var I = S.value;
          try {
            for (var E = (c = void 0, it(I.actions)), T = E.next(); !T.done; T = E.next()) {
              var R = T.value;
              R.type === Cp ? b[R.activity.id || R.activity.type] = R : R.type === Yh && (b[R.activity.id || R.activity.type] = !1);
            }
          } catch (ne) {
            c = {
              error: ne
            };
          } finally {
            try {
              T && !T.done && (l = E.return) && l.call(E);
            } finally {
              if (c)
                throw c.error;
            }
          }
        }
      } catch (ne) {
        o = {
          error: ne
        };
      } finally {
        try {
          S && !S.done && (i = w.return) && i.call(w);
        } finally {
          if (o)
            throw o.error;
        }
      }
      var $ = mt(Cc(this, n, r, s, v, a, this.machine.config.predictableActionArguments || this.machine.config.preserveActionOrder), 2), D = $[0], M = $[1], z = mt(Gk(D, $p), 2), F = z[0], V = z[1], H = D.filter(function(ne) {
        var oe;
        return ne.type === Cp && ((oe = ne.activity) === null || oe === void 0 ? void 0 : oe.type) === Np;
      }), U = H.reduce(function(ne, oe) {
        return ne[oe.activity.id] = lE(oe.activity, u.machine, M, s), ne;
      }, n ? me({}, n.children) : {}), Z = new Dr({
        value: m || n.value,
        context: M,
        _event: s,
        // Persist _sessionid between states
        _sessionid: n ? n._sessionid : null,
        historyValue: m ? g ? qk(g, m) : void 0 : n ? n.historyValue : void 0,
        history: !m || e.source ? n : void 0,
        actions: m ? V : [],
        activities: m ? b : n ? n.activities : {},
        events: [],
        configuration: p,
        transitions: e.transitions,
        children: U,
        done: h,
        tags: $y(p),
        machine: this
      }), q = r !== M;
      Z.changed = s.name === w0 || q;
      var X = Z.history;
      X && delete X.history;
      var se = !h && (this._transient || d.some(function(ne) {
        return ne._transient;
      }));
      if (!f && (!se || s.name === uo))
        return Z;
      var te = Z;
      if (!h)
        for (se && (te = this.resolveRaisedTransition(te, {
          type: Fk
        }, s, a)); F.length; ) {
          var ue = F.shift();
          te = this.resolveRaisedTransition(te, ue._event, s, a);
        }
      var ee = te.changed || (X ? !!te.actions.length || q || typeof X.value != typeof te.value || !$0(te.value, X.value) : void 0);
      return te.changed = ee, te.history = X, te;
    }, t.prototype.getStateNode = function(e) {
      if (ao(e))
        return this.machine.getStateNodeById(e);
      if (!this.states)
        throw new Error("Unable to retrieve child state '".concat(e, "' from '").concat(this.id, "'; no child states exist."));
      var n = this.states[e];
      if (!n)
        throw new Error("Child state '".concat(e, "' does not exist on '").concat(this.id, "'"));
      return n;
    }, t.prototype.getStateNodeById = function(e) {
      var n = ao(e) ? e.slice(Mp.length) : e;
      if (n === this.id)
        return this;
      var r = this.machine.idMap[n];
      if (!r)
        throw new Error("Child state node '#".concat(n, "' does not exist on machine '").concat(this.id, "'"));
      return r;
    }, t.prototype.getStateNodeByPath = function(e) {
      if (typeof e == "string" && ao(e))
        try {
          return this.getStateNodeById(e.slice(1));
        } catch {
        }
      for (var n = Rp(e, this.delimiter).slice(), r = this; n.length; ) {
        var a = n.shift();
        if (!a.length)
          break;
        r = r.getStateNode(a);
      }
      return r;
    }, t.prototype.resolve = function(e) {
      var n, r = this;
      if (!e)
        return this.initialStateValue || ro;
      switch (this.type) {
        case "parallel":
          return Ei(this.initialStateValue, function(s, o) {
            return s ? r.getStateNode(o).resolve(e[o] || s) : ro;
          });
        case "compound":
          if (pt(e)) {
            var a = this.getStateNode(e);
            return a.type === "parallel" || a.type === "compound" ? (n = {}, n[e] = a.initialStateValue, n) : e;
          }
          return Object.keys(e).length ? Ei(e, function(s, o) {
            return s ? r.getStateNode(o).resolve(s) : ro;
          }) : this.initialStateValue || {};
        default:
          return e || ro;
      }
    }, t.prototype.getResolvedPath = function(e) {
      if (ao(e)) {
        var n = this.machine.idMap[e.slice(Mp.length)];
        if (!n)
          throw new Error("Unable to find state node '".concat(e, "'"));
        return n.path;
      }
      return Rp(e, this.delimiter);
    }, Object.defineProperty(t.prototype, "initialStateValue", {
      get: function() {
        var e;
        if (this.__cache.initialStateValue)
          return this.__cache.initialStateValue;
        var n;
        if (this.type === "parallel")
          n = Ny(this.states, function(r) {
            return r.initialStateValue || ro;
          }, function(r) {
            return r.type !== "history";
          });
        else if (this.initial !== void 0) {
          if (!this.states[this.initial])
            throw new Error("Initial state '".concat(this.initial, "' not found on '").concat(this.key, "'"));
          n = Ac(this.states[this.initial]) ? this.initial : (e = {}, e[this.initial] = this.states[this.initial].initialStateValue, e);
        } else
          n = {};
        return this.__cache.initialStateValue = n, this.__cache.initialStateValue;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getInitialState = function(e, n) {
      this._init();
      var r = this.getStateNodes(e);
      return this.resolveTransition({
        configuration: r,
        exitSet: [],
        transitions: [],
        source: void 0,
        actions: []
      }, void 0, n ?? this.machine.context, void 0);
    }, Object.defineProperty(t.prototype, "initialState", {
      /**
       * The initial State instance, which includes all actions to be executed from
       * entering the initial state.
       */
      get: function() {
        var e = this.initialStateValue;
        if (!e)
          throw new Error("Cannot retrieve initial state from simple state '".concat(this.id, "'."));
        return this.getInitialState(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "target", {
      /**
       * The target state value of the history state node, if it exists. This represents the
       * default state value to transition to if no history value exists yet.
       */
      get: function() {
        var e;
        if (this.type === "history") {
          var n = this.config;
          pt(n.target) ? e = ao(n.target) ? Ec(this.machine.getStateNodeById(n.target).path.slice(this.path.length - 1)) : n.target : e = n.target;
        }
        return e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getRelativeStateNodes = function(e, n, r) {
      return r === void 0 && (r = !0), r ? e.type === "history" ? e.resolveHistory(n) : e.initialStateNodes : [e];
    }, Object.defineProperty(t.prototype, "initialStateNodes", {
      get: function() {
        var e = this;
        if (Ac(this))
          return [this];
        if (this.type === "compound" && !this.initial)
          return Xt || mn(!1, "Compound state node '".concat(this.id, "' has no initial state.")), [this];
        var n = mc(this.initialStateValue);
        return Gt(n.map(function(r) {
          return e.getFromRelativePath(r);
        }));
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getFromRelativePath = function(e) {
      if (!e.length)
        return [this];
      var n = mt(e), r = n[0], a = n.slice(1);
      if (!this.states)
        throw new Error("Cannot retrieve subPath '".concat(r, "' from node with no states"));
      var s = this.getStateNode(r);
      if (s.type === "history")
        return s.resolveHistory();
      if (!this.states[r])
        throw new Error("Child state '".concat(r, "' does not exist on '").concat(this.id, "'"));
      return this.states[r].getFromRelativePath(a);
    }, t.prototype.historyValue = function(e) {
      if (Object.keys(this.states).length)
        return {
          current: e || this.initialStateValue,
          states: Ny(this.states, function(n, r) {
            if (!e)
              return n.historyValue();
            var a = pt(e) ? void 0 : e[r];
            return n.historyValue(a || n.initialStateValue);
          }, function(n) {
            return !n.history;
          })
        };
    }, t.prototype.resolveHistory = function(e) {
      var n = this;
      if (this.type !== "history")
        return [this];
      var r = this.parent;
      if (!e) {
        var a = this.target;
        return a ? Gt(mc(a).map(function(o) {
          return r.getFromRelativePath(o);
        })) : r.initialStateNodes;
      }
      var s = Hk(r.path, "states")(e).current;
      return pt(s) ? [r.getStateNode(s)] : Gt(mc(s).map(function(o) {
        return n.history === "deep" ? r.getFromRelativePath(o) : [r.states[o[0]]];
      }));
    }, Object.defineProperty(t.prototype, "stateIds", {
      /**
       * All the state node IDs of this state node and its descendant state nodes.
       */
      get: function() {
        var e = this, n = Gt(Object.keys(this.states).map(function(r) {
          return e.states[r].stateIds;
        }));
        return [this.id].concat(n);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "events", {
      /**
       * All the event types accepted by this state node and its descendants.
       */
      get: function() {
        var e, n, r, a;
        if (this.__cache.events)
          return this.__cache.events;
        var s = this.states, o = new Set(this.ownEvents);
        if (s)
          try {
            for (var i = it(Object.keys(s)), c = i.next(); !c.done; c = i.next()) {
              var l = c.value, u = s[l];
              if (u.states)
                try {
                  for (var d = (r = void 0, it(u.events)), f = d.next(); !f.done; f = d.next()) {
                    var p = f.value;
                    o.add("".concat(p));
                  }
                } catch (h) {
                  r = {
                    error: h
                  };
                } finally {
                  try {
                    f && !f.done && (a = d.return) && a.call(d);
                  } finally {
                    if (r)
                      throw r.error;
                  }
                }
            }
          } catch (h) {
            e = {
              error: h
            };
          } finally {
            try {
              c && !c.done && (n = i.return) && n.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
        return this.__cache.events = Array.from(o);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "ownEvents", {
      /**
       * All the events that have transitions directly from this state node.
       *
       * Excludes any inert events.
       */
      get: function() {
        var e = new Set(this.transitions.filter(function(n) {
          return !(!n.target && !n.actions.length && n.internal);
        }).map(function(n) {
          return n.eventType;
        }));
        return Array.from(e);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resolveTarget = function(e) {
      var n = this;
      if (e !== void 0)
        return e.map(function(r) {
          if (!pt(r))
            return r;
          var a = r[0] === n.delimiter;
          if (a && !n.parent)
            return n.getStateNodeByPath(r.slice(1));
          var s = a ? n.key + r : r;
          if (n.parent)
            try {
              var o = n.parent.getStateNodeByPath(s);
              return o;
            } catch (i) {
              throw new Error("Invalid transition definition for state node '".concat(n.id, `':
`).concat(i.message));
            }
          else
            return n.getStateNodeByPath(s);
        });
    }, t.prototype.formatTransition = function(e) {
      var n = this, r = Zk(e.target), a = "internal" in e ? e.internal : r ? r.some(function(c) {
        return pt(c) && c[0] === n.delimiter;
      }) : !0, s = this.machine.options.guards, o = this.resolveTarget(r), i = me(me({}, e), {
        actions: Fa($r(e.actions)),
        cond: k0(e.cond, s),
        target: o,
        source: this,
        internal: a,
        eventType: e.event,
        toJSON: function() {
          return me(me({}, i), {
            target: i.target ? i.target.map(function(c) {
              return "#".concat(c.id);
            }) : void 0,
            source: "#".concat(n.id)
          });
        }
      });
      return i;
    }, t.prototype.formatTransitions = function() {
      var e, n, r = this, a;
      if (!this.config.on)
        a = [];
      else if (Array.isArray(this.config.on))
        a = this.config.on;
      else {
        var s = this.config.on, o = pi, i = s[o], c = i === void 0 ? [] : i, l = Xh(s, [typeof o == "symbol" ? o : o + ""]);
        a = Gt(Object.keys(l).map(function(b) {
          !Xt && b === uo && mn(!1, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " + 'Please check the `on` configuration for "#'.concat(r.id, '".'));
          var w = no(b, l[b]);
          return Xt || NE(r, b, w), w;
        }).concat(no(pi, c)));
      }
      var u = this.config.always ? no("", this.config.always) : [], d = this.config.onDone ? no(String(ac(this.id)), this.config.onDone) : [];
      Xt || mn(!(this.config.onDone && !this.parent), 'Root nodes cannot have an ".onDone" transition. Please check the config of "'.concat(this.id, '".'));
      var f = Gt(this.invoke.map(function(b) {
        var w = [];
        return b.onDone && w.push.apply(w, Bt([], mt(no(String(gc(b.id)), b.onDone)), !1)), b.onError && w.push.apply(w, Bt([], mt(no(String(Ni(b.id)), b.onError)), !1)), w;
      })), p = this.after, h = Gt(Bt(Bt(Bt(Bt([], mt(d), !1), mt(f), !1), mt(a), !1), mt(u), !1).map(function(b) {
        return $r(b).map(function(w) {
          return r.formatTransition(w);
        });
      }));
      try {
        for (var m = it(p), g = m.next(); !g.done; g = m.next()) {
          var v = g.value;
          h.push(v);
        }
      } catch (b) {
        e = {
          error: b
        };
      } finally {
        try {
          g && !g.done && (n = m.return) && n.call(m);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return h;
    }, t;
  }()
), Oy = !1;
function RE(t, e) {
  return !Xt && !("predictableActionArguments" in t) && !Oy && (Oy = !0, console.warn("It is highly recommended to set `predictableActionArguments` to `true` when using `createMachine`. https://xstate.js.org/docs/guides/actions.html")), new AE(t, e);
}
var xt = oE, O0 = sI;
function Pp(t) {
  var e = re.useRef();
  return e.current || (e.current = { v: t() }), e.current.v;
}
var Rc = globalThis && globalThis.__assign || function() {
  return Rc = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var a in e)
        Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
    }
    return t;
  }, Rc.apply(this, arguments);
}, $E = globalThis && globalThis.__rest || function(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}, F0 = globalThis && globalThis.__read || function(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), a, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (i) {
    o = { error: i };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
};
function DE(t, e) {
  var n = Pp(function() {
    return typeof t == "function" ? t() : t;
  });
  if (process.env.NODE_ENV !== "production" && typeof t != "function") {
    var r = F0(Pa(n), 1), a = r[0];
    t !== a && console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
  }
  var s = e.context, o = e.guards, i = e.actions, c = e.activities, l = e.services, u = e.delays;
  e.state;
  var d = $E(e, ["context", "guards", "actions", "activities", "services", "delays", "state"]), f = Pp(function() {
    var p = {
      context: s,
      guards: o,
      actions: i,
      activities: c,
      services: l,
      delays: u
    }, h = n.withConfig(p, function() {
      return Rc(Rc({}, n.context), s);
    });
    return D0(h, d);
  });
  return O0(function() {
    Object.assign(f.machine.options.actions, i), Object.assign(f.machine.options.guards, o), Object.assign(f.machine.options.activities, c), Object.assign(f.machine.options.services, l), Object.assign(f.machine.options.delays, u);
  }, [i, o, c, l, u]), f;
}
function OE(t) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e[n - 1] = arguments[n];
  var r = F0(e, 2), a = r[0], s = a === void 0 ? {} : a, o = r[1], i = DE(t, s);
  return kc(function() {
    if (o) {
      var c = i.subscribe(zi(o));
      return function() {
        c.unsubscribe();
      };
    }
  }, [o]), kc(function() {
    var c = s.state;
    return i.start(c ? Dr.create(c) : void 0), function() {
      i.stop(), i.status = Qt.NotStarted;
    };
  }, []), i;
}
globalThis && globalThis.__read;
globalThis && globalThis.__values;
function M0(t) {
  return t.status !== 0 ? t.getSnapshot() : t.machine.initialState;
}
function nm(t) {
  return "state" in t && "machine" in t;
}
function FE(t, e, n) {
  if (t.status === Qt.NotStarted)
    return !0;
  var r = n.changed === void 0 && (Object.keys(n.children).length > 0 || typeof e.changed == "boolean");
  return !(n.changed || r);
}
function ME(t) {
  return t;
}
function P0(t) {
  return "state" in t;
}
function PE(t) {
  return "deferred" in t;
}
function BE(t) {
  return "getSnapshot" in t ? nm(t) ? M0(t) : t.getSnapshot() : P0(t) ? t.state : void 0;
}
function LE(t, e) {
  e === void 0 && (e = BE);
  var n = Va(t), r = Va([]), a = Pi(function(l) {
    var u = t.subscribe(l).unsubscribe;
    return u;
  }, [t]), s = Pi(function() {
    return e(t);
  }, [t, e]), o = Pi(function(l, u) {
    return nm(t) ? FE(t, l, u) : l === u;
  }, [t]), i = y0.useSyncExternalStoreWithSelector(a, s, s, ME, o), c = Pp(function() {
    return function() {
      for (var l = [], u = 0; u < arguments.length; u++)
        l[u] = arguments[u];
      var d = l[0];
      process.env.NODE_ENV !== "production" && l.length > 1 && console.warn("Unexpected payload: ".concat(JSON.stringify(l[1]), ". Only a single event object can be sent to actor send() functions."));
      var f = n.current;
      PE(f) && f.deferred ? r.current.push(d) : f.send(d);
    };
  });
  return O0(function() {
    for (n.current = t; r.current.length > 0; ) {
      var l = r.current.shift();
      t.send(l);
    }
  }, [t]), [i, c];
}
var WE = function(t, e) {
  return t === e;
}, zE = function(t, e) {
  if (nm(t)) {
    if (t.status === 0 && e.current)
      return e.current;
    var n = M0(t);
    return e.current = t.status === 0 ? n : null, n;
  }
  return P0(t) ? t.state : void 0;
};
function VE(t, e, n, r) {
  n === void 0 && (n = WE);
  var a = Va(null), s = Pi(function(c) {
    var l = t.subscribe(c).unsubscribe;
    return l;
  }, [t]), o = Pi(function() {
    return r ? r(t) : zE(t, a);
  }, [t, r]), i = y0.useSyncExternalStoreWithSelector(s, o, o, e, n);
  return i;
}
var HE = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.triggerModelLoading = function() {
      this.modelLoadingPromise = this.loadModels();
    }, t;
  }()
), fa;
(function(t) {
  t.DARK = "dark", t.BRIGHT = "bright", t.NORMAL = "normal";
})(fa || (fa = {}));
var nt;
(function(t) {
  t.MATCHED = "MATCHED", t.TOO_FAR = "TOO FAR", t.TOO_CLOSE = "TOO CLOSE", t.CANT_IDENTIFY = "CANNOT IDENTIFY", t.FACE_IDENTIFIED = "ONE FACE IDENTIFIED", t.TOO_MANY = "TOO MANY FACES", t.OFF_CENTER = "OFF CENTER";
})(nt || (nt = {}));
var lt = {
  TIMEOUT: "TIMEOUT",
  RUNTIME_ERROR: "RUNTIME_ERROR",
  FRESHNESS_TIMEOUT: "FRESHNESS_TIMEOUT",
  SERVER_ERROR: "SERVER_ERROR",
  CAMERA_FRAMERATE_ERROR: "CAMERA_FRAMERATE_ERROR",
  CAMERA_ACCESS_ERROR: "CAMERA_ACCESS_ERROR",
  FACE_DISTANCE_ERROR: "FACE_DISTANCE_ERROR",
  MOBILE_LANDSCAPE_ERROR: "MOBILE_LANDSCAPE_ERROR",
  MULTIPLE_FACES_ERROR: "MULTIPLE_FACES_ERROR"
}, jE = 0.32, UE = 0.4, GE = 0.37, co = {
  SUCCESS_CODE: 1e3,
  DEFAULT_ERROR_CODE: 4e3,
  FACE_FIT_TIMEOUT: 4001,
  USER_CANCEL: 4003,
  RUNTIME_ERROR: 4005,
  USER_ERROR_DURING_CONNECTION: 4007
}, Cr;
function Fy(t, e, n) {
  return t * (n - e) + e;
}
function B0(t) {
  var e = t.flippedCenterX - t.width / 2, n = t.flippedCenterX + t.width / 2, r = t.centerY - t.height / 2, a = t.centerY + t.height / 2, s = {
    left: e,
    top: r,
    right: n,
    bottom: a
  };
  return { ovalBoundingBox: s, minOvalX: e, maxOvalX: n, minOvalY: r, maxOvalY: a };
}
function L0(t, e) {
  var n = Math.max(t.left, e.left), r = Math.max(t.top, e.top), a = Math.min(t.right, e.right), s = Math.min(t.bottom, e.bottom), o = Math.abs(Math.max(0, a - n) * Math.max(0, s - r));
  if (o === 0)
    return 0;
  var i = Math.abs((t.right - t.left) * (t.bottom - t.top)), c = Math.abs((e.right - e.left) * (e.bottom - e.top));
  return o / (i + c - o);
}
function qE(t) {
  var e, n, r = t.sessionInformation, a = t.videoWidth, s = (n = (e = r?.Challenge) === null || e === void 0 ? void 0 : e.FaceMovementAndLightChallenge) === null || n === void 0 ? void 0 : n.OvalParameters;
  if (!s || !s.CenterX || !s.CenterY || !s.Width || !s.Height)
    throw new Error("Oval parameters not returned from session information.");
  return {
    flippedCenterX: a - s.CenterX,
    centerX: s.CenterX,
    centerY: s.CenterY,
    width: s.Width,
    height: s.Height
  };
}
function Bp(t) {
  var e = t.width, n = t.height, r = t.widthSeed, a = r === void 0 ? 1 : r, s = t.centerXSeed, o = s === void 0 ? 0.5 : s, i = t.centerYSeed, c = i === void 0 ? 0.5 : i, l = t.ratioMultiplier, u = l === void 0 ? 0.8 : l, d = n, f = e, p = a * u, h = Math.floor(7 * e / 16), m = Math.floor(9 * e / 16), g = Math.floor(7 * n / 16), v = Math.floor(9 * n / 16), b = Fy(o, h, m), w = Fy(c, g, v);
  e >= n && (f = 3 / 4 * d);
  var S = p * f, I = 1.618 * S;
  return {
    flippedCenterX: Math.floor(f - b),
    centerX: Math.floor(b),
    centerY: Math.floor(w),
    width: Math.floor(S),
    height: Math.floor(I)
  };
}
function Lp(t, e, n) {
  var r = n.getTracks()[0].getSettings(), a = r.width, s = r.height, o = e.getBoundingClientRect(), i = o.width, c = o.height;
  t.width = Math.ceil(i), t.height = Math.ceil(c);
  var l = Bp({
    width: a,
    height: s,
    ratioMultiplier: 0.5
  });
  l.flippedCenterX = a - l.centerX;
  var u = i / e.videoWidth;
  W0({
    canvas: t,
    oval: l,
    scaleFactor: u,
    videoEl: e,
    isStartScreen: !0
  });
}
function W0(t) {
  var e = t.canvas, n = t.oval, r = t.scaleFactor, a = t.videoEl, s = t.isStartScreen, o = n.flippedCenterX, i = n.centerY, c = n.width, l = n.height, u = e.getBoundingClientRect(), d = u.width, f = u.height, p = e.getContext("2d");
  if (p) {
    p.restore(), p.clearRect(0, 0, d, f), p.fillStyle = s ? getComputedStyle(e).getPropertyValue("--amplify-colors-background-primary") : "#fff", p.fillRect(0, 0, d, f);
    var h = { width: a.videoWidth, height: a.videoHeight }, m = {
      x: (d - h.width * r) / 2,
      y: (f - h.height * r) / 2
    };
    p.setTransform(r, 0, 0, r, m.x, m.y), p.beginPath(), p.ellipse(o, i, c / 2, l / 2, 0, 0, 2 * Math.PI), p.strokeStyle = getComputedStyle(e).getPropertyValue("--amplify-colors-border-secondary"), p.lineWidth = 3, p.stroke(), p.save(), p.clip(), p.setTransform(1, 0, 0, 1, 0, 0), p.clearRect(0, 0, d, f);
  } else
    throw new Error("Cannot find Canvas.");
}
function KE(t) {
  var e = t.canvas, n = e.getContext("2d");
  if (n)
    n.restore(), n.clearRect(0, 0, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  else
    throw new Error("Cannot find Canvas.");
}
function XE(t, e, n, r) {
  var a, s, o, i = (s = (a = r?.Challenge) === null || a === void 0 ? void 0 : a.FaceMovementAndLightChallenge) === null || s === void 0 ? void 0 : s.ChallengeConfig;
  if (!i || !i.OvalIouThreshold || !i.OvalIouHeightThreshold || !i.OvalIouWidthThreshold || !i.FaceIouHeightThreshold || !i.FaceIouWidthThreshold)
    throw new Error("Challenge information not returned from session information.");
  var c = i.OvalIouThreshold, l = i.OvalIouHeightThreshold, u = i.OvalIouWidthThreshold, d = i.FaceIouHeightThreshold, f = i.FaceIouWidthThreshold, p = Wp(t, e), h = p.left, m = p.right, g = p.top, v = p.bottom, b = B0(e), w = b.ovalBoundingBox, S = b.minOvalX, I = b.minOvalY, E = b.maxOvalX, T = b.maxOvalY, R = L0(p, w), $ = c, D = e.width * u, M = e.height * l, z = e.width * f, F = e.height * d, V = Math.max(Math.min(1, 0.75 * (R - n) / ($ - n) + 0.25), 0) * 100, H = S > h && E > m, U = h > S && m > E;
  return R > $ && Math.abs(S - h) < D && Math.abs(E - m) < D && Math.abs(T - v) < M ? o = nt.MATCHED : H || U ? o = nt.OFF_CENTER : I - g > F || v - T > F || S - h > z && m - E > z ? o = nt.TOO_CLOSE : o = nt.TOO_FAR, { faceMatchState: o, faceMatchPercentage: V };
}
function z0(t) {
  var e = t.leftEye, n = t.rightEye, r = t.mouth, a = [];
  a[0] = (e[0] + n[0]) / 2, a[1] = (e[1] + n[1]) / 2;
  var s = Math.sqrt(Math.pow(e[0] - n[0], 2) + Math.pow(e[1] - n[1], 2)), o = Math.sqrt(Math.pow(a[0] - r[0], 2) + Math.pow(a[1] - r[1], 2));
  return { pupilDistance: s, faceHeight: o };
}
function Wp(t, e) {
  var n = t.leftEye, r = t.rightEye, a = t.nose, s = t.leftEar, o = t.rightEar, i = t.top, c = t.height, l = e.height, u = e.centerY, d = u - l / 2, f = [];
  f[0] = (n[0] + r[0]) / 2, f[1] = (n[1] + r[1]) / 2;
  var p = z0(t), h = p.pupilDistance, m = p.faceHeight, g = 2, v = 1.8, b = (g * h + v * m) / 2, w = 1.618 * b, S;
  f[1] <= (d + l) / 2 ? S = (f[0] + a[0]) / 2 : S = f[0];
  var I = i + c, E = I - w, T = Math.min(S - b / 2, o[0]), R = Math.max(S + b / 2, s[0]);
  return {
    left: T,
    top: E,
    right: R,
    bottom: I
  };
}
function My(t) {
  var e = document.createElement("canvas");
  e.width = t.videoWidth, e.height = t.videoHeight;
  var n = e.getContext("2d");
  if (n) {
    n.drawImage(t, 0, 0, e.width, e.height);
    for (var r = n.getImageData(0, 0, e.width, e.height).data, a = 8, s = new Array(a).fill(0), o = 0; o < r.length; o++) {
      var i = Math.round(r[o++] * 0.2126 + r[o++] * 0.7152 + r[o++] * 0.0722);
      s[i % 32]++;
    }
    for (var c = -1, l = 0, o = 0; o < a; o++)
      s[o] > l && (l = s[o], c = o);
    return e.remove(), c === 0 ? fa.DARK : c === a ? fa.BRIGHT : fa.NORMAL;
  } else
    throw new Error("Cannot find Video Element.");
}
function YE(t) {
  return t.label.toLowerCase().includes("virtual");
}
Cr = {}, Cr[lt.RUNTIME_ERROR] = "RUNTIME_ERROR", Cr[lt.SERVER_ERROR] = "SERVER_ERROR", Cr[lt.TIMEOUT] = "TIMEOUT", Cr[lt.FACE_DISTANCE_ERROR] = "FACE_DISTANCE_ERROR", Cr[lt.MULTIPLE_FACES_ERROR] = "MULTIPLE_FACES_ERROR", Cr[lt.CAMERA_FRAMERATE_ERROR] = "CAMERA_FRAMERATE_ERROR", Cr[lt.CAMERA_ACCESS_ERROR] = "CAMERA_ACCESS_ERROR", Cr[lt.MOBILE_LANDSCAPE_ERROR] = "MOBILE_LANDSCAPE_ERROR", Cr[lt.FRESHNESS_TIMEOUT] = "FRESHNESS_TIMEOUT";
var ZE = 0.9, JE = 0.75;
function Uf(t) {
  var e = t.ctx, n = t.prevColor, r = t.nextColor, a = t.fraction, s = e.canvas.width, o = e.canvas.height;
  e.fillStyle = r, e.fillRect(0, 0, s, o * a), a !== 1 && (e.fillStyle = n, e.fillRect(0, o * a, s, o * (1 - a)));
}
function QE(t) {
  var e = t.overlayCanvas, n = t.prevColor, r = t.nextColor, a = t.videoEl, s = t.ovalDetails, o = t.heightFraction, i = t.scaleFactor, c = a.getBoundingClientRect(), l = c.x, u = c.y, d = s.flippedCenterX, f = s.centerY, p = s.width, h = s.height, m = d * i + l, g = f * i + u, v = e.width, b = e.height, w = e.getContext("2d");
  if (w)
    w.canvas.width = window.innerWidth, w.canvas.height = window.innerHeight, w.clearRect(0, 0, v, b), Uf({
      ctx: w,
      prevColor: n,
      nextColor: r,
      fraction: o
    }), w.save(), w.beginPath(), w.rect(0, 0, v, b), w.clip(), w.clearRect(0, 0, v, b), w.globalAlpha = ZE, Uf({
      ctx: w,
      prevColor: n,
      nextColor: r,
      fraction: o
    }), w.beginPath(), w.ellipse(m, g, p * i / 2, h * i / 2, 0, 0, 2 * Math.PI), w.strokeStyle = "white", w.lineWidth = 8, w.stroke(), w.clip(), w.clearRect(0, 0, v, b), w.globalAlpha = JE, Uf({
      ctx: w,
      prevColor: n,
      nextColor: r,
      fraction: o
    }), w.restore();
  else
    throw new Error("Cannot find Overlay Canvas.");
}
var eT = function(t) {
  return !!t;
};
function tT(t) {
  var e = t.Challenge.FaceMovementAndLightChallenge.ColorSequences || [], n = e.map(function(r) {
    var a = r.FreshnessColor, s = r.DownscrollDuration, o = r.FlatDisplayDuration, i = a.RGB, c = "rgb(".concat(i[0], ",").concat(i[1], ",").concat(i[2], ")");
    return typeof c < "u" && typeof s < "u" && typeof o < "u" ? {
      color: c,
      downscrollDuration: s,
      flatDisplayDuration: o
    } : void 0;
  });
  return n.filter(eT);
}
function Py(t) {
  return t.slice(t.indexOf("(") + 1, t.indexOf(")")).split(",").map(function(e) {
    return parseInt(e);
  });
}
function nT(t, e) {
  return ot(this, void 0, void 0, function() {
    var n, r;
    return tt(this, function(a) {
      switch (a.label) {
        case 0:
          return [4, t.detectFaces(e)];
        case 1:
          switch (n = a.sent(), n.length) {
            case 0: {
              r = nt.CANT_IDENTIFY;
              break;
            }
            case 1: {
              r = nt.FACE_IDENTIFIED;
              break;
            }
            default: {
              r = nt.TOO_MANY;
              break;
            }
          }
          return [2, r];
      }
    });
  });
}
function By(t) {
  var e = t.faceDetector, n = t.videoEl, r = t.ovalDetails, a = t.reduceThreshold, s = a === void 0 ? !1 : a, o = t.isMobile, i = o === void 0 ? !1 : o;
  return ot(this, void 0, void 0, function() {
    var c, l, u, d, f, p, h, m, g, v, b;
    return tt(this, function(w) {
      switch (w.label) {
        case 0:
          return [4, e.detectFaces(n)];
        case 1:
          switch (c = w.sent(), u = !1, c.length) {
            case 0: {
              d = lt.FACE_DISTANCE_ERROR;
              break;
            }
            case 1: {
              l = c[0], f = r.width, p = z0(l), h = p.pupilDistance, m = p.faceHeight, g = 2, v = 1.8, b = (g * h + v * m) / 2 / g, f && (u = b / f < (s ? i ? GE : UE : jE), u || (d = lt.FACE_DISTANCE_ERROR));
              break;
            }
            default: {
              d = lt.MULTIPLE_FACES_ERROR;
              break;
            }
          }
          return [2, { isDistanceBelowThreshold: u, error: d }];
      }
    });
  });
}
function Gf(t) {
  var e = t.deviceHeight, n = t.deviceWidth, r = t.height, a = t.width, s = t.top, o = t.left;
  return {
    Height: r / e,
    Width: a / n,
    Top: s / e,
    Left: o / n
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rT = 1e-7, aT = 1e-4;
class V0 {
  constructor(e, n) {
    this.backend = e, this.dataMover = n, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
  }
  get(e) {
    return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
  }
  set(e, n) {
    this.dataIdsCount++, this.data.set(e, n);
  }
  has(e) {
    return this.data.has(e);
  }
  delete(e) {
    return this.dataIdsCount--, this.data.delete(e);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
}
class rm {
  refCount(e) {
    return er("refCount");
  }
  incRef(e) {
    return er("incRef");
  }
  timerAvailable() {
    return !0;
  }
  time(e) {
    return er("time");
  }
  read(e) {
    return er("read");
  }
  readSync(e) {
    return er("readSync");
  }
  readToGPU(e, n) {
    return er("readToGPU");
  }
  numDataIds() {
    return er("numDataIds");
  }
  disposeData(e, n) {
    return er("disposeData");
  }
  write(e, n, r) {
    return er("write");
  }
  move(e, n, r, a, s) {
    return er("move");
  }
  createTensorFromGPUData(e, n, r) {
    return er("createTensorFromGPUData");
  }
  memory() {
    return er("memory");
  }
  /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
  floatPrecision() {
    return er("floatPrecision");
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return this.floatPrecision() === 32 ? rT : aT;
  }
  dispose() {
    return er("dispose");
  }
}
function er(t) {
  throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function am(t, e, n) {
  return Math.max(t, Math.min(e, n));
}
function hi(t, e, n) {
  const r = t[e];
  t[e] = t[n], t[n] = r;
}
function A(t, e) {
  if (!t)
    throw new Error(typeof e == "string" ? e : e());
}
function ar(t, e, n = "") {
  A(Ir(t, e), () => n + ` Shapes ${t} and ${e} must match`);
}
function Po(t) {
  A(t != null, () => "The input to the tensor constructor must be a non-null value.");
}
function Y(t) {
  if (t.length === 0)
    return 1;
  let e = t[0];
  for (let n = 1; n < t.length; n++)
    e *= t[n];
  return e;
}
function sT(t, e) {
  if (t === e)
    return !0;
  if (t == null || e == null || t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== null && e[n] !== null && t[n] !== e[n])
      return !1;
  return !0;
}
function Ir(t, e) {
  if (t === e)
    return !0;
  if (t == null || e == null || t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function Ji(t) {
  return t % 1 === 0;
}
function vc(t, e) {
  return e <= t.length ? t : t + " ".repeat(e - t.length);
}
function H0(t, e) {
  let n = 1, r = -1;
  for (let s = 0; s < t.length; ++s)
    if (t[s] >= 0)
      n *= t[s];
    else if (t[s] === -1) {
      if (r !== -1)
        throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);
      r = s;
    } else if (t[s] < 0)
      throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);
  if (r === -1) {
    if (e > 0 && e !== n)
      throw Error(`Size(${e}) must match the product of shape ${t}`);
    return t;
  }
  if (n === 0)
    throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);
  if (e % n !== 0)
    throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);
  const a = t.slice();
  return a[r] = e / n, a;
}
function Vt(t, e) {
  const n = e.length;
  return t = t == null ? e.map((r, a) => a) : [].concat(t), A(t.every((r) => r >= -n && r < n), () => `All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`), A(t.every((r) => Ji(r)), () => `All values in axis param must be integers but got axis ${t}`), t.map((r) => r < 0 ? n + r : r);
}
function oT(t, e) {
  const n = [], r = [], a = e != null && Array.isArray(e) && e.length === 0, s = e == null || a ? null : Vt(e, t).sort();
  let o = 0;
  for (let i = 0; i < t.length; ++i) {
    if (s != null) {
      if (s[o] === i && t[i] !== 1)
        throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);
      (s[o] == null || s[o] > i) && t[i] === 1 && (n.push(t[i]), r.push(i)), s[o] <= i && o++;
    }
    t[i] !== 1 && (n.push(t[i]), r.push(i));
  }
  return { newShape: n, keptDims: r };
}
function Dn(t, e) {
  return tn(t, e);
}
function tn(t, e) {
  let n = null;
  if (t == null || t === "float32")
    n = new Float32Array(e);
  else if (t === "int32")
    n = new Int32Array(e);
  else if (t === "bool")
    n = new Uint8Array(e);
  else if (t === "string")
    n = new Array(e);
  else
    throw new Error(`Unknown data type ${t}`);
  return n;
}
function iT(t, e) {
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (isNaN(r) || !isFinite(r))
      throw Error(`A tensor of type ${e} being uploaded contains ${r}.`);
  }
}
function uT(t) {
  return t === "bool" || t === "complex64" || t === "float32" || t === "int32" || t === "string";
}
function cT(t, e) {
  return !(e === "complex64" || e === "float32" && t !== "complex64" || e === "int32" && t !== "float32" && t !== "complex64" || e === "bool" && t === "bool");
}
function Qi(t) {
  if (t === "float32" || t === "int32")
    return 4;
  if (t === "complex64")
    return 8;
  if (t === "bool")
    return 1;
  throw new Error(`Unknown dtype ${t}`);
}
function lT(t) {
  if (t == null)
    return 0;
  let e = 0;
  return t.forEach((n) => e += n.length), e;
}
function fl(t) {
  return typeof t == "string" || t instanceof String;
}
function dT(t) {
  return typeof t == "boolean";
}
function fT(t) {
  return typeof t == "number";
}
function ku(t) {
  return Array.isArray(t) ? ku(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray ? "int32" : fT(t) ? "float32" : fl(t) ? "string" : dT(t) ? "bool" : "float32";
}
function zp(t) {
  return !!(t && t.constructor && t.call && t.apply);
}
function Ie(t) {
  const e = t.length;
  if (e < 2)
    return [];
  const n = new Array(e - 1);
  n[e - 2] = t[e - 1];
  for (let r = e - 3; r >= 0; --r)
    n[r] = n[r + 1] * t[r + 1];
  return n;
}
function j0(t, e, n, r = !1) {
  const a = new Array();
  if (e.length === 1) {
    const s = e[0] * (r ? 2 : 1);
    for (let o = 0; o < s; o++)
      a[o] = n[t + o];
  } else {
    const s = e[0], o = e.slice(1), i = o.reduce((c, l) => c * l) * (r ? 2 : 1);
    for (let c = 0; c < s; c++)
      a[c] = j0(t + c * i, o, n, r);
  }
  return a;
}
function xr(t, e, n = !1) {
  if (t.length === 0)
    return e[0];
  const r = t.reduce((a, s) => a * s) * (n ? 2 : 1);
  if (r === 0)
    return [];
  if (r !== e.length)
    throw new Error(`[${t}] does not match the input size ${e.length}${n ? " for a complex tensor" : ""}.`);
  return j0(0, t, e, n);
}
function pT(t, e) {
  if (Array.isArray(t))
    return t;
  if (e === "float32")
    return t instanceof Float32Array ? t : new Float32Array(t);
  if (e === "int32")
    return t instanceof Int32Array ? t : new Int32Array(t);
  if (e === "bool" || e === "string")
    return Uint8Array.from(new Int32Array(t));
  throw new Error(`Unknown dtype ${e}`);
}
function sm(t, e) {
  const n = In(t, e);
  for (let r = 0; r < n.length; r++)
    n[r] = 1;
  return n;
}
function In(t, e) {
  if (e == null || e === "float32" || e === "complex64")
    return new Float32Array(t);
  if (e === "int32")
    return new Int32Array(t);
  if (e === "bool")
    return new Uint8Array(t);
  throw new Error(`Unknown data type ${e}`);
}
function U0(t, e) {
  const n = t.reduce((r, a) => r * a, 1);
  if (e == null || e === "float32")
    return xr(t, new Float32Array(n));
  if (e === "int32")
    return xr(t, new Int32Array(n));
  if (e === "bool")
    return xr(t, new Uint8Array(n));
  throw new Error(`Unknown data type ${e}`);
}
function fr(t) {
  t.forEach((e) => {
    A(Number.isInteger(e) && e >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${t}].`);
  });
}
function Zr(t, e, n) {
  if (e === 0)
    return 0;
  if (e === 1)
    return t[0];
  let r = t[t.length - 1];
  for (let a = 0; a < t.length - 1; ++a)
    r += n[a] * t[a];
  return r;
}
function Bo(t, e, n) {
  if (e === 0)
    return [];
  if (e === 1)
    return [t];
  const r = new Array(e);
  for (let a = 0; a < r.length - 1; ++a)
    r[a] = Math.floor(t / n[a]), t -= r[a] * n[a];
  return r[r.length - 1] = t, r;
}
function Ds(t) {
  return t && t.then && typeof t.then == "function";
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ly = "tfjsflags";
class hT {
  // tslint:disable-next-line: no-any
  constructor(e) {
    this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = mT, this.populateURLFlags();
  }
  setPlatform(e, n) {
    this.platform != null && (Xe().getBool("IS_TEST") || Xe().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)), this.platformName = e, this.platform = n;
  }
  registerFlag(e, n, r) {
    if (this.flagRegistry[e] = { evaluationFn: n, setHook: r }, this.urlFlags[e] != null) {
      const a = this.urlFlags[e];
      Xe().getBool("IS_TEST") || Xe().getBool("PROD") || console.warn(`Setting feature override from URL ${e}: ${a}.`), this.set(e, a);
    }
  }
  async getAsync(e) {
    return e in this.flags ? this.flags[e] : (this.flags[e] = await this.evaluateFlag(e), this.flags[e]);
  }
  get(e) {
    if (e in this.flags)
      return this.flags[e];
    const n = this.evaluateFlag(e);
    if (Ds(n))
      throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);
    return this.flags[e] = n, this.flags[e];
  }
  getNumber(e) {
    return this.get(e);
  }
  getBool(e) {
    return this.get(e);
  }
  getString(e) {
    return this.get(e);
  }
  getFlags() {
    return this.flags;
  }
  // For backwards compatibility.
  get features() {
    return this.flags;
  }
  set(e, n) {
    if (this.flagRegistry[e] == null)
      throw new Error(`Cannot set flag ${e} as it has not been registered.`);
    this.flags[e] = n, this.flagRegistry[e].setHook != null && this.flagRegistry[e].setHook(n);
  }
  evaluateFlag(e) {
    if (this.flagRegistry[e] == null)
      throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);
    return this.flagRegistry[e].evaluationFn();
  }
  setFlags(e) {
    this.flags = Object.assign({}, e);
  }
  reset() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global > "u" || typeof this.global.location > "u" || typeof this.global.location.search > "u")
      return;
    const e = this.getQueryParams(this.global.location.search);
    Ly in e && e[Ly].split(",").forEach((r) => {
      const [a, s] = r.split(":");
      this.urlFlags[a] = yT(a, s);
    });
  }
}
function mT(t) {
  const e = {};
  return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (n, ...r) => (gT(e, r[0], r[1]), r.join("="))), e;
}
function gT(t, e, n) {
  t[decodeURIComponent(e)] = decodeURIComponent(n || "");
}
function yT(t, e) {
  const n = e.toLowerCase();
  return n === "true" || n === "false" ? n === "true" : `${+n}` === n ? +n : e;
}
function Xe() {
  return G0;
}
let G0 = null;
function vT(t) {
  G0 = t;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let qf;
function q0() {
  if (qf == null) {
    let t;
    if (typeof window < "u")
      t = window;
    else if (typeof global < "u")
      t = global;
    else if (typeof process < "u")
      t = process;
    else if (typeof self < "u")
      t = self;
    else
      throw new Error("Could not find a global object");
    qf = t;
  }
  return qf;
}
function bT() {
  const t = q0();
  return t._tfGlobals == null && (t._tfGlobals = /* @__PURE__ */ new Map()), t._tfGlobals;
}
function om(t, e) {
  const n = bT();
  if (n.has(t))
    return n.get(t);
  {
    const r = e();
    return n.set(t, r), n.get(t);
  }
}
const im = "Abs", pl = "Acos", hl = "Acosh", Eu = "Add", ml = "AddN", gl = "All", yl = "Any", um = "ArgMax", cm = "ArgMin", vl = "Asin", bl = "Asinh", wl = "Atan", Sl = "Atanh", _l = "Atan2", xl = "AvgPool", K0 = "AvgPoolGrad", lm = "AvgPool3D", X0 = "AvgPool3DGrad", Il = "BatchMatMul", dm = "BatchToSpaceND", kl = "Bincount", El = "BitwiseAnd", fm = "BroadcastArgs", Tl = "Cast", Cl = "Ceil", Tu = "ClipByValue", Y0 = "Complex", Z0 = "ComplexAbs", pm = "Concat", Nl = "Conv2D", J0 = "Conv2DBackpropFilter", Al = "Conv2DBackpropInput", Rl = "Conv3D", hm = "Conv3DBackpropFilterV2", $l = "Conv3DBackpropInputV2", Dl = "Cos", Ol = "Cosh", Fl = "Cumprod", Ml = "Cumsum", Pl = "CropAndResize", mm = "DenseBincount", Bl = "DepthToSpace", Ll = "DepthwiseConv2dNative", Q0 = "DepthwiseConv2dNativeBackpropFilter", e1 = "DepthwiseConv2dNativeBackpropInput", gm = "Diag", Wl = "Dilation2D", $c = "Dilation2DBackpropInput", Dc = "Dilation2DBackpropFilter", t1 = "Draw", zl = "RealDiv", n1 = "Einsum", Vl = "Elu", ym = "EluGrad", Hl = "Erf", jl = "Equal", Ul = "Exp", vm = "ExpandDims", Gl = "Expm1", r1 = "FFT", bm = "Fill", ql = "FlipLeftRight", Kl = "Floor", Xl = "FloorDiv", Yl = "FusedBatchNorm", wm = "GatherV2", Zl = "GatherNd", Jl = "Greater", Ql = "GreaterEqual", ed = "Identity", a1 = "IFFT", s1 = "Imag", td = "IsFinite", nd = "IsInf", rd = "IsNan", ad = "LeakyRelu", sd = "Less", od = "LessEqual", id = "LinSpace", ud = "Log", cd = "Log1p", ld = "LogicalAnd", dd = "LogicalNot", fd = "LogicalOr", wT = "LogicalXor", pd = "LRN", Sm = "LRNGrad", hd = "Max", md = "Maximum", gd = "MaxPool", o1 = "MaxPoolGrad", _m = "MaxPool3D", i1 = "MaxPool3DGrad", xm = "MaxPoolWithArgmax", yd = "Mean", vd = "Min", bd = "Minimum", wd = "MirrorPad", Sd = "Mod", _d = "Multinomial", xd = "Multiply", Im = "Neg", Id = "NotEqual", kd = "NonMaxSuppressionV3", Ed = "NonMaxSuppressionV4", Td = "NonMaxSuppressionV5", km = "OnesLike", Cd = "OneHot", Em = "Pack", Nd = "PadV2", Ad = "Pow", Rd = "Prelu", $d = "Prod", u1 = "RaggedGather", c1 = "RaggedRange", l1 = "RaggedTensorToTensor", Tm = "Range", d1 = "Real", Dd = "Reciprocal", Od = "Relu", Cm = "Reshape", Fd = "ResizeNearestNeighbor", Nm = "ResizeNearestNeighborGrad", Md = "ResizeBilinear", Am = "ResizeBilinearGrad", Pd = "Relu6", Bd = "Reverse", Ld = "Round", Wd = "Rsqrt", zd = "ScatterNd", Vd = "TensorScatterUpdate", Hd = "SearchSorted", Rm = "Select", jd = "Selu", $m = "Slice", Ud = "Sin", Gd = "Sinh", qd = "Sign", Kd = "Sigmoid", Xd = "Softplus", Yd = "Sqrt", Zd = "Sum", Dm = "SpaceToBatchND", Om = "SplitV", Jd = "Softmax", Fm = "SparseFillEmptyRows", Qd = "SparseReshape", Mm = "SparseSegmentMean", Pm = "SparseSegmentSum", ef = "SparseToDense", tf = "SquaredDifference", f1 = "Square", Bm = "StaticRegexReplace", nf = "StridedSlice", Lm = "StringNGrams", Wm = "StringSplit", zm = "StringToHashBucketFast", rf = "Sub", af = "Tan", sf = "Tanh", Cu = "Tile", of = "TopK", uf = "Transform", vo = "Transpose", Vm = "Unique", Hm = "Unpack", p1 = "UnsortedSegmentSum", jm = "ZerosLike", Nu = "Step", Wy = "FromPixels", cf = "RotateWithOffset", eu = "_FusedMatMul", tu = "FusedConv2D", nu = "FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bs(...t) {
  Xe().getBool("IS_TEST") || Xe().getBool("PROD") || console.warn(...t);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Oc = om("kernelRegistry", () => /* @__PURE__ */ new Map()), ST = om("gradRegistry", () => /* @__PURE__ */ new Map());
function Fc(t, e) {
  const n = m1(t, e);
  return Oc.get(n);
}
function zy(t) {
  return ST.get(t);
}
function Vy(t) {
  const e = Oc.entries(), n = [];
  for (; ; ) {
    const { done: r, value: a } = e.next();
    if (r)
      break;
    const [s, o] = a, [i] = s.split("_");
    i === t && n.push(o);
  }
  return n;
}
function h1(t) {
  const { kernelName: e, backendName: n } = t, r = m1(e, n);
  Oc.has(r) && bs(`The kernel '${e}' for backend '${n}' is already registered`), Oc.set(r, t);
}
function m1(t, e) {
  return `${e}_${t}`;
}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g1(t) {
  return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray;
}
var y1 = Ot, wr = null;
try {
  wr = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function Ot(t, e, n) {
  this.low = t | 0, this.high = e | 0, this.unsigned = !!n;
}
Ot.prototype.__isLong__;
Object.defineProperty(Ot.prototype, "__isLong__", { value: !0 });
function sr(t) {
  return (t && t.__isLong__) === !0;
}
Ot.isLong = sr;
var Hy = {}, jy = {};
function Hs(t, e) {
  var n, r, a;
  return e ? (t >>>= 0, (a = 0 <= t && t < 256) && (r = jy[t], r) ? r : (n = Ft(t, (t | 0) < 0 ? -1 : 0, !0), a && (jy[t] = n), n)) : (t |= 0, (a = -128 <= t && t < 128) && (r = Hy[t], r) ? r : (n = Ft(t, t < 0 ? -1 : 0, !1), a && (Hy[t] = n), n));
}
Ot.fromInt = Hs;
function Sr(t, e) {
  if (isNaN(t))
    return e ? xs : _r;
  if (e) {
    if (t < 0)
      return xs;
    if (t >= v1)
      return S1;
  } else {
    if (t <= -Gy)
      return rr;
    if (t + 1 >= Gy)
      return w1;
  }
  return t < 0 ? Sr(-t, e).neg() : Ft(t % ko | 0, t / ko | 0, e);
}
Ot.fromNumber = Sr;
function Ft(t, e, n) {
  return new Ot(t, e, n);
}
Ot.fromBits = Ft;
var Mc = Math.pow;
function Um(t, e, n) {
  if (t.length === 0)
    throw Error("empty string");
  if (t === "NaN" || t === "Infinity" || t === "+Infinity" || t === "-Infinity")
    return _r;
  if (typeof e == "number" ? (n = e, e = !1) : e = !!e, n = n || 10, n < 2 || 36 < n)
    throw RangeError("radix");
  var r;
  if ((r = t.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (r === 0)
    return Um(t.substring(1), e, n).neg();
  for (var a = Sr(Mc(n, 8)), s = _r, o = 0; o < t.length; o += 8) {
    var i = Math.min(8, t.length - o), c = parseInt(t.substring(o, o + i), n);
    if (i < 8) {
      var l = Sr(Mc(n, i));
      s = s.mul(l).add(Sr(c));
    } else
      s = s.mul(a), s = s.add(Sr(c));
  }
  return s.unsigned = e, s;
}
Ot.fromString = Um;
function Wr(t, e) {
  return typeof t == "number" ? Sr(t, e) : typeof t == "string" ? Um(t, e) : Ft(t.low, t.high, typeof e == "boolean" ? e : t.unsigned);
}
Ot.fromValue = Wr;
var Uy = 65536, _T = 1 << 24, ko = Uy * Uy, v1 = ko * ko, Gy = v1 / 2, qy = Hs(_T), _r = Hs(0);
Ot.ZERO = _r;
var xs = Hs(0, !0);
Ot.UZERO = xs;
var mo = Hs(1);
Ot.ONE = mo;
var b1 = Hs(1, !0);
Ot.UONE = b1;
var Vp = Hs(-1);
Ot.NEG_ONE = Vp;
var w1 = Ft(-1, 2147483647, !1);
Ot.MAX_VALUE = w1;
var S1 = Ft(-1, -1, !0);
Ot.MAX_UNSIGNED_VALUE = S1;
var rr = Ft(0, -2147483648, !1);
Ot.MIN_VALUE = rr;
var ye = Ot.prototype;
ye.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
ye.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * ko + (this.low >>> 0) : this.high * ko + (this.low >>> 0);
};
ye.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(rr)) {
      var n = Sr(e), r = this.div(n), a = r.mul(n).sub(this);
      return r.toString(e) + a.toInt().toString(e);
    } else
      return "-" + this.neg().toString(e);
  for (var s = Sr(Mc(e, 6), this.unsigned), o = this, i = ""; ; ) {
    var c = o.div(s), l = o.sub(c.mul(s)).toInt() >>> 0, u = l.toString(e);
    if (o = c, o.isZero())
      return u + i;
    for (; u.length < 6; )
      u = "0" + u;
    i = "" + u + i;
  }
};
ye.getHighBits = function() {
  return this.high;
};
ye.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
ye.getLowBits = function() {
  return this.low;
};
ye.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
ye.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(rr) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, n = 31; n > 0 && !(e & 1 << n); n--)
    ;
  return this.high != 0 ? n + 33 : n + 1;
};
ye.isZero = function() {
  return this.high === 0 && this.low === 0;
};
ye.eqz = ye.isZero;
ye.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
ye.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
ye.isOdd = function() {
  return (this.low & 1) === 1;
};
ye.isEven = function() {
  return (this.low & 1) === 0;
};
ye.equals = function(e) {
  return sr(e) || (e = Wr(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
ye.eq = ye.equals;
ye.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
ye.neq = ye.notEquals;
ye.ne = ye.notEquals;
ye.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
ye.lt = ye.lessThan;
ye.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
ye.lte = ye.lessThanOrEqual;
ye.le = ye.lessThanOrEqual;
ye.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
ye.gt = ye.greaterThan;
ye.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
ye.gte = ye.greaterThanOrEqual;
ye.ge = ye.greaterThanOrEqual;
ye.compare = function(e) {
  if (sr(e) || (e = Wr(e)), this.eq(e))
    return 0;
  var n = this.isNegative(), r = e.isNegative();
  return n && !r ? -1 : !n && r ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
ye.comp = ye.compare;
ye.negate = function() {
  return !this.unsigned && this.eq(rr) ? rr : this.not().add(mo);
};
ye.neg = ye.negate;
ye.add = function(e) {
  sr(e) || (e = Wr(e));
  var n = this.high >>> 16, r = this.high & 65535, a = this.low >>> 16, s = this.low & 65535, o = e.high >>> 16, i = e.high & 65535, c = e.low >>> 16, l = e.low & 65535, u = 0, d = 0, f = 0, p = 0;
  return p += s + l, f += p >>> 16, p &= 65535, f += a + c, d += f >>> 16, f &= 65535, d += r + i, u += d >>> 16, d &= 65535, u += n + o, u &= 65535, Ft(f << 16 | p, u << 16 | d, this.unsigned);
};
ye.subtract = function(e) {
  return sr(e) || (e = Wr(e)), this.add(e.neg());
};
ye.sub = ye.subtract;
ye.multiply = function(e) {
  if (this.isZero())
    return _r;
  if (sr(e) || (e = Wr(e)), wr) {
    var n = wr.mul(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Ft(n, wr.get_high(), this.unsigned);
  }
  if (e.isZero())
    return _r;
  if (this.eq(rr))
    return e.isOdd() ? rr : _r;
  if (e.eq(rr))
    return this.isOdd() ? rr : _r;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative())
    return this.mul(e.neg()).neg();
  if (this.lt(qy) && e.lt(qy))
    return Sr(this.toNumber() * e.toNumber(), this.unsigned);
  var r = this.high >>> 16, a = this.high & 65535, s = this.low >>> 16, o = this.low & 65535, i = e.high >>> 16, c = e.high & 65535, l = e.low >>> 16, u = e.low & 65535, d = 0, f = 0, p = 0, h = 0;
  return h += o * u, p += h >>> 16, h &= 65535, p += s * u, f += p >>> 16, p &= 65535, p += o * l, f += p >>> 16, p &= 65535, f += a * u, d += f >>> 16, f &= 65535, f += s * l, d += f >>> 16, f &= 65535, f += o * c, d += f >>> 16, f &= 65535, d += r * u + a * l + s * c + o * i, d &= 65535, Ft(p << 16 | h, d << 16 | f, this.unsigned);
};
ye.mul = ye.multiply;
ye.divide = function(e) {
  if (sr(e) || (e = Wr(e)), e.isZero())
    throw Error("division by zero");
  if (wr) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var n = (this.unsigned ? wr.div_u : wr.div_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Ft(n, wr.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? xs : _r;
  var r, a, s;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this))
      return xs;
    if (e.gt(this.shru(1)))
      return b1;
    s = xs;
  } else {
    if (this.eq(rr)) {
      if (e.eq(mo) || e.eq(Vp))
        return rr;
      if (e.eq(rr))
        return mo;
      var o = this.shr(1);
      return r = o.div(e).shl(1), r.eq(_r) ? e.isNegative() ? mo : Vp : (a = this.sub(e.mul(r)), s = r.add(a.div(e)), s);
    } else if (e.eq(rr))
      return this.unsigned ? xs : _r;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative())
      return this.div(e.neg()).neg();
    s = _r;
  }
  for (a = this; a.gte(e); ) {
    r = Math.max(1, Math.floor(a.toNumber() / e.toNumber()));
    for (var i = Math.ceil(Math.log(r) / Math.LN2), c = i <= 48 ? 1 : Mc(2, i - 48), l = Sr(r), u = l.mul(e); u.isNegative() || u.gt(a); )
      r -= c, l = Sr(r, this.unsigned), u = l.mul(e);
    l.isZero() && (l = mo), s = s.add(l), a = a.sub(u);
  }
  return s;
};
ye.div = ye.divide;
ye.modulo = function(e) {
  if (sr(e) || (e = Wr(e)), wr) {
    var n = (this.unsigned ? wr.rem_u : wr.rem_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Ft(n, wr.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
ye.mod = ye.modulo;
ye.rem = ye.modulo;
ye.not = function() {
  return Ft(~this.low, ~this.high, this.unsigned);
};
ye.and = function(e) {
  return sr(e) || (e = Wr(e)), Ft(this.low & e.low, this.high & e.high, this.unsigned);
};
ye.or = function(e) {
  return sr(e) || (e = Wr(e)), Ft(this.low | e.low, this.high | e.high, this.unsigned);
};
ye.xor = function(e) {
  return sr(e) || (e = Wr(e)), Ft(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
ye.shiftLeft = function(e) {
  return sr(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Ft(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : Ft(0, this.low << e - 32, this.unsigned);
};
ye.shl = ye.shiftLeft;
ye.shiftRight = function(e) {
  return sr(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Ft(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : Ft(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
ye.shr = ye.shiftRight;
ye.shiftRightUnsigned = function(e) {
  if (sr(e) && (e = e.toInt()), e &= 63, e === 0)
    return this;
  var n = this.high;
  if (e < 32) {
    var r = this.low;
    return Ft(r >>> e | n << 32 - e, n >>> e, this.unsigned);
  } else
    return e === 32 ? Ft(n, 0, this.unsigned) : Ft(n >>> e - 32, 0, this.unsigned);
};
ye.shru = ye.shiftRightUnsigned;
ye.shr_u = ye.shiftRightUnsigned;
ye.toSigned = function() {
  return this.unsigned ? Ft(this.low, this.high, !1) : this;
};
ye.toUnsigned = function() {
  return this.unsigned ? this : Ft(this.low, this.high, !0);
};
ye.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
ye.toBytesLE = function() {
  var e = this.high, n = this.low;
  return [
    n & 255,
    n >>> 8 & 255,
    n >>> 16 & 255,
    n >>> 24,
    e & 255,
    e >>> 8 & 255,
    e >>> 16 & 255,
    e >>> 24
  ];
};
ye.toBytesBE = function() {
  var e = this.high, n = this.low;
  return [
    e >>> 24,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    n >>> 24,
    n >>> 16 & 255,
    n >>> 8 & 255,
    n & 255
  ];
};
Ot.fromBytes = function(e, n, r) {
  return r ? Ot.fromBytesLE(e, n) : Ot.fromBytesBE(e, n);
};
Ot.fromBytesLE = function(e, n) {
  return new Ot(
    e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24,
    e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24,
    n
  );
};
Ot.fromBytesBE = function(e, n) {
  return new Ot(
    e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7],
    e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3],
    n
  );
};
const _1 = /* @__PURE__ */ Vs(y1), xT = /* @__PURE__ */ Gh({
  __proto__: null,
  default: _1
}, [y1]);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ws = (
  // tslint:disable-next-line
  _1 || xT
);
function lf(t) {
  return ws.fromString(t, !0, 16);
}
const x1 = lf("c3a5c85c97cb3127"), ys = lf("b492b66fbe98f273"), Rn = lf("9ae16a3b2f90404f");
function Hp(t) {
  return t.xor(t.shru(47));
}
function I1(t, e, n) {
  const r = t.slice(e, e + n);
  return ws.fromBytes(Array.from(r), !0, !0);
}
function Nt(t, e) {
  return I1(t, e, 8);
}
function Ky(t, e) {
  return I1(t, e, 4);
}
function dn(t, e) {
  return e === 0 ? t : t.shru(e).or(t.shl(64 - e));
}
function La(t, e, n = lf("9ddfea08eb382d69")) {
  let r = t.xor(e).mul(n);
  r = r.xor(r.shru(47));
  let a = e.xor(r).mul(n);
  return a = a.xor(a.shru(47)), a = a.mul(n), a;
}
function IT(t, e, n, r, a, s) {
  a = a.add(t), s = dn(s.add(a).add(r), 21);
  const o = a;
  return a = a.add(e), a = a.add(n), s = s.add(dn(a, 44)), [a.add(r), s.add(o)];
}
function oc(t, e, n, r) {
  return IT(Nt(t, e), Nt(t, e + 8), Nt(t, e + 16), Nt(t, e + 24), n, r);
}
function kT(t, e = t.length) {
  if (e >= 8) {
    const n = Rn.add(e * 2), r = Nt(t, 0).add(Rn), a = Nt(t, e - 8), s = dn(a, 37).mul(n).add(r), o = dn(r, 25).add(a).mul(n);
    return La(s, o, n);
  }
  if (e >= 4) {
    const n = Rn.add(e * 2), r = Ky(t, 0);
    return La(r.shl(3).add(e), Ky(t, e - 4), n);
  }
  if (e > 0) {
    const n = t[0], r = t[e >> 1], a = t[e - 1], s = n + (r << 8), o = e + (a << 2);
    return Hp(Rn.mul(s).xor(x1.mul(o))).mul(Rn);
  }
  return Rn;
}
function ET(t, e = t.length) {
  const n = Rn.add(e * 2), r = Nt(t, 0).mul(ys), a = Nt(t, 8), s = Nt(t, e - 8).mul(n), o = Nt(t, e - 16).mul(Rn);
  return La(dn(r.add(a), 43).add(dn(s, 30)).add(o), r.add(dn(a.add(Rn), 18)).add(s), n);
}
function TT(t, e = t.length) {
  const n = Rn.add(e * 2), r = Nt(t, 0).mul(Rn), a = Nt(t, 8), s = Nt(t, e - 8).mul(n), o = Nt(t, e - 16).mul(Rn), i = dn(r.add(a), 43).add(dn(s, 30)).add(o), c = La(i, r.add(dn(a.add(Rn), 18)).add(s), n), l = Nt(t, 16).mul(n), u = Nt(t, 24), d = i.add(Nt(t, e - 32)).mul(n), f = c.add(Nt(t, e - 24)).mul(n);
  return La(dn(l.add(u), 43).add(dn(d, 30)).add(f), l.add(dn(u.add(r), 18)).add(d), n);
}
function CT(t, e = t.length) {
  const n = ws.fromNumber(81, !0);
  if (e <= 32)
    return e <= 16 ? kT(t, e) : ET(t, e);
  if (e <= 64)
    return TT(t, e);
  let r = n, a = n.mul(ys).add(113), s = Hp(a.mul(Rn).add(113)).mul(Rn), o = [ws.UZERO, ws.UZERO], i = [ws.UZERO, ws.UZERO];
  r = r.mul(Rn).add(Nt(t, 0));
  let c = 0;
  const l = (e - 1 >> 6) * 64, u = l + (e - 1 & 63) - 63;
  do
    r = dn(r.add(a).add(o[0]).add(Nt(t, c + 8)), 37).mul(ys), a = dn(a.add(o[1]).add(Nt(t, c + 48)), 42).mul(ys), r = r.xor(i[1]), a = a.add(o[0]).add(Nt(t, c + 40)), s = dn(s.add(i[0]), 33).mul(ys), o = oc(t, c, o[1].mul(ys), r.add(i[0])), i = oc(t, c + 32, s.add(i[1]), a.add(Nt(t, c + 16))), [s, r] = [r, s], c += 64;
  while (c !== l);
  const d = ys.add(s.and(255).shl(1));
  return c = u, i[0] = i[0].add(e - 1 & 63), o[0] = o[0].add(i[0]), i[0] = i[0].add(o[0]), r = dn(r.add(a).add(o[0]).add(Nt(t, c + 8)), 37).mul(d), a = dn(a.add(o[1]).add(Nt(t, c + 48)), 42).mul(d), r = r.xor(i[1].mul(9)), a = a.add(o[0].mul(9).add(Nt(t, c + 40))), s = dn(s.add(i[0]), 33).mul(d), o = oc(t, c, o[1].mul(d), r.add(i[0])), i = oc(t, c + 32, s.add(i[1]), a.add(Nt(t, c + 16))), [s, r] = [r, s], La(La(o[0], i[0], d).add(Hp(a).mul(x1)).add(s), La(o[1], i[1], d).add(r), d);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gm(t, e) {
  return e === "string" ? Ts(t) : js([t], e);
}
function NT(t, e) {
  return t instanceof Float32Array && e === "float32" || t instanceof Int32Array && e === "int32" || t instanceof Uint8Array && e === "bool";
}
function js(t, e) {
  if (e === "string")
    throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t) && (t = au(t)), Xe().getBool("DEBUG") && iT(t, e), NT(t, e))
    return t;
  if (e == null || e === "float32" || e === "complex64")
    return new Float32Array(t);
  if (e === "int32")
    return new Int32Array(t);
  if (e === "bool") {
    const n = new Uint8Array(t.length);
    for (let r = 0; r < n.length; ++r)
      Math.round(t[r]) !== 0 && (n[r] = 1);
    return n;
  } else
    throw new Error(`Unknown data type ${e}`);
}
function Ha() {
  return Xe().platform.now();
}
function AT(t, e) {
  return Xe().platform.fetch(t, e);
}
function Ts(t, e = "utf-8") {
  return e = e || "utf-8", Xe().platform.encode(t, e);
}
function ru(t, e = "utf-8") {
  return e = e || "utf-8", Xe().platform.decode(t, e);
}
function kr(t) {
  return Xe().platform.isTypedArray != null ? Xe().platform.isTypedArray(t) : g1(t);
}
function au(t, e = [], n = !1) {
  if (e == null && (e = []), typeof t == "boolean" || typeof t == "number" || typeof t == "string" || Ds(t) || t == null || kr(t) && n)
    e.push(t);
  else if (Array.isArray(t) || kr(t))
    for (let r = 0; r < t.length; ++r)
      au(t[r], e, n);
  else {
    let r = -1;
    for (const a of Object.keys(t))
      /^([1-9]+[0-9]*|0)$/.test(a) && (r = Math.max(r, Number(a)));
    for (let a = 0; a <= r; a++)
      au(t[a], e, n);
  }
  return e;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class RT {
  constructor(e, n) {
    this.backendTimer = e, this.logger = n, n == null && (this.logger = new DT());
  }
  profileKernel(e, n, r) {
    let a;
    const s = () => {
      a = r();
    };
    let o;
    const i = Ha();
    if (this.backendTimer.timerAvailable())
      o = this.backendTimer.time(s);
    else {
      s();
      for (const l of a)
        l.dataSync();
      o = Promise.resolve({ kernelMs: Ha() - i });
    }
    if (Xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        u.data().then((d) => {
          $T(d, u.dtype, e);
        });
      }
    return {
      kernelName: e,
      outputs: a,
      inputs: n,
      timeMs: o.then((l) => l.kernelMs),
      extraInfo: o.then((l) => l.getExtraProfileInfo != null ? l.getExtraProfileInfo() : "")
    };
  }
  logKernelProfile(e) {
    const { kernelName: n, outputs: r, timeMs: a, inputs: s, extraInfo: o } = e;
    r.forEach((i) => {
      Promise.all([i.data(), a, o]).then((c) => {
        this.logger.logKernelProfile(n, i, c[0], c[1], s, c[2]);
      });
    });
  }
}
function $T(t, e, n) {
  if (e !== "float32")
    return !1;
  for (let r = 0; r < t.length; r++) {
    const a = t[r];
    if (isNaN(a) || !isFinite(a))
      return console.warn(`Found ${a} in the result of '${n}'`), !0;
  }
  return !1;
}
class DT {
  logKernelProfile(e, n, r, a, s, o) {
    const i = typeof a == "number" ? vc(`${a}ms`, 9) : a.error, c = vc(e, 25), l = n.rank, u = n.size, d = vc(n.shape.toString(), 14);
    let f = "";
    for (const p in s) {
      const h = s[p];
      if (h != null) {
        const m = h.shape || n.shape, g = m.length;
        f += `${p}: ${g}D ${g > 0 ? m : ""} `;
      }
    }
    console.log(`%c${c}	%c${i}	%c${l}D ${d}	%c${u}	%c${f}	%c${o}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OT(t, e, n) {
  const r = {}, a = {};
  for (let c = 0; c < e.length; c++)
    r[e[c].id] = !0;
  for (let c = 0; c < t.length; c++) {
    const l = t[c], u = l.inputs;
    for (const d in u) {
      const f = u[d];
      let p = !1;
      for (let h = 0; h < e.length; h++)
        if (r[f.id]) {
          l.outputs.forEach((m) => r[m.id] = !0), p = !0, a[l.id] = !0;
          break;
        }
      if (p)
        break;
    }
  }
  const s = {};
  s[n.id] = !0;
  const o = {};
  for (let c = t.length - 1; c >= 0; c--) {
    const l = t[c], u = l.inputs;
    for (let d = 0; d < l.outputs.length; d++)
      if (s[l.outputs[d].id]) {
        for (const f in u)
          s[u[f].id] = !0, o[l.id] = !0;
        break;
      }
  }
  const i = [];
  for (let c = 0; c < t.length; c++) {
    const l = t[c];
    if (a[l.id] && o[l.id]) {
      const u = {};
      for (const f in l.inputs) {
        const p = l.inputs[f];
        r[p.id] && (u[f] = p);
      }
      const d = Object.assign({}, l);
      d.inputs = u, d.outputs = l.outputs, i.push(d);
    }
  }
  return i;
}
function FT(t, e, n, r) {
  for (let a = e.length - 1; a >= 0; a--) {
    const s = e[a], o = [];
    if (s.outputs.forEach((c) => {
      const l = t[c.id];
      l != null ? o.push(l) : o.push(null);
    }), s.gradient == null)
      throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);
    const i = s.gradient(o);
    for (const c in s.inputs) {
      if (!(c in i))
        throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(i)}.`);
      const l = n(() => i[c]());
      if (l.dtype !== "float32")
        throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);
      const u = s.inputs[c];
      if (!Ir(l.shape, u.shape))
        throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);
      if (t[u.id] == null)
        t[u.id] = l;
      else {
        const d = t[u.id];
        t[u.id] = r(d, l), d.dispose();
      }
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Xy = 20, mi = 3, Kf = 7;
function MT(t, e, n, r) {
  const a = Ie(e), s = PT(t, e, n, a), o = e.length, i = bc(t, e, n, a, s), c = ["Tensor"];
  return r && (c.push(`  dtype: ${n}`), c.push(`  rank: ${o}`), c.push(`  shape: [${e}]`), c.push("  values:")), c.push(i.map((l) => "    " + l).join(`
`)), c.join(`
`);
}
function PT(t, e, n, r) {
  const a = Y(e), s = r[r.length - 1], o = new Array(s).fill(0), i = e.length, c = n === "complex64" ? Di(t) : t;
  if (i > 1)
    for (let l = 0; l < a / s; l++) {
      const u = l * s;
      for (let d = 0; d < s; d++)
        o[d] = Math.max(o[d], $i(c[u + d], 0, n).length);
    }
  return o;
}
function $i(t, e, n) {
  let r;
  return Array.isArray(t) ? r = `${parseFloat(t[0].toFixed(Kf))} + ${parseFloat(t[1].toFixed(Kf))}j` : fl(t) ? r = `'${t}'` : n === "bool" ? r = k1(t) : r = parseFloat(t.toFixed(Kf)).toString(), vc(r, e);
}
function k1(t) {
  return t === 0 ? "false" : "true";
}
function bc(t, e, n, r, a, s = !0) {
  const o = n === "complex64" ? 2 : 1, i = e[0], c = e.length;
  if (c === 0) {
    if (n === "complex64") {
      const m = Di(t);
      return [$i(m[0], 0, n)];
    }
    return n === "bool" ? [k1(t[0])] : [t[0].toString()];
  }
  if (c === 1) {
    if (i > Xy) {
      const g = mi * o;
      let v = Array.from(t.slice(0, g)), b = Array.from(t.slice((i - mi) * o, i * o));
      return n === "complex64" && (v = Di(v), b = Di(b)), [
        "[" + v.map((w, S) => $i(w, a[S], n)).join(", ") + ", ..., " + b.map((w, S) => $i(w, a[i - mi + S], n)).join(", ") + "]"
      ];
    }
    return [
      "[" + (n === "complex64" ? Di(t) : Array.from(t)).map((g, v) => $i(g, a[v], n)).join(", ") + "]"
    ];
  }
  const l = e.slice(1), u = r.slice(1), d = r[0] * o, f = [];
  if (i > Xy) {
    for (let m = 0; m < mi; m++) {
      const g = m * d, v = g + d;
      f.push(...bc(
        t.slice(g, v),
        l,
        n,
        u,
        a,
        !1
        /* isLast */
      ));
    }
    f.push("...");
    for (let m = i - mi; m < i; m++) {
      const g = m * d, v = g + d;
      f.push(...bc(
        t.slice(g, v),
        l,
        n,
        u,
        a,
        m === i - 1
        /* isLast */
      ));
    }
  } else
    for (let m = 0; m < i; m++) {
      const g = m * d, v = g + d;
      f.push(...bc(
        t.slice(g, v),
        l,
        n,
        u,
        a,
        m === i - 1
        /* isLast */
      ));
    }
  const p = c === 2 ? "," : "";
  f[0] = "[" + (i > 0 ? f[0] + p : "");
  for (let m = 1; m < f.length - 1; m++)
    f[m] = " " + f[m] + p;
  let h = `,
`;
  for (let m = 2; m < c; m++)
    h += `
`;
  return f[f.length - 1] = " " + f[f.length - 1] + "]" + (s ? "" : h), f;
}
function Di(t) {
  const e = [];
  for (let n = 0; n < t.length; n += 2)
    e.push([t[n], t[n + 1]]);
  return e;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class on {
  constructor(e, n, r) {
    if (this.dtype = n, this.shape = e.slice(), this.size = Y(e), r != null) {
      const a = r.length;
      A(a === this.size, () => `Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if (n === "complex64")
      throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = r || tn(n, this.size), this.strides = Ie(e);
  }
  /**
   * Sets a value in the buffer at a given location.
   *
   * @param value The value to set.
   * @param locs  The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  set(e, ...n) {
    n.length === 0 && (n = [0]), A(n.length === this.rank, () => `The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);
    const r = this.locToIndex(n);
    this.values[r] = e;
  }
  /**
   * Returns the value in the buffer at the provided location.
   *
   * @param locs The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  get(...e) {
    e.length === 0 && (e = [0]);
    let n = 0;
    for (const a of e) {
      if (a < 0 || a >= this.shape[n]) {
        const s = `Requested out of range element at ${e}.   Buffer shape=${this.shape}`;
        throw new Error(s);
      }
      n++;
    }
    let r = e[e.length - 1];
    for (let a = 0; a < e.length - 1; ++a)
      r += this.strides[a] * e[a];
    return this.values[r];
  }
  locToIndex(e) {
    if (this.rank === 0)
      return 0;
    if (this.rank === 1)
      return e[0];
    let n = e[e.length - 1];
    for (let r = 0; r < e.length - 1; ++r)
      n += this.strides[r] * e[r];
    return n;
  }
  indexToLoc(e) {
    if (this.rank === 0)
      return [];
    if (this.rank === 1)
      return [e];
    const n = new Array(this.shape.length);
    for (let r = 0; r < n.length - 1; ++r)
      n[r] = Math.floor(e / this.strides[r]), e -= n[r] * this.strides[r];
    return n[n.length - 1] = e, n;
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Creates an immutable `tf.Tensor` object from the buffer.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  toTensor() {
    return Fr().makeTensor(this.values, this.shape, this.dtype);
  }
}
let Fr = null, lo = null;
function BT(t) {
  Fr = t;
}
function LT(t) {
  lo = t;
}
class en {
  constructor(e, n, r, a) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = n || "float32", this.size = Y(e), this.strides = Ie(e), this.dataId = r, this.id = a, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async buffer() {
    const e = await this.data();
    return lo.buffer(this.shape, this.dtype, e);
  }
  /**
   * Returns a `tf.TensorBuffer` that holds the underlying data.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  bufferSync() {
    return lo.buffer(this.shape, this.dtype, this.dataSync());
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * asynchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async array() {
    const e = await this.data();
    return xr(this.shape, e, this.dtype === "complex64");
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * synchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  arraySync() {
    return xr(this.shape, this.dataSync(), this.dtype === "complex64");
  }
  /**
   * Asynchronously downloads the values from the `tf.Tensor`. Returns a
   * promise of `TypedArray` that resolves when the computation has finished.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async data() {
    this.throwIfDisposed();
    const e = Fr().read(this.dataId);
    if (this.dtype === "string") {
      const n = await e;
      try {
        return n.map((r) => ru(r));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return e;
  }
  /**
   * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
   * and `data()`, this method prevents data from being downloaded to CPU.
   *
   * For WebGL backend, the data will be stored on a densely packed texture.
   * This means that the texture will use the RGBA channels to store value.
   *
   * For WebGPU backend, the data will be stored on a buffer. There is no
   * parameter, so can not use a user-defined size to create the buffer.
   *
   * @param options:
   *     For WebGL,
   *         - customTexShape: Optional. If set, will use the user defined
   *     texture shape to create the texture.
   *
   * @returns For WebGL backend, a GPUData contains the new texture and
   *     its information.
   *     {
   *        tensorRef: The tensor that is associated with this texture,
   *        texture: WebGLTexture,
   *        texShape: [number, number] // [height, width]
   *     }
   *
   *     For WebGPU backend, a GPUData contains the new buffer.
   *     {
   *        tensorRef: The tensor that is associated with this buffer,
   *        buffer: GPUBuffer,
   *     }
   *
   *     Remember to dispose the GPUData after it is used by
   *     `res.tensorRef.dispose()`.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataToGPU(e) {
    return this.throwIfDisposed(), Fr().readToGPU(this.dataId, e);
  }
  /**
   * Synchronously downloads the values from the `tf.Tensor`. This blocks the
   * UI thread until the values are ready, which can cause performance issues.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataSync() {
    this.throwIfDisposed();
    const e = Fr().readSync(this.dataId);
    if (this.dtype === "string")
      try {
        return e.map((n) => ru(n));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    return e;
  }
  /** Returns the underlying bytes of the tensor's data. */
  async bytes() {
    this.throwIfDisposed();
    const e = await Fr().read(this.dataId);
    return this.dtype === "string" ? e : new Uint8Array(e.buffer);
  }
  /**
   * Disposes `tf.Tensor` from memory.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dispose() {
    this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), Fr().disposeTensor(this), this.isDisposedInternal = !0);
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed)
      throw new Error("Tensor is disposed.");
  }
  /**
   * Prints the `tf.Tensor`. See `tf.print` for details.
   *
   * @param verbose Whether to print verbose information about the tensor,
   *    including dtype and size.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  print(e = !1) {
    return lo.print(this, e);
  }
  /**
   * Returns a copy of the tensor. See `tf.clone` for details.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  clone() {
    return this.throwIfDisposed(), lo.clone(this);
  }
  /**
   * Returns a human-readable description of the tensor. Useful for logging.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  toString(e = !1) {
    const n = this.dataSync();
    return MT(n, this.shape, this.dtype, e);
  }
  cast(e) {
    return this.throwIfDisposed(), lo.cast(this, e);
  }
  variable(e = !0, n, r) {
    return this.throwIfDisposed(), Fr().makeVariable(this, e, n, r);
  }
}
Object.defineProperty(en, Symbol.hasInstance, {
  value: (t) => !!t && t.data != null && t.dataSync != null && t.throwIfDisposed != null
});
function WT() {
  return om("Tensor", () => en);
}
WT();
class Pc extends en {
  constructor(e, n, r, a) {
    super(e.shape, e.dtype, e.dataId, a), this.trainable = n, this.name = r;
  }
  /**
   * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
   * the same shape and dtype as the old `tf.Tensor`.
   *
   * @param newValue New tensor to be assigned to this variable.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  assign(e) {
    if (e.dtype !== this.dtype)
      throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);
    if (!Ir(e.shape, this.shape))
      throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);
    Fr().disposeTensor(this), this.dataId = e.dataId, Fr().incRef(
      this,
      null
      /* backend */
    );
  }
  dispose() {
    Fr().disposeVariable(this), this.isDisposedInternal = !0;
  }
}
Object.defineProperty(Pc, Symbol.hasInstance, {
  value: (t) => t instanceof en && t.assign != null && t.assign instanceof Function
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Yy;
(function(t) {
  t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6";
})(Yy || (Yy = {}));
var jp;
(function(t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64";
})(jp || (jp = {}));
var Up;
(function(t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64";
})(Up || (Up = {}));
var Gp;
(function(t) {
  t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64";
})(Gp || (Gp = {}));
var qp;
(function(t) {
  t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64";
})(qp || (qp = {}));
const zT = {
  float32: Gp,
  int32: jp,
  bool: Up,
  complex64: qp
};
function Lo(t, e) {
  if (t === "string" || e === "string") {
    if (t === "string" && e === "string")
      return "string";
    throw new Error(`Can not upcast ${t} with ${e}`);
  }
  return zT[t][e];
}
function E1(t) {
  return t != null && typeof t == "object" && "texture" in t && t.texture instanceof WebGLTexture;
}
function T1(t) {
  return typeof GPUBuffer < "u" && t != null && typeof t == "object" && "buffer" in t && t.buffer instanceof GPUBuffer;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kt(t, e) {
  if (t.dtype === e.dtype)
    return [t, e];
  const n = Lo(t.dtype, e.dtype);
  return [t.cast(n), e.cast(n)];
}
function VT(t, e) {
  A(t.dtype === e.dtype, () => `The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`);
}
function C1(t) {
  const e = [];
  return N1(t, e, /* @__PURE__ */ new Set()), e;
}
function N1(t, e, n) {
  if (t == null)
    return;
  if (t instanceof en) {
    e.push(t);
    return;
  }
  if (!HT(t))
    return;
  const r = t;
  for (const a in r) {
    const s = r[a];
    n.has(s) || (n.add(s), N1(s, e, n));
  }
}
function HT(t) {
  return Array.isArray(t) || typeof t == "object";
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xf(t) {
  return t.kernelName != null;
}
class Zy {
  constructor() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,
      get kernelNames() {
        return Array.from(new Set(this.kernels.map((e) => e.name)));
      }
    };
  }
  dispose() {
    for (const e in this.registeredVariables)
      this.registeredVariables[e].dispose();
  }
}
class Eo {
  constructor(e) {
    this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Zy();
  }
  async ready() {
    if (this.pendingBackendInit != null)
      return this.pendingBackendInit.then(() => {
      });
    if (this.backendInstance != null)
      return;
    const e = this.getSortedBackends();
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (await this.initializeBackend(r).success) {
        await this.setBackend(r);
        return;
      }
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  get backend() {
    if (this.pendingBackendInit != null)
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    if (this.backendInstance == null) {
      const { name: e, asyncInit: n } = this.initializeBackendsAndReturnBest();
      if (n)
        throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      this.setBackend(e);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(e) {
    if (!(e in this.registry))
      if (e in this.registryFactory) {
        const { asyncInit: n } = this.initializeBackend(e);
        if (n)
          return null;
      } else
        return null;
    return this.registry[e];
  }
  findBackendFactory(e) {
    return e in this.registryFactory ? this.registryFactory[e].factory : null;
  }
  registerBackend(e, n, r = 1) {
    return e in this.registryFactory ? (bs(`${e} backend was already registered. Reusing existing backend factory.`), !1) : (this.registryFactory[e] = { factory: n, priority: r }, !0);
  }
  async setBackend(e) {
    if (this.registryFactory[e] == null)
      throw new Error(`Backend name '${e}' not found in registry`);
    if (this.backendName = e, this.registry[e] == null) {
      this.backendInstance = null;
      const { success: n, asyncInit: r } = this.initializeBackend(e);
      if (!(r ? await n : n))
        return !1;
    }
    return this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new RT(this.backendInstance), !0;
  }
  setupRegisteredKernels() {
    Vy(this.backendName).forEach((n) => {
      n.setupFunc != null && n.setupFunc(this.backendInstance);
    });
  }
  disposeRegisteredKernels(e) {
    Vy(e).forEach((r) => {
      r.disposeFunc != null && r.disposeFunc(this.registry[e]);
    });
  }
  /**
   * Initializes a backend by looking up the backend name in the factory
   * registry and calling the factory method. Returns a boolean representing
   * whether the initialization of the backend suceeded. Throws an error if
   * there is no backend in the factory registry.
   */
  initializeBackend(e) {
    const n = this.registryFactory[e];
    if (n == null)
      throw new Error(`Cannot initialize backend ${e}, no registration found.`);
    try {
      const r = n.factory();
      if (r && !(r instanceof rm) && typeof r.then == "function") {
        const a = ++this.pendingBackendInitId, s = r.then((o) => a < this.pendingBackendInitId ? !1 : (this.registry[e] = o, this.pendingBackendInit = null, !0)).catch((o) => (a < this.pendingBackendInitId || (this.pendingBackendInit = null, bs(`Initialization of backend ${e} failed`), bs(o.stack || o.message)), !1));
        return this.pendingBackendInit = s, { success: s, asyncInit: !0 };
      } else
        return this.registry[e] = r, { success: !0, asyncInit: !1 };
    } catch (r) {
      return bs(`Initialization of backend ${e} failed`), bs(r.stack || r.message), { success: !1, asyncInit: !1 };
    }
  }
  removeBackend(e) {
    if (!(e in this.registryFactory))
      throw new Error(`${e} backend not found in registry`);
    this.backendName === e && this.pendingBackendInit != null && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0)
      throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort((e, n) => this.registryFactory[n].priority - this.registryFactory[e].priority);
  }
  initializeBackendsAndReturnBest() {
    const e = this.getSortedBackends();
    for (let n = 0; n < e.length; n++) {
      const r = e[n], { success: a, asyncInit: s } = this.initializeBackend(r);
      if (s || a)
        return { name: r, asyncInit: s };
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  moveData(e, n) {
    const r = this.state.tensorInfo.get(n), a = r.backend, s = this.readSync(n), o = a.refCount(n);
    a.disposeData(n, !0), r.backend = e, e.move(n, s, r.shape, r.dtype, o), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }
  tidy(e, n) {
    let r = null;
    if (n == null) {
      if (typeof e != "function")
        throw new Error("Please provide a function to tidy()");
      n = e;
    } else {
      if (typeof e != "string" && !(e instanceof String))
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if (typeof n != "function")
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      r = e;
    }
    let a;
    return this.scopedRun(() => this.startScope(r), () => this.endScope(a), () => (a = n(), a instanceof Promise && console.error("Cannot return a Promise inside of tidy."), a));
  }
  scopedRun(e, n, r) {
    e();
    try {
      const a = r();
      return n(), a;
    } catch (a) {
      throw n(), a;
    }
  }
  nextTensorId() {
    return Eo.nextTensorId++;
  }
  nextVariableId() {
    return Eo.nextVariableId++;
  }
  /**
   * This method is called instead of the public-facing tensor.clone() when
   * saving a tensor for backwards pass. It makes sure to add the clone
   * operation to the tape regardless of being called inside a kernel
   * execution.
   */
  clone(e) {
    const n = W.runKernel(ed, { x: e }), r = { x: e }, a = (o) => ({
      x: () => {
        const i = "float32", c = { x: o }, l = { dtype: i };
        return W.runKernel(
          Tl,
          c,
          // tslint:disable-next-line: no-unnecessary-type-assertion
          l
        );
      }
    }), s = [];
    return this.addTapeNode(this.state.activeScope.name, r, [n], a, s, {}), n;
  }
  /**
   * Execute a kernel with the given name and return the output tensor.
   *
   * @param kernelName The name of the kernel to execute.
   * @param inputs A map of input names to tensors.
   * @param attrs A map of attribute names to their values. An attribute is a
   *     primitive (non-tensor) input to the kernel.
   * @param inputsToSave A list of tensors, inputs to save for the backprop
   *     computation.
   * @param outputsToSave A list of booleans, specifying which output to save
   *     for the backprop computation. These are booleans since the output
   * tensors are not visible to the user.
   */
  runKernel(e, n, r) {
    if (this.backendName == null && this.backend, !(Fc(e, this.backendName) != null))
      throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);
    return this.runKernelFunc({ kernelName: e, inputs: n, attrs: r });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(e, n, r) {
    const a = this.backend.numDataIds();
    let s = 0;
    r.forEach((c) => {
      s += c.dtype === "complex64" ? 3 : 1;
    });
    const o = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i = a - n - s - o;
    if (i > 0)
      throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`);
  }
  /**
   * Internal helper method to execute a kernel Func
   *
   * Use `runKernel` to execute kernels from outside of engine.
   */
  runKernelFunc(e) {
    let n, r = [];
    const a = this.isTapeOn(), s = this.state.numBytes, o = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    let i;
    this.backendName == null && this.backend;
    let c;
    const l = Xf(e) ? e.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
    if (Xf(e)) {
      const { kernelName: h, inputs: m, attrs: g } = e;
      this.backendName == null && this.backend;
      const v = Fc(h, this.backendName);
      A(v != null, () => `Cannot find registered kernel '${h}' for backend '${this.backendName}'`), i = () => {
        const b = this.backend.numDataIds();
        c = v.kernelFunc({ inputs: m, attrs: g, backend: this.backend });
        const w = Array.isArray(c) ? c : [c];
        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(h, b, w);
        const S = w.map((I) => I.rank != null ? I : this.makeTensorFromTensorInfo(I));
        if (a) {
          const I = this.getTensorsForGradient(h, m, S);
          r = this.saveTensorsForBackwardMode(I);
        }
        return S;
      };
    } else {
      const { forwardFunc: h } = e, m = (g) => {
        a && (r = g.map((v) => this.keep(this.clone(v))));
      };
      i = () => {
        const g = this.backend.numDataIds();
        c = this.tidy(() => h(this.backend, m));
        const v = Array.isArray(c) ? c : [c];
        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(l, g, v), v;
      };
    }
    const { inputs: u, attrs: d } = e, f = Xf(e) ? null : e.backwardsFunc;
    let p;
    return this.scopedRun(
      // Stop recording to a tape when running a kernel.
      () => this.state.kernelDepth++,
      () => this.state.kernelDepth--,
      () => {
        !this.ENV.getBool("DEBUG") && !this.state.profiling ? n = i() : (p = this.profiler.profileKernel(l, u, () => i()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(p), n = p.outputs);
      }
    ), a && this.addTapeNode(l, u, n, f, r, d), this.state.profiling && this.state.activeProfile.kernels.push({
      name: l,
      bytesAdded: this.state.numBytes - s,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - o,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(u).map((h) => u[h] != null ? u[h].shape : null),
      outputShapes: n.map((h) => h.shape),
      kernelTimeMs: p.timeMs,
      extraInfo: p.extraInfo
    }), Array.isArray(c) ? n : n[0];
  }
  /**
   * Saves tensors used in forward mode for use in backward mode.
   *
   * @param tensors the list of tensors to save.
   */
  saveTensorsForBackwardMode(e) {
    return e.map((r) => this.keep(this.clone(r)));
  }
  /**
   * Returns a list of tensors to save for a given gradient calculation.
   *
   * @param kernelName name of kernel to look up gradient for.
   * @param inputs a map of input tensors.
   * @param outputs an array of output tensors from forward mode of kernel.
   */
  getTensorsForGradient(e, n, r) {
    const a = zy(e);
    if (a != null) {
      const s = a.inputsToSave || [], o = a.outputsToSave || [];
      let i;
      a.saveAllInputs ? (A(Array.isArray(n), () => "saveAllInputs is true, expected inputs to be an array."), i = Object.keys(n).map((l) => n[l])) : i = s.map((l) => n[l]);
      const c = r.filter((l, u) => o[u]);
      return i.concat(c);
    }
    return [];
  }
  /**
   * Internal method used by public APIs for tensor creation. Makes a new
   * tensor with the provided shape, dtype and values. It always
   * creates a new data id and writes the values to the underlying backend.
   */
  makeTensor(e, n, r, a) {
    if (e == null)
      throw new Error("Values passed to engine.makeTensor() are null");
    r = r || "float32", a = a || this.backend;
    let s = e;
    r === "string" && fl(e[0]) && (s = e.map((c) => Ts(c)));
    const o = a.write(s, n, r), i = new en(n, r, o, this.nextTensorId());
    if (this.trackTensor(i, a), r === "string") {
      const c = this.state.tensorInfo.get(o), l = lT(s);
      this.state.numBytes += l - c.bytes, c.bytes = l;
    }
    return i;
  }
  /**
   * Internal method used by backends. Makes a new tensor
   * that is a wrapper around an existing data id. It doesn't create
   * a new data id, only increments the ref count used in memory tracking.
   * @deprecated
   */
  makeTensorFromDataId(e, n, r, a) {
    r = r || "float32";
    const s = { dataId: e, shape: n, dtype: r };
    return this.makeTensorFromTensorInfo(s, a);
  }
  /**
   * Internal method used by backends. Makes a new tensor that is a wrapper
   * around an existing data id in TensorInfo. It doesn't create a new data id,
   * only increments the ref count used in memory tracking.
   */
  makeTensorFromTensorInfo(e, n) {
    const { dataId: r, shape: a, dtype: s } = e, o = new en(a, s, r, this.nextTensorId());
    return this.trackTensor(o, n), o;
  }
  makeVariable(e, n = !0, r, a) {
    r = r || this.nextVariableId().toString(), a != null && a !== e.dtype && (e = e.cast(a));
    const s = new Pc(e, n, r, this.nextTensorId());
    if (this.state.registeredVariables[s.name] != null)
      throw new Error(`Variable with name ${s.name} was already registered`);
    return this.state.registeredVariables[s.name] = s, this.incRef(s, this.backend), s;
  }
  trackTensor(e, n) {
    this.state.numTensors++, e.dtype === "string" && this.state.numStringTensors++;
    let r = 0;
    e.dtype !== "complex64" && e.dtype !== "string" && (r = e.size * Qi(e.dtype)), this.state.numBytes += r, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
      backend: n || this.backend,
      dtype: e.dtype,
      shape: e.shape,
      bytes: r
    })), e instanceof Pc || this.track(e);
  }
  // Track the tensor by dataId and increase the refCount for the dataId in the
  // backend.
  // TODO(pyu10055): This is currently used by makeVariable method, to increase
  // refCount on the backend for the dataId. It can potentially be replaced with
  // Identity op indead of calling backend directly.
  incRef(e, n) {
    this.trackTensor(e, n), this.backend.incRef(e.dataId);
  }
  removeDataId(e, n) {
    this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === n && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
  }
  disposeTensor(e) {
    if (!this.state.tensorInfo.has(e.dataId))
      return;
    const n = this.state.tensorInfo.get(e.dataId);
    if (this.state.numTensors--, e.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= n.bytes), e.dtype !== "complex64" && e.dtype !== "string") {
      const r = e.size * Qi(e.dtype);
      this.state.numBytes -= r;
    }
    n.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, n.backend);
  }
  disposeVariables() {
    for (const e in this.state.registeredVariables) {
      const n = this.state.registeredVariables[e];
      this.disposeVariable(n);
    }
  }
  disposeVariable(e) {
    this.disposeTensor(e), this.state.registeredVariables[e.name] != null && delete this.state.registeredVariables[e.name];
  }
  memory() {
    const e = this.backend.memory();
    return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, e.reasons == null && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
  }
  async profile(e) {
    this.state.profiling = !0;
    const n = this.state.numBytes, r = this.state.numTensors;
    this.state.activeProfile.kernels = [], this.state.activeProfile.result = await e(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((a) => a.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - n, this.state.activeProfile.newTensors = this.state.numTensors - r;
    for (const a of this.state.activeProfile.kernels)
      a.kernelTimeMs = await a.kernelTimeMs, a.extraInfo = await a.extraInfo;
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(e, n, r, a, s, o) {
    const i = { id: this.state.nextTapeNodeId++, kernelName: e, inputs: n, outputs: r, saved: s }, c = zy(e);
    c != null && (a = c.gradFunc), a != null && (i.gradient = (l) => (l = l.map((u, d) => {
      if (u == null) {
        const f = r[d], p = In(f.size, f.dtype);
        return this.makeTensor(p, f.shape, f.dtype);
      }
      return u;
    }), a(l.length > 1 ? l : l[0], s, o))), this.state.activeTape.push(i);
  }
  keep(e) {
    return e.kept = !0, e;
  }
  startTape() {
    this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  /**
   * Start a scope. Use this with endScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  startScope(e) {
    const n = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    e && (n.name = e), this.state.scopeStack.push(n), this.state.activeScope = n;
  }
  /**
   * End a scope. Use this with startScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  endScope(e) {
    const n = C1(e), r = new Set(n.map((s) => s.id));
    for (let s = 0; s < this.state.activeScope.track.length; s++) {
      const o = this.state.activeScope.track[s];
      !o.kept && !r.has(o.id) && o.dispose();
    }
    const a = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach((s) => {
      !s.kept && s.scopeId === a.id && this.track(s);
    });
  }
  /**
   * Returns gradients of `f` with respect to each of the `xs`. The gradients
   * returned are of the same length as `xs`, but some might be null if `f`
   * was not a function of that `x`. It also takes optional dy to multiply the
   * gradient, which defaults to `1`.
   */
  gradients(e, n, r, a = !1) {
    if (A(n.length > 0, () => "gradients() received an empty list of xs."), r != null && r.dtype !== "float32")
      throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);
    const s = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e));
    A(s instanceof en, () => "The result y returned by f() must be a tensor.");
    const o = OT(this.state.activeTape, n, s);
    if (!a && o.length === 0 && n.length > 0)
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", () => {
      const i = {};
      i[s.id] = r ?? jT(s.shape), FT(
        i,
        o,
        // Pass the tidy function to avoid circular dep with `tape.ts`.
        (l) => this.tidy(l),
        // Pass an add function to avoide a circular dep with `tape.ts`.
        UT
      );
      const c = n.map((l) => i[l.id]);
      return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((l) => {
        for (const u of l.saved)
          u.dispose();
      }), this.state.activeTape = null), { value: s, grads: c };
    });
  }
  customGrad(e) {
    return A(zp(e), () => "The f passed in customGrad(f) must be a function."), (...n) => {
      A(n.every((i) => i instanceof en), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let r;
      const a = {};
      n.forEach((i, c) => {
        a[c] = i;
      });
      const s = (i, c) => (r = e(...n, c), A(r.value instanceof en, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), A(zp(r.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), r.value), o = (i, c) => {
        const l = r.gradFunc(i, c), u = Array.isArray(l) ? l : [l];
        A(u.length === n.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), A(u.every((f) => f instanceof en), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        const d = {};
        return u.forEach((f, p) => {
          d[p] = () => f;
        }), d;
      };
      return this.runKernelFunc({
        forwardFunc: s,
        backwardsFunc: o,
        inputs: a
      });
    };
  }
  readSync(e) {
    return this.state.tensorInfo.get(e).backend.readSync(e);
  }
  read(e) {
    return this.state.tensorInfo.get(e).backend.read(e);
  }
  readToGPU(e, n) {
    return this.state.tensorInfo.get(e).backend.readToGPU(e, n);
  }
  async time(e) {
    const n = Ha(), r = await this.backend.time(e);
    return r.wallMs = Ha() - n, r;
  }
  /**
   * Tracks a Tensor in the current scope to be automatically cleaned up
   * when the current scope ends, and returns the value.
   *
   * @param result The Tensor to track in the current scope.
   */
  track(e) {
    return this.state.activeScope != null && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  /**
   * Resets the engine state. Removes all backends but does not remove
   * registered backend factories.
   */
  reset() {
    this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Zy();
    for (const e in this.registry)
      this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }
}
Eo.nextTensorId = 0;
Eo.nextVariableId = 0;
function jT(t) {
  const e = sm(Y(t), "float32");
  return W.makeTensor(e, t, "float32");
}
function A1() {
  const t = q0();
  if (t._tfengine == null) {
    const e = new hT(t);
    t._tfengine = new Eo(e);
  }
  return vT(t._tfengine.ENV), BT(() => t._tfengine), t._tfengine;
}
const W = A1();
function UT(t, e) {
  const n = { a: t, b: e };
  return W.runKernel(Eu, n);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GT() {
  return typeof window < "u" && window.document != null || //@ts-ignore
  typeof WorkerGlobalScope < "u";
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Un = Xe();
Un.registerFlag("DEBUG", () => !1, (t) => {
  t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
});
Un.registerFlag("IS_BROWSER", () => GT());
Un.registerFlag("IS_NODE", () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u");
Un.registerFlag("IS_CHROME", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
Un.registerFlag("IS_SAFARI", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
Un.registerFlag("PROD", () => !1);
Un.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => Un.getBool("DEBUG"));
Un.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => !0);
Un.registerFlag("IS_TEST", () => !1);
Un.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => Un.getBool("DEBUG"));
Un.registerFlag("WRAP_TO_IMAGEBITMAP", () => !1);
Un.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => !1);
Un.registerFlag("USE_SETTIMEOUTCUSTOM", () => !1);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ya(t, e) {
  let n = t;
  if (kr(t))
    return e === "string" ? [] : [t.length];
  if (E1(t)) {
    const a = t.channels || "RGBA";
    return [t.height, t.width * a.length];
  } else if (T1(t))
    return [t.buffer.size / (e == null ? 4 : Qi(e))];
  if (!Array.isArray(t))
    return [];
  const r = [];
  for (; Array.isArray(n) || kr(n) && e !== "string"; )
    r.push(n.length), n = n[0];
  return Array.isArray(t) && Xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && R1(t, r, []), r;
}
function R1(t, e, n) {
  if (n = n || [], !Array.isArray(t) && !kr(t)) {
    A(e.length === 0, () => `Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);
    return;
  }
  A(e.length > 0, () => `Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`), A(t.length === e[0], () => `Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);
  const r = e.slice(1);
  for (let a = 0; a < t.length; ++a)
    R1(t[a], r, n.concat(a));
}
function Jy(t, e, n, r) {
  if (t !== "string_or_numeric") {
    if (t == null)
      throw new Error("Expected dtype cannot be null.");
    if (t !== "numeric" && t !== e || t === "numeric" && e === "string")
      throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`);
  }
}
function C(t, e, n, r = "numeric") {
  if (t instanceof en)
    return Jy(r, t.dtype, e, n), t;
  let a = ku(t);
  if (a !== "string" && ["bool", "int32", "float32"].indexOf(r) >= 0 && (a = r), Jy(r, a, e, n), t == null || !kr(t) && !Array.isArray(t) && typeof t != "number" && typeof t != "boolean" && typeof t != "string") {
    const c = t == null ? "null" : t.constructor.name;
    throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${c}'`);
  }
  const s = Ya(t, a);
  !kr(t) && !Array.isArray(t) && (t = [t]);
  const i = a !== "string" ? js(t, a) : au(t, [], !0);
  return W.makeTensor(i, s, a);
}
function Bc(t, e, n, r = "numeric") {
  if (!Array.isArray(t))
    throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);
  return t.map((s, o) => C(s, `${e}[${o}]`, n, r));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $1 = "__op";
function B(t) {
  const e = Object.keys(t);
  if (e.length !== 1)
    throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);
  let n = e[0];
  const r = t[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1)), n = n + $1;
  const a = (...s) => {
    W.startScope(n);
    try {
      const o = r(...s);
      return Ds(o) && console.error("Cannot return a Promise inside of tidy."), W.endScope(o), o;
    } catch (o) {
      throw W.endScope(null), o;
    }
  };
  return Object.defineProperty(a, "name", { value: n, configurable: !0 }), a;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qT(t, e) {
  const n = C(t, "real", "complex"), r = C(e, "imag", "complex");
  ar(n.shape, r.shape, `real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);
  const a = { real: n, imag: r };
  return W.runKernel(Y0, a);
}
const ja = /* @__PURE__ */ B({ complex_: qT });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Za(t, e, n, r) {
  if (r == null)
    r = ku(t);
  else if (r === "complex64")
    throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (T1(t) || E1(t)) {
    if (r !== "float32" && r !== "int32")
      throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);
    return W.backend.createTensorFromGPUData(t, e || n, r);
  }
  if (!kr(t) && !Array.isArray(t) && typeof t != "number" && typeof t != "boolean" && typeof t != "string")
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (e != null) {
    fr(e);
    const a = Y(e), s = Y(n);
    A(a === s, () => `Based on the provided shape, [${e}], the tensor should have ${a} values but has ${s}`);
    for (let o = 0; o < n.length; ++o) {
      const i = n[o], c = o === n.length - 1 ? i !== Y(e.slice(o)) : !0;
      A(n[o] === e[o] || !c, () => `Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `);
    }
  }
  return !kr(t) && !Array.isArray(t) && (t = [t]), e = e || n, t = r !== "string" ? js(t, r) : au(t, [], !0), W.makeTensor(t, e, r);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mr(t, e, n) {
  const r = Ya(t, n);
  return Za(t, e, r, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Kp = {
  float32: 4,
  float16: 2,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1,
  complex64: 8
};
class zr {
  /**
   * Concatenate a number of ArrayBuffers into one.
   *
   * @param buffers An array of ArrayBuffers to concatenate, or a single
   *     ArrayBuffer.
   * @returns Result of concatenating `buffers` in order.
   */
  static join(e) {
    return new zr(e).slice();
  }
  constructor(e) {
    if (this.shards = [], this.previousShardIndex = 0, e == null || (e instanceof Array || (e = [e]), e = e.map((r) => kr(r) ? r.buffer : r), e.length === 0))
      return;
    this.bufferUniformSize = e[0].byteLength;
    let n = 0;
    for (let r = 0; r < e.length; r++) {
      const a = e[r];
      r !== e.length - 1 && a.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
      const s = n + a.byteLength;
      this.shards.push({ buffer: a, start: n, end: s }), n = s;
    }
    this.shards.length === 0 && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
  }
  slice(e = 0, n = this.byteLength) {
    if (this.shards.length === 0)
      return new ArrayBuffer(0);
    if (e = isNaN(Number(e)) ? 0 : e, n = isNaN(Number(n)) ? 0 : n, e = Math.max(0, e), n = Math.min(this.byteLength, n), n <= e)
      return new ArrayBuffer(0);
    const r = this.findShardForByte(e);
    if (r === -1)
      throw new Error(`Could not find start shard for byte ${e}`);
    const a = n - e, s = new ArrayBuffer(a), o = new Uint8Array(s);
    let i = 0;
    for (let c = r; c < this.shards.length; c++) {
      const l = this.shards[c], d = e + i - l.start, f = i, h = Math.min(n, l.end) - l.start, m = new Uint8Array(l.buffer, d, h - d);
      if (o.set(m, f), i += m.length, n < l.end)
        break;
    }
    return s;
  }
  /**
   * Get the index of the shard that contains the byte at `byteIndex`.
   */
  findShardForByte(e) {
    if (this.shards.length === 0 || e < 0 || e >= this.byteLength)
      return -1;
    if (this.bufferUniformSize != null)
      return this.previousShardIndex = Math.floor(e / this.bufferUniformSize), this.previousShardIndex;
    function n(a) {
      return e < a.start ? -1 : e >= a.end ? 1 : 0;
    }
    if (n(this.shards[this.previousShardIndex]) === 0)
      return this.previousShardIndex;
    const r = KT(this.shards, n);
    return r === -1 ? -1 : (this.previousShardIndex = r, this.previousShardIndex);
  }
}
function KT(t, e) {
  let n = 0, r = t.length;
  for (; n <= r; ) {
    const a = Math.floor((r - n) / 2) + n, s = e(t[a]);
    if (s === 0)
      return a;
    s < 0 ? r = a : n = a + 1;
  }
  return -1;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Lc = 4;
async function XT(t, e) {
  const n = [], r = [], a = Array.isArray(t) ? t.map((o) => o.name) : Object.keys(t);
  for (let o = 0; o < a.length; ++o) {
    const i = a[o], c = Array.isArray(t) ? t[o].tensor : t[i];
    if (c.dtype !== "float32" && c.dtype !== "int32" && c.dtype !== "bool" && c.dtype !== "string" && c.dtype !== "complex64")
      throw new Error(`Unsupported dtype in weight '${i}': ${c.dtype}`);
    const l = { name: i, shape: c.shape, dtype: c.dtype };
    if (c.dtype === "string") {
      const u = new Promise(async (d) => {
        const f = await c.bytes(), p = f.reduce((g, v) => g + v.length, 0) + Lc * f.length, h = new Uint8Array(p);
        let m = 0;
        for (let g = 0; g < f.length; g++) {
          const v = f[g], b = new Uint8Array(new Uint32Array([v.length]).buffer);
          h.set(b, m), m += Lc, h.set(v, m), m += v.length;
        }
        d(h);
      });
      r.push(u);
    } else
      r.push(c.data());
    e != null && (l.group = e), n.push(l);
  }
  const s = await Promise.all(r);
  return { data: YT(s), specs: n };
}
function D1(t, e) {
  const n = new zr(t), r = {};
  let a, s = 0;
  for (const o of e) {
    const i = o.name, c = o.dtype, l = o.shape, u = Y(l);
    let d;
    if ("quantization" in o) {
      const f = o.quantization;
      if (f.dtype === "uint8" || f.dtype === "uint16") {
        if (!("min" in f && "scale" in f))
          throw new Error(`Weight ${o.name} with quantization ${f.dtype} doesn't have corresponding metadata min and scale.`);
      } else if (f.dtype === "float16") {
        if (c !== "float32")
          throw new Error(`Weight ${o.name} is quantized with ${f.dtype} which only supports weights of type float32 not ${c}.`);
      } else
        throw new Error(`Weight ${o.name} has unknown quantization dtype ${f.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
      const p = Kp[f.dtype], h = n.slice(s, s + u * p), m = f.dtype === "uint8" ? new Uint8Array(h) : new Uint16Array(h);
      if (c === "float32")
        if (f.dtype === "uint8" || f.dtype === "uint16") {
          d = new Float32Array(m.length);
          for (let g = 0; g < m.length; g++) {
            const v = m[g];
            d[g] = v * f.scale + f.min;
          }
        } else if (f.dtype === "float16")
          a === void 0 && (a = rC()), d = a(m);
        else
          throw new Error(`Unsupported quantization type ${f.dtype} for weight type float32.`);
      else if (c === "int32") {
        if (f.dtype !== "uint8" && f.dtype !== "uint16")
          throw new Error(`Unsupported quantization type ${f.dtype} for weight type int32.`);
        d = new Int32Array(m.length);
        for (let g = 0; g < m.length; g++) {
          const v = m[g];
          d[g] = Math.round(v * f.scale + f.min);
        }
      } else
        throw new Error(`Unsupported dtype in weight '${i}': ${c}`);
      s += u * p;
    } else if (c === "string") {
      const f = Y(o.shape);
      d = [];
      for (let p = 0; p < f; p++) {
        const h = new Uint32Array(n.slice(s, s + Lc))[0];
        s += Lc;
        const m = new Uint8Array(n.slice(s, s + h));
        d.push(m), s += h;
      }
    } else {
      const f = Kp[c], p = n.slice(s, s + u * f);
      if (c === "float32")
        d = new Float32Array(p);
      else if (c === "int32")
        d = new Int32Array(p);
      else if (c === "bool")
        d = new Uint8Array(p);
      else if (c === "complex64") {
        d = new Float32Array(p);
        const h = new Float32Array(d.length / 2), m = new Float32Array(d.length / 2);
        for (let b = 0; b < h.length; b++)
          h[b] = d[b * 2], m[b] = d[b * 2 + 1];
        const g = Mr(h, l, "float32"), v = Mr(m, l, "float32");
        r[i] = ja(g, v), g.dispose(), v.dispose();
      } else
        throw new Error(`Unsupported dtype in weight '${i}': ${c}`);
      s += u * f;
    }
    c !== "complex64" && (r[i] = Mr(d, l, c));
  }
  return r;
}
function YT(t) {
  if (t === null)
    throw new Error(`Invalid input value: ${JSON.stringify(t)}`);
  let e = 0;
  const n = [];
  t.forEach((s) => {
    if (e += s.byteLength, n.push(s.byteLength === s.buffer.byteLength ? s : new s.constructor(s)), !(s instanceof Float32Array || s instanceof Int32Array || s instanceof Uint8Array))
      throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`);
  });
  const r = new Uint8Array(e);
  let a = 0;
  return n.forEach((s) => {
    r.set(new Uint8Array(s.buffer), a), a += s.byteLength;
  }), r.buffer;
}
const qm = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
function Qy(t) {
  return qm ? Buffer.byteLength(t, "utf8") : new Blob([t]).size;
}
function ZT(t) {
  if (qm)
    return Buffer.from(t).toString("base64");
  const e = new Uint8Array(t);
  let n = "";
  for (let r = 0, a = e.length; r < a; r++)
    n += String.fromCharCode(e[r]);
  return btoa(n);
}
function JT(t) {
  if (qm) {
    const r = Buffer.from(t, "base64");
    return r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
  }
  const e = atob(t), n = new Uint8Array(e.length);
  for (let r = 0; r < e.length; ++r)
    n.set([e.charCodeAt(r)], r);
  return n.buffer;
}
function QT(t) {
  return zr.join(t);
}
function ev(t) {
  const e = "/";
  for (t = t.trim(); t.endsWith(e); )
    t = t.slice(0, t.length - 1);
  const n = t.split(e);
  return n[n.length - 1];
}
function O1(t, e) {
  const n = {
    modelTopology: t.modelTopology,
    format: t.format,
    generatedBy: t.generatedBy,
    convertedBy: t.convertedBy,
    weightsManifest: e
  };
  return t.signature != null && (n.signature = t.signature), t.userDefinedMetadata != null && (n.userDefinedMetadata = t.userDefinedMetadata), t.modelInitializer != null && (n.modelInitializer = t.modelInitializer), t.initializerSignature != null && (n.initializerSignature = t.initializerSignature), t.trainingConfig != null && (n.trainingConfig = t.trainingConfig), n;
}
function F1(t, e, n) {
  const r = {
    modelTopology: t.modelTopology,
    format: t.format,
    generatedBy: t.generatedBy,
    convertedBy: t.convertedBy
  };
  if (t.trainingConfig != null && (r.trainingConfig = t.trainingConfig), t.weightsManifest != null) {
    if (!e)
      throw new Error("modelJSON has weightsManifest but weightSpecs is null");
    if (!n)
      throw new Error("modelJSON has weightsManifest but weightData is null");
    r.weightSpecs = e, r.weightData = n;
  }
  return t.signature != null && (r.signature = t.signature), t.userDefinedMetadata != null && (r.userDefinedMetadata = t.userDefinedMetadata), t.modelInitializer != null && (r.modelInitializer = t.modelInitializer), t.initializerSignature != null && (r.initializerSignature = t.initializerSignature), r;
}
async function Km(t, e) {
  let n, r;
  return t.weightsManifest != null && ([n, r] = await e(t.weightsManifest)), F1(t, n, r);
}
function Au(t) {
  if (t.modelTopology instanceof ArrayBuffer)
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: /* @__PURE__ */ new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: t.modelTopology == null ? 0 : Qy(JSON.stringify(t.modelTopology)),
    weightSpecsBytes: t.weightSpecs == null ? 0 : Qy(JSON.stringify(t.weightSpecs)),
    weightDataBytes: t.weightData == null ? 0 : new zr(t.weightData).byteLength
  };
}
function M1(t) {
  const e = [];
  for (const n of t)
    e.push(...n.weights);
  return e;
}
function eC() {
  const t = (n) => {
    let r = n << 13, a = 0;
    for (; !(r & 8388608); )
      a -= 8388608, r <<= 1;
    return r &= -8388609, a += 947912704, r | a;
  }, e = new Uint32Array(2048);
  e[0] = 0;
  for (let n = 1; n < 1024; n++)
    e[n] = t(n);
  for (let n = 1024; n < 2048; n++)
    e[n] = 939524096 + (n - 1024 << 13);
  return e;
}
function tC() {
  const t = new Uint32Array(64);
  t[0] = 0, t[31] = 1199570944, t[32] = 2147483648, t[63] = 3347054592;
  for (let e = 1; e < 31; e++)
    t[e] = e << 23;
  for (let e = 33; e < 63; e++)
    t[e] = 2147483648 + (e - 32 << 23);
  return t;
}
function nC() {
  const t = new Uint32Array(64);
  for (let e = 0; e < 64; e++)
    t[e] = 1024;
  return t[0] = t[32] = 0, t;
}
function rC() {
  const t = eC(), e = tC(), n = nC();
  return (r) => {
    const a = new ArrayBuffer(4 * r.length), s = new Uint32Array(a);
    for (let o = 0; o < r.length; o++) {
      const i = r[o], c = t[n[i >> 10] + (i & 1023)] + e[i >> 10];
      s[o] = c;
    }
    return new Float32Array(a);
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Wt {
  constructor() {
    this.saveRouters = [], this.loadRouters = [];
  }
  static getInstance() {
    return Wt.instance == null && (Wt.instance = new Wt()), Wt.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerSaveRouter(e) {
    Wt.getInstance().saveRouters.push(e);
  }
  /**
   * Register a load-handler router.
   *
   * @param loadRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `load` method defined or `null`.
   */
  static registerLoadRouter(e) {
    Wt.getInstance().loadRouters.push(e);
  }
  /**
   * Look up IOHandler for saving, given a URL-like string.
   *
   * @param url
   * @returns If only one match is found, an instance of IOHandler with the
   * `save` method defined. If no match is found, `null`.
   * @throws Error, if more than one match is found.
   */
  static getSaveHandlers(e) {
    return Wt.getHandlers(e, "save");
  }
  /**
   * Look up IOHandler for loading, given a URL-like string.
   *
   * @param url
   * @param loadOptions Optional, custom load options.
   * @returns All valid handlers for `url`, given the currently registered
   *   handler routers.
   */
  static getLoadHandlers(e, n) {
    return Wt.getHandlers(e, "load", n);
  }
  static getHandlers(e, n, r) {
    const a = [];
    return (n === "load" ? Wt.getInstance().loadRouters : Wt.getInstance().saveRouters).forEach((o) => {
      const i = o(e, r);
      i !== null && a.push(i);
    }), a;
  }
}
const aC = (t) => Wt.registerSaveRouter(t), sC = (t) => Wt.registerLoadRouter(t), oC = (t) => Wt.getSaveHandlers(t), iC = (t, e) => Wt.getLoadHandlers(t, e);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Xp = "tensorflowjs", Yp = 1, Is = "models_store", Ba = "model_info_store";
function P1() {
  if (!Xe().getBool("IS_BROWSER"))
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  const t = typeof window > "u" ? self : window, e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
  if (e == null)
    throw new Error("The current browser does not appear to support IndexedDB.");
  return e;
}
function Zp(t) {
  const e = t.result;
  e.createObjectStore(Is, { keyPath: "modelPath" }), e.createObjectStore(Ba, { keyPath: "modelPath" });
}
class Os {
  constructor(e) {
    if (this.indexedDB = P1(), e == null || !e)
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e;
  }
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    return this.databaseAction(this.modelPath, e);
  }
  async load() {
    return this.databaseAction(this.modelPath);
  }
  /**
   * Perform database action to put model artifacts into or read model artifacts
   * from IndexedDB object store.
   *
   * Whether the action is put or get depends on whether `modelArtifacts` is
   * specified. If it is specified, the action will be put; otherwise the action
   * will be get.
   *
   * @param modelPath A unique string path for the model.
   * @param modelArtifacts If specified, it will be the model artifacts to be
   *   stored in IndexedDB.
   * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`
   *   of `ModelArtifacts`, if the action is get.
   */
  databaseAction(e, n) {
    return new Promise((r, a) => {
      const s = this.indexedDB.open(Xp, Yp);
      s.onupgradeneeded = () => Zp(s), s.onsuccess = () => {
        const o = s.result;
        if (n == null) {
          const i = o.transaction(Is, "readonly"), l = i.objectStore(Is).get(this.modelPath);
          l.onsuccess = () => {
            if (l.result == null)
              return o.close(), a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
            r(l.result.modelArtifacts);
          }, l.onerror = (u) => (o.close(), a(l.error)), i.oncomplete = () => o.close();
        } else {
          n.weightData = zr.join(n.weightData);
          const i = Au(n), c = o.transaction(Ba, "readwrite");
          let l = c.objectStore(Ba), u;
          try {
            u = l.put({ modelPath: this.modelPath, modelArtifactsInfo: i });
          } catch (f) {
            return a(f);
          }
          let d;
          u.onsuccess = () => {
            d = o.transaction(Is, "readwrite");
            const f = d.objectStore(Is);
            let p;
            try {
              p = f.put({
                modelPath: this.modelPath,
                modelArtifacts: n,
                modelArtifactsInfo: i
              });
            } catch (h) {
              return a(h);
            }
            p.onsuccess = () => r({ modelArtifactsInfo: i }), p.onerror = (h) => {
              l = c.objectStore(Ba);
              const m = l.delete(this.modelPath);
              m.onsuccess = () => (o.close(), a(p.error)), m.onerror = (g) => (o.close(), a(p.error));
            };
          }, u.onerror = (f) => (o.close(), a(u.error)), c.oncomplete = () => {
            d == null ? o.close() : d.oncomplete = () => o.close();
          };
        }
      }, s.onerror = (o) => a(s.error);
    });
  }
}
Os.URL_SCHEME = "indexeddb://";
const B1 = (t) => Xe().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Os.URL_SCHEME) ? uC(t.slice(Os.URL_SCHEME.length)) : null;
Wt.registerSaveRouter(B1);
Wt.registerLoadRouter(B1);
function uC(t) {
  return new Os(t);
}
function cC(t) {
  return t.startsWith(Os.URL_SCHEME) ? t.slice(Os.URL_SCHEME.length) : t;
}
class lC {
  constructor() {
    this.indexedDB = P1();
  }
  async listModels() {
    return new Promise((e, n) => {
      const r = this.indexedDB.open(Xp, Yp);
      r.onupgradeneeded = () => Zp(r), r.onsuccess = () => {
        const a = r.result, s = a.transaction(Ba, "readonly"), i = s.objectStore(Ba).getAll();
        i.onsuccess = () => {
          const c = {};
          for (const l of i.result)
            c[l.modelPath] = l.modelArtifactsInfo;
          e(c);
        }, i.onerror = (c) => (a.close(), n(i.error)), s.oncomplete = () => a.close();
      }, r.onerror = (a) => n(r.error);
    });
  }
  async removeModel(e) {
    return e = cC(e), new Promise((n, r) => {
      const a = this.indexedDB.open(Xp, Yp);
      a.onupgradeneeded = () => Zp(a), a.onsuccess = () => {
        const s = a.result, o = s.transaction(Ba, "readwrite"), i = o.objectStore(Ba), c = i.get(e);
        let l;
        c.onsuccess = () => {
          if (c.result == null)
            return s.close(), r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));
          {
            const u = i.delete(e), d = () => {
              l = s.transaction(Is, "readwrite");
              const p = l.objectStore(Is).delete(e);
              p.onsuccess = () => n(c.result.modelArtifactsInfo), p.onerror = (h) => r(c.error);
            };
            u.onsuccess = d, u.onerror = (f) => (d(), s.close(), r(c.error));
          }
        }, c.onerror = (u) => (s.close(), r(c.error)), o.oncomplete = () => {
          l == null ? s.close() : l.oncomplete = () => s.close();
        };
      }, a.onerror = (s) => r(a.error);
    });
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const da = "/", fo = "tensorflowjs_models", L1 = "info", dC = "model_topology", fC = "weight_specs", pC = "weight_data", hC = "model_metadata";
function W1(t) {
  return {
    info: [fo, t, L1].join(da),
    topology: [fo, t, dC].join(da),
    weightSpecs: [fo, t, fC].join(da),
    weightData: [fo, t, pC].join(da),
    modelMetadata: [fo, t, hC].join(da)
  };
}
function z1(t) {
  for (const e of Object.values(t))
    window.localStorage.removeItem(e);
}
function mC(t) {
  const e = t.split(da);
  if (e.length < 3)
    throw new Error(`Invalid key format: ${t}`);
  return e.slice(1, e.length - 1).join(da);
}
function gC(t) {
  return t.startsWith(Fs.URL_SCHEME) ? t.slice(Fs.URL_SCHEME.length) : t;
}
class Fs {
  constructor(e) {
    if (!Xe().getBool("IS_BROWSER") || typeof window > "u" || typeof window.localStorage > "u")
      throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, e == null || !e)
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e, this.keys = W1(this.modelPath);
  }
  /**
   * Save model artifacts to browser local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @param modelArtifacts The model artifacts to be stored.
   * @returns An instance of SaveResult.
   */
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    {
      const n = JSON.stringify(e.modelTopology), r = JSON.stringify(e.weightSpecs), a = Au(e), s = zr.join(e.weightData);
      try {
        this.LS.setItem(this.keys.info, JSON.stringify(a)), this.LS.setItem(this.keys.topology, n), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, ZT(s));
        const o = {
          format: e.format,
          generatedBy: e.generatedBy,
          convertedBy: e.convertedBy,
          signature: e.signature != null ? e.signature : void 0,
          userDefinedMetadata: e.userDefinedMetadata != null ? e.userDefinedMetadata : void 0,
          modelInitializer: e.modelInitializer != null ? e.modelInitializer : void 0,
          initializerSignature: e.initializerSignature != null ? e.initializerSignature : void 0,
          trainingConfig: e.trainingConfig != null ? e.trainingConfig : void 0
        };
        return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(o)), { modelArtifactsInfo: a };
      } catch {
        throw z1(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`);
      }
    }
  }
  /**
   * Load a model from local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @returns The loaded model (if loading succeeds).
   */
  async load() {
    const e = JSON.parse(this.LS.getItem(this.keys.info));
    if (e == null)
      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
    if (e.modelTopologyType !== "JSON")
      throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
    const n = {}, r = JSON.parse(this.LS.getItem(this.keys.topology));
    if (r == null)
      throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
    n.modelTopology = r;
    const a = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
    if (a == null)
      throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
    n.weightSpecs = a;
    const s = this.LS.getItem(this.keys.modelMetadata);
    if (s != null) {
      const i = JSON.parse(s);
      n.format = i.format, n.generatedBy = i.generatedBy, n.convertedBy = i.convertedBy, i.signature != null && (n.signature = i.signature), i.userDefinedMetadata != null && (n.userDefinedMetadata = i.userDefinedMetadata), i.modelInitializer != null && (n.modelInitializer = i.modelInitializer), i.initializerSignature != null && (n.initializerSignature = i.initializerSignature), i.trainingConfig != null && (n.trainingConfig = i.trainingConfig);
    }
    const o = this.LS.getItem(this.keys.weightData);
    if (o == null)
      throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
    return n.weightData = JT(o), n;
  }
}
Fs.URL_SCHEME = "localstorage://";
const V1 = (t) => Xe().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Fs.URL_SCHEME) ? yC(t.slice(Fs.URL_SCHEME.length)) : null;
Wt.registerSaveRouter(V1);
Wt.registerLoadRouter(V1);
function yC(t) {
  return new Fs(t);
}
class vC {
  constructor() {
    A(Xe().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), A(typeof window > "u" || typeof window.localStorage < "u", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
  }
  async listModels() {
    const e = {}, n = fo + da, r = da + L1;
    for (let a = 0; a < this.LS.length; ++a) {
      const s = this.LS.key(a);
      if (s.startsWith(n) && s.endsWith(r)) {
        const o = mC(s);
        e[o] = JSON.parse(this.LS.getItem(s));
      }
    }
    return e;
  }
  async removeModel(e) {
    e = gC(e);
    const n = W1(e);
    if (this.LS.getItem(n.info) == null)
      throw new Error(`Cannot find model at path '${e}'`);
    const r = JSON.parse(this.LS.getItem(n.info));
    return z1(n), r;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bo = "://";
class An {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    return An.instance == null && (An.instance = new An()), An.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerManager(e, n) {
    A(e != null, () => "scheme must not be undefined or null."), e.endsWith(bo) && (e = e.slice(0, e.indexOf(bo))), A(e.length > 0, () => "scheme must not be an empty string.");
    const r = An.getInstance();
    A(r.managers[e] == null, () => `A model store manager is already registered for scheme '${e}'.`), r.managers[e] = n;
  }
  static getManager(e) {
    const n = An.getInstance().managers[e];
    if (n == null)
      throw new Error(`Cannot find model manager for scheme '${e}'`);
    return n;
  }
  static getSchemes() {
    return Object.keys(An.getInstance().managers);
  }
}
function wc(t) {
  if (t.indexOf(bo) === -1)
    throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${An.getSchemes().join(",")}`);
  return {
    scheme: t.split(bo)[0],
    path: t.split(bo)[1]
  };
}
async function H1(t, e, n = !1) {
  A(t !== e, () => `Old path and new path are the same: '${t}'`);
  const r = Wt.getLoadHandlers(t);
  A(r.length > 0, () => `Copying failed because no load handler is found for source URL ${t}.`), A(r.length < 2, () => `Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);
  const a = r[0], s = Wt.getSaveHandlers(e);
  A(s.length > 0, () => `Copying failed because no save handler is found for destination URL ${e}.`), A(s.length < 2, () => `Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);
  const o = s[0], i = wc(t).scheme, c = wc(t).path, l = i === wc(t).scheme, u = await a.load();
  n && l && await An.getManager(i).removeModel(c);
  const d = await o.save(u);
  return n && !l && await An.getManager(i).removeModel(c), d.modelArtifactsInfo;
}
async function bC() {
  const t = An.getSchemes(), e = {};
  for (const n of t) {
    const r = await An.getManager(n).listModels();
    for (const a in r) {
      const s = n + bo + a;
      e[s] = r[a];
    }
  }
  return e;
}
async function wC(t) {
  const e = wc(t);
  return An.getManager(e.scheme).removeModel(e.path);
}
async function SC(t, e) {
  return H1(t, e, !1);
}
async function _C(t, e) {
  return H1(t, e, !0);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class xC {
  constructor() {
    this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = !1;
  }
  fetch(e, n) {
    return fetch(e, n);
  }
  now() {
    return performance.now();
  }
  encode(e, n) {
    if (n !== "utf-8" && n !== "utf8")
      throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);
    return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
  }
  decode(e, n) {
    return new TextDecoder(n).decode(e);
  }
  // If the setTimeout nesting level is greater than 5 and timeout is less
  // than 4ms, timeout will be clamped to 4ms, which hurts the perf.
  // Interleaving window.postMessage and setTimeout will trick the browser and
  // avoid the clamp.
  setTimeoutCustom(e, n) {
    if (typeof window > "u" || !Xe().getBool("USE_SETTIMEOUTCUSTOM")) {
      setTimeout(e, n);
      return;
    }
    this.functionRefs.push(e), setTimeout(() => {
      window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
    }, n), this.hasEventListener || (this.hasEventListener = !0, window.addEventListener("message", (r) => {
      if (r.source === window && r.data.name === this.messageName) {
        r.stopPropagation();
        const a = this.functionRefs[r.data.index];
        a(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0);
      }
    }, !0));
  }
  isTypedArray(e) {
    return g1(e);
  }
}
if (Xe().get("IS_BROWSER")) {
  Xe().setPlatform("browser", new xC());
  try {
    An.registerManager(Fs.URL_SCHEME, new vC());
  } catch {
  }
  try {
    An.registerManager(Os.URL_SCHEME, new lC());
  } catch {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IC = {
  // tslint:disable-next-line:no-require-imports
  importFetch: () => require("node-fetch")
};
let Yf;
class kC {
  constructor() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }
  fetch(e, n) {
    return Xe().global.fetch != null ? Xe().global.fetch(e, n) : (Yf == null && (Yf = IC.importFetch()), Yf(e, n));
  }
  now() {
    const e = process.hrtime();
    return e[0] * 1e3 + e[1] / 1e6;
  }
  encode(e, n) {
    if (n !== "utf-8" && n !== "utf8")
      throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);
    return this.textEncoder.encode(e);
  }
  decode(e, n) {
    return e.length === 0 ? "" : new this.util.TextDecoder(n).decode(e);
  }
  isTypedArray(e) {
    return this.util.types.isFloat32Array(e) || this.util.types.isInt32Array(e) || this.util.types.isUint8Array(e) || this.util.types.isUint8ClampedArray(e);
  }
}
Xe().get("IS_NODE") && !Xe().get("IS_BROWSER") && Xe().setPlatform("node", new kC());
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qe(t, e = "float32", n) {
  return e = e || "float32", fr(t), new on(t, e, n);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EC(t, e) {
  const n = C(t, "x", "cast");
  if (!uT(e))
    throw new Error(`Failed to cast to unknown dtype ${e}`);
  if (e === "string" && n.dtype !== "string" || e !== "string" && n.dtype === "string")
    throw new Error("Only strings can be casted to strings");
  const r = { x: n }, a = { dtype: e };
  return W.runKernel(Tl, r, a);
}
const zt = /* @__PURE__ */ B({ cast_: EC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TC(t) {
  const n = { x: C(t, "x", "clone", "string_or_numeric") };
  return W.runKernel(ed, n);
}
const Wa = /* @__PURE__ */ B({ clone_: TC });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function j1(t, e = !1) {
  console.log(t.toString(e));
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
A1();
const CC = {
  buffer: Qe,
  cast: zt,
  clone: Wa,
  print: j1
};
LT(CC);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jp() {
  return W;
}
function Je(t, e) {
  return W.tidy(t, e);
}
function un(t) {
  C1(t).forEach((n) => n.dispose());
}
function Yr(t) {
  return W.keep(t);
}
function tv(t) {
  return W.setBackend(t);
}
function NC() {
  return W.ready();
}
function U1(t, e, n = 1) {
  return W.registerBackend(t, e, n);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AC(t, e) {
  let n = C(t, "a", "add"), r = C(e, "b", "add");
  [n, r] = Kt(n, r);
  const a = { a: n, b: r };
  return W.runKernel(Eu, a);
}
const Ae = /* @__PURE__ */ B({ add_: AC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RC(t, e) {
  let n = C(t, "a", "floorDiv"), r = C(e, "b", "floorDiv");
  [n, r] = Kt(n, r);
  const a = { a: n, b: r };
  return W.runKernel(Xl, a);
}
const G1 = /* @__PURE__ */ B({ floorDiv_: RC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $C(t, e) {
  let n = C(t, "a", "div"), r = C(e, "b", "div");
  if ([n, r] = Kt(n, r), n.dtype === "int32" && r.dtype === "int32")
    return G1(n, r);
  const a = { a: n, b: r }, s = {};
  return W.runKernel(zl, a, s);
}
const Ze = /* @__PURE__ */ B({ div_: $C });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DC(t, e) {
  let n = C(t, "a", "mul"), r = C(e, "b", "mul");
  [n, r] = Kt(n, r);
  const a = { a: n, b: r };
  return W.runKernel(xd, a);
}
const he = /* @__PURE__ */ B({ mul_: DC });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OC(t) {
  const e = C(t, "x", "abs");
  if (e.dtype === "complex64") {
    const n = { x: e };
    return W.runKernel(Z0, n);
  } else {
    const n = { x: e };
    return W.runKernel(im, n);
  }
}
const cr = /* @__PURE__ */ B({ abs_: OC });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FC(t) {
  const n = { x: C(t, "x", "acos") };
  return W.runKernel(pl, n);
}
const MC = /* @__PURE__ */ B({ acos_: FC });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PC(t) {
  const n = { x: C(t, "x", "acosh") };
  return W.runKernel(hl, n);
}
const BC = /* @__PURE__ */ B({ acosh_: PC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LC(t) {
  A(Array.isArray(t), () => "The argument passed to tf.addN() must be a list of tensors"), A(t.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${t.length}`);
  const e = t.map((a, s) => C(a, `tensors${s}`, "addN")), n = e[0];
  e.forEach((a) => {
    if (a.dtype !== n.dtype)
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), e.forEach((a) => {
    if (!Ir(a.shape, n.shape))
      throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  const r = e;
  return W.runKernel(ml, r);
}
const WC = /* @__PURE__ */ B({ addN_: LC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zC(t, e = null, n = !1) {
  const a = { x: C(t, "x", "all", "bool") }, s = { axis: e, keepDims: n };
  return W.runKernel(gl, a, s);
}
const VC = /* @__PURE__ */ B({ all_: zC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HC(t, e = null, n = !1) {
  const a = { x: C(t, "x", "any", "bool") }, s = { axis: e, keepDims: n };
  return W.runKernel(yl, a, s);
}
const jC = /* @__PURE__ */ B({ any_: HC });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UC(t, e = 0) {
  const r = { x: C(t, "x", "argMax") }, a = { axis: e };
  return W.runKernel(um, r, a);
}
const GC = /* @__PURE__ */ B({ argMax_: UC });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qC(t, e = 0) {
  const r = { x: C(t, "x", "argMin") }, a = { axis: e };
  return W.runKernel(cm, r, a);
}
const KC = /* @__PURE__ */ B({ argMin_: qC });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XC(t) {
  const n = { x: C(t, "x", "asin") };
  return W.runKernel(vl, n);
}
const YC = /* @__PURE__ */ B({ asin_: XC });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZC(t) {
  const n = { x: C(t, "x", "asinh") };
  return W.runKernel(bl, n);
}
const JC = /* @__PURE__ */ B({ asinh_: ZC });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QC(t) {
  const n = { x: C(t, "x", "atan") };
  return W.runKernel(wl, n);
}
const eN = /* @__PURE__ */ B({ atan_: QC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tN(t, e) {
  let n = C(t, "a", "atan2"), r = C(e, "b", "atan2");
  [n, r] = Kt(n, r);
  const a = { a: n, b: r };
  return W.runKernel(_l, a);
}
const nN = /* @__PURE__ */ B({ atan2_: tN });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rN(t) {
  const n = { x: C(t, "x", "atanh") };
  return W.runKernel(Sl, n);
}
const aN = /* @__PURE__ */ B({ atanh_: rN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wo(t, e, n, r, a = "NHWC", s) {
  const o = t[3], i = [...e, o], c = zo(a);
  return Kn(t, i, n, s, r, null, null, c);
}
function Vr(t, e, n, r, a, s, o = "channelsLast") {
  const [i, c] = su(e);
  let l;
  if (o === "channelsLast")
    l = [i, c, t[3], t[3]];
  else if (o === "channelsFirst")
    l = [i, c, t[1], t[1]];
  else
    throw new Error(`Unknown dataFormat ${o}`);
  return Kn(t, l, n, r, a, s, !1, o);
}
function Ja(t, e, n, r, a, s, o = "NDHWC") {
  const [i, c, l] = Qp(e);
  let u, d;
  if (o === "NDHWC")
    d = "channelsLast", u = [i, c, l, t[4], t[4]];
  else if (o === "NCDHW")
    d = "channelsFirst", u = [i, c, l, t[1], t[1]];
  else
    throw new Error(`Unknown dataFormat ${o}`);
  return Us(t, u, n, r, a, !1, d, s);
}
function Kn(t, e, n, r, a, s, o = !1, i = "channelsLast") {
  let [c, l, u, d] = [-1, -1, -1, -1];
  if (i === "channelsLast")
    [c, l, u, d] = t;
  else if (i === "channelsFirst")
    [c, d, l, u] = t;
  else
    throw new Error(`Unknown dataFormat ${i}`);
  const [f, p, , h] = e, [m, g] = su(n), [v, b] = su(r), w = wo(f, v), S = wo(p, b), { padInfo: I, outHeight: E, outWidth: T } = iN(a, l, u, m, g, w, S, s, i), R = o ? h * d : h;
  let $;
  return i === "channelsFirst" ? $ = [c, R, E, T] : i === "channelsLast" && ($ = [c, E, T, R]), {
    batchSize: c,
    dataFormat: i,
    inHeight: l,
    inWidth: u,
    inChannels: d,
    outHeight: E,
    outWidth: T,
    outChannels: R,
    padInfo: I,
    strideHeight: m,
    strideWidth: g,
    filterHeight: f,
    filterWidth: p,
    effectiveFilterHeight: w,
    effectiveFilterWidth: S,
    dilationHeight: v,
    dilationWidth: b,
    inShape: t,
    outShape: $,
    filterShape: e
  };
}
function Us(t, e, n, r, a, s = !1, o = "channelsLast", i) {
  let [c, l, u, d, f] = [-1, -1, -1, -1, -1];
  if (o === "channelsLast")
    [c, l, u, d, f] = t;
  else if (o === "channelsFirst")
    [c, f, l, u, d] = t;
  else
    throw new Error(`Unknown dataFormat ${o}`);
  const [p, h, m, , g] = e, [v, b, w] = Qp(n), [S, I, E] = Qp(r), T = wo(p, S), R = wo(h, I), $ = wo(m, E), { padInfo: D, outDepth: M, outHeight: z, outWidth: F } = uN(a, l, u, d, v, b, w, T, R, $, i), V = s ? g * f : g;
  let H;
  return o === "channelsFirst" ? H = [c, V, M, z, F] : o === "channelsLast" && (H = [c, M, z, F, V]), {
    batchSize: c,
    dataFormat: o,
    inDepth: l,
    inHeight: u,
    inWidth: d,
    inChannels: f,
    outDepth: M,
    outHeight: z,
    outWidth: F,
    outChannels: V,
    padInfo: D,
    strideDepth: v,
    strideHeight: b,
    strideWidth: w,
    filterDepth: p,
    filterHeight: h,
    filterWidth: m,
    effectiveFilterDepth: T,
    effectiveFilterHeight: R,
    effectiveFilterWidth: $,
    dilationDepth: S,
    dilationHeight: I,
    dilationWidth: E,
    inShape: t,
    outShape: H,
    filterShape: e
  };
}
function sN(t, e, n, r, a) {
  r == null && (r = q1(t, e, n));
  const s = t[0], o = t[1], i = ou((s - e + 2 * r) / n + 1, a), c = ou((o - e + 2 * r) / n + 1, a);
  return [i, c];
}
function oN(t, e, n, r, a, s) {
  a == null && (a = q1(t, e[0], r[0]));
  const o = [0, 0, 0, n];
  for (let i = 0; i < 3; i++)
    t[i] + 2 * a >= e[i] && (o[i] = ou((t[i] - e[i] + 2 * a) / r[i] + 1, s));
  return o;
}
function q1(t, e, n, r = 1) {
  const a = wo(e, r);
  return Math.floor((t[0] * (n - 1) - n + a) / 2);
}
function su(t) {
  return typeof t == "number" ? [t, t, t] : t.length === 2 ? [t[0], t[1], 1] : t;
}
function Qp(t) {
  return typeof t == "number" ? [t, t, t] : t;
}
function wo(t, e) {
  return e <= 1 ? t : t + (t - 1) * (e - 1);
}
function iN(t, e, n, r, a, s, o, i, c) {
  let l, u, d;
  if (typeof t == "number") {
    l = { top: t, bottom: t, left: t, right: t, type: t === 0 ? "VALID" : "NUMBER" };
    const p = sN([e, n], s, r, t, i);
    u = p[0], d = p[1];
  } else if (t === "same") {
    u = Math.ceil(e / r), d = Math.ceil(n / a);
    const f = Math.max(0, (u - 1) * r + s - e), p = Math.max(0, (d - 1) * a + o - n), h = Math.floor(f / 2), m = f - h, g = Math.floor(p / 2), v = p - g;
    l = { top: h, bottom: m, left: g, right: v, type: "SAME" };
  } else if (t === "valid")
    l = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, u = Math.ceil((e - s + 1) / r), d = Math.ceil((n - o + 1) / a);
  else if (typeof t == "object") {
    const f = c === "channelsLast" ? t[1][0] : t[2][0], p = c === "channelsLast" ? t[1][1] : t[2][1], h = c === "channelsLast" ? t[2][0] : t[3][0], m = c === "channelsLast" ? t[2][1] : t[3][1];
    l = { top: f, bottom: p, left: h, right: m, type: f === 0 && p === 0 && h === 0 && m === 0 ? "VALID" : "EXPLICIT" }, u = ou((e - s + f + p) / r + 1, i), d = ou((n - o + h + m) / a + 1, i);
  } else
    throw Error(`Unknown padding parameter: ${t}`);
  return { padInfo: l, outHeight: u, outWidth: d };
}
function uN(t, e, n, r, a, s, o, i, c, l, u) {
  let d, f, p, h;
  if (t === "valid" && (t = 0), typeof t == "number") {
    d = {
      top: t,
      bottom: t,
      left: t,
      right: t,
      front: t,
      back: t,
      type: t === 0 ? "VALID" : "NUMBER"
    };
    const g = oN([e, n, r, 1], [i, c, l], 1, [a, s, o], t, u);
    f = g[0], p = g[1], h = g[2];
  } else if (t === "same") {
    f = Math.ceil(e / a), p = Math.ceil(n / s), h = Math.ceil(r / o);
    const m = (f - 1) * a + i - e, g = (p - 1) * s + c - n, v = (h - 1) * o + l - r, b = Math.floor(m / 2), w = m - b, S = Math.floor(g / 2), I = g - S, E = Math.floor(v / 2), T = v - E;
    d = { top: S, bottom: I, left: E, right: T, front: b, back: w, type: "SAME" };
  } else
    throw Error(`Unknown padding parameter: ${t}`);
  return { padInfo: d, outDepth: f, outHeight: p, outWidth: h };
}
function ou(t, e) {
  if (!e)
    return Math.trunc(t);
  switch (e) {
    case "round":
      return Math.round(t);
    case "ceil":
      return Math.ceil(t);
    case "floor":
      return Math.floor(t);
    default:
      throw new Error(`Unknown roundingMode ${e}`);
  }
}
function Wc(t) {
  const [e, n, r] = su(t);
  return e === 1 && n === 1 && r === 1;
}
function Er(t, e) {
  return Wc(t) || Wc(e);
}
function To(t) {
  return su(t).every((e) => e > 0);
}
function zo(t) {
  if (t === "NHWC")
    return "channelsLast";
  if (t === "NCHW")
    return "channelsFirst";
  throw new Error(`Unknown dataFormat ${t}`);
}
function Hr(t, e, n) {
  if (n != null) {
    if (typeof e == "string")
      throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);
    if (typeof e == "number")
      A(Ji(e), () => `Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);
    else if (typeof e == "object")
      e.forEach((r) => {
        r.forEach((a) => {
          A(Ji(a), () => `Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`);
        });
      });
    else
      throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cN(t, e) {
  const r = { x: C(t, "x", "reshape", "string_or_numeric") }, a = { shape: e };
  return W.runKernel(Cm, r, a);
}
const ae = /* @__PURE__ */ B({ reshape_: cN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lN(t, e, n, r, a) {
  const s = C(t, "x", "avgPool", "float32"), o = 1;
  A(Er(n, o), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);
  let i = s, c = !1;
  s.rank === 3 && (c = !0, i = ae(s, [1, s.shape[0], s.shape[1], s.shape[2]])), A(i.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${i.rank}.`), Hr("avgPool", r, a);
  const l = { x: i }, u = { filterSize: e, strides: n, pad: r, dimRoundingMode: a };
  let d = W.runKernel(xl, l, u);
  return d = zt(d, s.dtype), c ? ae(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const K1 = /* @__PURE__ */ B({ avgPool_: lN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dN(t, e, n, r, a, s = "NDHWC") {
  const o = C(t, "x", "avgPool3d", "float32");
  let i = o, c = !1;
  o.rank === 4 && (c = !0, i = ae(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), A(i.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`), A(s === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`), A(typeof n == "number" && n > 0 || Array.isArray(n) && n[0] > 0 && n[1] > 0 && n[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${n}'`), Hr("avgPool3d", r, a);
  const l = { x: i }, u = { filterSize: e, strides: n, pad: r, dimRoundingMode: a, dataFormat: s };
  let d = W.runKernel(lm, l, u);
  return d = zt(d, i.dtype), c ? ae(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
}
const fN = /* @__PURE__ */ B({ avgPool3d_: dN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pN(t, e = 0) {
  A(t.length >= 1, () => "Pass at least one tensor to concat");
  const n = Bc(t, "tensors", "concat", "string_or_numeric");
  if (n[0].dtype === "complex64" && n.forEach((s) => {
    if (s.dtype !== "complex64")
      throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `);
  }), n.length === 1)
    return Wa(n[0]);
  const r = n, a = { axis: e };
  return W.runKernel(pm, r, a);
}
const yn = /* @__PURE__ */ B({ concat_: pN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hN(t, e, n = !1, r = !1) {
  let a = C(t, "a", "matMul"), s = C(e, "b", "matMul");
  [a, s] = Kt(a, s);
  const o = { a, b: s }, i = { transposeA: n, transposeB: r };
  return W.runKernel(Il, o, i);
}
const wt = /* @__PURE__ */ B({ matMul_: hN });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mN(t) {
  const n = { x: C(t, "x", "sigmoid", "float32") };
  return W.runKernel(Kd, n);
}
const Cs = /* @__PURE__ */ B({ sigmoid_: mN });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gN(t, e, n) {
  const r = C(t, "x", "slice", "string_or_numeric");
  if (r.rank === 0)
    throw new Error("Slicing scalar is not possible");
  const a = { x: r }, s = { begin: e, size: n };
  return W.runKernel($m, a, s);
}
const qe = /* @__PURE__ */ B({ slice_: gN });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yN(t) {
  const n = { x: C(t, "x", "tanh", "float32") };
  return W.runKernel(sf, n);
}
const eh = /* @__PURE__ */ B({ tanh_: yN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vN(t, e, n, r, a, s) {
  const o = C(t, "forgetBias", "basicLSTMCell"), i = C(e, "lstmKernel", "basicLSTMCell"), c = C(n, "lstmBias", "basicLSTMCell"), l = C(r, "data", "basicLSTMCell"), u = C(a, "c", "basicLSTMCell"), d = C(s, "h", "basicLSTMCell"), f = yn([l, d], 1), p = wt(f, i), h = Ae(p, c), m = h.shape[0], g = h.shape[1] / 4, v = [m, g], b = qe(h, [0, 0], v), w = qe(h, [0, g], v), S = qe(h, [0, g * 2], v), I = qe(h, [0, g * 3], v), E = Ae(he(Cs(b), eh(w)), he(u, Cs(Ae(o, S)))), T = he(eh(E), Cs(I));
  return [E, T];
}
const bN = /* @__PURE__ */ B({ basicLSTMCell_: vN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wN(t, e, n) {
  const r = C(t, "x", "batchToSpaceND"), a = e.reduce((i, c) => i * c);
  A(r.rank >= 1 + e.length, () => `input rank is ${r.rank} but should be > than blockShape.length ${e.length}`), A(n.length === e.length, () => `crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`), A(r.shape[0] % a === 0, () => `input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${a}`);
  const s = { x: r }, o = { blockShape: e, crops: n };
  return W.runKernel(dm, s, o);
}
const X1 = /* @__PURE__ */ B({ batchToSpaceND_: wN });
function SN(t) {
  let e;
  return t.rank === 0 || t.rank === 1 ? e = ae(t, [1, 1, 1, t.size]) : t.rank === 2 ? e = ae(t, [1, 1, t.shape[0], t.shape[1]]) : t.rank === 3 ? e = ae(t, [1, t.shape[0], t.shape[1], t.shape[2]]) : e = t, e;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _N(t, e, n, r, a, s) {
  s == null && (s = 1e-3);
  const o = C(t, "x", "batchNorm"), i = C(e, "mean", "batchNorm"), c = C(n, "variance", "batchNorm");
  let l;
  a != null && (l = C(a, "scale", "batchNorm"));
  let u;
  r != null && (u = C(r, "offset", "batchNorm")), A(i.rank === c.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), A(u == null || i.rank === u.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), A(l == null || i.rank === l.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  const f = {
    x: SN(o),
    scale: l,
    offset: u,
    mean: i,
    variance: c
  }, p = { varianceEpsilon: s }, h = W.runKernel(Yl, f, p);
  return ae(h, o.shape);
}
const df = /* @__PURE__ */ B({ batchNorm_: _N });
function xN(t, e, n, r, a, s) {
  const o = C(t, "x", "batchNorm"), i = C(e, "mean", "batchNorm"), c = C(n, "variance", "batchNorm");
  let l;
  a != null && (l = C(a, "scale", "batchNorm"));
  let u;
  return r != null && (u = C(r, "offset", "batchNorm")), A(o.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`), A(i.rank === 2 || i.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`), A(c.rank === 2 || c.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`), l != null && A(l.rank === 2 || l.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`), u != null && A(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`), df(o, i, c, u, l, s);
}
const IN = /* @__PURE__ */ B({ batchNorm2d_: xN });
function kN(t, e, n, r, a, s) {
  const o = C(t, "x", "batchNorm"), i = C(e, "mean", "batchNorm"), c = C(n, "variance", "batchNorm");
  let l;
  a != null && (l = C(a, "scale", "batchNorm"));
  let u;
  return r != null && (u = C(r, "offset", "batchNorm")), A(o.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`), A(i.rank === 3 || i.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`), A(c.rank === 3 || c.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`), l != null && A(l.rank === 3 || l.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`), u != null && A(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`), df(o, i, c, u, l, s);
}
const EN = /* @__PURE__ */ B({ batchNorm3d_: kN });
function TN(t, e, n, r, a, s) {
  const o = C(t, "x", "batchNorm"), i = C(e, "mean", "batchNorm"), c = C(n, "variance", "batchNorm");
  let l;
  a != null && (l = C(a, "scale", "batchNorm"));
  let u;
  return r != null && (u = C(r, "offset", "batchNorm")), A(o.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`), A(i.rank === 4 || i.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`), A(c.rank === 4 || c.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`), l != null && A(l.rank === 4 || l.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`), u != null && A(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`), df(o, i, c, u, l, s);
}
const CN = /* @__PURE__ */ B({ batchNorm4d_: TN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NN(t, e, n) {
  const r = C(t, "x", "bincount"), a = C(e, "weights", "bincount");
  A(r.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${r.dtype}`), A(n >= 0, () => `size must be non-negative, but got ${n}.`), A(a.size === r.size || a.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`);
  const s = { x: r, weights: a }, o = { size: n };
  return W.runKernel(kl, s, o);
}
const Y1 = /* @__PURE__ */ B({ bincount_: NN });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AN(t, e) {
  const n = C(t, "x", "bitwiseAnd"), r = C(e, "y", "bitwiseAnd");
  if (!Ir(n.shape, r.shape))
    throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);
  if (n.dtype !== "int32" || r.dtype !== "int32")
    throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);
  const a = { a: n, b: r };
  return W.runKernel(El, a);
}
const RN = /* @__PURE__ */ B({ bitwiseAnd_: AN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $N(t, e) {
  const n = C(t, "s0", "broadcastArgs", "int32"), r = C(e, "s1", "broadcastArgs", "int32");
  if (n.rank !== 1)
    throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);
  if (r.rank !== 1)
    throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);
  const a = { s0: n, s1: r };
  return W.runKernel(fm, a);
}
const DN = /* @__PURE__ */ B({ broadcastArgs_: $N });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ON(t, e) {
  let n = C(t, "broadcastTo", "x");
  const r = n.shape;
  if (fr(e), e.length < n.rank)
    throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);
  if (e.length > n.rank) {
    const l = n.shape.slice();
    for (; l.length < e.length; )
      l.unshift(1);
    n = ae(n, l);
  }
  const a = n.shape, s = Array.from(e);
  for (let l = e.length - 1; l >= 0; l--)
    if (a[l] === e[l])
      s[l] = 1;
    else if (n.shape[l] !== 1)
      throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);
  if (s.map((l, u) => l > 1 ? u : -1).filter((l) => l >= 0).length === 0)
    return Wa(n);
  const i = { x: n }, c = { reps: s };
  return W.runKernel(Cu, i, c);
}
const Vi = /* @__PURE__ */ B({ broadcastTo_: ON });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FN(t) {
  const n = { x: C(t, "x", "ceil", "float32") };
  return W.runKernel(Cl, n);
}
const MN = /* @__PURE__ */ B({ ceil_: FN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ru(t, e, n) {
  fr(t), n = n || ku(e);
  const r = { shape: t, value: e, dtype: n };
  return W.runKernel(bm, {}, r);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PN(t, e, n) {
  const r = C(t, "x", "clipByValue");
  if (A(e <= n, () => `Error in clip: min (${e}) must be less than or equal to max (${n}).`), e === n)
    return Ru(r.shape, e, r.dtype);
  const a = { x: r }, s = { clipValueMin: e, clipValueMax: n };
  return W.runKernel(Tu, a, s);
}
const Z1 = /* @__PURE__ */ B({ clipByValue_: PN });
function BN(t) {
  return yn(
    t,
    0
    /* axis */
  );
}
const LN = /* @__PURE__ */ B({ concat1d_: BN });
function WN(t, e) {
  return yn(t, e);
}
const zN = /* @__PURE__ */ B({ concat2d_: WN });
function VN(t, e) {
  return yn(t, e);
}
const HN = /* @__PURE__ */ B({ concat3d_: VN });
function jN(t, e) {
  return yn(t, e);
}
const UN = /* @__PURE__ */ B({ concat4d_: jN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GN(t, e, n, r, a = "NHWC", s = [1, 1], o) {
  const i = C(t, "x", "conv2d", "float32"), c = C(e, "filter", "conv2d", "float32");
  let l = i, u = !1;
  i.rank === 3 && (u = !0, l = ae(i, [1, i.shape[0], i.shape[1], i.shape[2]])), A(l.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${l.rank}.`), A(c.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`), Hr("conv2d", r, o);
  const d = a === "NHWC" ? l.shape[3] : l.shape[1];
  A(d === c.shape[2], () => `Error in conv2d: depth of input (${d}) must match input depth for filter ${c.shape[2]}.`), A(Er(n, s), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`), A(To(s), () => "Error in conv2D: Dilated rates should be larger than 0."), A(To(n), () => "Error in conv2D: Strides should be larger than 0.");
  const f = { x: l, filter: c }, p = { strides: n, pad: r, dataFormat: a, dilations: s, dimRoundingMode: o }, h = W.runKernel(Nl, f, p);
  return u ? ae(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
}
const ff = /* @__PURE__ */ B({ conv2d_: GN });
function qN(t, e, n, r, a = "NWC", s = 1, o) {
  const i = C(t, "x", "conv1d"), c = C(e, "filter", "conv1d");
  let l = i, u = !1;
  i.rank === 2 && (u = !0, l = ae(i, [1, i.shape[0], i.shape[1]])), A(l.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${l.rank}.`), A(c.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`), Hr("conv1d", r, o), A(l.shape[2] === c.shape[1], () => `Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`), A(Er(n, s), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`), A(To(s), () => "Error in conv1D: Dilated rates should be larger than 0."), A(To(n), () => "Error in conv1D: Stride should be larger than 0."), A(a === "NWC", () => `Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);
  const d = ae(c, [1, c.shape[0], c.shape[1], c.shape[2]]), f = ae(l, [l.shape[0], 1, l.shape[1], l.shape[2]]), g = ff(f, d, [1, n], r, "NHWC", [1, s], o);
  return u ? ae(g, [g.shape[2], g.shape[3]]) : ae(g, [g.shape[0], g.shape[2], g.shape[3]]);
}
const KN = /* @__PURE__ */ B({ conv1d_: qN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XN(t, e, n, r, a, s = "NHWC", o) {
  A(t.length === e.rank, () => `Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);
  let i = t, c = e, l = !1;
  e.rank === 3 && (l = !0, c = ae(e, [1, e.shape[0], e.shape[1], e.shape[2]]), i = [1, t[0], t[1], t[2]]), A(i.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`), A(c.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`), A(n.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);
  const u = s === "NHWC" ? i[3] : i[1], d = s === "NHWC" ? c.shape[3] : c.shape[1];
  A(u === n.shape[2], () => `Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`), A(d === n.shape[3], () => `Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`), Hr("conv2dDerInput", a, o);
  const f = { dy: c, filter: n }, p = { strides: r, pad: a, dataFormat: s, dimRoundingMode: o, inputShape: i }, h = W.runKernel(Al, f, p);
  return l ? ae(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
}
const J1 = /* @__PURE__ */ B({ conv2DBackpropInput_: XN });
function YN(t, e, n, r, a, s) {
  const o = C(t, "x", "conv2dTranspose"), i = C(e, "filter", "conv2dTranspose");
  return J1(n, o, i, r, a, "NHWC", s);
}
const ZN = /* @__PURE__ */ B({ conv2dTranspose_: YN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JN(t, e, n, r, a = "NDHWC", s = [1, 1, 1]) {
  const o = C(t, "x", "conv3d"), i = C(e, "filter", "conv3d");
  let c = o, l = !1;
  o.rank === 4 && (l = !0, c = ae(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), A(c.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${c.rank}.`), A(i.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`), A(c.shape[4] === i.shape[3], () => `Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${i.shape[3]}.`), A(Er(n, s), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`), A(a === "NDHWC", () => `Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`), A(To(s), () => "Error in conv3D: Dilated rates should be larger than 0."), A(To(n), () => "Error in conv3D: Strides should be larger than 0.");
  const u = { x: c, filter: i }, d = { strides: n, pad: r, dataFormat: a, dilations: s }, f = W.runKernel(Rl, u, d);
  return l ? ae(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]) : f;
}
const QN = /* @__PURE__ */ B({ conv3d_: JN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eA(t, e, n, r, a) {
  A(t.length === e.rank, () => `Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);
  let s = t, o = e, i = !1;
  e.rank === 4 && (i = !0, o = ae(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]), s = [1, t[0], t[1], t[2], t[3]]);
  const c = s[4], l = o.shape[4];
  A(s.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`), A(o.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`), A(n.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`), A(c === n.shape[3], () => `Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[3]}.`), A(l === n.shape[4], () => `Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);
  const u = { dy: o, filter: n }, d = { pad: a, strides: r, inputShape: s }, f = W.runKernel($l, u, d);
  return i ? ae(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]) : f;
}
const tA = /* @__PURE__ */ B({ conv3DBackpropInput_: eA });
function nA(t, e, n, r, a) {
  const s = C(t, "x", "conv3dTranspose"), o = C(e, "filter", "conv3dTranspose");
  return tA(n, s, o, r, a);
}
const rA = /* @__PURE__ */ B({ conv3dTranspose_: nA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aA(t) {
  const n = { x: C(t, "x", "cos", "float32") };
  return W.runKernel(Dl, n);
}
const sA = /* @__PURE__ */ B({ cos_: aA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oA(t) {
  const n = { x: C(t, "x", "cosh", "float32") };
  return W.runKernel(Ol, n);
}
const iA = /* @__PURE__ */ B({ cosh_: oA });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uA(t, e = 0, n = !1, r = !1) {
  const s = { x: C(t, "x", "cumprod") }, o = { axis: e, exclusive: n, reverse: r };
  return W.runKernel(Fl, s, o);
}
const cA = /* @__PURE__ */ B({ cumprod_: uA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lA(t, e = 0, n = !1, r = !1) {
  const s = { x: C(t, "x", "cumsum") }, o = { axis: e, exclusive: n, reverse: r };
  return W.runKernel(Ml, s, o);
}
const dA = /* @__PURE__ */ B({ cumsum_: lA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fA(t, e, n, r = !1) {
  const a = C(t, "x", "denseBincount"), s = C(e, "weights", "denseBincount");
  A(a.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${a.dtype}`), A(a.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`), A(n >= 0, () => `size must be non-negative, but got ${n}.`), A(s.size === a.size || s.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`);
  const o = { x: a, weights: s }, i = { size: n, binaryOutput: r };
  return W.runKernel(mm, o, i);
}
const pA = /* @__PURE__ */ B({ denseBincount_: fA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hA(t, e, n = "NHWC") {
  const r = C(t, "x", "depthToSpace", "float32"), a = n === "NHWC" ? r.shape[1] : r.shape[2], s = n === "NHWC" ? r.shape[2] : r.shape[3], o = n === "NHWC" ? r.shape[3] : r.shape[1];
  A(e > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${e}`), A(a * e >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${a} and ${e}  for depthToSpace with input shape
    ${r.shape}`), A(s * e >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${r.shape}`), A(o % (e * e) === 0, () => `Dimension size must be evenly divisible by ${e * e} but is ${o} for depthToSpace with input shape ${r.shape}`);
  const i = { x: r }, c = { blockSize: e, dataFormat: n };
  return W.runKernel(Bl, i, c);
}
const mA = /* @__PURE__ */ B({ depthToSpace_: hA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gA(t, e, n, r, a = "NHWC", s = [1, 1], o) {
  const i = C(t, "x", "depthwiseConv2d", "float32"), c = C(e, "filter", "depthwiseConv2d", "float32");
  let l = i, u = !1;
  i.rank === 3 && (u = !0, l = ae(i, [1, i.shape[0], i.shape[1], i.shape[2]])), A(l.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`), A(c.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);
  const d = a === "NHWC" ? l.shape[3] : l.shape[1];
  A(d === c.shape[2], () => `Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${c.shape[2]}.`), Hr("depthwiseConv2d", r, o);
  const f = { x: l, filter: c }, p = { strides: n, pad: r, dataFormat: a, dilations: s, dimRoundingMode: o }, h = W.runKernel(Ll, f, p);
  return u ? ae(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
}
const Xm = /* @__PURE__ */ B({ depthwiseConv2d_: gA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yA(t) {
  const n = { x: C(t, "x", "diag") };
  return W.runKernel(gm, n);
}
const vA = /* @__PURE__ */ B({ diag_: yA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bA(t, e, n, r, a = [1, 1], s = "NHWC") {
  const o = C(t, "x", "dilation2d"), i = C(e, "filter", "dilation2d");
  A(o.rank === 3 || o.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`), A(i.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`), A(s === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);
  let c = o, l = !1;
  o.rank === 3 && (c = ae(o, [1, o.shape[0], o.shape[1], o.shape[2]]), l = !0), A(c.shape[3] === i.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${i.shape[2]}`);
  const u = { x: c, filter: i }, d = { strides: n, pad: r, dilations: a }, f = W.runKernel(Wl, u, d);
  return l ? ae(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
}
const wA = /* @__PURE__ */ B({ dilation2d_: bA });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zc(t, e) {
  const n = t.length, r = [];
  for (let a = 0; a < n; a++) {
    const s = n - 1 - a, o = t[s] || 1;
    (e[e.length - 1 - a] || 1) > 1 && o === 1 && r.unshift(s);
  }
  return r;
}
function SA(t, e) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const a = t[t.length - r - 1], s = e.length - r - 1, o = e[s];
    (a == null || a === 1 && o > 1) && n.unshift(s);
  }
  return n;
}
function At(t, e) {
  const n = Math.max(t.length, e.length), r = new Array(n);
  for (let a = 0; a < n; a++) {
    let s = t[t.length - a - 1];
    s == null && (s = 1);
    let o = e[e.length - a - 1];
    if (o == null && (o = 1), s === 1)
      r[n - a - 1] = o;
    else if (o === 1)
      r[n - a - 1] = s;
    else if (s !== o) {
      const i = `Operands could not be broadcast together with shapes ${t} and ${e}.`;
      throw Error(i);
    } else
      r[n - a - 1] = s;
  }
  return r;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _A(t, e) {
  let n = C(t, "a", "equal", "string_or_numeric"), r = C(e, "b", "equal", "string_or_numeric");
  [n, r] = Kt(n, r), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(jl, a);
}
const Q1 = /* @__PURE__ */ B({ equal_: _A });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xA(t, e, n) {
  const r = C(e, "a", "where"), a = C(n, "b", "where"), s = C(t, "condition", "where", "bool"), o = At(At(s.shape, r.shape), a.shape), i = Vi(s, o), c = Vi(r, o), l = Vi(a, o), u = {
    condition: i,
    t: c,
    e: l
  };
  return W.runKernel(Rm, u);
}
const za = /* @__PURE__ */ B({ where_: xA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IA(t) {
  const n = { x: C(t, "x", "zerosLike") };
  return W.runKernel(jm, n);
}
const lr = /* @__PURE__ */ B({ zerosLike_: IA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kA(t, e) {
  let n = C(t, "a", "div"), r = C(e, "b", "div");
  [n, r] = Kt(n, r);
  const a = Ze(n, r), s = lr(a), o = Q1(r, s);
  return za(o, s, a);
}
const EA = /* @__PURE__ */ B({ divNoNan_: kA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TA(t, e) {
  const n = C(t, "t1", "dot"), r = C(e, "t2", "dot");
  A((n.rank === 1 || n.rank === 2) && (r.rank === 1 || r.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);
  const a = n.rank === 1 ? n.size : n.shape[1], s = r.rank === 1 ? r.size : r.shape[0];
  if (A(a === s, () => `Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`), n.rank === 1 && r.rank === 1) {
    const o = ae(n, [1, -1]), i = ae(r, [-1, 1]), c = wt(o, i);
    return ae(c, []);
  } else if (n.rank === 1 && r.rank === 2) {
    const o = ae(n, [1, -1]), i = ae(r, [r.shape[0], r.shape[1]]), c = wt(o, i);
    return ae(c, [c.size]);
  } else if (n.rank === 2 && r.rank === 1) {
    const o = ae(r, [-1, 1]), i = wt(n, o);
    return ae(i, [i.size]);
  } else {
    const o = ae(r, [r.shape[0], r.shape[1]]);
    return wt(n, o);
  }
}
const CA = /* @__PURE__ */ B({ dot_: TA });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NA(t, ...e) {
  const n = e.map((a, s) => C(a, `tensors${s}`, "einsum")), r = { equation: t };
  return W.runKernel(n1, n, r);
}
const po = /* @__PURE__ */ B({ einsum_: NA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AA(t) {
  const n = { x: C(t, "x", "elu", "float32") };
  return W.runKernel(Vl, n);
}
const ew = /* @__PURE__ */ B({ elu_: AA });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RA(t, e) {
  const n = C(t, "x", "ensureShape", "string_or_numeric");
  if (!sT(n.shape, e))
    throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);
  return t;
}
const $A = /* @__PURE__ */ B({ ensureShape_: RA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DA(t) {
  let e = C(t, "x", "erf");
  A(e.dtype === "int32" || e.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), e.dtype === "int32" && (e = zt(e, "float32"));
  const n = { x: e };
  return W.runKernel(Hl, n);
}
const OA = /* @__PURE__ */ B({ erf_: DA });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tw(t, e) {
  for (let n = 0; n < t.length; ++n)
    if (t[t.length - n - 1] !== e - 1 - n)
      return !1;
  return !0;
}
function FA(t, e, n) {
  const r = t.length + e.length, a = [];
  let s = 0, o = 0;
  for (let i = 0; i < r; i++)
    n.indexOf(i) === -1 ? a.push(t[s++]) : a.push(e[o++]);
  return a;
}
function On(t, e) {
  const n = [], r = t.length;
  for (let s = 0; s < r; s++)
    e.indexOf(s) === -1 && n.push(t[s]);
  const a = e.map((s) => t[s]);
  return [n, a];
}
function vn(t, e) {
  const n = e.map((r) => 1);
  return FA(t, n, e);
}
function Fn(t, e, n) {
  A(tw(e, n), () => `${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`);
}
function pr(t, e) {
  if (tw(t, e))
    return null;
  const n = [];
  for (let r = 0; r < e; ++r)
    t.indexOf(r) === -1 && n.push(r);
  return t.forEach((r) => n.push(r)), n;
}
function pf(t) {
  return t.map((e, n) => [n, e]).sort((e, n) => e[1] - n[1]).map((e) => e[0]);
}
function Mn(t, e) {
  const n = [];
  for (let r = e - t; r < e; ++r)
    n.push(r);
  return n;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MA(t, e = null, n = !1) {
  const a = { x: C(t, "x", "max") }, s = { reductionIndices: e, keepDims: n };
  return W.runKernel(hd, a, s);
}
const So = /* @__PURE__ */ B({ max_: MA });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PA(t, e = null, n = !1) {
  const a = { x: C(t, "x", "min") }, s = { axis: e, keepDims: n };
  return W.runKernel(vd, a, s);
}
const th = /* @__PURE__ */ B({ min_: PA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BA(t, e) {
  let n = C(t, "base", "pow"), r = C(e, "exp", "pow");
  [n, r] = Kt(n, r);
  const a = { a: n, b: r };
  return W.runKernel(Ad, a);
}
const iu = /* @__PURE__ */ B({ pow_: BA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ut(t, e) {
  if ((kr(t) && e !== "string" || Array.isArray(t)) && e !== "complex64")
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if (e === "string" && kr(t) && !(t instanceof Uint8Array))
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Za(t, [], [], e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LA(t) {
  const n = { x: C(t, "x", "sqrt", "float32") };
  return W.runKernel(Yd, n);
}
const ga = /* @__PURE__ */ B({ sqrt_: LA });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WA(t) {
  const e = C(t, "x", "square"), n = {};
  return W.runKernel("Square", { x: e }, n);
}
const Pr = /* @__PURE__ */ B({ square_: WA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zA(t, e = null, n = !1) {
  let r = C(t, "x", "sum");
  r.dtype === "bool" && (r = zt(r, "int32"));
  const a = { x: r }, s = { axis: e, keepDims: n };
  return W.runKernel(Zd, a, s);
}
const Dt = /* @__PURE__ */ B({ sum_: zA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VA(t, e = "euclidean", n = null, r = !1) {
  t = C(t, "x", "norm");
  const a = nw(t, e, n);
  let s = a.shape;
  if (r) {
    const o = Vt(n, t.shape);
    s = vn(a.shape, o);
  }
  return ae(a, s);
}
function nw(t, e, n = null) {
  if (t.rank === 0)
    return cr(t);
  if (t.rank !== 1 && n === null)
    return nw(ae(t, [-1]), e, n);
  if (t.rank === 1 || typeof n == "number" || Array.isArray(n) && n.length === 1) {
    if (e === 1)
      return Dt(cr(t), n);
    if (e === 1 / 0)
      return So(cr(t), n);
    if (e === -1 / 0)
      return th(cr(t), n);
    if (e === "euclidean" || e === 2)
      return ga(Dt(iu(cr(t), ut(2, "int32")), n));
    throw new Error(`Error in norm: invalid ord value: ${e}`);
  }
  if (Array.isArray(n) && n.length === 2) {
    if (e === 1)
      return So(Dt(cr(t), n[0]), n[1] - 1);
    if (e === 1 / 0)
      return So(Dt(cr(t), n[1]), n[0]);
    if (e === -1 / 0)
      return th(Dt(cr(t), n[1]), n[0]);
    if (e === "fro" || e === "euclidean")
      return ga(Dt(Pr(t), n));
    throw new Error(`Error in norm: invalid ord value: ${e}`);
  }
  throw new Error(`Error in norm: invalid axis: ${n}`);
}
const hf = /* @__PURE__ */ B({ norm_: VA });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HA(t, e = null, n = !1) {
  return hf(t, "euclidean", e, n);
}
const jA = /* @__PURE__ */ B({ euclideanNorm_: HA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UA(t) {
  const n = { x: C(t, "x", "exp") };
  return W.runKernel(Ul, n);
}
const ya = /* @__PURE__ */ B({ exp_: UA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GA(t, e = 0) {
  const n = C(t, "x", "expandDims", "string_or_numeric");
  A(e <= n.rank, () => "Axis must be <= rank of the tensor");
  const r = { input: n }, a = { dim: e };
  return W.runKernel(vm, r, a);
}
const Kr = /* @__PURE__ */ B({ expandDims_: GA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qA(t) {
  const n = { x: C(t, "x", "expm1") };
  return W.runKernel(Gl, n);
}
const KA = /* @__PURE__ */ B({ expm1_: qA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XA(t, e) {
  const n = C(t, "x", "tile", "string_or_numeric");
  A(n.rank === e.length, () => `Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);
  const r = { x: n }, a = { reps: e };
  return W.runKernel(Cu, r, a);
}
const Hi = /* @__PURE__ */ B({ tile_: XA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YA(t, e, n, r = "float32") {
  e == null && (e = t);
  const a = Qe([t, e], r), s = t <= e ? t : e;
  for (let i = 0; i < s; ++i)
    a.set(1, i, i);
  const o = ae(a.toTensor(), [t, e]);
  if (n == null)
    return o;
  if (n.length === 1)
    return Hi(Kr(o, 0), [n[0], 1, 1]);
  if (n.length === 2)
    return Hi(Kr(Kr(o, 0), 0), [n[0], n[1], 1, 1]);
  if (n.length === 3)
    return Hi(Kr(Kr(Kr(o, 0), 0), 0), [
      n[0],
      n[1],
      n[2],
      1,
      1
    ]);
  throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`);
}
const rw = /* @__PURE__ */ B({ eye_: YA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZA(t) {
  const n = { x: C(t, "x", "floor", "float32") };
  return W.runKernel(Kl, n);
}
const aw = /* @__PURE__ */ B({ floor_: ZA });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JA(t, e, n = 0, r = 0) {
  const a = C(t, "x", "gather"), s = C(e, "indices", "gather", "int32"), o = { x: a, indices: s }, i = { axis: n, batchDims: r };
  return W.runKernel(wm, o, i);
}
const sw = /* @__PURE__ */ B({ gather_: JA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QA(t, e) {
  let n = C(t, "a", "greater", "string_or_numeric"), r = C(e, "b", "greater", "string_or_numeric");
  [n, r] = Kt(n, r), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(Jl, a);
}
const mf = /* @__PURE__ */ B({ greater_: QA });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e4(t, e) {
  let n = C(t, "a", "greaterEqual", "string_or_numeric"), r = C(e, "b", "greaterEqual", "string_or_numeric");
  [n, r] = Kt(n, r), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(Ql, a);
}
const ow = /* @__PURE__ */ B({ greaterEqual_: e4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t4(t) {
  const n = { input: C(t, "input", "imag") };
  return W.runKernel(s1, n);
}
const gf = /* @__PURE__ */ B({ imag_: t4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function n4(t) {
  const n = { x: C(t, "x", "isFinite") };
  return W.runKernel(td, n);
}
const r4 = /* @__PURE__ */ B({ isFinite_: n4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a4(t) {
  const n = { x: C(t, "x", "isInf") };
  return W.runKernel(nd, n);
}
const s4 = /* @__PURE__ */ B({ isInf_: a4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o4(t) {
  const n = { x: C(t, "x", "isNaN") };
  return W.runKernel(rd, n);
}
const i4 = /* @__PURE__ */ B({ isNaN_: o4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u4(t, e = 0.2) {
  const r = { x: C(t, "x", "leakyRelu") }, a = { alpha: e };
  return W.runKernel(ad, r, a);
}
const iw = /* @__PURE__ */ B({ leakyRelu_: u4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c4(t, e) {
  let n = C(t, "a", "less", "string_or_numeric"), r = C(e, "b", "less", "string_or_numeric");
  [n, r] = Kt(n, r), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(sd, a);
}
const nh = /* @__PURE__ */ B({ less_: c4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l4(t, e) {
  let n = C(t, "a", "lessEqual", "string_or_numeric"), r = C(e, "b", "lessEqual", "string_or_numeric");
  [n, r] = Kt(n, r), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(od, a);
}
const Ym = /* @__PURE__ */ B({ lessEqual_: l4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function d4(t, e, n) {
  if (n <= 0)
    throw new Error("The number of values should be positive.");
  const r = { start: t, stop: e, num: n };
  return W.runKernel(id, {}, r);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f4(t, e = 5, n = 1, r = 1, a = 0.5) {
  const s = C(t, "x", "localResponseNormalization");
  A(s.rank === 4 || s.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`), A(Ji(e), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);
  let o = s, i = !1;
  s.rank === 3 && (i = !0, o = ae(s, [1, s.shape[0], s.shape[1], s.shape[2]]));
  const c = { x: o }, l = { depthRadius: e, bias: n, alpha: r, beta: a }, u = W.runKernel(pd, c, l);
  return i ? ae(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
}
const p4 = /* @__PURE__ */ B({ localResponseNormalization_: f4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h4(t) {
  const n = { x: C(t, "x", "log", "float32") };
  return W.runKernel(ud, n);
}
const uu = /* @__PURE__ */ B({ log_: h4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function m4(t) {
  const n = { x: C(t, "x", "log1p") };
  return W.runKernel(cd, n);
}
const uw = /* @__PURE__ */ B({ log1p_: m4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g4(t, e) {
  A(zp(t), () => "The f passed in variableGrads(f) must be a function"), A(e == null || Array.isArray(e) && e.every((l) => l instanceof Pc), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
  const n = e != null;
  if (!n) {
    e = [];
    for (const l in W.registeredVariables)
      e.push(W.registeredVariables[l]);
  }
  const r = n ? e.filter((l) => !l.trainable) : null, a = e.length;
  e = e.filter((l) => l.trainable), A(e.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);
  const s = !0, { value: o, grads: i } = W.gradients(t, e, null, s);
  A(i.some((l) => l != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), A(o.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);
  const c = {};
  return e.forEach((l, u) => {
    i[u] != null && (c[l.name] = i[u]);
  }), r?.forEach((l) => c[l.name] = null), { value: o, grads: c };
}
function va(t) {
  return W.customGrad(t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function y4(t) {
  const n = { x: C(t, "x", "neg") };
  return W.runKernel(Im, n);
}
const Jr = /* @__PURE__ */ B({ neg_: y4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function v4(t) {
  const n = { x: C(t, "x", "softplus") };
  return W.runKernel(Xd, n);
}
const cw = /* @__PURE__ */ B({ softplus_: v4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function b4(t) {
  const e = C(t, "x", "logSigmoid");
  return va((r) => ({ value: Jr(cw(Jr(r))), gradFunc: (o) => he(o, Cs(Jr(r))) }))(e);
}
const w4 = /* @__PURE__ */ B({ logSigmoid_: b4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function S4(t, e) {
  let n = C(t, "a", "sub"), r = C(e, "b", "sub");
  [n, r] = Kt(n, r);
  const a = { a: n, b: r };
  return W.runKernel(rf, a);
}
const Ke = /* @__PURE__ */ B({ sub_: S4 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _4(t, e = -1) {
  const n = C(t, "logits", "logSoftmax");
  if (e === -1 && (e = n.rank - 1), e !== n.rank - 1)
    throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);
  return va((a, s) => {
    const i = So(a, e, !0), c = Ke(a, i), l = Ke(zt(c, "float32"), uu(Dt(ya(c), e, !0)));
    return s([l]), { value: l, gradFunc: (d, f) => {
      const [p] = f, h = !0, m = ya(p);
      return Ke(d, he(Dt(d, e, h), m));
    } };
  })(n);
}
const x4 = /* @__PURE__ */ B({ logSoftmax_: _4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I4(t, e = null, n = !1) {
  const r = C(t, "x", "logSumExp"), a = Vt(e, r.shape), s = So(
    r,
    a,
    !0
    /* keepDims */
  ), o = Ke(r, s), i = ya(o), c = Dt(i, a), l = uu(c), u = Ae(ae(s, l.shape), l);
  if (n) {
    const d = vn(u.shape, a);
    return ae(u, d);
  }
  return u;
}
const lw = /* @__PURE__ */ B({ logSumExp_: I4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k4(t, e) {
  const n = C(t, "a", "logicalAnd", "bool"), r = C(e, "b", "logicalAnd", "bool");
  At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(ld, a);
}
const Vc = /* @__PURE__ */ B({ logicalAnd_: k4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E4(t) {
  const n = { x: C(t, "x", "logicalNot", "bool") };
  return W.runKernel(dd, n);
}
const dw = /* @__PURE__ */ B({ logicalNot_: E4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T4(t, e) {
  const n = C(t, "a", "logicalOr", "bool"), r = C(e, "b", "logicalOr", "bool");
  At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(fd, a);
}
const fw = /* @__PURE__ */ B({ logicalOr_: T4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function C4(t, e) {
  const n = C(t, "a", "logicalXor", "bool"), r = C(e, "b", "logicalXor", "bool");
  return At(n.shape, r.shape), Vc(fw(t, e), dw(Vc(t, e)));
}
const N4 = /* @__PURE__ */ B({ logicalXor_: C4 });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ic = 2147483648;
function A4(t, e, n = "left") {
  const r = C(t, "sortedSequence", "searchSorted"), a = C(e, "values", "searchSorted"), s = r.shape[r.shape.length - 1], o = a.shape[a.shape.length - 1], i = ae(r, [-1, s]), c = ae(a, [-1, o]);
  if (i.rank < 2)
    throw new Error("Sorted input argument must be at least 2-dimensional");
  if (i.shape[0] !== c.shape[0])
    throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
  if (Y(c.shape) >= ic)
    throw new Error(`values tensor size must less than ${ic}`);
  if (i.shape[1] >= ic)
    throw new Error(`trailing dim_size must less than ${ic} for int32 output type, was ${i.shape[1]}`);
  const l = {
    sortedSequence: i,
    values: c
  }, u = { side: n };
  return W.runKernel(Hd, l, u);
}
const Zm = /* @__PURE__ */ B({ searchSorted_: A4 });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R4(t, e) {
  return Zm(t, e, "left");
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $4(t, e, n, r, a) {
  const s = C(t, "x", "maxPool"), o = 1;
  let i = s, c = !1;
  s.rank === 3 && (c = !0, i = ae(s, [1, s.shape[0], s.shape[1], s.shape[2]])), A(i.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${i.rank}.`), A(Er(n, o), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`), Hr("maxPool", r, a);
  const l = { x: i }, u = { filterSize: e, strides: n, pad: r, dimRoundingMode: a }, d = W.runKernel(gd, l, u);
  return c ? ae(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const pw = /* @__PURE__ */ B({ maxPool_: $4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D4(t, e = [1, 1, 1], n, r, a, s = "NDHWC") {
  const o = C(t, "x", "maxPool3d");
  let i = o, c = !1;
  o.rank === 4 && (c = !0, i = ae(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), A(i.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`), A(s === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`), Hr("maxPool3d", r, a);
  const l = { x: i }, u = { filterSize: e, strides: n, pad: r, dimRoundingMode: a, dataFormat: s }, d = W.runKernel(_m, l, u);
  return c ? ae(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
}
const O4 = /* @__PURE__ */ B({ maxPool3d_: D4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F4(t, e, n, r, a = !1) {
  const o = { x: C(t, "x", "maxPoolWithArgmax") }, i = { filterSize: e, strides: n, pad: r, includeBatchInIndex: a }, c = W.runKernel(xm, o, i);
  return { result: c[0], indexes: c[1] };
}
const M4 = /* @__PURE__ */ B({ maxPoolWithArgmax_: F4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function P4(t, e) {
  let n = C(t, "a", "maximum"), r = C(e, "b", "maximum");
  [n, r] = Kt(n, r), n.dtype === "bool" && (n = zt(n, "int32"), r = zt(r, "int32")), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(md, a);
}
const hw = /* @__PURE__ */ B({ maximum_: P4 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B4(t, e = null, n = !1) {
  const a = { x: C(t, "x", "mean") }, s = { axis: e, keepDims: n };
  return W.runKernel(yd, a, s);
}
const Hc = /* @__PURE__ */ B({ mean_: B4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Co(t, e = "float32") {
  if (fr(t), e === "complex64") {
    const r = Co(t, "float32"), a = Co(t, "float32");
    return ja(r, a);
  }
  const n = In(Y(t), e);
  return W.makeTensor(n, t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ks(t, e = "float32") {
  if (fr(t), e === "complex64") {
    const r = ks(t, "float32"), a = Co(t, "float32");
    return ja(r, a);
  }
  const n = sm(Y(t), e);
  return W.makeTensor(n, t, e);
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function L4(t, e, { indexing: n = "xy" } = {}) {
  if (n !== "xy" && n !== "ij")
    throw new TypeError(`${n} is not a valid third argument to meshgrid`);
  if (t === void 0)
    return [];
  let r = C(t, "x", "meshgrid", t instanceof en ? t.dtype : "float32");
  if (e === void 0)
    return [r];
  let a = C(e, "y", "meshgrid", e instanceof en ? e.dtype : "float32");
  const s = Y(r.shape), o = Y(a.shape);
  return n === "xy" ? (r = ae(r, [1, -1]), a = ae(a, [-1, 1]), [
    wt(ks([o, 1], r.dtype), r),
    wt(a, ks([1, s], a.dtype))
  ]) : (r = ae(r, [-1, 1]), a = ae(a, [1, -1]), [
    wt(r, ks([1, o], r.dtype)),
    wt(ks([s, 1], a.dtype), a)
  ]);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function W4(t, e) {
  let n = C(t, "a", "minimum"), r = C(e, "b", "minimum");
  [n, r] = Kt(n, r), n.dtype === "bool" && (n = zt(n, "int32"), r = zt(r, "int32")), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(bd, a);
}
const jc = /* @__PURE__ */ B({ minimum_: W4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z4(t, e, n) {
  A(n === "reflect" || n === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);
  const r = C(t, "x", "mirrorPad");
  if (r.rank === 0)
    throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
  A(e.length === r.rank, () => `Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);
  const a = n === "reflect" ? 1 : 0;
  for (let i = 0; i < r.rank; i++)
    A(e[i].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), A(e[i][0] >= 0 && e[i][0] <= r.shape[i] - a && e[i][1] >= 0 && e[i][1] <= r.shape[i] - a, () => `Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i] - a} or less than 0 for input of shape ${r.shape}`);
  const s = { paddings: e, mode: n }, o = { x: r };
  return W.runKernel(wd, o, s);
}
const V4 = /* @__PURE__ */ B({ mirrorPad_: z4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H4(t, e) {
  let n = C(t, "a", "mod"), r = C(e, "b", "mod");
  [n, r] = Kt(n, r);
  const a = { a: n, b: r };
  return W.runKernel(Sd, a);
}
const j4 = /* @__PURE__ */ B({ mod_: H4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function U4(t, e = null, n = !1) {
  t = C(t, "x", "moments");
  const r = Vt(e, t.shape), a = Hc(t, r, n);
  let s = a.shape;
  n || (s = vn(a.shape, r));
  const o = Pr(Ke(zt(t, "float32"), ae(a, s))), i = Hc(o, r, n);
  return { mean: a, variance: i };
}
const G4 = /* @__PURE__ */ B({ moments_: U4 });
function q4(t, e, n, r) {
  const a = C(e, "data", "multiRNNCell"), s = Bc(n, "c", "multiRNNCell"), o = Bc(r, "h", "multiRNNCell");
  let i = a;
  const c = [];
  for (let d = 0; d < t.length; d++) {
    const f = t[d](i, s[d], o[d]);
    c.push(f[0]), c.push(f[1]), i = f[1];
  }
  const l = [], u = [];
  for (let d = 0; d < c.length; d += 2)
    l.push(c[d]), u.push(c[d + 1]);
  return [l, u];
}
const K4 = /* @__PURE__ */ B({ multiRNNCell_: q4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function X4(t, e, n, r = !1) {
  const a = C(t, "logits", "multinomial"), s = a.size, o = a.rank;
  if (s < 2)
    throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);
  if (o > 2)
    throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);
  n = n || Math.random();
  const c = { logits: o === 1 ? ae(a, [1, -1]) : a }, l = { numSamples: e, seed: n, normalized: r }, u = W.runKernel(_d, c, l);
  return o === 1 ? ae(u, [u.size]) : u;
}
const Y4 = /* @__PURE__ */ B({ multinomial_: X4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Z4(t, e) {
  let n = C(t, "a", "notEqual", "string_or_numeric"), r = C(e, "b", "notEqual", "string_or_numeric");
  [n, r] = Kt(n, r), At(n.shape, r.shape);
  const a = { a: n, b: r };
  return W.runKernel(Id, a);
}
const mw = /* @__PURE__ */ B({ notEqual_: Z4 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J4(t, e, n = 1, r = 0, a = "int32") {
  if (e < 2)
    throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);
  const o = { indices: C(t, "indices", "oneHot", "int32") }, i = { dtype: a, depth: e, onValue: n, offValue: r };
  return W.runKernel(Cd, o, i);
}
const Q4 = /* @__PURE__ */ B({ oneHot_: J4 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eR(t) {
  const n = { x: C(t, "x", "onesLike") };
  return W.runKernel(km, n);
}
const tR = /* @__PURE__ */ B({ onesLike_: eR });
function nR(t, e) {
  const n = C(t, "v1", "outerProduct"), r = C(e, "v2", "outerProduct");
  A(n.rank === 1 && r.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);
  const a = ae(n, [-1, 1]), s = ae(r, [1, -1]);
  return wt(a, s);
}
const rR = /* @__PURE__ */ B({ outerProduct_: nR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aR(t, e, n = 0) {
  const r = C(t, "x", "pad");
  if (r.rank === 0)
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  const a = { paddings: e, constantValue: n }, s = { x: r };
  return W.runKernel(Nd, s, a);
}
const $u = /* @__PURE__ */ B({ pad_: aR });
function sR(t, e, n = 0) {
  return A(e.length === 2, () => "Invalid number of paddings. Must be length of 2."), $u(t, [e], n);
}
const oR = /* @__PURE__ */ B({ pad1d_: sR });
function iR(t, e, n = 0) {
  return A(e.length === 2 && e[0].length === 2 && e[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), $u(t, e, n);
}
const uR = /* @__PURE__ */ B({ pad2d_: iR });
function cR(t, e, n = 0) {
  return A(e.length === 3 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), $u(t, e, n);
}
const lR = /* @__PURE__ */ B({ pad3d_: cR });
function dR(t, e, n = 0) {
  return A(e.length === 4 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2 && e[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), $u(t, e, n);
}
const fR = /* @__PURE__ */ B({ pad4d_: dR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pR(t, e, n) {
  const r = C(t, "x", "spaceToBatchND");
  A(r.rank >= 1 + e.length, () => `input rank ${r.rank} should be > than [blockShape] ${e.length}`), A(n.length === e.length, () => `paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`), A(r.shape.reduce((o, i, c) => c > 0 && c <= e.length ? o && (i + n[c - 1][0] + n[c - 1][1]) % e[c - 1] === 0 : o, !0), () => `input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);
  const a = { x: r }, s = { blockShape: e, paddings: n };
  return W.runKernel(Dm, a, s);
}
const gw = /* @__PURE__ */ B({ spaceToBatchND_: pR });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hR(t, e, n, r, a, s, o) {
  a == null && (a = [1, 1]), s == null && (s = 1), r === 0 && (r = "valid");
  const i = C(t, "x", "maxPool");
  let c = i, l = !1;
  i.rank === 3 && (l = !0, c = ae(i, [1, i.shape[0], i.shape[1], i.shape[2]])), A(Er(s, a), () => `Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);
  const u = Vr(c.shape, e, s, a, r), d = [u.dilationHeight, u.dilationWidth];
  let f;
  r === "same" ? f = gR([u.filterHeight, u.filterWidth], d) : f = [[0, 0], [0, 0]];
  const p = d[0] === 1 && d[1] === 1, [h, m] = mR([u.inHeight, u.inWidth], d, f), g = p ? r : "valid", v = p ? c : gw(c, d, h), w = (n === "avg" ? () => K1(v, e, s, g, o) : () => pw(v, e, s, g, o))(), S = p ? w : X1(w, d, m);
  return l ? ae(S, [S.shape[1], S.shape[2], S.shape[3]]) : S;
}
function mR(t, e, n) {
  const r = n.map((u) => u[0]), a = n.map((u) => u[1]), s = t.concat(r, a), o = e.map((u, d) => (u - s[d] % u) % u), i = a.map((u, d) => u + o[d]), c = e.map((u, d) => [r[d], i[d]]), l = e.map((u, d) => [0, o[d]]);
  return [c, l];
}
function gR(t, e) {
  const r = t.map((o, i) => o + (o - 1) * (e[i] - 1)).map((o) => o - 1), a = r.map((o) => Math.floor(o / 2)), s = r.map((o, i) => o - a[i]);
  return r.map((o, i) => [a[i], s[i]]);
}
const yR = /* @__PURE__ */ B({ pool_: hR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vR(t, e) {
  const n = C(t, "x", "prelu"), r = C(e, "alpha", "prelu"), a = { x: n, alpha: r };
  return W.runKernel(Rd, a);
}
const yw = /* @__PURE__ */ B({ prelu_: vR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bR(t, e = null, n = !1) {
  let r = C(t, "x", "prod");
  r.dtype === "bool" && (r = zt(r, "int32"));
  const a = { x: r }, s = { axis: e, keepDims: n };
  return W.runKernel($d, a, s);
}
const wR = /* @__PURE__ */ B({ prod_: bR });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SR(t, e, n, r) {
  const a = t.map((u, d) => C(u, `tensors${d}`, "raggedGather", "int32")), s = C(e, "paramsDenseValues", "raggedGather"), o = C(n, "indices", "raggedGather", "int32"), i = {
    paramsNestedSplits: a,
    paramsDenseValues: s,
    indices: o
  }, c = { outputRaggedRank: r }, l = W.runKernel(u1, i, c);
  return {
    outputNestedSplits: l.slice(0, l.length - 1),
    outputDenseValues: l[l.length - 1]
  };
}
const _R = /* @__PURE__ */ B({ raggedGather_: SR });
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xR(t, e, n) {
  const r = C(t, "starts", "raggedRange"), a = C(e, "limits", "raggedRange", r.dtype), s = C(n, "deltas", "raggedRange", r.dtype), o = {
    starts: r,
    limits: a,
    deltas: s
  }, i = W.runKernel(c1, o);
  return {
    rtNestedSplits: i[0],
    rtDenseValues: i[1]
  };
}
const IR = /* @__PURE__ */ B({ raggedRange_: xR });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kR(t, e, n, r, a) {
  const s = C(t, "shape", "raggedTensorToTensor", "int32"), o = C(e, "values", "raggedTensorToTensor"), i = C(n, "defaultValue", "raggedTensorToTensor", o.dtype), c = r.map((d, f) => C(d, `tensors${f}`, "raggedTensorToTensor", "int32")), l = {
    shape: s,
    values: o,
    defaultValue: i,
    rowPartitionTensors: c
  }, u = { rowPartitionTypes: a };
  return W.runKernel(l1, l, u);
}
const ER = /* @__PURE__ */ B({ raggedTensorToTensor_: kR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TR(t, e, n) {
  fr(t);
  const r = Y(t);
  let a = null;
  if (n == null || n === "float32")
    a = new Float32Array(r);
  else if (n === "int32")
    a = new Int32Array(r);
  else if (n === "bool")
    a = new Uint8Array(r);
  else
    throw new Error(`Unknown data type ${n}`);
  for (let s = 0; s < r; s++)
    a[s] = e();
  return W.makeTensor(a, t, n);
}
const CR = /* @__PURE__ */ B({ rand_: TR });
var Jm = { exports: {} };
Jm.exports;
(function(t) {
  (function(e, n, r) {
    function a(c) {
      var l = this, u = i();
      l.next = function() {
        var d = 2091639 * l.s0 + l.c * 23283064365386963e-26;
        return l.s0 = l.s1, l.s1 = l.s2, l.s2 = d - (l.c = d | 0);
      }, l.c = 1, l.s0 = u(" "), l.s1 = u(" "), l.s2 = u(" "), l.s0 -= u(c), l.s0 < 0 && (l.s0 += 1), l.s1 -= u(c), l.s1 < 0 && (l.s1 += 1), l.s2 -= u(c), l.s2 < 0 && (l.s2 += 1), u = null;
    }
    function s(c, l) {
      return l.c = c.c, l.s0 = c.s0, l.s1 = c.s1, l.s2 = c.s2, l;
    }
    function o(c, l) {
      var u = new a(c), d = l && l.state, f = u.next;
      return f.int32 = function() {
        return u.next() * 4294967296 | 0;
      }, f.double = function() {
        return f() + (f() * 2097152 | 0) * 11102230246251565e-32;
      }, f.quick = f, d && (typeof d == "object" && s(d, u), f.state = function() {
        return s(u, {});
      }), f;
    }
    function i() {
      var c = 4022871197, l = function(u) {
        u = String(u);
        for (var d = 0; d < u.length; d++) {
          c += u.charCodeAt(d);
          var f = 0.02519603282416938 * c;
          c = f >>> 0, f -= c, f *= c, c = f >>> 0, f -= c, c += f * 4294967296;
        }
        return (c >>> 0) * 23283064365386963e-26;
      };
      return l;
    }
    n && n.exports ? n.exports = o : r && r.amd ? r(function() {
      return o;
    }) : this.alea = o;
  })(
    $n,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(Jm);
var NR = Jm.exports, Qm = { exports: {} };
Qm.exports;
(function(t) {
  (function(e, n, r) {
    function a(i) {
      var c = this, l = "";
      c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.next = function() {
        var d = c.x ^ c.x << 11;
        return c.x = c.y, c.y = c.z, c.z = c.w, c.w ^= c.w >>> 19 ^ d ^ d >>> 8;
      }, i === (i | 0) ? c.x = i : l += i;
      for (var u = 0; u < l.length + 64; u++)
        c.x ^= l.charCodeAt(u) | 0, c.next();
    }
    function s(i, c) {
      return c.x = i.x, c.y = i.y, c.z = i.z, c.w = i.w, c;
    }
    function o(i, c) {
      var l = new a(i), u = c && c.state, d = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var f = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, h = (f + p) / (1 << 21);
        while (h === 0);
        return h;
      }, d.int32 = l.next, d.quick = d, u && (typeof u == "object" && s(u, l), d.state = function() {
        return s(l, {});
      }), d;
    }
    n && n.exports ? n.exports = o : r && r.amd ? r(function() {
      return o;
    }) : this.xor128 = o;
  })(
    $n,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(Qm);
var AR = Qm.exports, eg = { exports: {} };
eg.exports;
(function(t) {
  (function(e, n, r) {
    function a(i) {
      var c = this, l = "";
      c.next = function() {
        var d = c.x ^ c.x >>> 2;
        return c.x = c.y, c.y = c.z, c.z = c.w, c.w = c.v, (c.d = c.d + 362437 | 0) + (c.v = c.v ^ c.v << 4 ^ (d ^ d << 1)) | 0;
      }, c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.v = 0, i === (i | 0) ? c.x = i : l += i;
      for (var u = 0; u < l.length + 64; u++)
        c.x ^= l.charCodeAt(u) | 0, u == l.length && (c.d = c.x << 10 ^ c.x >>> 4), c.next();
    }
    function s(i, c) {
      return c.x = i.x, c.y = i.y, c.z = i.z, c.w = i.w, c.v = i.v, c.d = i.d, c;
    }
    function o(i, c) {
      var l = new a(i), u = c && c.state, d = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var f = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, h = (f + p) / (1 << 21);
        while (h === 0);
        return h;
      }, d.int32 = l.next, d.quick = d, u && (typeof u == "object" && s(u, l), d.state = function() {
        return s(l, {});
      }), d;
    }
    n && n.exports ? n.exports = o : r && r.amd ? r(function() {
      return o;
    }) : this.xorwow = o;
  })(
    $n,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(eg);
var RR = eg.exports, tg = { exports: {} };
tg.exports;
(function(t) {
  (function(e, n, r) {
    function a(i) {
      var c = this;
      c.next = function() {
        var u = c.x, d = c.i, f, p;
        return f = u[d], f ^= f >>> 7, p = f ^ f << 24, f = u[d + 1 & 7], p ^= f ^ f >>> 10, f = u[d + 3 & 7], p ^= f ^ f >>> 3, f = u[d + 4 & 7], p ^= f ^ f << 7, f = u[d + 7 & 7], f = f ^ f << 13, p ^= f ^ f << 9, u[d] = p, c.i = d + 1 & 7, p;
      };
      function l(u, d) {
        var f, p = [];
        if (d === (d | 0))
          p[0] = d;
        else
          for (d = "" + d, f = 0; f < d.length; ++f)
            p[f & 7] = p[f & 7] << 15 ^ d.charCodeAt(f) + p[f + 1 & 7] << 13;
        for (; p.length < 8; )
          p.push(0);
        for (f = 0; f < 8 && p[f] === 0; ++f)
          ;
        for (f == 8 ? p[7] = -1 : p[f], u.x = p, u.i = 0, f = 256; f > 0; --f)
          u.next();
      }
      l(c, i);
    }
    function s(i, c) {
      return c.x = i.x.slice(), c.i = i.i, c;
    }
    function o(i, c) {
      i == null && (i = +/* @__PURE__ */ new Date());
      var l = new a(i), u = c && c.state, d = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var f = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, h = (f + p) / (1 << 21);
        while (h === 0);
        return h;
      }, d.int32 = l.next, d.quick = d, u && (u.x && s(u, l), d.state = function() {
        return s(l, {});
      }), d;
    }
    n && n.exports ? n.exports = o : r && r.amd ? r(function() {
      return o;
    }) : this.xorshift7 = o;
  })(
    $n,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(tg);
var $R = tg.exports, ng = { exports: {} };
ng.exports;
(function(t) {
  (function(e, n, r) {
    function a(i) {
      var c = this;
      c.next = function() {
        var u = c.w, d = c.X, f = c.i, p, h;
        return c.w = u = u + 1640531527 | 0, h = d[f + 34 & 127], p = d[f = f + 1 & 127], h ^= h << 13, p ^= p << 17, h ^= h >>> 15, p ^= p >>> 12, h = d[f] = h ^ p, c.i = f, h + (u ^ u >>> 16) | 0;
      };
      function l(u, d) {
        var f, p, h, m, g, v = [], b = 128;
        for (d === (d | 0) ? (p = d, d = null) : (d = d + "\0", p = 0, b = Math.max(b, d.length)), h = 0, m = -32; m < b; ++m)
          d && (p ^= d.charCodeAt((m + 32) % d.length)), m === 0 && (g = p), p ^= p << 10, p ^= p >>> 15, p ^= p << 4, p ^= p >>> 13, m >= 0 && (g = g + 1640531527 | 0, f = v[m & 127] ^= p + g, h = f == 0 ? h + 1 : 0);
        for (h >= 128 && (v[(d && d.length || 0) & 127] = -1), h = 127, m = 4 * 128; m > 0; --m)
          p = v[h + 34 & 127], f = v[h = h + 1 & 127], p ^= p << 13, f ^= f << 17, p ^= p >>> 15, f ^= f >>> 12, v[h] = p ^ f;
        u.w = g, u.X = v, u.i = h;
      }
      l(c, i);
    }
    function s(i, c) {
      return c.i = i.i, c.w = i.w, c.X = i.X.slice(), c;
    }
    function o(i, c) {
      i == null && (i = +/* @__PURE__ */ new Date());
      var l = new a(i), u = c && c.state, d = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var f = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, h = (f + p) / (1 << 21);
        while (h === 0);
        return h;
      }, d.int32 = l.next, d.quick = d, u && (u.X && s(u, l), d.state = function() {
        return s(l, {});
      }), d;
    }
    n && n.exports ? n.exports = o : r && r.amd ? r(function() {
      return o;
    }) : this.xor4096 = o;
  })(
    $n,
    // window object or global
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(ng);
var DR = ng.exports, rg = { exports: {} };
rg.exports;
(function(t) {
  (function(e, n, r) {
    function a(i) {
      var c = this, l = "";
      c.next = function() {
        var d = c.b, f = c.c, p = c.d, h = c.a;
        return d = d << 25 ^ d >>> 7 ^ f, f = f - p | 0, p = p << 24 ^ p >>> 8 ^ h, h = h - d | 0, c.b = d = d << 20 ^ d >>> 12 ^ f, c.c = f = f - p | 0, c.d = p << 16 ^ f >>> 16 ^ h, c.a = h - d | 0;
      }, c.a = 0, c.b = 0, c.c = -1640531527, c.d = 1367130551, i === Math.floor(i) ? (c.a = i / 4294967296 | 0, c.b = i | 0) : l += i;
      for (var u = 0; u < l.length + 20; u++)
        c.b ^= l.charCodeAt(u) | 0, c.next();
    }
    function s(i, c) {
      return c.a = i.a, c.b = i.b, c.c = i.c, c.d = i.d, c;
    }
    function o(i, c) {
      var l = new a(i), u = c && c.state, d = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var f = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, h = (f + p) / (1 << 21);
        while (h === 0);
        return h;
      }, d.int32 = l.next, d.quick = d, u && (typeof u == "object" && s(u, l), d.state = function() {
        return s(l, {});
      }), d;
    }
    n && n.exports ? n.exports = o : r && r.amd ? r(function() {
      return o;
    }) : this.tychei = o;
  })(
    $n,
    t,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(rg);
var OR = rg.exports, vw = { exports: {} };
const FR = {}, MR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: FR
}, Symbol.toStringTag, { value: "Module" })), Ma = /* @__PURE__ */ _a(MR);
(function(t) {
  (function(e, n, r) {
    var a = 256, s = 6, o = 52, i = "random", c = r.pow(a, s), l = r.pow(2, o), u = l * 2, d = a - 1, f;
    function p(S, I, E) {
      var T = [];
      I = I == !0 ? { entropy: !0 } : I || {};
      var R = v(g(
        I.entropy ? [S, w(n)] : S ?? b(),
        3
      ), T), $ = new h(T), D = function() {
        for (var M = $.g(s), z = c, F = 0; M < l; )
          M = (M + F) * a, z *= a, F = $.g(1);
        for (; M >= u; )
          M /= 2, z /= 2, F >>>= 1;
        return (M + F) / z;
      };
      return D.int32 = function() {
        return $.g(4) | 0;
      }, D.quick = function() {
        return $.g(4) / 4294967296;
      }, D.double = D, v(w($.S), n), (I.pass || E || function(M, z, F, V) {
        return V && (V.S && m(V, $), M.state = function() {
          return m($, {});
        }), F ? (r[i] = M, z) : M;
      })(
        D,
        R,
        "global" in I ? I.global : this == r,
        I.state
      );
    }
    function h(S) {
      var I, E = S.length, T = this, R = 0, $ = T.i = T.j = 0, D = T.S = [];
      for (E || (S = [E++]); R < a; )
        D[R] = R++;
      for (R = 0; R < a; R++)
        D[R] = D[$ = d & $ + S[R % E] + (I = D[R])], D[$] = I;
      (T.g = function(M) {
        for (var z, F = 0, V = T.i, H = T.j, U = T.S; M--; )
          z = U[V = d & V + 1], F = F * a + U[d & (U[V] = U[H = d & H + z]) + (U[H] = z)];
        return T.i = V, T.j = H, F;
      })(a);
    }
    function m(S, I) {
      return I.i = S.i, I.j = S.j, I.S = S.S.slice(), I;
    }
    function g(S, I) {
      var E = [], T = typeof S, R;
      if (I && T == "object")
        for (R in S)
          try {
            E.push(g(S[R], I - 1));
          } catch {
          }
      return E.length ? E : T == "string" ? S : S + "\0";
    }
    function v(S, I) {
      for (var E = S + "", T, R = 0; R < E.length; )
        I[d & R] = d & (T ^= I[d & R] * 19) + E.charCodeAt(R++);
      return w(I);
    }
    function b() {
      try {
        var S;
        return f && (S = f.randomBytes) ? S = S(a) : (S = new Uint8Array(a), (e.crypto || e.msCrypto).getRandomValues(S)), w(S);
      } catch {
        var I = e.navigator, E = I && I.plugins;
        return [+/* @__PURE__ */ new Date(), e, E, e.screen, w(n)];
      }
    }
    function w(S) {
      return String.fromCharCode.apply(0, S);
    }
    if (v(r.random(), n), t.exports) {
      t.exports = p;
      try {
        f = Ma;
      } catch {
      }
    } else
      r["seed" + i] = p;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self < "u" ? self : $n,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(vw);
var PR = vw.exports, BR = NR, LR = AR, WR = RR, zR = $R, VR = DR, HR = OR, Gs = PR;
Gs.alea = BR;
Gs.xor128 = LR;
Gs.xorwow = WR;
Gs.xorshift7 = zR;
Gs.xor4096 = VR;
Gs.tychei = HR;
var yf = Gs;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ag {
  constructor(e, n, r, a, s) {
    this.mean = e, this.stdDev = n, this.dtype = r, this.nextVal = NaN, this.truncated = a, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
    const o = s || Math.random();
    this.random = yf.alea(o.toString());
  }
  /** Returns next sample from a Gaussian distribution. */
  nextValue() {
    if (!isNaN(this.nextVal)) {
      const a = this.nextVal;
      return this.nextVal = NaN, a;
    }
    let e, n, r = !1;
    for (; !r; ) {
      let a, s, o;
      do
        a = 2 * this.random() - 1, s = 2 * this.random() - 1, o = a * a + s * s;
      while (o >= 1 || o === 0);
      const i = Math.sqrt(-2 * Math.log(o) / o);
      e = this.mean + this.stdDev * a * i, n = this.mean + this.stdDev * s * i, (!this.truncated || this.isValidTruncated(e)) && (r = !0);
    }
    return (!this.truncated || this.isValidTruncated(n)) && (this.nextVal = this.convertValue(n)), this.convertValue(e);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(e) {
    return this.dtype == null || this.dtype === "float32" ? e : Math.round(e);
  }
  /** Returns true if less than 2-standard-deviations from the mean. */
  isValidTruncated(e) {
    return e <= this.upper && e >= this.lower;
  }
}
class jR {
  constructor(e, n, r, a) {
    this.alpha = e, this.beta = 1 / n, this.dtype = r;
    const s = a || Math.random();
    this.randu = yf.alea(s.toString()), this.randn = new ag(0, 1, r, !1, this.randu()), e < 1 ? this.d = e + 2 / 3 : this.d = e - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  /** Returns next sample from a gamma distribution. */
  nextValue() {
    let e, n, r, a, s, o;
    for (; ; ) {
      do
        a = this.randn.nextValue(), o = 1 + this.c * a;
      while (o <= 0);
      if (o *= o * o, e = a * a, n = 1 - 0.331 * e * e, r = 0.5 * e + this.d * (1 - o + Math.log(o)), s = this.randu(), s < n || Math.log(s) < r)
        break;
    }
    return o = 1 / this.beta * this.d * o, this.alpha < 1 && (o *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(o);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(e) {
    return this.dtype === "float32" ? e : Math.round(e);
  }
}
class UR {
  constructor(e = 0, n = 1, r, a) {
    if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = e, this.range = n - e, this.dtype = r, a == null && (a = Math.random()), typeof a == "number" && (a = a.toString()), !this.canReturnFloat() && this.range <= 1)
      throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);
    this.random = yf.alea(a);
  }
  convertValue(e) {
    return this.canReturnFloat() ? e : Math.round(e);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GR(t, e, n = 1, r = "float32", a) {
  if (fr(t), n == null && (n = 1), r == null && (r = "float32"), r !== "float32" && r !== "int32")
    throw new Error(`Unsupported data type ${r}`);
  const s = new jR(e, n, r, a), o = Qe(t, r);
  for (let i = 0; i < o.values.length; i++)
    o.values[i] = s.nextValue();
  return o.toTensor();
}
const qR = /* @__PURE__ */ B({ randomGamma_: GR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KR(t, e = 0, n = 1, r, a) {
  if (fr(t), r != null && r === "bool")
    throw new Error(`Unsupported data type ${r}`);
  const s = new ag(e, n, r, !1, a), o = Qe(t, r);
  for (let i = 0; i < o.values.length; i++)
    o.values[i] = s.nextValue();
  return o.toTensor();
}
const bw = /* @__PURE__ */ B({ randomNormal_: KR });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XR(t, e, n) {
  if (e != null && e === "bool")
    throw new Error(`Unsupported data type ${e}`);
  return bw(t, 0, 1, e, n);
}
const YR = /* @__PURE__ */ B({ randomStandardNormal_: XR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZR(t, e = 0, n = 1, r = "float32", a) {
  fr(t);
  const s = Qe(t, r), o = new UR(e, n, null, a);
  for (let i = 0; i < s.values.length; i++)
    s.values[i] = o.nextValue();
  return s.toTensor();
}
const sg = /* @__PURE__ */ B({ randomUniform_: ZR });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JR(t, e, n, r) {
  return sg(t, e, n, "int32", r);
}
const QR = /* @__PURE__ */ B({ randomUniformInt_: JR });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cu(t, e, n = 1, r = "float32") {
  if (n === 0)
    throw new Error("Cannot have a step of zero");
  const a = { start: t, stop: e, step: n, dtype: r };
  return W.runKernel(Tm, {}, a);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e$(t) {
  const n = { input: C(t, "input", "real") };
  return W.runKernel(d1, n);
}
const lu = /* @__PURE__ */ B({ real_: e$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t$(t) {
  const n = { x: C(t, "x", "reciprocal") };
  return W.runKernel(Dd, n);
}
const n$ = /* @__PURE__ */ B({ reciprocal_: t$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r$(t) {
  const n = { x: C(t, "x", "relu") };
  return W.runKernel(Od, n);
}
const vf = /* @__PURE__ */ B({ relu_: r$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a$(t) {
  const n = { x: C(t, "x", "relu6") };
  return W.runKernel(Pd, n);
}
const ww = /* @__PURE__ */ B({ relu6_: a$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s$(t, e) {
  const r = { x: C(t, "x", "reverse") }, a = { dims: e };
  return W.runKernel(Bd, r, a);
}
const Ms = /* @__PURE__ */ B({ reverse_: s$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o$(t) {
  const e = C(t, "x", "reverse");
  return A(e.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`), Ms(e, 0);
}
const i$ = /* @__PURE__ */ B({ reverse1d_: o$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u$(t, e) {
  const n = C(t, "x", "reverse");
  return A(n.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`), Ms(n, e);
}
const c$ = /* @__PURE__ */ B({ reverse2d_: u$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l$(t, e) {
  const n = C(t, "x", "reverse");
  return A(n.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`), Ms(n, e);
}
const d$ = /* @__PURE__ */ B({ reverse3d_: l$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f$(t, e) {
  const n = C(t, "x", "reverse");
  return A(n.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`), Ms(n, e);
}
const p$ = /* @__PURE__ */ B({ reverse4d_: f$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h$(t) {
  const n = { x: C(t, "x", "round") };
  return W.runKernel(Ld, n);
}
const Sw = /* @__PURE__ */ B({ round_: h$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function m$(t) {
  const n = { x: C(t, "x", "rsqrt", "float32") };
  return W.runKernel(Wd, n);
}
const g$ = /* @__PURE__ */ B({ rsqrt_: m$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function y$(t) {
  const n = { x: C(t, "x", "selu") };
  return W.runKernel(jd, n);
}
const v$ = /* @__PURE__ */ B({ selu_: y$ });
function b$(t, e, n, r, a, s = [1, 1], o = "NHWC") {
  const i = C(t, "x", "separableConv2d"), c = C(e, "depthwiseFilter", "separableConv2d"), l = C(n, "pointwiseFilter", "separableConv2d");
  let u = i, d = !1;
  if (i.rank === 3 && (d = !0, u = ae(i, [1, i.shape[0], i.shape[1], i.shape[2]])), o === "NCHW")
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  A(u.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`), A(c.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`), A(l.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`), A(l.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`), A(l.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);
  const f = c.shape[2], p = c.shape[3];
  A(l.shape[2] === f * p, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${f * p}, but got ${l.shape[2]}.`);
  const h = Xm(u, c, r, a, o, s), g = ff(h, l, 1, "valid", o);
  return d ? ae(g, [g.shape[1], g.shape[2], g.shape[3]]) : g;
}
const w$ = /* @__PURE__ */ B({ separableConv2d_: b$ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function S$(t, e) {
  const n = C(t, "x", "setdiff1d"), r = C(e, "y", "setdiff1d");
  A(n.dtype === r.dtype, () => `x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`), A(n.rank === 1, () => `x should be 1D tensor, but got x (${n.shape}).`), A(r.rank === 1, () => `y should be 1D tensor, but got y (${r.shape}).`);
  const a = await n.data(), s = await r.data(), o = new Set(s);
  let i = 0;
  for (let u = 0; u < a.length; u++)
    o.has(a[u]) || i++;
  const c = new on([i], n.dtype), l = new on([i], "int32");
  for (let u = 0, d = 0; u < a.length; u++)
    o.has(a[u]) || (c.values[d] = a[u], l.values[d] = u, d++);
  return [c.toTensor(), l.toTensor()];
}
const _$ = S$;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function x$(t) {
  const n = { x: C(t, "x", "sign") };
  return W.runKernel(qd, n);
}
const I$ = /* @__PURE__ */ B({ sign_: x$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k$(t) {
  const n = { x: C(t, "x", "sin", "float32") };
  return W.runKernel(Ud, n);
}
const E$ = /* @__PURE__ */ B({ sin_: k$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T$(t) {
  const n = { x: C(t, "x", "sinh") };
  return W.runKernel(Gd, n);
}
const C$ = /* @__PURE__ */ B({ sinh_: T$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N$(t, e, n) {
  const r = C(t, "x", "slice1d");
  return A(r.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`), qe(r, [e], [n]);
}
const A$ = /* @__PURE__ */ B({ slice1d_: N$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R$(t, e, n) {
  const r = C(t, "x", "slice2d");
  return A(r.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`), qe(r, e, n);
}
const $$ = /* @__PURE__ */ B({ slice2d_: R$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D$(t, e, n) {
  const r = C(t, "x", "slice3d");
  return A(r.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`), qe(r, e, n);
}
const O$ = /* @__PURE__ */ B({ slice3d_: D$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F$(t, e, n) {
  const r = C(t, "x", "slice4d");
  return A(r.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`), qe(r, e, n);
}
const M$ = /* @__PURE__ */ B({ slice4d_: F$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function P$(t, e = -1) {
  const n = C(t, "logits", "softmax", "float32");
  if (e === -1 && (e = n.rank - 1), e !== n.rank - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);
  const r = { logits: n }, a = { dim: e };
  return W.runKernel(Jd, r, a);
}
const B$ = /* @__PURE__ */ B({ softmax_: P$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function L$(t) {
  A(t.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);
  const e = { input: t };
  return W.runKernel(r1, e);
}
const og = /* @__PURE__ */ B({ fft_: L$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function W$(t) {
  A(t.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);
  const e = { input: t };
  return W.runKernel(a1, e);
}
const Uc = /* @__PURE__ */ B({ ifft_: W$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z$(t) {
  const e = t.shape[t.shape.length - 1], n = t.size / e;
  let r;
  if (e <= 2) {
    const a = ae(t, [n, e]);
    r = Uc(a);
  } else {
    const a = [n, 2 * (e - 1)], s = ae(lu(t), [n, e]), o = ae(gf(t), [n, e]), i = Ms(qe(s, [0, 1], [n, e - 2]), 1), c = he(Ms(qe(o, [0, 1], [n, e - 2]), 1), ut(-1)), l = yn([s, i], 1), u = yn([o, c], 1), d = ae(ja(l, u), [a[0], a[1]]);
    r = Uc(d);
  }
  if (r = lu(r), t.rank === 3 && t.shape[0] !== 0) {
    const a = r, s = t.shape[0];
    r = ae(r, [s, r.shape[0] / s, r.shape[1]]), a.dispose();
  }
  return r;
}
const _w = /* @__PURE__ */ B({ irfft_: z$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function V$(t, e, n = 0) {
  const a = { x: C(t, "x", "split") }, s = { numOrSizeSplits: e, axis: n };
  return W.runKernel(Om, a, s);
}
const du = /* @__PURE__ */ B({ split_: V$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H$(t, e) {
  A(t.dtype === "float32", () => `The dtype for rfft() must be real value but got ${t.dtype}`);
  let n = t.shape[t.shape.length - 1];
  const r = t.size / n;
  let a;
  if (e != null && e < n) {
    const h = t.shape.map((g) => 0), m = t.shape.map((g) => g);
    m[t.shape.length - 1] = e, a = qe(t, h, m), n = e;
  } else if (e != null && e > n) {
    const h = t.shape.map((m) => m);
    h[t.shape.length - 1] = e - n, a = yn([t, Co(h)], t.shape.length - 1), n = e;
  } else
    a = t;
  const s = lr(a), o = ae(ja(a, s), [r, n]), i = og(o), c = Math.floor(n / 2) + 1, l = lu(i), u = gf(i), d = du(l, [c, n - c], l.shape.length - 1), f = du(u, [c, n - c], u.shape.length - 1), p = a.shape.slice();
  return p[a.shape.length - 1] = c, ae(ja(d[0], f[0]), p);
}
const ig = /* @__PURE__ */ B({ rfft_: H$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function j$(t, e) {
  let n = C(t, "a", "squaredDifference"), r = C(e, "b", "squaredDifference");
  [n, r] = Kt(n, r), At(n.shape, r.shape);
  const a = { a: n, b: r }, s = {};
  return W.runKernel(tf, a, s);
}
const xw = /* @__PURE__ */ B({ squaredDifference_: j$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function U$(t, e) {
  const n = C(t, "x", "squeeze", "string_or_numeric");
  return ae(n, oT(n.shape, e).newShape);
}
const hn = /* @__PURE__ */ B({ squeeze_: U$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function G$(t, e = 0) {
  const n = Bc(t, "tensors", "stack", "string_or_numeric");
  A(n.length >= 1, () => "Pass at least one tensor to tf.stack"), n.length > 0 && A(e <= n[0].rank, () => "Axis must be <= rank of the tensor");
  const r = n, a = { axis: e };
  return W.runKernel(Em, r, a);
}
const ba = /* @__PURE__ */ B({ stack_: G$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function q$(t, e = 0) {
  const r = { x: C(t, "x", "step") }, a = { alpha: e };
  return W.runKernel(Nu, r, a);
}
const Iw = /* @__PURE__ */ B({ step_: q$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function K$(t, e, n, r, a = 0, s = 0, o = 0, i = 0, c = 0) {
  const u = { x: C(t, "x", "stridedSlice", "string_or_numeric") }, d = {
    begin: e,
    end: n,
    strides: r,
    beginMask: a,
    endMask: s,
    ellipsisMask: o,
    newAxisMask: i,
    shrinkAxisMask: c
  };
  return W.runKernel(nf, u, d);
}
const X$ = /* @__PURE__ */ B({ stridedSlice_: K$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y$(t) {
  const n = { x: C(t, "x", "tan", "float32") };
  return W.runKernel(af, n);
}
const Z$ = /* @__PURE__ */ B({ tan_: Y$ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xn(t, e) {
  Po(t);
  const n = Ya(t, e);
  if (n.length !== 1)
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Za(t, null, n, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ns(t, e, n) {
  if (Po(t), e != null && e.length !== 2)
    throw new Error("tensor2d() requires shape to have two numbers");
  const r = Ya(t, n);
  if (r.length !== 2 && r.length !== 1)
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (r.length === 1 && e == null)
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Za(t, e, r, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kw(t, e, n) {
  if (Po(t), e != null && e.length !== 3)
    throw new Error("tensor3d() requires shape to have three numbers");
  const r = Ya(t, n);
  if (r.length !== 3 && r.length !== 1)
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (r.length === 1 && e == null)
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Za(t, e, r, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J$(t, e, n) {
  if (Po(t), e != null && e.length !== 4)
    throw new Error("tensor4d() requires shape to have four numbers");
  const r = Ya(t, n);
  if (r.length !== 4 && r.length !== 1)
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (r.length === 1 && e == null)
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Za(t, e, r, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Q$(t, e, n) {
  if (Po(t), e != null && e.length !== 5)
    throw new Error("tensor5d() requires shape to have five numbers");
  const r = Ya(t, n);
  if (r.length !== 5 && r.length !== 1)
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (r.length === 1 && e == null)
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Za(t, e, r, n);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eD(t, e, n) {
  if (Po(t), e != null && e.length !== 6)
    throw new Error("tensor6d() requires shape to have six numbers");
  const r = Ya(t, n);
  if (r.length !== 6 && r.length !== 1)
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (r.length === 1 && e == null)
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return e = e || r, Za(t, e, r, n);
}
function tD(t, e, n) {
  const r = e.rank > 1 ? e.shape[e.rank - 1] : 1, a = e.rank > 1 ? e.rank - 1 : 1, s = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${a}.`;
  if (n.rank < a)
    throw new Error(s + ` update.rank < ${a}. `);
  if (t.length < r + (n.rank - a))
    throw new Error(s + ` Output shape length < ${r + (n.rank - a)}`);
  if (n.rank !== a + t.length - r)
    throw new Error(s + ` update.rank != ${a + t.length - r}`);
  for (let o = 0; o < a; ++o)
    if (n.shape[o] !== e.shape[o])
      throw new Error(s + ` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);
  for (let o = 0; o < n.rank - a; ++o)
    if (n.shape[o + a] !== t[o + r])
      throw new Error(s + ` updates.shape[${o + a}] (${n.shape[o + a]}) != shape[${o + a}] (${t[o + a]})`);
}
function Ew(t, e, n) {
  if (e.rank < 1)
    throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);
  if (t.rank < 1)
    throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);
  if (e.dtype !== "int32")
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);
  if (n.length < 1)
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);
  if (n.length === 0) {
    if (e.size === 0)
      throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);
    if (t.size === 0)
      throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`);
  }
  tD(n, e, t);
}
function Vo(t, e, n) {
  const r = e.shape.length, a = r > 1 ? e.shape[r - 1] : 1, s = n.length;
  let o = 1;
  for (let d = a; d < s; ++d)
    o *= n[d];
  const i = a < 1 ? 1 : a, c = Y(e.shape) / i, l = [...Ie(n.slice(0, a)), 1], u = Y(n);
  return { sliceRank: a, numUpdates: c, sliceSize: o, strides: l, outputSize: u };
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nD(t, e, n) {
  const r = C(t, "tensor", "tensorScatterupdate"), a = C(e, "indices", "tensorScatterupdate", "int32"), s = C(n, "updates", "tensorScatterupdate");
  if (Ew(s, a, r.shape), r.dtype !== s.dtype)
    throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);
  const o = {
    tensor: r,
    indices: a,
    updates: s
  }, i = {};
  return W.runKernel(Vd, o, i);
}
const rD = B({ tensorScatterUpdate_: nD });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aD(t, e = 1, n = !0) {
  const r = C(t, "x", "topk");
  if (r.rank === 0)
    throw new Error("topk() expects the input to be of rank 1 or higher");
  const a = r.shape[r.shape.length - 1];
  if (e < 0)
    throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);
  if (e > a)
    throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${e}`);
  const s = { x: r }, o = { k: e, sorted: n }, [i, c] = W.runKernel(of, s, o);
  return { values: i, indices: c };
}
const sD = /* @__PURE__ */ B({ topk_: aD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oD(t, e = 0, n = 1, r, a) {
  if (fr(t), r != null && r === "bool")
    throw new Error("Unsupported data type $ { dtype }");
  const s = new ag(e, n, r, !0, a), o = Qe(t, r);
  for (let i = 0; i < o.values.length; i++)
    o.values[i] = s.nextValue();
  return o.toTensor();
}
const iD = /* @__PURE__ */ B({ truncatedNormal_: oD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uD(t, e = 0) {
  const n = C(t, "x", "unique", "string_or_numeric");
  A(n.rank > 0, () => "The input tensor must be at least 1D");
  const r = { x: n }, a = { axis: e }, [s, o] = W.runKernel(Vm, r, a);
  return { values: s, indices: o };
}
const cD = /* @__PURE__ */ B({ unique_: uD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lD(t, e, n) {
  const r = C(t, "x", "unsortedSegmentSum"), a = C(e, "segmentIds", "unsortedSegmentSum", "int32");
  A(Ji(n), () => "numSegments must be of dtype int");
  const s = { x: r, segmentIds: a }, o = { numSegments: n };
  return W.runKernel(p1, s, o);
}
const dD = /* @__PURE__ */ B({ unsortedSegmentSum_: lD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fD(t, e = 0) {
  const n = C(t, "x", "unstack", "string_or_numeric");
  A(e >= -n.shape.length && e < n.shape.length, () => `Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);
  const r = { value: n }, a = { axis: e };
  return W.runKernel(Hm, r, a);
}
const qs = /* @__PURE__ */ B({ unstack_: fD });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pD(t, e) {
  return Zm(t, e, "right");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hD(t, e = !0, n, r) {
  return W.makeVariable(t, e, n, r);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tw(t, e) {
  const n = [];
  for (let s = 0; s < e.length; s++)
    e[s] && n.push(s);
  const r = Qe(t, "int32"), a = Qe([n.length, t.length], "int32");
  for (let s = 0; s < n.length; s++) {
    const o = r.indexToLoc(n[s]), i = s * t.length;
    a.values.set(o, i);
  }
  return a.toTensor();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function mD(t) {
  const e = C(t, "condition", "whereAsync", "bool"), n = await e.data(), r = Tw(e.shape, n);
  return t !== e && e.dispose(), r;
}
const Cw = mD;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function gD(t, e, n) {
  const r = C(t, "tensor", "boolMask"), a = C(e, "mask", "boolMask", "bool"), s = n ?? 0, o = a.rank, i = r.shape;
  A(o > 0, () => "mask cannot be scalar"), ar(i.slice(s, s + o), a.shape, "mask's shape must match the first K dimensions of tensor's shape,");
  let c = 1;
  for (let m = s; m < s + o; m++)
    c *= i[m];
  const l = i.slice(0, s).concat([c], i.slice(s + o)), u = ae(r, l), d = ae(a, [-1]), f = await Cw(d), p = hn(f, [1]), h = sw(u, p, s);
  return t !== r && r.dispose(), e !== a && a.dispose(), p.dispose(), u.dispose(), d.dispose(), f.dispose(), h;
}
const yD = gD;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vD(t, e, n) {
  const r = C(t, "x", "transpose");
  if (e == null && (e = r.shape.map((o, i) => i).reverse()), A(r.rank === e.length, () => `Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`), e.forEach((o) => {
    A(o >= 0 && o < r.rank, () => `All entries in 'perm' must be between 0 and ${r.rank - 1} but got ${e}`);
  }), r.rank <= 1)
    return r.clone();
  const a = { x: r }, s = { perm: e };
  return r.dtype === "complex64" ? Je(() => {
    let o = lu(r), i = gf(r);
    return o = W.runKernel(vo, { x: o }, s), i = W.runKernel(vo, { x: i }, s), n && (i = Jr(i)), ja(o, i);
  }) : W.runKernel(vo, a, s);
}
const rh = /* @__PURE__ */ B({ transpose_: vD });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bD(t, e, n, r, a = !0) {
  const s = C(t, "v", "movingAverage"), o = C(e, "x", "movingAverage"), i = C(n, "decay", "movingAverage");
  VT(s, o), A(Ir(s.shape, o.shape), () => "Shape mismatch in v and x");
  const c = ut(1), l = Ke(c, i);
  let u = he(Ke(o, s), l);
  if (a) {
    A(r != null, () => "When using zeroDebias: true, step is required.");
    const d = C(r, "step", "movingAverage");
    u = Ze(u, Ke(c, iu(i, d)));
  }
  return Ae(s, u);
}
const wD = /* @__PURE__ */ B({ movingAverage_: bD });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SD(t, e, n) {
  fr(n);
  const r = C(t, "indices", "scatterND", "int32"), a = C(e, "updates", "scatterND");
  Ew(a, r, n);
  const s = { indices: r, updates: a }, o = { shape: n };
  return W.runKernel(zd, s, o);
}
const _D = /* @__PURE__ */ B({ scatterND_: SD });
function xD(t, e, n, r) {
  if (t.dtype !== "int32")
    throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
  if (t.rank > 2)
    throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);
  const a = t.rank > 0 ? t.shape[0] : 1, s = t.rank > 1 ? t.shape[1] : 1;
  if (n.length !== s)
    throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);
  const o = e.size;
  if (!(e.rank === 0 || e.rank === 1 && o === a))
    throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${a}]`);
  if (e.dtype !== r.dtype)
    throw new Error("sparseValues.dtype must match defaultValues.dtype");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ID(t, e, n, r = 0) {
  fr(n);
  const a = C(t, "sparseIndices", "sparseToDense", "int32"), s = C(e, "sparseValues", "sparseToDense", "string_or_numeric"), o = C(r, "defaultValue", "sparseToDense", s.dtype);
  xD(a, s, n, o);
  const i = {
    sparseIndices: a,
    sparseValues: s,
    defaultValue: o
  }, c = { outputShape: n };
  return W.runKernel(ef, i, c);
}
const kD = /* @__PURE__ */ B({ sparseToDense_: ID });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ED(t, e) {
  const n = C(e, "indices", "gatherND", "int32"), a = { params: C(t, "x", "gatherND", "string_or_numeric"), indices: n };
  return W.runKernel(Zl, a);
}
const TD = /* @__PURE__ */ B({ gatherND_: ED });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CD(t, e) {
  if (e == null)
    return t.shape.slice();
  if (Ir(t.shape, e))
    return e;
  if (t.shape.length === e.length) {
    const n = [];
    for (let r = 0; r < t.shape.length; r++)
      e[r] == null && t.shape[r] != null ? n.push(t.shape[r]) : n.push(e[r]);
    return n;
  }
  return e;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ND(t, e, n, r) {
  const a = C(t, "x", "dropout");
  if (A(a.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`), A(e >= 0 && e < 1, () => `rate must be a float in the range [0, 1), but got ${e}.`), e === 0)
    return t instanceof en ? a.clone() : a;
  const s = CD(a, n), o = 1 - e, i = Ze(aw(Ae(sg(s, 0, 1, "float32", r), o)), o);
  return he(a, i);
}
const AD = /* @__PURE__ */ B({ dropout_: ND });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nw(t) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(t) / Math.log(2))));
}
function ug(t, e, n) {
  const r = 1 - t % 2, a = new Float32Array(t);
  for (let s = 0; s < t; ++s) {
    const o = 2 * Math.PI * s / (t + r - 1);
    a[s] = e - n * Math.cos(o);
  }
  return xn(a, "float32");
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function RD(t, e, n = 1) {
  const r = C(t, "predictions", "inTopK"), a = C(e, "targets", "inTopK");
  A(r.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`), A(r.rank - 1 === a.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`), ar(r.shape.slice(0, r.shape.length - 1), a.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
  const s = r.shape[r.shape.length - 1];
  A(n > 0 && n <= s, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);
  const o = await r.data(), i = await a.data(), [c, l] = [o.length / s, s], u = Dn("bool", c);
  for (let d = 0; d < c; d++) {
    const f = d * l, p = o.subarray(f, f + l), h = [];
    for (let m = 0; m < p.length; m++)
      h.push({ value: p[m], index: m });
    h.sort((m, g) => g.value - m.value), u[d] = 0;
    for (let m = 0; m < n; m++)
      if (h[m].index === i[d]) {
        u[d] = 1;
        break;
      }
  }
  return t !== r && r.dispose(), e !== a && a.dispose(), Mr(u, a.shape, "bool");
}
const $D = RD;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DD(t, e, n, r, a, s = "NHWC", o) {
  let i = t;
  t.rank === 3 && (i = ae(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  let c = e;
  c.rank === 3 && (c = ae(e, [1, e.shape[0], e.shape[1], e.shape[2]])), A(i.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`), A(c.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`), A(n.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);
  const l = s === "NHWC" ? i.shape[3] : i.shape[1], u = s === "NHWC" ? c.shape[3] : c.shape[1];
  A(l === n[2], () => `Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`), A(u === n[3], () => `Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`), Hr("conv2dDerFilter", a, o);
  const d = { x: i, dy: c }, f = { strides: r, pad: a, dataFormat: s, dimRoundingMode: o, filterShape: n };
  return W.runKernel(J0, d, f);
}
const OD = /* @__PURE__ */ B({ conv2DBackpropFilter_: DD });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cg(t, e, n) {
  if (n == null || n === "linear")
    return t;
  if (n === "relu")
    return he(t, Iw(e));
  throw new Error(`Cannot compute gradient for fused activation ${n}.`);
}
function lg(t, e) {
  let n = e;
  const r = SA(t.shape, e.shape);
  return r.length > 0 && (n = Dt(n, r)), ae(n, t.shape);
}
function dg(t, e, n, r) {
  if (e === "linear")
    return t;
  if (e === "relu")
    return vf(t);
  if (e === "elu")
    return ew(t);
  if (e === "relu6")
    return ww(t);
  if (e === "prelu")
    return yw(t, n);
  if (e === "leakyrelu")
    return iw(t, r);
  if (e === "sigmoid")
    return Cs(t);
  throw new Error(`Unknown fused activation ${e}.`);
}
const fg = (t, e) => !(t > 0) || e === "linear";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FD({ x: t, filter: e, strides: n, pad: r, dataFormat: a = "NHWC", dilations: s = [1, 1], dimRoundingMode: o, bias: i, activation: c = "linear", preluActivationWeights: l, leakyreluAlpha: u }) {
  if (c = c || "linear", fg(W.state.gradientDepth, c) === !1) {
    A(a === "NHWC", () => `Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
    let E = ff(t, e, n, r, a, s, o);
    return i != null && (E = Ae(E, i)), dg(E, c, l, u);
  }
  const d = C(t, "x", "conv2d", "float32"), f = C(e, "filter", "conv2d", "float32");
  let p = d, h = !1;
  d.rank === 3 && (h = !0, p = ae(d, [1, d.shape[0], d.shape[1], d.shape[2]])), A(p.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`), A(f.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`), Hr("fused conv2d", r, o);
  const m = a === "NHWC" ? p.shape[3] : p.shape[1];
  A(f.shape[2] === m, () => `Error in conv2d: depth of input (${m}) must match input depth for filter ${f.shape[2]}.`), A(Er(n, s), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);
  const g = Kn(p.shape, f.shape, n, s, r, o);
  let v;
  i != null && (v = C(i, "bias", "fused conv2d"), [v] = Kt(v, d), a === "NHWC" ? At(g.outShape, v.shape) : (A(v.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`), A(v.shape.length === 0 || v.shape[0] === g.outChannels || v.shape[0] === 1, () => `Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${g.outChannels})`)));
  let b;
  if (l != null) {
    const E = l.shape;
    if (A(E.length <= 1 || E.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`), E.length === 1)
      A(E[0] === 1 || E[0] === g.outChannels, () => `Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${g.outChannels}).`);
    else if (E.length === 3)
      try {
        At(E, g.outShape);
      } catch {
        const R = `Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${g.outShape}).`;
        throw Error(R);
      }
    b = C(l, "prelu weights", "fused conv2d");
  }
  const w = (E, T) => {
    A(a === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);
    const [R, $, D, M] = T, z = cg(E, D, c);
    A(Wc(s), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);
    const F = J1($.shape, z, R, n, r), V = OD($, z, R.shape, n, r), H = [F, V];
    if (M != null) {
      const U = lg(M, z);
      H.push(U);
    }
    return H;
  }, S = {
    x: p,
    filter: f,
    bias: v,
    preluActivationWeights: b
  }, I = {
    strides: n,
    pad: r,
    dataFormat: a,
    dilations: s,
    dimRoundingMode: o,
    activation: c,
    leakyreluAlpha: u
  };
  return i == null ? va((T, R, $) => {
    let D = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      W.runKernel(tu, S, I)
    );
    return $([R, T, D]), h && (D = ae(D, [D.shape[1], D.shape[2], D.shape[3]])), { value: D, gradFunc: w };
  })(p, f) : va((T, R, $, D) => {
    let M = W.runKernel(tu, S, I);
    return D([R, T, M, $]), h && (M = ae(M, [M.shape[1], M.shape[2], M.shape[3]])), { value: M, gradFunc: w };
  })(p, f, v);
}
const MD = /* @__PURE__ */ B({ fusedConv2d_: FD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PD(t, e, n, r, a, s = [1, 1], o) {
  let i = t;
  t.rank === 3 && (i = ae(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  let c = e;
  c.rank === 3 && (c = ae(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
  const l = { x: i, dy: c }, u = { strides: r, pad: a, dimRoundingMode: o, dilations: s, filterShape: n };
  return W.runKernel(Q0, l, u);
}
const BD = B({ depthwiseConv2dNativeBackpropFilter_: PD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LD(t, e, n, r, a, s = [1, 1], o) {
  let i = e, c = !1;
  e.rank === 3 && (c = !0, i = ae(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
  const l = { dy: i, filter: n }, u = { strides: r, pad: a, dimRoundingMode: o, dilations: s, inputShape: t }, d = (
    // tslint:disable-next-line: no-unnecessary-type-assertion
    W.runKernel(e1, l, u)
  );
  return c ? ae(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const WD = B({ depthwiseConv2dNativeBackpropInput_: LD });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zD({ x: t, filter: e, strides: n, pad: r, dataFormat: a = "NHWC", dilations: s = [1, 1], dimRoundingMode: o, bias: i, activation: c = "linear", preluActivationWeights: l, leakyreluAlpha: u }) {
  if (fg(W.state.gradientDepth, c) === !1) {
    let I = Xm(t, e, n, r, a, s, o);
    return i != null && (I = Ae(I, i)), dg(I, c, l, u);
  }
  const d = C(t, "x", "depthwiseConv2d", "float32"), f = C(e, "filter", "depthwiseConv2d", "float32");
  let p = d, h = !1;
  d.rank === 3 && (h = !0, p = ae(d, [1, d.shape[0], d.shape[1], d.shape[2]])), A(p.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`), A(f.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`), A(p.shape[3] === f.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`), s == null && (s = [1, 1]), A(Er(n, s), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`), Hr("fused depthwiseConv2d", r, o);
  const m = Kn(
    p.shape,
    f.shape,
    n,
    s,
    r,
    o,
    !0
    /* depthwise */
  );
  let g;
  i != null && (g = C(i, "bias", "fused conv2d"), [g] = Kt(g, d), At(m.outShape, g.shape));
  let v;
  l != null && (v = C(l, "prelu weights", "fused depthwiseConv2d"));
  const b = (I, E) => {
    A(Wc(s), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);
    const [T, R, $, D] = E, M = cg(I, $, c), z = WD(R.shape, M, T, n, r, s, o), F = BD(R, M, T.shape, n, r, s, o);
    if (D != null) {
      const V = lg(g, M);
      return [z, F, V];
    }
    return [z, F];
  }, w = {
    x: p,
    filter: f,
    bias: g,
    preluActivationWeights: v
  }, S = {
    strides: n,
    pad: r,
    dataFormat: a,
    dilations: s,
    dimRoundingMode: o,
    activation: c,
    leakyreluAlpha: u
  };
  return i == null ? va((E, T, R) => {
    let $ = W.runKernel(nu, w, S);
    return R([T, E, $]), h && ($ = ae($, [$.shape[1], $.shape[2], $.shape[3]])), { value: $, gradFunc: b };
  })(p, f) : va((E, T, R, $) => {
    let D = W.runKernel(nu, w, S);
    return $([T, E, D, R]), h && (D = ae(D, [D.shape[1], D.shape[2], D.shape[3]])), { value: D, gradFunc: b };
  })(p, f, g);
}
const VD = /* @__PURE__ */ B({ fusedDepthwiseConv2d_: zD });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HD({ a: t, b: e, transposeA: n = !1, transposeB: r = !1, bias: a, activation: s = "linear", preluActivationWeights: o, leakyreluAlpha: i = 0.2 }) {
  if (fg(W.state.gradientDepth, s) === !1) {
    let M = wt(t, e, n, r);
    return a != null && (M = Ae(M, a)), dg(M, s, o, i);
  }
  let c = C(t, "a", "fused matMul"), l = C(e, "b", "fused matMul");
  [c, l] = Kt(c, l);
  const u = n ? c.shape[c.rank - 2] : c.shape[c.rank - 1], d = r ? l.shape[l.rank - 1] : l.shape[l.rank - 2], f = n ? c.shape[c.rank - 1] : c.shape[c.rank - 2], p = r ? l.shape[l.rank - 2] : l.shape[l.rank - 1], h = c.shape.slice(0, -2), m = l.shape.slice(0, -2), g = Y(h), v = Y(m);
  A(u === d, () => `Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);
  const w = At(c.shape.slice(0, -2), l.shape.slice(0, -2)).concat([f, p]), S = n ? ae(c, [g, u, f]) : ae(c, [g, f, u]), I = r ? ae(l, [v, p, d]) : ae(l, [v, d, p]);
  let E;
  a != null && (E = C(a, "bias", "fused matMul"), [E] = Kt(E, c), At(w, E.shape));
  let T;
  o != null && (T = C(o, "prelu weights", "fused matMul"));
  const R = (M, z) => {
    const [F, V, H, U] = z, Z = cg(ae(M, H.shape), H, s);
    let q, X;
    if (!n && !r ? (q = wt(Z, V, !1, !0), X = wt(F, Z, !0, !1)) : !n && r ? (q = wt(Z, V, !1, !1), X = wt(Z, F, !0, !1)) : n && !r ? (q = wt(V, Z, !1, !0), X = wt(F, Z, !1, !1)) : (q = wt(V, Z, !0, !0), X = wt(Z, F, !0, !0)), a != null) {
      const se = lg(U, Z);
      return [q, X, se];
    } else
      return [q, X];
  }, $ = {
    a: S,
    b: I,
    bias: E,
    preluActivationWeights: T
  }, D = { transposeA: n, transposeB: r, activation: s, leakyreluAlpha: i };
  return a == null ? va((z, F, V) => {
    const H = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      W.runKernel(eu, $, D)
    );
    return V([z, F, H]), { value: ae(H, w), gradFunc: R };
  })(S, I) : va((z, F, V, H) => {
    const U = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      W.runKernel(eu, $, D)
    );
    return H([z, F, U, V]), { value: ae(U, w), gradFunc: R };
  })(S, I, E);
}
const jD = /* @__PURE__ */ B({ fusedMatMul_: HD });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  conv2d: MD,
  depthwiseConv2d: VD,
  matMul: jD
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GD(t) {
  return ug(t, 0.54, 0.46);
}
const qD = /* @__PURE__ */ B({ hammingWindow_: GD });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KD(t) {
  return ug(t, 0.5, 0.5);
}
const Aw = /* @__PURE__ */ B({ hannWindow_: KD });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XD(t, e, n, r = !1, a = 0) {
  let s = 0;
  const o = [];
  for (; s + e <= t.size; )
    o.push(qe(t, s, e)), s += n;
  if (r)
    for (; s < t.size; ) {
      const i = s + e - t.size, c = yn([
        qe(t, s, e - i),
        Ru([i], a)
      ]);
      o.push(c), s += n;
    }
  return o.length === 0 ? Ns([], [0, e]) : ae(yn(o), [o.length, e]);
}
const Rw = /* @__PURE__ */ B({ frame_: XD });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YD(t, e, n, r, a = Aw) {
  r == null && (r = Nw(e));
  const s = Rw(t, e, n), o = he(s, a(e));
  return ig(o, r);
}
const ZD = /* @__PURE__ */ B({ stft_: YD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JD(t, e, n, r, a = "bilinear", s = 0) {
  const o = C(t, "image", "cropAndResize"), i = C(e, "boxes", "cropAndResize", "float32"), c = C(n, "boxInd", "cropAndResize", "int32"), l = i.shape[0];
  A(o.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`), A(i.rank === 2 && i.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`), A(c.rank === 1 && c.shape[0] === l, () => `Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`), A(r.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`), A(r[0] >= 1 && r[1] >= 1, () => `cropSize must be atleast [1,1], but was ${r}`), A(a === "bilinear" || a === "nearest", () => `method must be bilinear or nearest, but was ${a}`);
  const u = { image: o, boxes: i, boxInd: c }, d = { method: a, extrapolationValue: s, cropSize: r };
  return W.runKernel(Pl, u, d);
}
const QD = /* @__PURE__ */ B({ cropAndResize_: JD });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eO(t) {
  const e = C(t, "image", "flipLeftRight", "float32");
  A(e.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);
  const n = { image: e };
  return W.runKernel(ql, n, {});
}
const tO = /* @__PURE__ */ B({ flipLeftRight_: eO });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nO(t) {
  const e = C(t, "image", "grayscaleToRGB"), n = e.rank - 1, r = e.shape[n];
  A(e.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`), A(r === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);
  const a = new Array(e.rank);
  return a.fill(1, 0, n), a[n] = 3, Hi(e, a);
}
const rO = /* @__PURE__ */ B({ grayscaleToRGB_: nO });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aO(t) {
  const e = C(t, "image", "RGBToGrayscale"), n = e.rank - 1, r = e.shape[n];
  A(e.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`), A(r === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);
  const a = e.dtype, s = zt(e, "float32"), o = xn([0.2989, 0.587, 0.114]);
  let i;
  switch (e.rank) {
    case 2:
      i = po("ij,j->i", s, o);
      break;
    case 3:
      i = po("ijk,k->ij", s, o);
      break;
    case 4:
      i = po("ijkl,l->ijk", s, o);
      break;
    case 5:
      i = po("ijklm,m->ijkl", s, o);
      break;
    case 6:
      i = po("ijklmn,n->ijklm", s, o);
      break;
    default:
      throw new Error("Not a valid tensor rank.");
  }
  return i = Kr(i, -1), zt(i, a);
}
const sO = /* @__PURE__ */ B({ rgbToGrayscale_: aO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oO(t, e, n = 0, r = 0.5) {
  const a = C(t, "image", "rotateWithOffset", "float32");
  A(a.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);
  const s = { image: a }, o = { radians: e, fillValue: n, center: r };
  return W.runKernel(cf, s, o);
}
const iO = /* @__PURE__ */ B({ rotateWithOffset_: oO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ho(t, e, n, r, a, s) {
  r == null && (r = 0.5), a == null && (a = Number.NEGATIVE_INFINITY), s == null && (s = 0);
  const o = t.shape[0];
  return n = Math.min(n, o), A(0 <= r && r <= 1, () => `iouThreshold must be in [0, 1], but was '${r}'`), A(t.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${t.rank}'`), A(t.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`), A(e.rank === 1, () => "scores must be a 1D tensor"), A(e.shape[0] === o, () => `scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`), A(0 <= s && s <= 1, () => `softNmsSigma must be in [0, 1], but was '${s}'`), { maxOutputSize: n, iouThreshold: r, scoreThreshold: a, softNmsSigma: s };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uO(t, e, n, r = 0.5, a = Number.NEGATIVE_INFINITY) {
  const s = C(t, "boxes", "nonMaxSuppression", "float32"), o = C(e, "scores", "nonMaxSuppression", "float32"), i = Ho(s, o, n, r, a);
  n = i.maxOutputSize, r = i.iouThreshold, a = i.scoreThreshold;
  const c = { maxOutputSize: n, iouThreshold: r, scoreThreshold: a };
  return W.runKernel(kd, { boxes: s, scores: o }, c);
}
const cO = /* @__PURE__ */ B({ nonMaxSuppression_: uO });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lO(t, e, n) {
  const r = dO(t, e, n), a = r < 0 ? -(r + 1) : r;
  t.splice(a, 0, e);
}
function dO(t, e, n) {
  return pO(t, e, n || fO);
}
function fO(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function pO(t, e, n) {
  let r = 0, a = t.length, s = 0, o = !1;
  for (; r < a; ) {
    s = r + (a - r >>> 1);
    const i = n(e, t[s]);
    i > 0 ? r = s + 1 : (a = s, o = !i);
  }
  return o ? r : -r - 1;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $w(t, e, n, r, a) {
  return pg(
    t,
    e,
    n,
    r,
    a,
    0
    /* softNmsSigma */
  );
}
function Dw(t, e, n, r, a, s) {
  return pg(
    t,
    e,
    n,
    r,
    a,
    0,
    !1,
    s,
    !0
    /* returnValidOutputs */
  );
}
function Ow(t, e, n, r, a, s) {
  return pg(
    t,
    e,
    n,
    r,
    a,
    s,
    !0
    /* returnScoresTensor */
  );
}
function pg(t, e, n, r, a, s, o = !1, i = !1, c = !1) {
  const l = [];
  for (let g = 0; g < e.length; g++)
    e[g] > a && l.push({ score: e[g], boxIndex: g, suppressBeginIndex: 0 });
  l.sort(nv);
  const u = s > 0 ? -0.5 / s : 0, d = [], f = [];
  for (; d.length < n && l.length > 0; ) {
    const g = l.pop(), { score: v, boxIndex: b, suppressBeginIndex: w } = g;
    if (v < a)
      break;
    let S = !1;
    for (let I = d.length - 1; I >= w; --I) {
      const E = hO(t, b, d[I]);
      if (E >= r) {
        S = !0;
        break;
      }
      if (g.score = g.score * mO(r, u, E), g.score <= a)
        break;
    }
    g.suppressBeginIndex = d.length, S || (g.score === v ? (d.push(b), f.push(g.score)) : g.score > a && lO(l, g, nv));
  }
  const p = d.length, h = n - p;
  i && h > 0 && (d.push(...new Array(h).fill(0)), f.push(...new Array(h).fill(0)));
  const m = { selectedIndices: d };
  return o && (m.selectedScores = f), c && (m.validOutputs = p), m;
}
function hO(t, e, n) {
  const r = t.subarray(e * 4, e * 4 + 4), a = t.subarray(n * 4, n * 4 + 4), s = Math.min(r[0], r[2]), o = Math.min(r[1], r[3]), i = Math.max(r[0], r[2]), c = Math.max(r[1], r[3]), l = Math.min(a[0], a[2]), u = Math.min(a[1], a[3]), d = Math.max(a[0], a[2]), f = Math.max(a[1], a[3]), p = (i - s) * (c - o), h = (d - l) * (f - u);
  if (p <= 0 || h <= 0)
    return 0;
  const m = Math.max(s, l), g = Math.max(o, u), v = Math.min(i, d), b = Math.min(c, f), w = Math.max(v - m, 0) * Math.max(b - g, 0);
  return w / (p + h - w);
}
function mO(t, e, n) {
  const r = Math.exp(e * n * n);
  return n <= t ? r : 0;
}
function nv(t, e) {
  return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function gO(t, e, n, r = 0.5, a = Number.NEGATIVE_INFINITY) {
  const s = C(t, "boxes", "nonMaxSuppressionAsync"), o = C(e, "scores", "nonMaxSuppressionAsync"), i = Ho(s, o, n, r, a);
  n = i.maxOutputSize, r = i.iouThreshold, a = i.scoreThreshold;
  const c = await Promise.all([s.data(), o.data()]), l = c[0], u = c[1], { selectedIndices: d } = $w(l, u, n, r, a);
  return s !== t && s.dispose(), o !== e && o.dispose(), xn(d, "int32");
}
const yO = gO;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vO(t, e, n, r = 0.5, a = Number.NEGATIVE_INFINITY, s = 0) {
  const o = C(t, "boxes", "nonMaxSuppression"), i = C(e, "scores", "nonMaxSuppression"), c = Ho(o, i, n, r, a, s);
  n = c.maxOutputSize, r = c.iouThreshold, a = c.scoreThreshold, s = c.softNmsSigma;
  const l = { boxes: o, scores: i }, u = { maxOutputSize: n, iouThreshold: r, scoreThreshold: a, softNmsSigma: s }, d = W.runKernel(Td, l, u);
  return { selectedIndices: d[0], selectedScores: d[1] };
}
const bO = /* @__PURE__ */ B({ nonMaxSuppressionWithScore_: vO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function wO(t, e, n, r = 0.5, a = Number.NEGATIVE_INFINITY, s = 0) {
  const o = C(t, "boxes", "nonMaxSuppressionAsync"), i = C(e, "scores", "nonMaxSuppressionAsync"), c = Ho(o, i, n, r, a, s);
  n = c.maxOutputSize, r = c.iouThreshold, a = c.scoreThreshold, s = c.softNmsSigma;
  const l = await Promise.all([o.data(), i.data()]), u = l[0], d = l[1], { selectedIndices: f, selectedScores: p } = Ow(u, d, n, r, a, s);
  return o !== t && o.dispose(), i !== e && i.dispose(), {
    selectedIndices: xn(f, "int32"),
    selectedScores: xn(p)
  };
}
const SO = wO;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _O(t, e, n, r = 0.5, a = Number.NEGATIVE_INFINITY, s = !1) {
  const o = C(t, "boxes", "nonMaxSuppression"), i = C(e, "scores", "nonMaxSuppression"), c = Ho(
    o,
    i,
    n,
    r,
    a,
    null
    /* softNmsSigma */
  ), l = c.maxOutputSize, u = c.iouThreshold, d = c.scoreThreshold, f = { boxes: o, scores: i }, p = {
    maxOutputSize: l,
    iouThreshold: u,
    scoreThreshold: d,
    padToMaxOutputSize: s
  }, h = W.runKernel(Ed, f, p);
  return { selectedIndices: h[0], validOutputs: h[1] };
}
const xO = /* @__PURE__ */ B({ nonMaxSuppressionPadded_: _O });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function IO(t, e, n, r = 0.5, a = Number.NEGATIVE_INFINITY, s = !1) {
  const o = C(t, "boxes", "nonMaxSuppressionAsync"), i = C(e, "scores", "nonMaxSuppressionAsync"), c = Ho(
    o,
    i,
    n,
    r,
    a,
    null
    /* softNmsSigma */
  ), l = c.maxOutputSize, u = c.iouThreshold, d = c.scoreThreshold, [f, p] = await Promise.all([o.data(), i.data()]), { selectedIndices: h, validOutputs: m } = Dw(f, p, l, u, d, s);
  return o !== t && o.dispose(), i !== e && i.dispose(), {
    selectedIndices: xn(h, "int32"),
    validOutputs: ut(m, "int32")
  };
}
const kO = IO;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EO(t, e, n = !1, r = !1) {
  const a = C(t, "images", "resizeBilinear");
  A(a.rank === 3 || a.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`), A(e.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${e}.`), A(r === !1 || n === !1, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
  let s = a, o = !1;
  a.rank === 3 && (o = !0, s = ae(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
  const i = { images: s }, c = { alignCorners: n, halfPixelCenters: r, size: e }, l = W.runKernel(Md, i, c);
  return o ? ae(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
}
const TO = /* @__PURE__ */ B({ resizeBilinear_: EO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CO(t, e, n = !1, r = !1) {
  const a = C(t, "images", "resizeNearestNeighbor");
  A(a.rank === 3 || a.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`), A(e.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`), A(a.dtype === "float32" || a.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), A(r === !1 || n === !1, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
  let s = a, o = !1;
  a.rank === 3 && (o = !0, s = ae(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
  const i = { images: s }, c = { alignCorners: n, halfPixelCenters: r, size: e }, l = W.runKernel(Fd, i, c);
  return o ? ae(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
}
const NO = /* @__PURE__ */ B({ resizeNearestNeighbor_: CO });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AO(t, e = "binary", n = !1, r = 0.5) {
  const a = C(t, "image", "threshold"), s = 0.2989, o = 0.587, i = 0.114, c = a.shape[0] * a.shape[1];
  let l = he(xn([r]), 255), u, d, f, p;
  if (A(a.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${a.rank}.`), A(a.shape[2] === 3 || a.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`), A(a.dtype === "int32" || a.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`), A(e === "otsu" || e === "binary", () => `Method must be binary or otsu, but was ${e}`), a.shape[2] === 3) {
    [u, d, f] = du(a, [1, 1, 1], -1);
    const g = he(u, s), v = he(d, o), b = he(f, i);
    p = Ae(Ae(g, v), b);
  } else
    p = t;
  if (e === "otsu") {
    const g = Y1(zt(Sw(p), "int32"), Mr([]), 256);
    l = RO(g, c);
  }
  const h = n ? Ym(p, l) : mf(p, l);
  return zt(he(h, 255), "int32");
}
function RO(t, e) {
  let n = xn([-1]), r = xn([0]), a = xn([0]), s, o, i, c, l, u;
  for (let d = 0; d < t.size - 1; d++) {
    s = qe(t, 0, d + 1), o = qe(t, d + 1), l = Ze(Dt(s), e), u = Ze(Dt(o), e);
    const f = Dt(he(s, cu(0, s.size)));
    i = Ze(f, Dt(s));
    const p = Ru(o.shape, s.size), h = Ae(cu(0, o.size), p), m = he(o, h);
    c = Ze(Dt(m), Dt(o));
    const g = Ke(i, c), v = Ke(i, c), b = he(l, u);
    a = he(he(b, g), v);
    const w = mf(a, r);
    r = za(w, a, r), n = za(w, xn([d]), n);
  }
  return n;
}
const $O = /* @__PURE__ */ B({ threshold_: AO });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DO(t, e, n = "nearest", r = "constant", a = 0, s) {
  const o = C(t, "image", "transform", "float32"), i = C(e, "transforms", "transform", "float32");
  A(o.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${o.rank}.`), A(i.rank === 2 && (i.shape[0] === o.shape[0] || i.shape[0] === 1) && i.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), A(s == null || s.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${s}.`);
  const c = { image: o, transforms: i }, l = { interpolation: n, fillMode: r, fillValue: a, outputShape: s };
  return W.runKernel(uf, c, l);
}
const OO = /* @__PURE__ */ B({ transform_: DO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FO(t, e, n) {
  const r = C(t, "a", "bandPart");
  A(r.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${r.rank}.`);
  const a = r.shape, [s, o] = r.shape.slice(-2);
  let i, c;
  typeof e == "number" ? (A(e % 1 === 0, () => `bandPart(): numLower must be an integer, got ${e}.`), A(e <= s, () => `bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`), i = C(e < 0 ? s : e, "numLower", "bandPart")) : (A(e.dtype === "int32", () => "bandPart(): numLower's dtype must be an int32."), i = za(nh(e, 0), s, jc(e, s))), typeof n == "number" ? (A(n % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${n}.`), A(n <= o, () => `bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`), c = C(n < 0 ? o : n, "numUpper", "bandPart")) : (A(n.dtype === "int32", () => "bandPart(): numUpper's dtype must be an int32."), c = za(nh(n, 0), o, jc(n, o)));
  const l = ae(cu(0, s, 1, "int32"), [-1, 1]), u = cu(0, o, 1, "int32"), d = Ke(l, u), f = Vc(Ym(d, i), ow(d, Jr(c))), p = Co([s, o], r.dtype);
  return ae(ba(qs(ae(r, [-1, s, o])).map((h) => za(f, h, p))), a);
}
const MO = /* @__PURE__ */ B({ bandPart_: FO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PO(t) {
  let e;
  if (Array.isArray(t)) {
    e = !1, A(t != null && t.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
    const a = t[0].shape[0];
    for (let s = 1; s < t.length; ++s)
      A(t[s].shape[0] === a, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[s].shape[0]} vs. ${a})`);
  } else
    e = !0, t = du(t, t.shape[0], 0).map((a) => hn(a, [0]));
  A(t.length <= t[0].shape[0], () => `Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);
  const n = [], r = t;
  for (let a = 0; a < t.length; ++a)
    n.push(W.tidy(() => {
      let s = r[a];
      if (a > 0)
        for (let o = 0; o < a; ++o) {
          const i = he(Dt(he(n[o], s)), n[o]);
          s = Ke(s, i);
        }
      return Ze(s, hf(s, "euclidean"));
    }));
  return e ? ba(n, 0) : n;
}
const BO = /* @__PURE__ */ B({ gramSchmidt_: PO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LO(t, e = !1) {
  if (A(t.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`), t.rank === 2)
    return rv(t, e);
  {
    const n = t.shape.slice(0, t.shape.length - 2).reduce((c, l) => c * l), r = qs(ae(t, [
      n,
      t.shape[t.shape.length - 2],
      t.shape[t.shape.length - 1]
    ]), 0), a = [], s = [];
    r.forEach((c) => {
      const [l, u] = rv(c, e);
      a.push(l), s.push(u);
    });
    const o = ae(ba(a, 0), t.shape), i = ae(ba(s, 0), t.shape);
    return [o, i];
  }
}
function rv(t, e = !1) {
  return W.tidy(() => {
    A(t.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);
    const n = t.shape[0], r = t.shape[1];
    let a = rw(n), s = Wa(t);
    const o = Ns([[1]], [1, 1]);
    let i = Wa(o);
    const c = n >= r ? r : n;
    for (let l = 0; l < c; ++l) {
      const u = s, d = i, f = a;
      [i, s, a] = W.tidy(() => {
        const p = qe(s, [l, l], [n - l, 1]), h = hf(p), m = qe(s, [l, l], [1, 1]), g = za(mf(m, 0), Ns([[-1]]), Ns([[1]])), v = Ke(m, he(g, h)), b = Ze(p, v);
        b.shape[0] === 1 ? i = Wa(o) : i = yn([
          o,
          qe(b, [1, 0], [b.shape[0] - 1, b.shape[1]])
        ], 0);
        const w = Jr(Ze(wt(g, v), h)), S = qe(s, [l, 0], [n - l, r]), I = he(w, i), E = rh(i);
        if (l === 0)
          s = Ke(S, wt(I, wt(E, S)));
        else {
          const $ = Ke(S, wt(I, wt(E, S)));
          s = yn([qe(s, [0, 0], [l, r]), $], 0);
        }
        const T = rh(I), R = qe(a, [0, l], [n, a.shape[1] - l]);
        if (l === 0)
          a = Ke(R, wt(wt(R, i), T));
        else {
          const $ = Ke(R, wt(wt(R, i), T));
          a = yn([qe(a, [0, 0], [n, l]), $], 1);
        }
        return [i, s, a];
      }), un([u, d, f]);
    }
    return !e && n > r && (a = qe(a, [0, 0], [n, r]), s = qe(s, [0, 0], [r, r])), [a, s];
  });
}
const WO = /* @__PURE__ */ B({ qr_: LO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Hn;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Hn || (Hn = {}));
function zO(t, e, n = Hn.SUM_BY_NONZERO_WEIGHTS) {
  const r = C(t, "losses", "computeWeightedLoss");
  let a = null;
  e != null && (a = C(e, "weights", "computeWeightedLoss"));
  const s = a == null ? r : he(r, a);
  if (n === Hn.NONE)
    return s;
  if (n === Hn.SUM)
    return Dt(s);
  if (n === Hn.MEAN) {
    if (a == null)
      return Hc(s);
    {
      const o = r.size / a.size, i = Ze(Dt(s), Dt(a));
      return o > 1 ? Ze(i, ut(o)) : i;
    }
  }
  if (n === Hn.SUM_BY_NONZERO_WEIGHTS) {
    if (a == null)
      return Ze(Dt(s), ut(r.size));
    {
      const o = he(a, ks(r.shape)), i = zt(Dt(mw(o, ut(0))), "float32");
      return Ze(Dt(s), i);
    }
  }
  throw Error(`Unknown reduction: ${n}`);
}
const xa = /* @__PURE__ */ B({ computeWeightedLoss_: zO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VO(t, e, n, r = Hn.SUM_BY_NONZERO_WEIGHTS) {
  const a = C(t, "labels", "absoluteDifference"), s = C(e, "predictions", "absoluteDifference");
  let o = null;
  n != null && (o = C(n, "weights", "absoluteDifference")), ar(a.shape, s.shape, "Error in absoluteDifference: ");
  const i = cr(Ke(a, s));
  return xa(i, o, r);
}
const HO = /* @__PURE__ */ B({ absoluteDifference_: VO });
function jO(t, e, n, r, a = Hn.SUM_BY_NONZERO_WEIGHTS) {
  const s = C(t, "labels", "cosineDistance"), o = C(e, "predictions", "cosineDistance");
  let i = null;
  r != null && (i = C(r, "weights", "cosineDistance")), ar(s.shape, o.shape, "Error in cosineDistance: ");
  const c = ut(1), l = Ke(c, Dt(he(s, o), n, !0));
  return xa(l, i, a);
}
const UO = /* @__PURE__ */ B({ cosineDistance_: jO });
function GO(t, e, n, r = Hn.SUM_BY_NONZERO_WEIGHTS) {
  let a = C(t, "labels", "hingeLoss");
  const s = C(e, "predictions", "hingeLoss");
  let o = null;
  n != null && (o = C(n, "weights", "hingeLoss")), ar(a.shape, s.shape, "Error in hingeLoss: ");
  const i = ut(1);
  a = Ke(he(ut(2), a), i);
  const c = vf(Ke(i, he(a, s)));
  return xa(c, o, r);
}
const qO = /* @__PURE__ */ B({ hingeLoss_: GO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KO(t, e, n, r = 1, a = Hn.SUM_BY_NONZERO_WEIGHTS) {
  const s = C(t, "labels", "huberLoss"), o = C(e, "predictions", "huberLoss");
  let i = null;
  n != null && (i = C(n, "weights", "huberLoss")), ar(s.shape, o.shape, "Error in huberLoss: ");
  const c = ut(r), l = cr(Ke(o, s)), u = jc(l, c), d = Ke(l, u), f = Ae(he(ut(0.5), Pr(u)), he(c, d));
  return xa(f, i, a);
}
const XO = /* @__PURE__ */ B({ huberLoss_: KO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YO(t, e, n, r = 1e-7, a = Hn.SUM_BY_NONZERO_WEIGHTS) {
  const s = C(t, "labels", "logLoss"), o = C(e, "predictions", "logLoss");
  let i = null;
  n != null && (i = C(n, "weights", "logLoss")), ar(s.shape, o.shape, "Error in logLoss: ");
  const c = ut(1), l = ut(r), u = Jr(he(s, uu(Ae(o, l)))), d = he(Ke(c, s), uu(Ae(Ke(c, o), l))), f = Ke(u, d);
  return xa(f, i, a);
}
const ZO = /* @__PURE__ */ B({ logLoss_: YO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JO(t, e, n, r = Hn.SUM_BY_NONZERO_WEIGHTS) {
  const a = C(t, "labels", "meanSquaredError"), s = C(e, "predictions", "meanSquaredError");
  let o = null;
  n != null && (o = C(n, "weights", "meanSquaredError")), ar(a.shape, s.shape, "Error in meanSquaredError: ");
  const i = xw(a, s);
  return xa(i, o, r);
}
const QO = /* @__PURE__ */ B({ meanSquaredError_: JO });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eF(t, e) {
  const n = C(t, "labels", "sigmoidCrossEntropyWithLogits"), r = C(e, "logits", "sigmoidCrossEntropyWithLogits");
  ar(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
  const a = vf(r), s = he(r, n), o = uw(ya(Jr(cr(r))));
  return Ae(Ke(a, s), o);
}
function tF(t, e, n, r = 0, a = Hn.SUM_BY_NONZERO_WEIGHTS) {
  let s = C(t, "multiClassLabels", "sigmoidCrossEntropy");
  const o = C(e, "logits", "sigmoidCrossEntropy");
  let i = null;
  if (n != null && (i = C(n, "weights", "sigmoidCrossEntropy")), ar(s.shape, o.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
    const l = ut(r), u = ut(1), d = ut(0.5);
    s = Ae(he(s, Ke(u, l)), he(d, l));
  }
  const c = eF(s, o);
  return xa(c, i, a);
}
const nF = /* @__PURE__ */ B({ sigmoidCrossEntropy_: tF });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rF(t, e, n = -1) {
  if (n === -1 && (n = e.rank - 1), n !== e.rank - 1)
    throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);
  return va((a, s, o) => {
    const c = lw(s, [n], !0), l = Ke(zt(s, "float32"), c);
    o([a, l]);
    const u = Jr(he(l, a));
    return { value: Dt(u, [n]), gradFunc: (p, h) => {
      const [m, g] = h, v = vn(p.shape, [n]);
      return [
        he(ae(p, v), Ke(zt(m, "float32"), ya(g))),
        he(ae(p, v), Ke(ya(g), zt(m, "float32")))
      ];
    } };
  })(t, e);
}
function aF(t, e, n, r = 0, a = Hn.SUM_BY_NONZERO_WEIGHTS) {
  let s = C(t, "onehotLabels", "softmaxCrossEntropy");
  const o = C(e, "logits", "softmaxCrossEntropy");
  let i = null;
  if (n != null && (i = C(n, "weights", "softmaxCrossEntropy")), ar(s.shape, o.shape, "Error in softmaxCrossEntropy: "), r > 0) {
    const l = ut(r), u = ut(1), d = ut(s.shape[1]);
    s = Ae(he(s, Ke(u, l)), Ze(l, d));
  }
  const c = rF(s, o);
  return xa(c, i, a);
}
const sF = /* @__PURE__ */ B({ softmaxCrossEntropy_: aF });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oF(t, e, n, r) {
  const a = C(t, "indices", "sparseFillEmptyRows", "int32"), s = C(e, "values", "sparseFillEmptyRows"), o = C(n, "denseShape", "sparseFillEmptyRows", "int32"), i = C(r, "defaultValue", "sparseFillEmptyRows", s.dtype);
  if (a.rank !== 2)
    throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);
  if (s.rank !== 1)
    throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);
  if (o.rank !== 1)
    throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);
  if (i.rank !== 0)
    throw new Error(`Default value should be a scalar but received shape ${i.shape}`);
  const c = {
    indices: a,
    values: s,
    denseShape: o,
    defaultValue: i
  }, l = W.runKernel(Fm, c);
  return {
    outputIndices: l[0],
    outputValues: l[1],
    emptyRowIndicator: l[2],
    reverseIndexMap: l[3]
  };
}
const iF = /* @__PURE__ */ B({ sparseFillEmptyRows_: oF });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uF(t, e, n) {
  const r = C(t, "inputIndices", "sparseReshape", "int32"), a = C(e, "inputShape", "sparseReshape", "int32"), s = C(n, "newShape", "sparseReshape", "int32");
  if (r.rank !== 2)
    throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);
  if (a.rank !== 1)
    throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);
  if (s.rank !== 1)
    throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);
  const o = {
    inputIndices: r,
    inputShape: a,
    newShape: s
  }, i = W.runKernel(Qd, o);
  return { outputIndices: i[0], outputShape: i[1] };
}
const cF = /* @__PURE__ */ B({ sparseReshape_: uF });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lF(t, e, n) {
  const r = C(t, "data", "sparseSegmentMean"), a = C(e, "indices", "sparseSegmentMean", "int32"), s = C(n, "segmentIds", "sparseSegmentMean", "int32");
  if (r.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (a.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);
  if (s.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);
  const o = {
    data: r,
    indices: a,
    segmentIds: s
  };
  return W.runKernel(Mm, o);
}
const dF = /* @__PURE__ */ B({ sparseSegmentMean_: lF });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fF(t, e, n) {
  const r = C(t, "data", "sparseSegmentSum"), a = C(e, "indices", "sparseSegmentSum", "int32"), s = C(n, "segmentIds", "sparseSegmentSum", "int32");
  if (r.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (a.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);
  if (s.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);
  const o = {
    data: r,
    indices: a,
    segmentIds: s
  };
  return W.runKernel(Pm, o);
}
const pF = /* @__PURE__ */ B({ sparseSegmentSum_: fF });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hF(t, e, n, r, a, s, o, i) {
  const c = C(t, "data", "stringNGrams", "string");
  if (c.dtype !== "string")
    throw new Error("Data must be of datatype string");
  if (c.shape.length !== 1)
    throw new Error(`Data must be a vector, saw: ${c.shape}`);
  const l = C(e, "dataSplits", "stringNGrams");
  if (l.dtype !== "int32")
    throw new Error("Data splits must be of datatype int32");
  const u = {
    separator: n,
    nGramWidths: r,
    leftPad: a,
    rightPad: s,
    padWidth: o,
    preserveShortSequences: i
  }, d = { data: c, dataSplits: l }, f = W.runKernel(Lm, d, u);
  return { nGrams: f[0], nGramsSplits: f[1] };
}
const mF = /* @__PURE__ */ B({ stringNGrams_: hF });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gF(t, e, n = !0) {
  const r = C(t, "input", "stringSplit", "string"), a = C(e, "delimiter", "stringSplit", "string");
  if (r.rank !== 1)
    throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);
  if (a.rank !== 0)
    throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);
  const s = { skipEmpty: n }, o = { input: r, delimiter: a }, i = W.runKernel(Wm, o, s);
  return { indices: i[0], values: i[1], shape: i[2] };
}
const yF = /* @__PURE__ */ B({ stringSplit_: gF });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vF(t, e) {
  const n = C(t, "input", "stringToHashBucketFast", "string"), r = { numBuckets: e };
  if (e <= 0)
    throw new Error("Number of buckets must be at least 1");
  const a = { input: n };
  return W.runKernel(zm, a, r);
}
const bF = /* @__PURE__ */ B({ stringToHashBucketFast_: vF });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wF(t, e, n, r = !0) {
  const a = C(t, "input", "staticRegexReplace", "string"), s = { pattern: e, rewrite: n, replaceGlobal: r };
  return W.runKernel(Bm, { x: a }, s);
}
const SF = /* @__PURE__ */ B({ staticRegexReplace_: wF });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _F = {
  fft: og,
  ifft: Uc,
  rfft: ig,
  irfft: _w
}, xF = {
  hammingWindow: qD,
  hannWindow: Aw,
  frame: Rw,
  stft: ZD
}, bf = {
  flipLeftRight: tO,
  grayscaleToRGB: rO,
  resizeNearestNeighbor: NO,
  resizeBilinear: TO,
  rgbToGrayscale: sO,
  rotateWithOffset: iO,
  cropAndResize: QD,
  nonMaxSuppression: cO,
  nonMaxSuppressionAsync: yO,
  nonMaxSuppressionWithScore: bO,
  nonMaxSuppressionWithScoreAsync: SO,
  nonMaxSuppressionPadded: xO,
  nonMaxSuppressionPaddedAsync: kO,
  threshold: $O,
  transform: OO
}, IF = {
  bandPart: MO,
  gramSchmidt: BO,
  qr: WO
}, kF = {
  absoluteDifference: HO,
  computeWeightedLoss: xa,
  cosineDistance: UO,
  hingeLoss: qO,
  huberLoss: XO,
  logLoss: ZO,
  meanSquaredError: QO,
  sigmoidCrossEntropy: nF,
  softmaxCrossEntropy: sF
}, EF = {
  sparseFillEmptyRows: iF,
  sparseReshape: cF,
  sparseSegmentMean: dF,
  sparseSegmentSum: pF
}, TF = {
  stringNGrams: mF,
  stringSplit: yF,
  stringToHashBucketFast: bF,
  staticRegexReplace: SF
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CF = /* @__PURE__ */ new Map(), NF = /* @__PURE__ */ new Map();
class AF {
  /**
   * Return the class name for this class to use in serialization contexts.
   *
   * Generally speaking this will be the same thing that constructor.name
   * would have returned.  However, the class name needs to be robust
   * against minification for serialization/deserialization to work properly.
   *
   * There's also places such as initializers.VarianceScaling, where
   * implementation details between different languages led to different
   * class hierarchies and a non-leaf node is used for serialization purposes.
   */
  getClassName() {
    return this.constructor.className;
  }
  /**
   * Creates an instance of T from a ConfigDict.
   *
   * This works for most descendants of serializable.  A few need to
   * provide special handling.
   * @param cls A Constructor for the class to instantiate.
   * @param config The Configuration for the object.
   */
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n);
  }
}
class Ss {
  constructor() {
    this.classNameMap = {};
  }
  /**
   * Returns the singleton instance of the map.
   */
  static getMap() {
    return Ss.instance == null && (Ss.instance = new Ss()), Ss.instance;
  }
  /**
   * Registers the class as serializable.
   */
  static register(e) {
    Ss.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }
}
function RF(t, e, n) {
  A(t.className != null, () => "Class being registered does not have the static className property defined."), A(typeof t.className == "string", () => "className is required to be a string, but got type " + typeof t.className), A(t.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), typeof e > "u" && (e = "Custom"), typeof n > "u" && (n = t.className);
  const r = n, a = e + ">" + r;
  return Ss.register(t), CF.set(a, t), NF.set(t, a), t;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ks extends AF {
  /**
   * Executes `f()` and minimizes the scalar output of `f()` by computing
   * gradients of y with respect to the list of trainable variables provided by
   * `varList`. If no list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to minimize.
   * @param returnCost Whether to return the scalar cost value produced by
   * executing `f()`.
   * @param varList An optional list of variables to update. If specified, only
   * the trainable variables in varList will be updated by minimize. Defaults to
   * all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  minimize(e, n = !1, r) {
    const { value: a, grads: s } = this.computeGradients(e, r);
    if (r != null) {
      const o = r.map((i) => ({ name: i.name, tensor: s[i.name] }));
      this.applyGradients(o);
    } else
      this.applyGradients(s);
    return un(s), n ? a : (a.dispose(), null);
  }
  /**
   * The number of iterations that this optimizer instance has been invoked for.
   */
  get iterations() {
    return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
  }
  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }
  /**
   * Executes f() and computes the gradient of the scalar output of f() with
   * respect to the list of trainable variables provided by `varList`. If no
   * list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to use for computing
   * gradients with respect to variables.
   * @param varList An optional list of variables to compute gradients with
   * respect to. If specified, only the trainable variables in varList will have
   * gradients computed with respect to. Defaults to all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  computeGradients(e, n) {
    return g4(e, n);
  }
  /**
   * Dispose the variables (if any) owned by this optimizer instance.
   */
  dispose() {
    this.iterations_ != null && un(this.iterations_);
  }
  async saveIterations() {
    return this.iterations_ == null && (this.iterations_ = 0), {
      name: "iter",
      // TODO(cais): Use 'int64' type when available.
      tensor: ut(this.iterations_, "int32")
    };
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for this optimizer yet.");
  }
  async setWeights(e) {
    throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
  }
  /**
   * Extract the first element of the weight values and set it
   * as the iterations counter variable of this instance of optimizer.
   *
   * @param weightValues
   * @returns Weight values with the first element consumed and excluded.
   */
  async extractIterations(e) {
    return this.iterations_ = (await e[0].tensor.data())[0], e.slice(1);
  }
}
Object.defineProperty(Ks, Symbol.hasInstance, {
  value: (t) => t.minimize != null && t.computeGradients != null && t.applyGradients != null
});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class $F extends Ks {
  /** @nocollapse */
  static get className() {
    return "Adadelta";
  }
  constructor(e, n, r = null) {
    super(), this.learningRate = e, this.rho = n, this.epsilon = r, this.accumulatedGrads = [], this.accumulatedUpdates = [], r == null && (this.epsilon = W.backend.epsilon());
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, a) => {
      const s = W.registeredVariables[r], o = !1;
      this.accumulatedGrads[a] == null && (this.accumulatedGrads[a] = {
        originalName: `${r}/accum_grad`,
        variable: Je(() => lr(s).variable(o))
      }), this.accumulatedUpdates[a] == null && (this.accumulatedUpdates[a] = {
        originalName: `${r}/accum_var`,
        variable: Je(() => lr(s).variable(o))
      });
      const i = Array.isArray(e) ? e[a].tensor : e[r];
      if (i == null)
        return;
      const c = this.accumulatedGrads[a].variable, l = this.accumulatedUpdates[a].variable;
      Je(() => {
        const u = Ae(he(c, this.rho), he(Pr(i), 1 - this.rho)), d = he(Ze(ga(Ae(l, this.epsilon)), ga(Ae(c, this.epsilon))), i), f = Ae(he(l, this.rho), he(Pr(d), 1 - this.rho));
        c.assign(u), l.assign(f);
        const p = Ae(he(d, -this.learningRate), s);
        s.assign(p);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedUpdates != null && (un(this.accumulatedGrads.map((e) => e.variable)), un(this.accumulatedUpdates.map((e) => e.variable)));
  }
  async getWeights() {
    const e = [...this.accumulatedGrads, ...this.accumulatedUpdates];
    return [await this.saveIterations()].concat(e.map((n) => ({ name: n.originalName, tensor: n.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = e.length / 2, r = !1;
    this.accumulatedGrads = e.slice(0, n).map((a) => ({
      originalName: a.name,
      variable: a.tensor.variable(r)
    })), this.accumulatedUpdates = e.slice(n, n * 2).map((a) => ({
      originalName: a.name,
      variable: a.tensor.variable(r)
    }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.rho, n.epsilon);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DF extends Ks {
  /** @nocollapse */
  static get className() {
    return "Adagrad";
  }
  constructor(e, n = 0.1) {
    super(), this.learningRate = e, this.initialAccumulatorValue = n, this.accumulatedGrads = [];
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, a) => {
      const s = W.registeredVariables[r];
      this.accumulatedGrads[a] == null && (this.accumulatedGrads[a] = {
        originalName: `${r}/accumulator`,
        variable: Je(() => Ru(s.shape, this.initialAccumulatorValue).variable(!1))
      });
      const o = Array.isArray(e) ? e[a].tensor : e[r];
      if (o == null)
        return;
      const i = this.accumulatedGrads[a].variable;
      Je(() => {
        const c = Ae(i, Pr(o));
        i.assign(c);
        const l = Ae(he(Ze(o, ga(Ae(c, W.backend.epsilon()))), -this.learningRate), s);
        s.assign(l);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedGrads != null && un(this.accumulatedGrads.map((e) => e.variable));
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulatedGrads.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = !1;
    this.accumulatedGrads = e.map((r) => ({ originalName: r.name, variable: r.tensor.variable(n) }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.initialAccumulatorValue);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OF extends Ks {
  /** @nocollapse */
  static get className() {
    return "Adam";
  }
  constructor(e, n, r, a = null) {
    super(), this.learningRate = e, this.beta1 = n, this.beta2 = r, this.epsilon = a, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], Je(() => {
      this.accBeta1 = ut(n).variable(), this.accBeta2 = ut(r).variable();
    }), a == null && (this.epsilon = W.backend.epsilon());
  }
  applyGradients(e) {
    const n = Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e);
    Je(() => {
      const r = Ke(1, this.accBeta1), a = Ke(1, this.accBeta2);
      n.forEach((s, o) => {
        const i = W.registeredVariables[s], c = !1;
        this.accumulatedFirstMoment[o] == null && (this.accumulatedFirstMoment[o] = {
          originalName: `${s}/m`,
          variable: Je(() => lr(i).variable(c))
        }), this.accumulatedSecondMoment[o] == null && (this.accumulatedSecondMoment[o] = {
          originalName: `${s}/v`,
          variable: Je(() => lr(i).variable(c))
        });
        const l = Array.isArray(e) ? e[o].tensor : e[s];
        if (l == null)
          return;
        const u = this.accumulatedFirstMoment[o].variable, d = this.accumulatedSecondMoment[o].variable, f = Ae(he(u, this.beta1), he(l, 1 - this.beta1)), p = Ae(he(d, this.beta2), he(Pr(l), 1 - this.beta2)), h = Ze(f, r), m = Ze(p, a);
        u.assign(f), d.assign(p);
        const g = Ae(he(Ze(h, Ae(ga(m), this.epsilon)), -this.learningRate), i);
        i.assign(g);
      }), this.accBeta1.assign(he(this.accBeta1, this.beta1)), this.accBeta2.assign(he(this.accBeta2, this.beta2));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && un(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedSecondMoment != null && un(this.accumulatedSecondMoment.map((e) => e.variable));
  }
  async getWeights() {
    const e = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
    return [await this.saveIterations()].concat(e.map((n) => ({ name: n.originalName, tensor: n.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e), Je(() => {
      this.accBeta1.assign(iu(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(iu(this.beta2, this.iterations_ + 1));
    });
    const n = e.length / 2, r = !1;
    this.accumulatedFirstMoment = e.slice(0, n).map((a) => ({
      originalName: a.name,
      variable: a.tensor.variable(r)
    })), this.accumulatedSecondMoment = e.slice(n, n * 2).map((a) => ({
      originalName: a.name,
      variable: a.tensor.variable(r)
    }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.beta1, n.beta2, n.epsilon);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class FF extends Ks {
  /** @nocollapse */
  static get className() {
    return "Adamax";
  }
  constructor(e, n, r, a = null, s = 0) {
    super(), this.learningRate = e, this.beta1 = n, this.beta2 = r, this.epsilon = a, this.decay = s, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], Je(() => {
      this.iteration = ut(0).variable(), this.accBeta1 = ut(n).variable();
    }), a == null && (this.epsilon = W.backend.epsilon());
  }
  applyGradients(e) {
    const n = Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e);
    Je(() => {
      const r = Ke(1, this.accBeta1), a = Ze(-this.learningRate, Ae(he(this.iteration, this.decay), 1));
      n.forEach((s, o) => {
        const i = W.registeredVariables[s], c = !1;
        this.accumulatedFirstMoment[o] == null && (this.accumulatedFirstMoment[o] = {
          originalName: `${s}/m`,
          variable: lr(i).variable(c)
        }), this.accumulatedWeightedInfNorm[o] == null && (this.accumulatedWeightedInfNorm[o] = {
          originalName: `${s}/v`,
          variable: lr(i).variable(c)
        });
        const l = Array.isArray(e) ? e[o].tensor : e[s];
        if (l == null)
          return;
        const u = this.accumulatedFirstMoment[o].variable, d = this.accumulatedWeightedInfNorm[o].variable, f = Ae(he(u, this.beta1), he(l, 1 - this.beta1)), p = he(d, this.beta2), h = cr(l), m = hw(p, h);
        u.assign(f), d.assign(m);
        const g = Ae(he(Ze(a, r), Ze(f, Ae(m, this.epsilon))), i);
        i.assign(g);
      }), this.iteration.assign(Ae(this.iteration, 1)), this.accBeta1.assign(he(this.accBeta1, this.beta1));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && un(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedWeightedInfNorm != null && un(this.accumulatedWeightedInfNorm.map((e) => e.variable));
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for Adamax yet.");
  }
  async setWeights(e) {
    throw new Error("setWeights() is not implemented for Adamax yet.");
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.beta1, n.beta2, n.epsilon, n.decay);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Fw extends Ks {
  /** @nocollapse */
  static get className() {
    return "SGD";
  }
  constructor(e) {
    super(), this.learningRate = e, this.setLearningRate(e);
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, a) => {
      const s = Array.isArray(e) ? e[a].tensor : e[r];
      if (s == null)
        return;
      const o = W.registeredVariables[r];
      Je(() => {
        const i = Ae(he(this.c, s), o);
        o.assign(i);
      });
    }), this.incrementIterations();
  }
  /**
   * Sets the learning rate of the optimizer.
   */
  setLearningRate(e) {
    this.learningRate = e, this.c != null && this.c.dispose(), this.c = Yr(ut(-e));
  }
  dispose() {
    this.c.dispose();
  }
  async getWeights() {
    return [await this.saveIterations()];
  }
  async setWeights(e) {
    if (e = await this.extractIterations(e), e.length !== 0)
      throw new Error("SGD optimizer does not have settable weights.");
  }
  getConfig() {
    return { learningRate: this.learningRate };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MF extends Fw {
  /** @nocollapse */
  // Name matters for Python compatibility.
  static get className() {
    return "Momentum";
  }
  constructor(e, n, r = !1) {
    super(e), this.learningRate = e, this.momentum = n, this.useNesterov = r, this.accumulations = [], this.m = ut(this.momentum);
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, a) => {
      const s = W.registeredVariables[r];
      this.accumulations[a] == null && (this.accumulations[a] = {
        originalName: `${r}/momentum`,
        variable: Je(() => lr(s).variable(!1))
      });
      const o = this.accumulations[a].variable, i = Array.isArray(e) ? e[a].tensor : e[r];
      i != null && Je(() => {
        let c;
        const l = Ae(he(this.m, o), i);
        this.useNesterov ? c = Ae(he(this.c, Ae(i, he(l, this.m))), s) : c = Ae(he(this.c, l), s), o.assign(l), s.assign(c);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.m.dispose(), this.accumulations != null && un(this.accumulations.map((e) => e.variable));
  }
  /**
   * Sets the momentum of the optimizer.
   *
   * @param momentum
   */
  setMomentum(e) {
    this.momentum = e;
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulations.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = !1;
    this.accumulations = e.map((r) => ({ originalName: r.name, variable: r.tensor.variable(n) }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.momentum, n.useNesterov);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class PF extends Ks {
  /** @nocollapse */
  static get className() {
    return "RMSProp";
  }
  constructor(e, n = 0.9, r = 0, a = null, s = !1) {
    if (super(), this.learningRate = e, this.decay = n, this.momentum = r, this.epsilon = a, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = s, a == null && (this.epsilon = W.backend.epsilon()), e == null)
      throw new Error("learningRate for RMSPropOptimizer must be defined.");
  }
  applyGradients(e) {
    (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, a) => {
      const s = W.registeredVariables[r], o = !1;
      this.accumulatedMeanSquares[a] == null && (this.accumulatedMeanSquares[a] = {
        originalName: `${r}/rms`,
        variable: Je(() => lr(s).variable(o))
      }), this.accumulatedMoments[a] == null && (this.accumulatedMoments[a] = {
        originalName: `${r}/momentum`,
        variable: Je(() => lr(s).variable(o))
      }), this.accumulatedMeanGrads[a] == null && this.centered && (this.accumulatedMeanGrads[a] = {
        originalName: `${r}/mg`,
        variable: Je(() => lr(s).variable(o))
      });
      const i = Array.isArray(e) ? e[a].tensor : e[r];
      if (i == null)
        return;
      const c = this.accumulatedMeanSquares[a].variable, l = this.accumulatedMoments[a].variable;
      Je(() => {
        const u = Ae(he(c, this.decay), he(Pr(i), 1 - this.decay));
        if (this.centered) {
          const d = this.accumulatedMeanGrads[a].variable, f = Ae(he(d, this.decay), he(i, 1 - this.decay)), p = Ze(he(i, this.learningRate), ga(Ke(u, Ae(Pr(f), this.epsilon)))), h = Ae(he(l, this.momentum), p);
          c.assign(u), d.assign(f), l.assign(h);
          const m = Ke(s, h);
          s.assign(m);
        } else {
          const d = Ae(he(c, this.decay), he(Pr(i), 1 - this.decay)), f = Ae(he(l, this.momentum), Ze(he(i, this.learningRate), ga(Ae(d, this.epsilon))));
          c.assign(d), l.assign(f);
          const p = Ke(s, f);
          s.assign(p);
        }
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedMeanSquares != null && un(this.accumulatedMeanSquares.map((e) => e.variable)), this.accumulatedMeanGrads != null && this.centered && un(this.accumulatedMeanGrads.map((e) => e.variable)), this.accumulatedMoments != null && un(this.accumulatedMoments.map((e) => e.variable));
  }
  async getWeights() {
    const e = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
    return this.centered && e.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(e.map((n) => ({ name: n.originalName, tensor: n.variable })));
  }
  async setWeights(e) {
    e = await this.extractIterations(e);
    const n = this.centered ? e.length / 3 : e.length / 2, r = !1;
    this.accumulatedMeanSquares = e.slice(0, n).map((a) => ({
      originalName: a.name,
      variable: a.tensor.variable(r)
    })), this.accumulatedMoments = e.slice(n, n * 2).map((a) => ({
      originalName: a.name,
      variable: a.tensor.variable(r)
    })), this.centered && (this.accumulatedMeanGrads = e.slice(n * 2, n * 3).map((a) => ({
      originalName: a.name,
      variable: a.tensor.variable(r)
    })));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }
  /** @nocollapse */
  static fromConfig(e, n) {
    return new e(n.learningRate, n.decay, n.momentum, n.epsilon, n.centered);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BF = [
  $F,
  DF,
  OF,
  FF,
  MF,
  PF,
  Fw
];
function LF() {
  for (const t of BF)
    RF(t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WF = "model", zF = ".json", VF = ".weights.bin";
function av(t) {
  return new Promise((e) => setTimeout(e)).then(t);
}
class Ps {
  constructor(e) {
    if (!Xe().getBool("IS_BROWSER"))
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(Ps.URL_SCHEME) && (e = e.slice(Ps.URL_SCHEME.length)), (e == null || e.length === 0) && (e = WF), this.modelJsonFileName = e + zF, this.weightDataFileName = e + VF;
  }
  async save(e) {
    if (typeof document > "u")
      throw new Error("Browser downloads are not supported in this environment since `document` is not present");
    const n = zr.join(e.weightData), r = window.URL.createObjectURL(new Blob([n], { type: "application/octet-stream" }));
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
    {
      const a = [{
        paths: ["./" + this.weightDataFileName],
        weights: e.weightSpecs
      }], s = O1(e, a), o = window.URL.createObjectURL(new Blob([JSON.stringify(s)], { type: "application/json" })), i = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
      if (i.download = this.modelJsonFileName, i.href = o, await av(() => i.dispatchEvent(new MouseEvent("click"))), e.weightData != null) {
        const c = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
        c.download = this.weightDataFileName, c.href = r, await av(() => c.dispatchEvent(new MouseEvent("click")));
      }
      return { modelArtifactsInfo: Au(e) };
    }
  }
}
Ps.URL_SCHEME = "downloads://";
class HF {
  constructor(e) {
    if (e == null || e.length < 1)
      throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);
    this.jsonFile = e[0], this.weightsFiles = e.slice(1);
  }
  async load() {
    return new Promise((e, n) => {
      const r = new FileReader();
      r.onload = (a) => {
        const s = JSON.parse(a.target.result), o = s.modelTopology;
        if (o == null) {
          n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (s.weightsManifest == null) {
          n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (this.weightsFiles.length === 0) {
          e({ modelTopology: o });
          return;
        }
        const c = Km(s, (l) => this.loadWeights(l));
        e(c);
      }, r.onerror = (a) => n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), r.readAsText(this.jsonFile);
    });
  }
  loadWeights(e) {
    const n = [], r = [];
    for (const o of e)
      n.push(...o.weights), r.push(...o.paths);
    const a = this.checkManifestAndWeightFiles(e), s = r.map((o) => this.loadWeightsFile(o, a[o]));
    return Promise.all(s).then((o) => [n, o]);
  }
  loadWeightsFile(e, n) {
    return new Promise((r, a) => {
      const s = new FileReader();
      s.onload = (o) => {
        const i = o.target.result;
        r(i);
      }, s.onerror = (o) => a(`Failed to weights data from file of path '${e}'.`), s.readAsArrayBuffer(n);
    });
  }
  /**
   * Check the compatibility between weights manifest and weight files.
   */
  checkManifestAndWeightFiles(e) {
    const n = [], r = this.weightsFiles.map((s) => ev(s.name)), a = {};
    for (const s of e)
      s.paths.forEach((o) => {
        const i = ev(o);
        if (n.indexOf(i) !== -1)
          throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);
        if (n.push(i), r.indexOf(i) === -1)
          throw new Error(`Weight file with basename '${i}' is not provided.`);
        a[o] = this.weightsFiles[r.indexOf(i)];
      });
    if (n.length !== this.weightsFiles.length)
      throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
    return a;
  }
}
const jF = (t) => Xe().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Ps.URL_SCHEME) ? UF(t.slice(Ps.URL_SCHEME.length)) : null;
Wt.registerSaveRouter(jF);
function UF(t = "model") {
  return new Ps(t);
}
function GF(t) {
  return new HF(t);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sv(t, e, n, r) {
  o(t), n = n ?? 0, r = r ?? 1, i(n, r);
  let a = 0;
  const s = (c) => (c.then((l) => {
    const u = n + ++a / t.length * (r - n);
    return e(u), l;
  }), c);
  function o(c) {
    A(c != null && Array.isArray(c) && c.length > 0, () => "promises must be a none empty array");
  }
  function i(c, l) {
    A(c >= 0 && c <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${c}`), A(l >= 0 && l <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${l}`), A(l >= c, () => `startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${l}`);
  }
  return Promise.all(t.map(s));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Mw(t, e) {
  e == null && (e = {});
  const n = e.fetchFunc == null ? Xe().platform.fetch : e.fetchFunc, r = t.map((d) => n(d, e.requestInit, { isBinary: !0 })), a = 0, s = 0.5, i = (e.onProgress == null ? await Promise.all(r) : await sv(r, e.onProgress, a, s)).map((d) => d.arrayBuffer()), c = 0.5, l = 1;
  return e.onProgress == null ? await Promise.all(i) : await sv(i, e.onProgress, c, l);
}
async function qF(t, e = "", n, r) {
  return Pw((o) => Mw(o, { requestInit: r }))(t, e, n);
}
function Pw(t) {
  return async (e, n = "", r) => {
    const a = e.map(() => !1), s = {}, o = r != null ? r.map(() => !1) : [], i = [];
    if (e.forEach((p, h) => {
      let m = 0;
      p.weights.forEach((g) => {
        const v = "quantization" in g ? g.quantization.dtype : g.dtype, b = Kp[v] * Y(g.shape), w = () => {
          a[h] = !0, s[h] == null && (s[h] = []), s[h].push({
            manifestEntry: g,
            groupOffset: m,
            sizeBytes: b
          });
        };
        r != null ? r.forEach((S, I) => {
          S === g.name && (w(), o[I] = !0);
        }) : w(), i.push(g.name), m += b;
      });
    }), !o.every((p) => p)) {
      const p = r.filter((h, m) => !o[m]);
      throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`);
    }
    const c = a.reduce((p, h, m) => (h && p.push(m), p), []), l = [];
    c.forEach((p) => {
      e[p].paths.forEach((h) => {
        const m = n + (n.endsWith("/") ? "" : "/") + h;
        l.push(m);
      });
    });
    const u = await t(l), d = {};
    let f = 0;
    return c.forEach((p) => {
      const h = e[p].paths.length, m = new zr(u.slice(f, f + h));
      s[p].forEach((v) => {
        const b = m.slice(v.groupOffset, v.groupOffset + v.sizeBytes), w = D1(b, [v.manifestEntry]);
        for (const S in w)
          d[S] = w[S];
      }), f += h;
    }), d;
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KF = "application/octet-stream", XF = "application/json";
class hg {
  constructor(e, n) {
    if (this.DEFAULT_METHOD = "POST", n == null && (n = {}), this.weightPathPrefix = n.weightPathPrefix, this.onProgress = n.onProgress, this.weightUrlConverter = n.weightUrlConverter, n.fetchFunc != null ? (A(typeof n.fetchFunc == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = n.fetchFunc) : this.fetch = Xe().platform.fetch, A(e != null && e.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(e) && A(e.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${e.length}).`), this.path = e, n.requestInit != null && n.requestInit.body != null)
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = n.requestInit || {};
  }
  async save(e) {
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
    const n = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
    n.body = new FormData();
    const r = [{
      paths: ["./model.weights.bin"],
      weights: e.weightSpecs
    }], a = O1(e, r);
    if (n.body.append("model.json", new Blob([JSON.stringify(a)], { type: XF }), "model.json"), e.weightData != null) {
      const o = zr.join(e.weightData);
      n.body.append("model.weights.bin", new Blob([o], { type: KF }), "model.weights.bin");
    }
    const s = await this.fetch(this.path, n);
    if (s.ok)
      return {
        modelArtifactsInfo: Au(e),
        responses: [s]
      };
    throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`);
  }
  /**
   * Load model artifacts via HTTP request(s).
   *
   * See the documentation to `tf.io.http` for details on the saved
   * artifacts.
   *
   * @returns The loaded model artifacts (if loading succeeds).
   */
  async load() {
    const e = await this.fetch(this.path, this.requestInit);
    if (!e.ok)
      throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);
    let n;
    try {
      n = await e.json();
    } catch {
      let o = `Failed to parse model JSON of response from ${this.path}.`;
      throw this.path.endsWith(".pb") ? o += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : o += " Please make sure the server is serving valid JSON for this request.", new Error(o);
    }
    const r = n.modelTopology, a = n.weightsManifest;
    if (r == null && a == null)
      throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
    return Km(n, (s) => this.loadWeights(s));
  }
  async loadWeights(e) {
    const n = Array.isArray(this.path) ? this.path[1] : this.path, [r, a] = YF(n), s = this.weightPathPrefix || r, o = M1(e), i = [], c = [];
    for (const u of e)
      for (const d of u.paths)
        this.weightUrlConverter != null ? c.push(this.weightUrlConverter(d)) : i.push(s + d + a);
    this.weightUrlConverter && i.push(...await Promise.all(c));
    const l = await Mw(i, {
      requestInit: this.requestInit,
      fetchFunc: this.fetch,
      onProgress: this.onProgress
    });
    return [o, l];
  }
}
hg.URL_SCHEME_REGEX = /^https?:\/\//;
function YF(t) {
  const e = t.lastIndexOf("/"), n = t.lastIndexOf("?"), r = t.substring(0, e), a = n > e ? t.substring(n) : "";
  return [r + "/", a];
}
function ah(t) {
  return t.match(hg.URL_SCHEME_REGEX) != null;
}
const Bw = (t, e) => {
  if (typeof fetch > "u" && (e == null || e.fetchFunc == null))
    return null;
  {
    let n = !0;
    if (Array.isArray(t) ? n = t.every((r) => ah(r)) : n = ah(t), n)
      return mg(t, e);
  }
  return null;
};
Wt.registerSaveRouter(Bw);
Wt.registerLoadRouter(Bw);
function mg(t, e) {
  return new hg(t, e);
}
function ZF(t, e) {
  return mg(t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Zf {
  constructor(e) {
    this.modelArtifacts = e;
  }
  load() {
    return this.modelArtifacts;
  }
}
class Lw {
  constructor(e) {
    this.saveHandler = e;
  }
  save(e) {
    return this.saveHandler(e);
  }
}
class JF {
  constructor(e) {
    e.load && (this.load = () => Promise.resolve(e.load())), e.save && (this.save = (n) => Promise.resolve(e.save(n)));
  }
}
function QF(t, e, n, r) {
  const a = arguments;
  return new JF(Ww(...a));
}
function Ww(t, e, n, r) {
  return arguments.length === 1 ? t.modelTopology != null || t.weightSpecs != null ? new Zf(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({ modelTopology: t })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({
    modelTopology: t,
    weightSpecs: e,
    weightData: n,
    trainingConfig: r
  }));
}
function eM(t) {
  return new Lw(t);
}
function tM(t) {
  return new Lw(t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompositeArrayBuffer: zr,
  browserFiles: GF,
  browserHTTPRequest: ZF,
  concatenateArrayBuffers: QT,
  copyModel: SC,
  decodeWeights: D1,
  encodeWeights: XT,
  fromMemory: QF,
  fromMemorySync: Ww,
  getLoadHandlers: iC,
  getModelArtifactsForJSON: Km,
  getModelArtifactsForJSONSync: F1,
  getModelArtifactsInfoForJSON: Au,
  getSaveHandlers: oC,
  getWeightSpecs: M1,
  http: mg,
  isHTTPScheme: ah,
  listModels: bC,
  loadWeights: qF,
  moveModel: _C,
  registerLoadRouter: sC,
  registerSaveRouter: aC,
  removeModel: wC,
  weightsLoaderFactory: Pw,
  withSaveHandler: eM,
  withSaveHandlerSync: tM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let ms, ov = !1;
function nM(t, e = 3) {
  if (e > 4)
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (t == null)
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  let n = !1, r = !1, a = !1, s = !1, o = !1, i = !1;
  if (t.data instanceof Uint8Array)
    n = !0;
  else if (typeof ImageData < "u" && t instanceof ImageData)
    r = !0;
  else if (typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement)
    a = !0;
  else if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement)
    s = !0;
  else if (t.getContext != null)
    o = !0;
  else if (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    i = !0;
  else
    throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);
  if (Fc(Wy, W.backendName) != null) {
    const h = { pixels: t }, m = { numChannels: e };
    return W.runKernel(Wy, h, m);
  }
  const [l, u] = a ? [
    t.videoWidth,
    t.videoHeight
  ] : [t.width, t.height];
  let d;
  if (o)
    d = // tslint:disable-next-line:no-any
    t.getContext("2d").getImageData(0, 0, l, u).data;
  else if (r || n)
    d = t.data;
  else if (s || a || i) {
    if (ms == null)
      if (typeof document > "u")
        if (typeof OffscreenCanvas < "u" && typeof OffscreenCanvasRenderingContext2D < "u")
          ms = new OffscreenCanvas(1, 1).getContext("2d");
        else
          throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
      else
        ms = document.createElement("canvas").getContext("2d", { willReadFrequently: !0 });
    ms.canvas.width = l, ms.canvas.height = u, ms.drawImage(t, 0, 0, l, u), d = ms.getImageData(0, 0, l, u).data;
  }
  let f;
  if (e === 4)
    f = new Int32Array(d);
  else {
    const h = l * u;
    f = new Int32Array(h * e);
    for (let m = 0; m < h; m++)
      for (let g = 0; g < e; ++g)
        f[m * e + g] = d[m * 4 + g];
  }
  return kw(f, [u, l, e], "int32");
}
function rM(t) {
  if (t.rank !== 2 && t.rank !== 3)
    throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);
  const e = t.rank === 2 ? 1 : t.shape[2];
  if (e > 4 || e === 2)
    throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);
  if (t.dtype !== "float32" && t.dtype !== "int32")
    throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);
}
async function aM(t, e) {
  let n = C(t, "img", "toPixels");
  if (!(t instanceof en)) {
    const l = n;
    n = zt(l, "int32"), l.dispose();
  }
  rM(n);
  const [r, a] = n.shape.slice(0, 2), s = n.rank === 2 ? 1 : n.shape[2], o = await n.data(), i = n.dtype === "float32" ? 255 : 1, c = new Uint8ClampedArray(a * r * 4);
  for (let l = 0; l < r * a; ++l) {
    const u = [0, 0, 0, 255];
    for (let f = 0; f < s; f++) {
      const p = o[l * s + f];
      if (n.dtype === "float32") {
        if (p < 0 || p > 1)
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`);
      } else if (n.dtype === "int32" && (p < 0 || p > 255))
        throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);
      s === 1 ? (u[0] = p * i, u[1] = p * i, u[2] = p * i) : u[f] = p * i;
    }
    const d = l * 4;
    c[d + 0] = Math.round(u[0]), c[d + 1] = Math.round(u[1]), c[d + 2] = Math.round(u[2]), c[d + 3] = Math.round(u[3]);
  }
  if (e != null) {
    ov || Fc(t1, W.backendName) != null && (console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."), ov = !0), e.width = a, e.height = r;
    const l = e.getContext("2d"), u = new ImageData(c, a, r);
    l.putImageData(u, 0, 0);
  }
  return n !== t && n.dispose(), c;
}
const sM = /* @__PURE__ */ B({ fromPixels_: nM });
function Vw(t, e) {
  const n = t.shape.length, r = e.shape.length;
  if (n < 1)
    throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);
  if (r < 1)
    throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);
  if (e.dtype !== "int32")
    throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);
  if (e.shape[r - 1] > n)
    throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r - 1]} vs. ${n}`);
  if (Y(t.shape) === 0)
    throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);
  const a = e.shape, s = a[a.length - 1];
  let o = 1;
  for (let d = 0; d < a.length - 1; ++d)
    o *= a[d];
  const i = t.shape, c = a.slice();
  c.pop();
  let l = 1;
  for (let d = s; d < n; ++d)
    l *= i[d], c.push(i[d]);
  const u = [
    ...Ie(t.shape).map((d) => d / l),
    1
  ].slice(0, s);
  return [c, o, l, u];
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sh = -2, oM = -1;
function iM(t, e, n) {
  const r = t.shape.length;
  A(r === e.length, () => `Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`), A(r === n.length, () => `Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);
  for (let a = 0; a < r; ++a)
    A(e[a] + n[a] <= t.shape[a], () => `Error in slice${r}D: begin[${a}] + size[${a}] (${e[a] + n[a]}) would overflow input.shape[${a}] (${t.shape[a]})`);
}
function Hw(t, e, n) {
  const r = [];
  for (let a = 0; a < t.length; a++)
    r[a] = Math.ceil((e[a] - t[a]) / n[a]);
  return r;
}
function jw(t, e, n) {
  let r = n.length;
  for (let a = 0; a < n.length; a++)
    if (n[a] > 1) {
      r = a;
      break;
    }
  for (let a = r + 1; a < n.length; a++)
    if (e[a] > 0 || n[a] !== t[a])
      return !1;
  return !0;
}
function Uw(t, e) {
  let n = t.length > 0 ? t[t.length - 1] : 1;
  for (let r = 0; r < t.length - 1; r++)
    n += t[r] * e[r];
  return n;
}
function Gw(t, e, n) {
  let r;
  const a = t.shape.length;
  typeof e == "number" ? r = [e, ...new Array(a - 1).fill(0)] : e.length < a ? r = e.concat(new Array(a - e.length).fill(0)) : r = e.slice(), r.forEach((o) => {
    A(o !== -1, () => "slice() does not support negative begin indexing.");
  });
  let s;
  return n == null ? s = new Array(a).fill(-1) : typeof n == "number" ? s = [n, ...new Array(a - 1).fill(-1)] : n.length < a ? s = n.concat(new Array(a - n.length).fill(-1)) : s = n, s = s.map((o, i) => o >= 0 ? o : (A(o === -1, () => `Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`), t.shape[i] - r[i])), [r, s];
}
function qw(t, e, n, r, a, s, o, i, c) {
  let l;
  if (r == null ? (l = new Array(e.length), l.fill(1)) : l = r, o != null && o & o - 1)
    throw new Error("Multiple ellipses in slice is not allowed.");
  let u = !1;
  const d = {
    dims: l.length,
    numAddAxisAfterEllipsis: 0,
    begin: e.slice(),
    end: n.slice(),
    strides: l.slice(),
    beginMask: a,
    endMask: s,
    ellipsisMask: o,
    newAxisMask: i,
    shrinkAxisMask: c
  };
  for (let w = 0; w < d.dims; w++)
    u && 1 << w & i && d.numAddAxisAfterEllipsis++, 1 << w & o && (u = !0);
  u || (d.ellipsisMask |= 1 << d.dims, d.dims++);
  const f = {
    dims: t.length,
    beginMask: 0,
    endMask: 0,
    beginValid: !1,
    endValid: !1
  };
  uM(d, f);
  let p = !0, h = !0, m = !0;
  const g = [], v = [];
  for (let w = 0; w < t.length; ++w) {
    if (f.strides[w] === 0)
      throw Error(`strides[${w}] must be non-zero`);
    const S = !!(f.shrinkAxisMask & 1 << w), I = t[w];
    if (I === -1) {
      g.push(S ? 1 : -1);
      continue;
    }
    const E = [f.beginMask & 1 << w, f.endMask & 1 << w], T = [
      f.strides[w] > 0 ? 0 : -1,
      f.strides[w] > 0 ? I : I - 1
    ];
    if (S && f.strides[w] <= 0)
      throw Error("only stride 1 allowed on non-range indexing.");
    m = m && f.strides[w] === 1;
    const R = !!(f.beginMask & 1 << w && f.endMask & 1 << w);
    if (f.beginValid && f.endValid) {
      if (S) {
        const z = f.begin[w] < 0 ? I + f.begin[w] : f.begin[w];
        if (f.begin[w] = z, f.end[w] = f.begin[w] + 1, z < 0 || z >= I)
          throw Error(`slice index ${f.begin[w]} of dimension ${w} out of bounds.`);
      } else
        f.begin[w] = iv(f.begin[w], 0, f.strides[w], I, E, T), f.end[w] = iv(f.end[w], 1, f.strides[w], I, E, T);
      const M = f.strides[w] === 1 && f.begin[w] === 0 && f.end[w] === I;
      p = p && M, h = h && (w === 0 && f.strides[w] === 1 || M);
    } else
      p = p && f.strides[w] === 1 && R, h = h && (w === 0 && f.strides[w] === 1 || R);
    let $, D = !1;
    if (f.beginValid && f.endValid ? ($ = f.end[w] - f.begin[w], D = !0) : S ? ($ = 1, D = !0) : R && I >= 0 && (f.strides[w] < 0 ? $ = -I : $ = I, D = !0), D) {
      let M;
      $ === 0 || $ < 0 != f.strides[w] < 0 ? M = 0 : M = Math.trunc($ / f.strides[w]) + ($ % f.strides[w] !== 0 ? 1 : 0), g.push(M);
    } else
      g.push(-1);
  }
  for (let w = 0; w < f.finalShapeGatherIndices.length; ++w) {
    const S = f.finalShapeGatherIndices[w];
    S >= 0 ? v.push(g[S]) : S === sh && v.push(1);
  }
  return {
    finalShapeSparse: v.filter((w, S) => f.finalShapeGatherIndices[S] !== sh),
    finalShape: v,
    isIdentity: p,
    sliceDim0: h,
    isSimpleSlice: m,
    begin: f.begin,
    end: f.end,
    strides: f.strides
  };
}
function uM(t, e) {
  e.beginMask = 0, e.endMask = 0, e.shrinkAxisMask = 0;
  let n = 0;
  e.beginValid = t.begin != null, e.endValid = t.end != null, e.begin = new Array(e.dims), e.end = new Array(e.dims), e.strides = new Array(e.dims), e.finalShapeGatherIndices = [], e.finalShapeGatherIndicesSparse = [], e.inputShapeGatherIndicesSparse = new Array(e.dims);
  for (let r = 0; r < t.dims; r++)
    if (1 << r & t.ellipsisMask) {
      const a = Math.min(e.dims - (t.dims - r) + 1 + t.numAddAxisAfterEllipsis, e.dims);
      for (; n < a; n++)
        e.begin[n] = 0, e.end[n] = 0, e.strides[n] = 1, e.beginMask |= 1 << n, e.endMask |= 1 << n, e.finalShapeGatherIndices.push(n), e.finalShapeGatherIndicesSparse.push(-1), e.inputShapeGatherIndicesSparse[n] = r;
    } else if (1 << r & t.newAxisMask)
      e.finalShapeGatherIndices.push(sh), e.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (n === e.begin.length)
        throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);
      t.begin != null && (e.begin[n] = t.begin[r]), t.end != null && (e.end[n] = t.end[r]), e.strides[n] = t.strides[r], t.beginMask & 1 << r && (e.beginMask |= 1 << n), t.endMask & 1 << r && (e.endMask |= 1 << n), t.shrinkAxisMask & 1 << r ? (e.finalShapeGatherIndices.push(oM), e.finalShapeGatherIndicesSparse.push(-1), e.shrinkAxisMask |= 1 << n) : (e.finalShapeGatherIndices.push(n), e.finalShapeGatherIndicesSparse.push(r)), e.inputShapeGatherIndicesSparse[n] = r, n++;
    }
}
function iv(t, e, n, r, a, s) {
  if (a[e])
    return n > 0 ? s[e] : s[e + 1 & 1];
  {
    const o = t < 0 ? r + t : t;
    return o < s[0] ? s[0] : o > s[1] ? s[1] : o;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kw(t, e) {
  const n = t[0].length;
  t.forEach((a, s) => {
    A(a.length === n, () => `Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`);
  }), A(e >= 0 && e < n, () => `Error in concat${n}D: axis must be between 0 and ${n - 1}.`);
  const r = t[0];
  t.forEach((a, s) => {
    for (let o = 0; o < n; o++)
      A(o === e || a[o] === r[o], () => `Error in concat${n}D: Shape of tensors[${s}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`);
  });
}
function _o(t, e) {
  const n = t[0].slice();
  for (let r = 1; r < t.length; r++)
    n[e] += t[r][e];
  return n;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Xr;
(function(t) {
  t[t.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", t[t.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", t[t.ROW_LENGTHS = 2] = "ROW_LENGTHS", t[t.ROW_SPLITS = 3] = "ROW_SPLITS", t[t.ROW_LIMITS = 4] = "ROW_LIMITS", t[t.ROW_STARTS = 5] = "ROW_STARTS";
})(Xr || (Xr = {}));
function cM(t, e, n) {
  let r = new Array();
  if (n == null && e == null)
    return r;
  if (e == null)
    for (; r.length < t + n.length; )
      r.push(-1);
  else
    r = e.slice();
  if (n == null)
    return r;
  if (t + n.length !== r.length)
    throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t + n.length}, but shape.rank = ${r.length}`);
  for (let a = 1; a < n.length; ++a) {
    const s = n[a], o = r[r.length - n.length + a], i = r[o];
    if (s >= 0)
      if (i >= 0) {
        if (i !== s)
          throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${a + t}] = ${s} but shape[${a + t}] = ${i}`);
      } else
        r[o] = s;
  }
  return r;
}
function lM(t) {
  const e = {
    FIRST_DIM_SIZE: Xr.FIRST_DIM_SIZE,
    VALUE_ROWIDS: Xr.VALUE_ROWIDS,
    ROW_LENGTHS: Xr.ROW_LENGTHS,
    ROW_SPLITS: Xr.ROW_SPLITS,
    ROW_LIMITS: Xr.ROW_LIMITS,
    ROW_STARTS: Xr.ROW_STARTS
  }, n = [];
  for (const r of t)
    if (r in e)
      n.push(e[r]);
    else
      break;
  return n;
}
function dM(t) {
  return t.length === 0 ? 0 : t[0] === Xr.FIRST_DIM_SIZE ? t.length - 1 : t.length;
}
function fM(t, e) {
  if (t == null || e == null)
    return;
  const n = t.length, r = e.length;
  if (n >= r)
    throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);
  for (let a = 0; a < Math.min(n, r - 1); ++a) {
    const s = t[a], o = e[a + 1];
    if (s >= 0 && o >= 0 && s !== 1 && s !== o)
      throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${a - t.length}] = ${s} but ragged tensor input.flatValues.shape[${a - t.length}] = ${o}`);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xw(t, e, n) {
  const r = n * (typeof t == "number" ? t : t[0]), a = e * (typeof t == "number" ? t : t[1]);
  return [r, a];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wf(t, e, n, r = !0) {
  let a = [];
  if (r)
    a = a.concat(e.slice(0)), a.push(t[0] / n), a = a.concat(t.slice(1));
  else {
    a = a.concat(t[0]);
    const s = e.length;
    for (let o = 0; o < s; ++o)
      a = a.concat([t[o + 1] / e[o], e[o]]);
    a = a.concat(t.slice(s + 1));
  }
  return a;
}
function Sf(t, e, n = !0) {
  const r = [];
  if (n) {
    r.push(e);
    for (let a = e + 1; a < t; ++a)
      a <= 2 * e ? (r.push(a), r.push(a - (e + 1))) : r.push(a);
  } else {
    const a = [], s = [];
    for (let o = 1; o < t; ++o)
      o >= e * 2 + 1 || o % 2 === 1 ? s.push(o) : a.push(o);
    r.push(...a), r.push(0), r.push(...s);
  }
  return r;
}
function _f(t, e, n, r = !0) {
  const a = [];
  r ? a.push(t[0] / n) : a.push(t[0] * n);
  for (let s = 1; s < t.length; ++s)
    s <= e.length ? r ? a.push(e[s - 1] * t[s]) : a.push(t[s] / e[s - 1]) : a.push(t[s]);
  return a;
}
function Yw(t, e) {
  const n = [0];
  for (let r = 0; r < e; ++r)
    n.push(t[r][0]);
  return n;
}
function Zw(t, e, n) {
  const r = t.slice(0, 1);
  for (let a = 0; a < n; ++a)
    r.push(t[a + 1] - e[a][0] - e[a][1]);
  return r;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pM = 1.7580993408473768, hM = 1.0507009873554805;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const mM = 0.3275911, gM = 0.254829592, yM = -0.284496736, vM = 1.421413741, bM = -1.453152027, wM = 1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function No(t, e) {
  if (t.length !== e.length)
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);
  const n = new Float32Array(t.length * 2);
  for (let r = 0; r < n.length; r += 2)
    n[r] = t[r / 2], n[r + 1] = e[r / 2];
  return n;
}
function SM(t) {
  const e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    e[r / 2] = t[r], n[r / 2] = t[r + 1];
  return { real: e, imag: n };
}
function _M(t) {
  const e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e);
  for (let a = 0; a < t.length; a += 4)
    n[Math.floor(a / 4)] = t[a], r[Math.floor(a / 4)] = t[a + 1];
  return { real: n, imag: r };
}
function xM(t) {
  const e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e);
  for (let a = 2; a < t.length; a += 4)
    n[Math.floor(a / 4)] = t[a], r[Math.floor(a / 4)] = t[a + 1];
  return { real: n, imag: r };
}
function Jw(t, e) {
  const n = t[e * 2], r = t[e * 2 + 1];
  return { real: n, imag: r };
}
function IM(t, e, n, r) {
  t[r * 2] = e, t[r * 2 + 1] = n;
}
function kM(t, e) {
  const n = new Float32Array(t / 2), r = new Float32Array(t / 2);
  for (let a = 0; a < Math.ceil(t / 2); a++) {
    const s = (e ? 2 : -2) * Math.PI * (a / t);
    n[a] = Math.cos(s), r[a] = Math.sin(s);
  }
  return { real: n, imag: r };
}
function EM(t, e, n) {
  const r = (n ? 2 : -2) * Math.PI * (t / e), a = Math.cos(r), s = Math.sin(r);
  return { real: a, imag: s };
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Jf = "->", TM = /->/g, uv = ",", cv = "...";
function CM(t, e) {
  t = t.replace(/\s/g, "");
  const n = (t.length - t.replace(TM, "").length) / Jf.length;
  if (n < 1)
    throw new Error("Equations without an arrow are not supported.");
  if (n > 1)
    throw new Error(`Equation must contain exactly one arrow ("${Jf}").`);
  const [r, a] = t.split(Jf);
  A(r.indexOf(cv) === -1, () => `The ellipsis notation ("${cv}") is not supported yet.`);
  const s = r.split(uv), o = s.length;
  if (e !== o)
    throw new Error(`Expected ${o} input tensors, received ${e}`);
  if (o > 2)
    throw new Error("Support for more than 2 input tensors is not implemented yet.");
  const i = [];
  for (let f = 0; f < a.length; ++f) {
    const p = a[f];
    if (!s.some((h) => h.indexOf(p) !== -1))
      throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);
    i.indexOf(p) === -1 && i.push(p);
  }
  for (let f = 0; f < r.length; ++f) {
    const p = r[f];
    i.indexOf(p) === -1 && p !== uv && i.push(p);
  }
  const c = new Array(s.length);
  for (let f = 0; f < o; ++f) {
    if (new Set(s[f].split("")).size !== s[f].length)
      throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);
    c[f] = [];
    for (let p = 0; p < s[f].length; ++p)
      c[f].push(i.indexOf(s[f][p]));
  }
  const l = i.length, u = a.length, d = [];
  for (let f = u; f < l; ++f)
    d.push(f);
  return { allDims: i, summedDims: d, idDims: c };
}
function NM(t, e) {
  let n = new Array(t);
  n.fill(-1);
  for (let a = 0; a < e.length; ++a)
    n[e[a]] = a;
  const r = [];
  for (let a = 0; a < t; ++a)
    n[a] === -1 && r.push(a);
  return n = n.filter((a) => a !== -1), { permutationIndices: n, expandDims: r };
}
function AM(t, e, n) {
  const r = new Array(t);
  for (let a = 0; a < n.length; ++a) {
    const s = n[a].shape;
    for (let o = 0; o < e[a].length; ++o)
      r[e[a][o]] === void 0 ? r[e[a][o]] = s[o] : A(r[e[a][o]] === s[o], () => `Expected dimension ${r[e[a][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`);
  }
}
function RM(t, e) {
  const n = t, r = [];
  let a = 0;
  t.length === 0 && n.push(-1), a = t.length + 1;
  for (let o = 0; o < a; ++o)
    r.push([]);
  const s = [];
  for (let o = 0; o < n.length; ++o) {
    const i = n[o], c = DM(e, i);
    for (const l of c)
      s.indexOf(l) === -1 && (r[o].push(l), s.push(l));
  }
  return { path: n, steps: r };
}
function $M(t) {
  return t.every((e, n) => e === n);
}
function DM(t, e) {
  const n = [];
  for (let r = 0; r < t.length; ++r)
    (t[r].length === 0 || t[r].indexOf(e) !== -1 || e === -1) && n.push(r);
  return n;
}
function Qw(t, e, n = 0) {
  let r = [];
  if (typeof e == "number")
    A(t.shape[n] % e === 0, () => "Number of splits must evenly divide the axis."), r = new Array(e).fill(t.shape[n] / e);
  else {
    const a = e.reduce((o, i) => (i === -1 && (o += 1), o), 0);
    A(a <= 1, () => "There should be only one negative value in split array.");
    const s = e.indexOf(-1);
    if (s !== -1) {
      const o = e.reduce((i, c) => c > 0 ? i + c : i);
      e[s] = t.shape[n] - o;
    }
    A(t.shape[n] === e.reduce((o, i) => o + i), () => "The sum of sizes must match the size of the axis dimension."), r = e;
  }
  return r;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e2(t) {
  return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`;
}
function t2(t, e) {
  return `indices(${t}, 0) is invalid: ${e} < 0`;
}
function n2(t, e, n) {
  return `indices(${t}, 0) is invalid: ${e} >= ${n}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r2(t, e) {
  return `only one output dimension may be -1, not both ${t} and ${e}`;
}
function a2(t, e) {
  return `size ${t} must be non-negative, not ${e}`;
}
function s2() {
  return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function o2(t, e) {
  const n = Y(t), r = Y(e);
  return `Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`;
}
function i2(t, e) {
  const n = Y(t), r = Y(e);
  return `Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gc() {
  return "segment ids must be >= 0";
}
function u2() {
  return "segment ids are not increasing";
}
function c2(t, e) {
  return `Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`;
}
function l2(t, e, n) {
  return `Bad: indices[${t}] == ${e} out of range [0, ${n})`;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function d2(t, e, n, r) {
  const a = e.shape.length, s = t.shape.length;
  if (r !== 0 && (r < -a || r > a))
    throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);
  if (r < 0 && (r += a), r > s)
    throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);
  if (n < r)
    throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);
  for (let d = 0; d < r; ++d)
    if (t.shape[d] !== e.shape[d])
      throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);
  const o = t.shape[n], i = [];
  let c = 1, l = 1, u = 1;
  for (let d = 0; d < r; ++d)
    i.push(t.shape[d]), c *= t.shape[d];
  for (let d = r; d < n; d++)
    i.push(t.shape[d]), l *= t.shape[d];
  for (let d = r; d < a; d++)
    i.push(e.shape[d]);
  for (let d = n + 1; d < s; d++)
    i.push(t.shape[d]), u *= t.shape[d];
  return { batchSize: c, sliceSize: u, outerSize: l, dimSize: o, outputShape: i };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fu(t) {
  try {
    return t.map((e) => ru(e));
  } catch (e) {
    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`);
  }
}
function f2(t) {
  return t.map((e) => Ts(e));
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
LF();
var OM = {};
(function() {
  var t;
  function e(y) {
    var x = 0;
    return function() {
      return x < y.length ? { done: !1, value: y[x++] } : { done: !0 };
    };
  }
  var n = typeof Object.defineProperties == "function" ? Object.defineProperty : function(y, x, k) {
    return y == Array.prototype || y == Object.prototype || (y[x] = k.value), y;
  };
  function r(y) {
    y = [typeof globalThis == "object" && globalThis, y, typeof window == "object" && window, typeof self == "object" && self, typeof $n == "object" && $n];
    for (var x = 0; x < y.length; ++x) {
      var k = y[x];
      if (k && k.Math == Math)
        return k;
    }
    throw Error("Cannot find global object");
  }
  var a = r(this);
  function s(y, x) {
    if (x)
      e: {
        var k = a;
        y = y.split(".");
        for (var N = 0; N < y.length - 1; N++) {
          var P = y[N];
          if (!(P in k))
            break e;
          k = k[P];
        }
        y = y[y.length - 1], N = k[y], x = x(N), x != N && x != null && n(k, y, { configurable: !0, writable: !0, value: x });
      }
  }
  s("Symbol", function(y) {
    function x(j) {
      if (this instanceof x)
        throw new TypeError("Symbol is not a constructor");
      return new k(N + (j || "") + "_" + P++, j);
    }
    function k(j, L) {
      this.g = j, n(this, "description", { configurable: !0, writable: !0, value: L });
    }
    if (y)
      return y;
    k.prototype.toString = function() {
      return this.g;
    };
    var N = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", P = 0;
    return x;
  }), s("Symbol.iterator", function(y) {
    if (y)
      return y;
    y = Symbol("Symbol.iterator");
    for (var x = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), k = 0; k < x.length; k++) {
      var N = a[x[k]];
      typeof N == "function" && typeof N.prototype[y] != "function" && n(N.prototype, y, { configurable: !0, writable: !0, value: function() {
        return o(e(this));
      } });
    }
    return y;
  });
  function o(y) {
    return y = { next: y }, y[Symbol.iterator] = function() {
      return this;
    }, y;
  }
  function i(y) {
    var x = typeof Symbol < "u" && Symbol.iterator && y[Symbol.iterator];
    return x ? x.call(y) : { next: e(y) };
  }
  function c(y) {
    if (!(y instanceof Array)) {
      y = i(y);
      for (var x, k = []; !(x = y.next()).done; )
        k.push(x.value);
      y = k;
    }
    return y;
  }
  var l = typeof Object.create == "function" ? Object.create : function(y) {
    function x() {
    }
    return x.prototype = y, new x();
  }, u;
  if (typeof Object.setPrototypeOf == "function")
    u = Object.setPrototypeOf;
  else {
    var d;
    e: {
      var f = { a: !0 }, p = {};
      try {
        p.__proto__ = f, d = p.a;
        break e;
      } catch {
      }
      d = !1;
    }
    u = d ? function(y, x) {
      if (y.__proto__ = x, y.__proto__ !== x)
        throw new TypeError(y + " is not extensible");
      return y;
    } : null;
  }
  var h = u;
  function m(y, x) {
    if (y.prototype = l(x.prototype), y.prototype.constructor = y, h)
      h(y, x);
    else
      for (var k in x)
        if (k != "prototype")
          if (Object.defineProperties) {
            var N = Object.getOwnPropertyDescriptor(x, k);
            N && Object.defineProperty(y, k, N);
          } else
            y[k] = x[k];
    y.na = x.prototype;
  }
  function g() {
    this.l = !1, this.i = null, this.h = void 0, this.g = 1, this.u = this.o = 0, this.j = null;
  }
  function v(y) {
    if (y.l)
      throw new TypeError("Generator is already running");
    y.l = !0;
  }
  g.prototype.s = function(y) {
    this.h = y;
  };
  function b(y, x) {
    y.j = { da: x, ea: !0 }, y.g = y.o || y.u;
  }
  g.prototype.return = function(y) {
    this.j = { return: y }, this.g = this.u;
  };
  function w(y, x, k) {
    return y.g = k, { value: x };
  }
  function S(y) {
    this.g = new g(), this.h = y;
  }
  function I(y, x) {
    v(y.g);
    var k = y.g.i;
    return k ? E(y, "return" in k ? k.return : function(N) {
      return { value: N, done: !0 };
    }, x, y.g.return) : (y.g.return(x), T(y));
  }
  function E(y, x, k, N) {
    try {
      var P = x.call(y.g.i, k);
      if (!(P instanceof Object))
        throw new TypeError("Iterator result " + P + " is not an object");
      if (!P.done)
        return y.g.l = !1, P;
      var j = P.value;
    } catch (L) {
      return y.g.i = null, b(y.g, L), T(y);
    }
    return y.g.i = null, N.call(y.g, j), T(y);
  }
  function T(y) {
    for (; y.g.g; )
      try {
        var x = y.h(y.g);
        if (x)
          return y.g.l = !1, { value: x.value, done: !1 };
      } catch (k) {
        y.g.h = void 0, b(y.g, k);
      }
    if (y.g.l = !1, y.g.j) {
      if (x = y.g.j, y.g.j = null, x.ea)
        throw x.da;
      return { value: x.return, done: !0 };
    }
    return { value: void 0, done: !0 };
  }
  function R(y) {
    this.next = function(x) {
      return v(y.g), y.g.i ? x = E(y, y.g.i.next, x, y.g.s) : (y.g.s(x), x = T(y)), x;
    }, this.throw = function(x) {
      return v(y.g), y.g.i ? x = E(y, y.g.i.throw, x, y.g.s) : (b(y.g, x), x = T(y)), x;
    }, this.return = function(x) {
      return I(y, x);
    }, this[Symbol.iterator] = function() {
      return this;
    };
  }
  function $(y) {
    function x(N) {
      return y.next(N);
    }
    function k(N) {
      return y.throw(N);
    }
    return new Promise(function(N, P) {
      function j(L) {
        L.done ? N(L.value) : Promise.resolve(L.value).then(x, k).then(j, P);
      }
      j(y.next());
    });
  }
  function D(y) {
    return $(new R(new S(y)));
  }
  s("Promise", function(y) {
    function x(L) {
      this.h = 0, this.i = void 0, this.g = [], this.s = !1;
      var K = this.j();
      try {
        L(K.resolve, K.reject);
      } catch (Q) {
        K.reject(Q);
      }
    }
    function k() {
      this.g = null;
    }
    function N(L) {
      return L instanceof x ? L : new x(function(K) {
        K(L);
      });
    }
    if (y)
      return y;
    k.prototype.h = function(L) {
      if (this.g == null) {
        this.g = [];
        var K = this;
        this.i(function() {
          K.l();
        });
      }
      this.g.push(L);
    };
    var P = a.setTimeout;
    k.prototype.i = function(L) {
      P(L, 0);
    }, k.prototype.l = function() {
      for (; this.g && this.g.length; ) {
        var L = this.g;
        this.g = [];
        for (var K = 0; K < L.length; ++K) {
          var Q = L[K];
          L[K] = null;
          try {
            Q();
          } catch (de) {
            this.j(de);
          }
        }
      }
      this.g = null;
    }, k.prototype.j = function(L) {
      this.i(function() {
        throw L;
      });
    }, x.prototype.j = function() {
      function L(de) {
        return function(Ee) {
          Q || (Q = !0, de.call(K, Ee));
        };
      }
      var K = this, Q = !1;
      return { resolve: L(this.D), reject: L(this.l) };
    }, x.prototype.D = function(L) {
      if (L === this)
        this.l(new TypeError("A Promise cannot resolve to itself"));
      else if (L instanceof x)
        this.H(L);
      else {
        e:
          switch (typeof L) {
            case "object":
              var K = L != null;
              break e;
            case "function":
              K = !0;
              break e;
            default:
              K = !1;
          }
        K ? this.A(L) : this.o(L);
      }
    }, x.prototype.A = function(L) {
      var K = void 0;
      try {
        K = L.then;
      } catch (Q) {
        this.l(Q);
        return;
      }
      typeof K == "function" ? this.I(K, L) : this.o(L);
    }, x.prototype.l = function(L) {
      this.u(2, L);
    }, x.prototype.o = function(L) {
      this.u(1, L);
    }, x.prototype.u = function(L, K) {
      if (this.h != 0)
        throw Error("Cannot settle(" + L + ", " + K + "): Promise already settled in state" + this.h);
      this.h = L, this.i = K, this.h === 2 && this.G(), this.B();
    }, x.prototype.G = function() {
      var L = this;
      P(function() {
        if (L.C()) {
          var K = a.console;
          typeof K < "u" && K.error(L.i);
        }
      }, 1);
    }, x.prototype.C = function() {
      if (this.s)
        return !1;
      var L = a.CustomEvent, K = a.Event, Q = a.dispatchEvent;
      return typeof Q > "u" ? !0 : (typeof L == "function" ? L = new L("unhandledrejection", { cancelable: !0 }) : typeof K == "function" ? L = new K("unhandledrejection", { cancelable: !0 }) : (L = a.document.createEvent("CustomEvent"), L.initCustomEvent("unhandledrejection", !1, !0, L)), L.promise = this, L.reason = this.i, Q(L));
    }, x.prototype.B = function() {
      if (this.g != null) {
        for (var L = 0; L < this.g.length; ++L)
          j.h(this.g[L]);
        this.g = null;
      }
    };
    var j = new k();
    return x.prototype.H = function(L) {
      var K = this.j();
      L.M(K.resolve, K.reject);
    }, x.prototype.I = function(L, K) {
      var Q = this.j();
      try {
        L.call(K, Q.resolve, Q.reject);
      } catch (de) {
        Q.reject(de);
      }
    }, x.prototype.then = function(L, K) {
      function Q(Le, Te) {
        return typeof Le == "function" ? function(Ge) {
          try {
            de(Le(Ge));
          } catch (ft) {
            Ee(ft);
          }
        } : Te;
      }
      var de, Ee, Be = new x(function(Le, Te) {
        de = Le, Ee = Te;
      });
      return this.M(Q(L, de), Q(K, Ee)), Be;
    }, x.prototype.catch = function(L) {
      return this.then(void 0, L);
    }, x.prototype.M = function(L, K) {
      function Q() {
        switch (de.h) {
          case 1:
            L(de.i);
            break;
          case 2:
            K(de.i);
            break;
          default:
            throw Error("Unexpected state: " + de.h);
        }
      }
      var de = this;
      this.g == null ? j.h(Q) : this.g.push(Q), this.s = !0;
    }, x.resolve = N, x.reject = function(L) {
      return new x(function(K, Q) {
        Q(L);
      });
    }, x.race = function(L) {
      return new x(function(K, Q) {
        for (var de = i(L), Ee = de.next(); !Ee.done; Ee = de.next())
          N(Ee.value).M(K, Q);
      });
    }, x.all = function(L) {
      var K = i(L), Q = K.next();
      return Q.done ? N([]) : new x(function(de, Ee) {
        function Be(Ge) {
          return function(ft) {
            Le[Ge] = ft, Te--, Te == 0 && de(Le);
          };
        }
        var Le = [], Te = 0;
        do
          Le.push(void 0), Te++, N(Q.value).M(Be(Le.length - 1), Ee), Q = K.next();
        while (!Q.done);
      });
    }, x;
  });
  function M(y, x) {
    y instanceof String && (y += "");
    var k = 0, N = !1, P = { next: function() {
      if (!N && k < y.length) {
        var j = k++;
        return { value: x(j, y[j]), done: !1 };
      }
      return N = !0, { done: !0, value: void 0 };
    } };
    return P[Symbol.iterator] = function() {
      return P;
    }, P;
  }
  var z = typeof Object.assign == "function" ? Object.assign : function(y, x) {
    for (var k = 1; k < arguments.length; k++) {
      var N = arguments[k];
      if (N)
        for (var P in N)
          Object.prototype.hasOwnProperty.call(N, P) && (y[P] = N[P]);
    }
    return y;
  };
  s("Object.assign", function(y) {
    return y || z;
  }), s("Object.is", function(y) {
    return y || function(x, k) {
      return x === k ? x !== 0 || 1 / x === 1 / k : x !== x && k !== k;
    };
  }), s("Array.prototype.includes", function(y) {
    return y || function(x, k) {
      var N = this;
      N instanceof String && (N = String(N));
      var P = N.length;
      for (k = k || 0, 0 > k && (k = Math.max(k + P, 0)); k < P; k++) {
        var j = N[k];
        if (j === x || Object.is(j, x))
          return !0;
      }
      return !1;
    };
  }), s("String.prototype.includes", function(y) {
    return y || function(x, k) {
      if (this == null)
        throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
      if (x instanceof RegExp)
        throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
      return this.indexOf(x, k || 0) !== -1;
    };
  }), s("Array.prototype.keys", function(y) {
    return y || function() {
      return M(this, function(x) {
        return x;
      });
    };
  });
  var F = this || self;
  function V(y, x) {
    y = y.split(".");
    var k = F;
    y[0] in k || typeof k.execScript > "u" || k.execScript("var " + y[0]);
    for (var N; y.length && (N = y.shift()); )
      y.length || x === void 0 ? k[N] && k[N] !== Object.prototype[N] ? k = k[N] : k = k[N] = {} : k[N] = x;
  }
  function H() {
    throw Error("Invalid UTF8");
  }
  function U(y, x) {
    return x = String.fromCharCode.apply(null, x), y == null ? x : y + x;
  }
  var Z, q = typeof TextDecoder < "u", X, se = typeof TextEncoder < "u", te = {}, ue = null;
  function ee(y) {
    var x;
    x === void 0 && (x = 0), ge(), x = te[x];
    for (var k = Array(Math.floor(y.length / 3)), N = x[64] || "", P = 0, j = 0; P < y.length - 2; P += 3) {
      var L = y[P], K = y[P + 1], Q = y[P + 2], de = x[L >> 2];
      L = x[(L & 3) << 4 | K >> 4], K = x[(K & 15) << 2 | Q >> 6], Q = x[Q & 63], k[j++] = de + L + K + Q;
    }
    switch (de = 0, Q = N, y.length - P) {
      case 2:
        de = y[P + 1], Q = x[(de & 15) << 2] || N;
      case 1:
        y = y[P], k[j] = x[y >> 2] + x[(y & 3) << 4 | de >> 4] + Q + N;
    }
    return k.join("");
  }
  function ne(y) {
    var x = y.length, k = 3 * x / 4;
    k % 3 ? k = Math.floor(k) : "=.".indexOf(y[x - 1]) != -1 && (k = "=.".indexOf(y[x - 2]) != -1 ? k - 2 : k - 1);
    var N = new Uint8Array(k), P = 0;
    return oe(y, function(j) {
      N[P++] = j;
    }), P !== k ? N.subarray(0, P) : N;
  }
  function oe(y, x) {
    function k(Q) {
      for (; N < y.length; ) {
        var de = y.charAt(N++), Ee = ue[de];
        if (Ee != null)
          return Ee;
        if (!/^[\s\xa0]*$/.test(de))
          throw Error("Unknown base64 encoding at char: " + de);
      }
      return Q;
    }
    ge();
    for (var N = 0; ; ) {
      var P = k(-1), j = k(0), L = k(64), K = k(64);
      if (K === 64 && P === -1)
        break;
      x(P << 2 | j >> 4), L != 64 && (x(j << 4 & 240 | L >> 2), K != 64 && x(L << 6 & 192 | K));
    }
  }
  function ge() {
    if (!ue) {
      ue = {};
      for (var y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), x = ["+/=", "+/", "-_=", "-_.", "-_"], k = 0; 5 > k; k++) {
        var N = y.concat(x[k].split(""));
        te[k] = N;
        for (var P = 0; P < N.length; P++) {
          var j = N[P];
          ue[j] === void 0 && (ue[j] = P);
        }
      }
    }
  }
  var be = typeof Uint8Array == "function";
  function fe(y) {
    return be && y != null && y instanceof Uint8Array;
  }
  var we;
  function Re(y) {
    if (this.L = y, y !== null && y.length === 0)
      throw Error("ByteString should be constructed with non-empty values");
  }
  var $e = typeof Uint8Array.prototype.slice == "function", Oe = 0, We = 0;
  function Ue(y, x) {
    if (y.constructor === Uint8Array)
      return y;
    if (y.constructor === ArrayBuffer)
      return new Uint8Array(y);
    if (y.constructor === Array)
      return new Uint8Array(y);
    if (y.constructor === String)
      return ne(y);
    if (y.constructor === Re)
      return !x && (x = y.L) && x.constructor === Uint8Array ? x : (x = y.L, x = x == null || fe(x) ? x : typeof x == "string" ? ne(x) : null, (y = y.L = x) ? new Uint8Array(y) : we || (we = new Uint8Array(0)));
    if (y instanceof Uint8Array)
      return new Uint8Array(y.buffer, y.byteOffset, y.byteLength);
    throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers");
  }
  function je(y, x) {
    return Error("Invalid wire type: " + y + " (at position " + x + ")");
  }
  function Ne() {
    return Error("Failed to read varint, encoding is invalid.");
  }
  function et(y, x) {
    x = x === void 0 ? {} : x, x = x.v === void 0 ? !1 : x.v, this.h = null, this.g = this.i = this.j = 0, this.v = x, y && Ye(this, y);
  }
  function Ye(y, x) {
    y.h = Ue(x, y.v), y.j = 0, y.i = y.h.length, y.g = y.j;
  }
  et.prototype.reset = function() {
    this.g = this.j;
  };
  function ct(y) {
    if (y.g > y.i)
      throw Error("Tried to read past the end of the data " + y.g + " > " + y.i);
  }
  function at(y) {
    var x = y.h, k = x[y.g], N = k & 127;
    if (128 > k)
      return y.g += 1, ct(y), N;
    if (k = x[y.g + 1], N |= (k & 127) << 7, 128 > k)
      return y.g += 2, ct(y), N;
    if (k = x[y.g + 2], N |= (k & 127) << 14, 128 > k)
      return y.g += 3, ct(y), N;
    if (k = x[y.g + 3], N |= (k & 127) << 21, 128 > k)
      return y.g += 4, ct(y), N;
    if (k = x[y.g + 4], y.g += 5, N |= (k & 15) << 28, 128 > k)
      return ct(y), N;
    if (128 <= x[y.g++] && 128 <= x[y.g++] && 128 <= x[y.g++] && 128 <= x[y.g++] && 128 <= x[y.g++])
      throw Ne();
    return ct(y), N;
  }
  var Ht = [];
  function st() {
    this.g = [];
  }
  st.prototype.length = function() {
    return this.g.length;
  }, st.prototype.end = function() {
    var y = this.g;
    return this.g = [], y;
  };
  function St(y, x) {
    for (; 127 < x; )
      y.g.push(x & 127 | 128), x >>>= 7;
    y.g.push(x);
  }
  function Mt(y) {
    var x = {}, k = x.W === void 0 ? !1 : x.W;
    this.l = { v: x.v === void 0 ? !1 : x.v }, this.W = k, x = this.l, Ht.length ? (k = Ht.pop(), x && (k.v = x.v), y && Ye(k, y), y = k) : y = new et(y, x), this.g = y, this.j = this.g.g, this.h = this.i = -1;
  }
  Mt.prototype.reset = function() {
    this.g.reset(), this.j = this.g.g, this.h = this.i = -1;
  };
  function Zt(y) {
    var x = y.g;
    if (x.g == x.i)
      return !1;
    y.j = y.g.g;
    var k = at(y.g) >>> 0;
    if (x = k >>> 3, k &= 7, !(0 <= k && 5 >= k))
      throw je(k, y.j);
    if (1 > x)
      throw Error("Invalid field number: " + x + " (at position " + y.j + ")");
    return y.i = x, y.h = k, !0;
  }
  function rn(y) {
    switch (y.h) {
      case 0:
        if (y.h != 0)
          rn(y);
        else
          e: {
            y = y.g;
            for (var x = y.g, k = x + 10; x < k; )
              if (!(y.h[x++] & 128)) {
                y.g = x, ct(y);
                break e;
              }
            throw Ne();
          }
        break;
      case 1:
        y = y.g, y.g += 8, ct(y);
        break;
      case 2:
        y.h != 2 ? rn(y) : (x = at(y.g) >>> 0, y = y.g, y.g += x, ct(y));
        break;
      case 5:
        y = y.g, y.g += 4, ct(y);
        break;
      case 3:
        x = y.i;
        do {
          if (!Zt(y))
            throw Error("Unmatched start-group tag: stream EOF");
          if (y.h == 4) {
            if (y.i != x)
              throw Error("Unmatched end-group tag");
            break;
          }
          rn(y);
        } while (1);
        break;
      default:
        throw je(y.h, y.j);
    }
  }
  var jt = [];
  function pn() {
    this.i = [], this.h = 0, this.g = new st();
  }
  function kn(y, x) {
    x.length !== 0 && (y.i.push(x), y.h += x.length);
  }
  function aa(y, x) {
    if (x = x.ba) {
      kn(y, y.g.end());
      for (var k = 0; k < x.length; k++)
        kn(y, x[k]);
    }
  }
  var En = typeof Symbol == "function" && typeof Symbol() == "symbol" ? Symbol(void 0) : void 0;
  function Ia(y, x) {
    Object.isFrozen(y) || (En ? y[En] |= x : y.N !== void 0 ? y.N |= x : Object.defineProperties(y, { N: { value: x, configurable: !0, writable: !0, enumerable: !1 } }));
  }
  function or(y) {
    var x;
    return En ? x = y[En] : x = y.N, x ?? 0;
  }
  function Xn(y) {
    return Ia(y, 1), y;
  }
  function Lt(y) {
    return Array.isArray(y) ? !!(or(y) & 2) : !1;
  }
  function ka(y) {
    if (!Array.isArray(y))
      throw Error("cannot mark non-array as immutable");
    Ia(y, 2);
  }
  function os(y) {
    return y !== null && typeof y == "object" && !Array.isArray(y) && y.constructor === Object;
  }
  var sa = Object.freeze(Xn([]));
  function is(y) {
    if (Lt(y.m))
      throw Error("Cannot mutate an immutable Message");
  }
  var hr = typeof Symbol < "u" && typeof Symbol.hasInstance < "u";
  function oa(y) {
    return { value: y, configurable: !1, writable: !1, enumerable: !1 };
  }
  function Tn(y, x, k) {
    return x === -1 ? null : x >= y.i ? y.g ? y.g[x] : void 0 : k !== void 0 && k && y.g && (k = y.g[x], k != null) ? k : y.m[x + y.h];
  }
  function Et(y, x, k, N) {
    N = N === void 0 ? !1 : N, is(y), x < y.i && !N ? y.m[x + y.h] = k : (y.g || (y.g = y.m[y.i + y.h] = {}))[x] = k;
  }
  function jr(y, x, k, N) {
    k = k === void 0 ? !0 : k, N = N === void 0 ? !1 : N;
    var P = Tn(y, x, N);
    return P == null && (P = sa), Lt(y.m) ? k && (ka(P), Object.freeze(P)) : (P === sa || Lt(P)) && (P = Xn(P.slice()), Et(y, x, P, N)), P;
  }
  function Pn(y, x, k) {
    return y = Tn(y, x), y = y == null ? y : +y, y ?? (k === void 0 ? 0 : k);
  }
  function J(y, x, k, N) {
    y.j || (y.j = {});
    var P = Lt(y.m), j = y.j[k];
    if (!j) {
      N = jr(y, k, !0, N === void 0 ? !1 : N), j = [], P = P || Lt(N);
      for (var L = 0; L < N.length; L++)
        j[L] = new x(N[L]), P && ka(j[L].m);
      P && (ka(j), Object.freeze(j)), y.j[k] = j;
    }
    return j;
  }
  function ce(y, x, k, N, P) {
    var j = j === void 0 ? !1 : j;
    return is(y), j = J(y, k, x, j), k = N || new k(), y = jr(y, x), P != null ? (j.splice(P, 0, k), y.splice(P, 0, k.m)) : (j.push(k), y.push(k.m)), k;
  }
  function Ce(y, x) {
    return y = Tn(y, x), y ?? 0;
  }
  function ve(y, x) {
    return y = Tn(y, x), y ?? "";
  }
  function bt(y) {
    switch (typeof y) {
      case "number":
        return isFinite(y) ? y : String(y);
      case "object":
        if (y && !Array.isArray(y)) {
          if (fe(y))
            return ee(y);
          if (y instanceof Re) {
            var x = y.L;
            return x = x == null || typeof x == "string" ? x : be && x instanceof Uint8Array ? ee(x) : null, (y.L = x) || "";
          }
        }
    }
    return y;
  }
  function _t(y) {
    var x = Ut;
    return x = x === void 0 ? Bn : x, Pe(y, x);
  }
  function He(y, x) {
    if (y != null) {
      if (Array.isArray(y))
        y = Pe(y, x);
      else if (os(y)) {
        var k = {}, N;
        for (N in y)
          k[N] = He(y[N], x);
        y = k;
      } else
        y = x(y);
      return y;
    }
  }
  function Pe(y, x) {
    for (var k = y.slice(), N = 0; N < k.length; N++)
      k[N] = He(k[N], x);
    return Array.isArray(y) && or(y) & 1 && Xn(k), k;
  }
  function Ut(y) {
    return y && typeof y == "object" && y.toJSON ? y.toJSON() : (y = bt(y), Array.isArray(y) ? _t(y) : y);
  }
  function Bn(y) {
    return fe(y) ? new Uint8Array(y) : y;
  }
  function Yn(y, x, k) {
    y || (y = us), us = null;
    var N = this.constructor.h;
    y || (y = N ? [N] : []), this.h = (N ? 0 : -1) - (this.constructor.g || 0), this.j = void 0, this.m = y;
    e: {
      if (N = this.m.length, y = N - 1, N && (N = this.m[y], os(N))) {
        this.i = y - this.h, this.g = N;
        break e;
      }
      x !== void 0 && -1 < x ? (this.i = Math.max(x, y + 1 - this.h), this.g = void 0) : this.i = Number.MAX_VALUE;
    }
    if (k)
      for (x = 0; x < k.length; x++)
        if (y = k[x], y < this.i)
          y += this.h, (N = this.m[y]) ? Array.isArray(N) && Xn(N) : this.m[y] = sa;
        else {
          N = this.g || (this.g = this.m[this.i + this.h] = {});
          var P = N[y];
          P ? Array.isArray(P) && Xn(P) : N[y] = sa;
        }
  }
  Yn.prototype.toJSON = function() {
    return _t(this.m);
  }, Yn.prototype.toString = function() {
    return this.m.toString();
  };
  var us;
  function Ur() {
    Yn.apply(this, arguments);
  }
  if (m(Ur, Yn), hr) {
    var cs = {};
    Object.defineProperties(Ur, (cs[Symbol.hasInstance] = oa(function() {
      throw Error("Cannot perform instanceof checks for MutableMessage");
    }), cs));
  }
  function an(y, x, k) {
    if (k) {
      var N = {}, P;
      for (P in k) {
        var j = k[P], L = j.ha;
        L || (N.F = j.la || j.fa.P, j.aa ? (N.U = Ea(j.aa), L = function(K) {
          return function(Q, de, Ee) {
            return K.F(Q, de, Ee, K.U);
          };
        }(N)) : j.ca ? (N.T = Lu(j.X.g, j.ca), L = function(K) {
          return function(Q, de, Ee) {
            return K.F(Q, de, Ee, K.T);
          };
        }(N)) : L = N.F, j.ha = L), L(x, y, j.X), N = { F: N.F, U: N.U, T: N.T };
      }
    }
    aa(x, y);
  }
  var ir = Symbol();
  function ls(y, x, k) {
    return y[ir] || (y[ir] = function(N, P) {
      return x(N, P, k);
    });
  }
  function Pu(y) {
    var x = y[ir];
    if (!x) {
      var k = ju(y);
      x = function(N, P) {
        return Uu(N, P, k);
      }, y[ir] = x;
    }
    return x;
  }
  function Ko(y) {
    var x = y.aa;
    if (x)
      return Pu(x);
    if (x = y.ka)
      return ls(y.X.g, x, y.ca);
  }
  function $f(y) {
    var x = Ko(y), k = y.X, N = y.fa.O;
    return x ? function(P, j) {
      return N(P, j, k, x);
    } : function(P, j) {
      return N(P, j, k);
    };
  }
  function Bu(y, x, k, N, P, j) {
    y = y();
    var L = 0;
    for (y.length && typeof y[0] != "number" && (k(x, y[0]), L++); L < y.length; ) {
      k = y[L++];
      for (var K = L + 1; K < y.length && typeof y[K] != "number"; )
        K++;
      var Q = y[L++];
      switch (K -= L, K) {
        case 0:
          N(x, k, Q);
          break;
        case 1:
          N(x, k, Q, y[L++]);
          break;
        case 2:
          P(x, k, Q, y[L++], y[L++]);
          break;
        case 3:
          K = y[L++];
          var de = y[L++], Ee = y[L++];
          Array.isArray(Ee) ? P(x, k, Q, K, de, Ee) : j(x, k, Q, K, de, Ee);
          break;
        case 4:
          j(x, k, Q, y[L++], y[L++], y[L++], y[L++]);
          break;
        default:
          throw Error("unexpected number of binary field arguments: " + K);
      }
    }
    return x;
  }
  var Xs = Symbol();
  function Ea(y) {
    var x = y[Xs];
    if (!x) {
      var k = Vu(y);
      x = function(N, P) {
        return Zo(N, P, k);
      }, y[Xs] = x;
    }
    return x;
  }
  function Lu(y, x) {
    var k = y[Xs];
    return k || (k = function(N, P) {
      return an(N, P, x);
    }, y[Xs] = k), k;
  }
  var Wu = Symbol();
  function zu(y, x) {
    y.push(x);
  }
  function Df(y, x, k) {
    y.push(x, k.P);
  }
  function Xo(y, x, k, N, P) {
    var j = Ea(P), L = k.P;
    y.push(x, function(K, Q, de) {
      return L(K, Q, de, N, j);
    });
  }
  function Of(y, x, k, N, P, j) {
    var L = Lu(N, j), K = k.P;
    y.push(x, function(Q, de, Ee) {
      return K(Q, de, Ee, N, L);
    });
  }
  function Vu(y) {
    var x = y[Wu];
    return x || Bu(y, y[Wu] = [], zu, Df, Xo, Of);
  }
  var Hu = Symbol();
  function Ta(y, x) {
    y[0] = x;
  }
  function Yo(y, x, k, N) {
    var P = k.O;
    y[x] = N ? function(j, L, K) {
      return P(j, L, K, N);
    } : P;
  }
  function Ff(y, x, k, N, P, j) {
    var L = k.O, K = Pu(P);
    y[x] = function(Q, de, Ee) {
      return L(Q, de, Ee, N, K, j);
    };
  }
  function Mf(y, x, k, N, P, j, L) {
    var K = k.O, Q = ls(N, P, j);
    y[x] = function(de, Ee, Be) {
      return K(de, Ee, Be, N, Q, L);
    };
  }
  function ju(y) {
    var x = y[Hu];
    return x || Bu(y, y[Hu] = {}, Ta, Yo, Ff, Mf);
  }
  function Uu(y, x, k) {
    for (; Zt(x) && x.h != 4; ) {
      var N = x.i, P = k[N];
      if (!P) {
        var j = k[0];
        j && (j = j[N]) && (P = k[N] = $f(j));
      }
      if ((!P || !P(x, y, N)) && (P = x, N = y, j = P.j, rn(P), !P.W)) {
        var L = P.g.h;
        P = P.g.g, P = j === P ? we || (we = new Uint8Array(0)) : $e ? L.slice(j, P) : new Uint8Array(L.subarray(j, P)), (j = N.ba) ? j.push(P) : N.ba = [P];
      }
    }
    return y;
  }
  function Ys(y, x, k) {
    if (jt.length) {
      var N = jt.pop();
      y && (Ye(N.g, y), N.i = -1, N.h = -1), y = N;
    } else
      y = new Mt(y);
    try {
      return Uu(new x(), y, ju(k));
    } finally {
      x = y.g, x.h = null, x.j = 0, x.i = 0, x.g = 0, x.v = !1, y.i = -1, y.h = -1, 100 > jt.length && jt.push(y);
    }
  }
  function Zo(y, x, k) {
    for (var N = k.length, P = N % 2 == 1, j = P ? 1 : 0; j < N; j += 2)
      (0, k[j + 1])(x, y, k[j]);
    an(y, x, P ? k[0] : void 0);
  }
  function Jo(y, x) {
    var k = new pn();
    Zo(y, k, Vu(x)), kn(k, k.g.end()), y = new Uint8Array(k.h), x = k.i;
    for (var N = x.length, P = 0, j = 0; j < N; j++) {
      var L = x[j];
      y.set(L, P), P += L.length;
    }
    return k.i = [y], y;
  }
  function ds(y, x) {
    return { O: y, P: x };
  }
  var Zn = ds(function(y, x, k) {
    if (y.h !== 5)
      return !1;
    y = y.g;
    var N = y.h[y.g], P = y.h[y.g + 1], j = y.h[y.g + 2], L = y.h[y.g + 3];
    return y.g += 4, ct(y), P = (N << 0 | P << 8 | j << 16 | L << 24) >>> 0, y = 2 * (P >> 31) + 1, N = P >>> 23 & 255, P &= 8388607, Et(x, k, N == 255 ? P ? NaN : 1 / 0 * y : N == 0 ? y * Math.pow(2, -149) * P : y * Math.pow(2, N - 150) * (P + Math.pow(2, 23))), !0;
  }, function(y, x, k) {
    if (x = Tn(x, k), x != null) {
      St(y.g, 8 * k + 5), y = y.g;
      var N = x;
      N = (k = 0 > N ? 1 : 0) ? -N : N, N === 0 ? 0 < 1 / N ? Oe = We = 0 : (We = 0, Oe = 2147483648) : isNaN(N) ? (We = 0, Oe = 2147483647) : 34028234663852886e22 < N ? (We = 0, Oe = (k << 31 | 2139095040) >>> 0) : 11754943508222875e-54 > N ? (N = Math.round(N / Math.pow(2, -149)), We = 0, Oe = (k << 31 | N) >>> 0) : (x = Math.floor(Math.log(N) / Math.LN2), N *= Math.pow(2, -x), N = Math.round(8388608 * N), 16777216 <= N && ++x, We = 0, Oe = (k << 31 | x + 127 << 23 | N & 8388607) >>> 0), k = Oe, y.g.push(k >>> 0 & 255), y.g.push(k >>> 8 & 255), y.g.push(k >>> 16 & 255), y.g.push(k >>> 24 & 255);
    }
  }), Gu = ds(function(y, x, k) {
    if (y.h !== 0)
      return !1;
    for (var N = y.g, P = 128, j = 0, L = y = 0; 4 > L && 128 <= P; L++)
      P = N.h[N.g++], ct(N), j |= (P & 127) << 7 * L;
    if (128 <= P && (P = N.h[N.g++], ct(N), j |= (P & 127) << 28, y |= (P & 127) >> 4), 128 <= P)
      for (L = 0; 5 > L && 128 <= P; L++)
        P = N.h[N.g++], ct(N), y |= (P & 127) << 7 * L + 3;
    if (128 > P)
      N = j >>> 0, P = y >>> 0, (y = P & 2147483648) && (N = ~N + 1 >>> 0, P = ~P >>> 0, N == 0 && (P = P + 1 >>> 0)), N = 4294967296 * P + (N >>> 0);
    else
      throw Ne();
    return Et(x, k, y ? -N : N), !0;
  }, function(y, x, k) {
    if (x = Tn(x, k), x != null && x != null) {
      St(y.g, 8 * k), y = y.g;
      var N = x;
      for (k = 0 > N, N = Math.abs(N), x = N >>> 0, N = Math.floor((N - x) / 4294967296), N >>>= 0, k && (N = ~N >>> 0, x = (~x >>> 0) + 1, 4294967295 < x && (x = 0, N++, 4294967295 < N && (N = 0))), Oe = x, We = N, k = Oe, x = We; 0 < x || 127 < k; )
        y.g.push(k & 127 | 128), k = (k >>> 7 | x << 25) >>> 0, x >>>= 7;
      y.g.push(k);
    }
  }), Pf = ds(function(y, x, k) {
    return y.h !== 0 ? !1 : (Et(x, k, at(y.g)), !0);
  }, function(y, x, k) {
    if (x = Tn(x, k), x != null && x != null)
      if (St(y.g, 8 * k), y = y.g, k = x, 0 <= k)
        St(y, k);
      else {
        for (x = 0; 9 > x; x++)
          y.g.push(k & 127 | 128), k >>= 7;
        y.g.push(1);
      }
  }), qu = ds(function(y, x, k) {
    if (y.h !== 2)
      return !1;
    var N = at(y.g) >>> 0;
    y = y.g;
    var P = y.g;
    y.g += N, ct(y), y = y.h;
    var j;
    if (q)
      (j = Z) || (j = Z = new TextDecoder("utf-8", { fatal: !0 })), j = j.decode(y.subarray(P, P + N));
    else {
      N = P + N;
      for (var L = [], K = null, Q, de, Ee; P < N; )
        Q = y[P++], 128 > Q ? L.push(Q) : 224 > Q ? P >= N ? H() : (de = y[P++], 194 > Q || (de & 192) !== 128 ? (P--, H()) : L.push((Q & 31) << 6 | de & 63)) : 240 > Q ? P >= N - 1 ? H() : (de = y[P++], (de & 192) !== 128 || Q === 224 && 160 > de || Q === 237 && 160 <= de || ((j = y[P++]) & 192) !== 128 ? (P--, H()) : L.push((Q & 15) << 12 | (de & 63) << 6 | j & 63)) : 244 >= Q ? P >= N - 2 ? H() : (de = y[P++], (de & 192) !== 128 || (Q << 28) + (de - 144) >> 30 || ((j = y[P++]) & 192) !== 128 || ((Ee = y[P++]) & 192) !== 128 ? (P--, H()) : (Q = (Q & 7) << 18 | (de & 63) << 12 | (j & 63) << 6 | Ee & 63, Q -= 65536, L.push((Q >> 10 & 1023) + 55296, (Q & 1023) + 56320))) : H(), 8192 <= L.length && (K = U(K, L), L.length = 0);
      j = U(K, L);
    }
    return Et(x, k, j), !0;
  }, function(y, x, k) {
    if (x = Tn(x, k), x != null) {
      var N = !1;
      if (N = N === void 0 ? !1 : N, se) {
        if (N && /(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(x))
          throw Error("Found an unpaired surrogate");
        x = (X || (X = new TextEncoder())).encode(x);
      } else {
        for (var P = 0, j = new Uint8Array(3 * x.length), L = 0; L < x.length; L++) {
          var K = x.charCodeAt(L);
          if (128 > K)
            j[P++] = K;
          else {
            if (2048 > K)
              j[P++] = K >> 6 | 192;
            else {
              if (55296 <= K && 57343 >= K) {
                if (56319 >= K && L < x.length) {
                  var Q = x.charCodeAt(++L);
                  if (56320 <= Q && 57343 >= Q) {
                    K = 1024 * (K - 55296) + Q - 56320 + 65536, j[P++] = K >> 18 | 240, j[P++] = K >> 12 & 63 | 128, j[P++] = K >> 6 & 63 | 128, j[P++] = K & 63 | 128;
                    continue;
                  } else
                    L--;
                }
                if (N)
                  throw Error("Found an unpaired surrogate");
                K = 65533;
              }
              j[P++] = K >> 12 | 224, j[P++] = K >> 6 & 63 | 128;
            }
            j[P++] = K & 63 | 128;
          }
        }
        x = j.subarray(0, P);
      }
      St(y.g, 8 * k + 2), St(y.g, x.length), kn(y, y.g.end()), kn(y, x);
    }
  }), Ku = ds(function(y, x, k, N, P) {
    if (y.h !== 2)
      return !1;
    x = ce(x, k, N), k = y.g.i, N = at(y.g) >>> 0;
    var j = y.g.g + N, L = j - k;
    if (0 >= L && (y.g.i = j, P(x, y), L = j - y.g.g), L)
      throw Error("Message parsing ended unexpectedly. Expected to read " + (N + " bytes, instead read " + (N - L) + " bytes, either the data ended unexpectedly or the message misreported its own length"));
    return y.g.g = j, y.g.i = k, !0;
  }, function(y, x, k, N, P) {
    if (x = J(x, N, k), x != null)
      for (N = 0; N < x.length; N++) {
        var j = y;
        St(j.g, 8 * k + 2);
        var L = j.g.end();
        kn(j, L), L.push(j.h), j = L, P(x[N], y), L = y;
        var K = j.pop();
        for (K = L.h + L.g.length() - K; 127 < K; )
          j.push(K & 127 | 128), K >>>= 7, L.h++;
        j.push(K), L.h++;
      }
  });
  function Jn() {
    Ur.apply(this, arguments);
  }
  if (m(Jn, Ur), hr) {
    var Qo = {};
    Object.defineProperties(Jn, (Qo[Symbol.hasInstance] = oa(Object[Symbol.hasInstance]), Qo));
  }
  function Gr(y) {
    Jn.call(this, y);
  }
  m(Gr, Jn);
  function ei() {
    return [1, Pf, 2, Zn, 3, qu, 4, qu];
  }
  function Zs(y) {
    Jn.call(this, y, -1, ti);
  }
  m(Zs, Jn), Zs.prototype.addClassification = function(y, x) {
    return ce(this, 1, Gr, y, x), this;
  };
  function Xu() {
    return [1, Ku, Gr, ei];
  }
  var ti = [1];
  function fs(y) {
    Jn.call(this, y);
  }
  m(fs, Jn);
  function ni() {
    return [1, Zn, 2, Zn, 3, Zn, 4, Zn, 5, Zn];
  }
  function Js(y) {
    Jn.call(this, y, -1, eo);
  }
  m(Js, Jn);
  function Qs() {
    return [1, Ku, fs, ni];
  }
  var eo = [1];
  function Ca(y) {
    Jn.call(this, y);
  }
  m(Ca, Jn);
  function ri() {
    return [1, Zn, 2, Zn, 3, Zn, 4, Zn, 5, Zn, 6, Gu];
  }
  var ps = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], hs = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [
    386,
    385
  ], [385, 384], [384, 398], [398, 362]], Yu = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], O = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], G = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], le = [
    [10, 338],
    [338, 297],
    [297, 332],
    [332, 284],
    [284, 251],
    [251, 389],
    [389, 356],
    [356, 454],
    [454, 323],
    [323, 361],
    [361, 288],
    [288, 397],
    [397, 365],
    [365, 379],
    [379, 378],
    [378, 400],
    [400, 377],
    [377, 152],
    [152, 148],
    [148, 176],
    [176, 149],
    [149, 150],
    [150, 136],
    [136, 172],
    [172, 58],
    [58, 132],
    [132, 93],
    [93, 234],
    [234, 127],
    [127, 162],
    [162, 21],
    [21, 54],
    [54, 103],
    [103, 67],
    [67, 109],
    [109, 10]
  ], De = [].concat(c(ps), c(hs), c(Yu), c(O), c(G), c(le));
  function Me(y, x, k) {
    if (k = y.createShader(k === 0 ? y.VERTEX_SHADER : y.FRAGMENT_SHADER), y.shaderSource(k, x), y.compileShader(k), !y.getShaderParameter(k, y.COMPILE_STATUS))
      throw Error(`Could not compile WebGL shader.

` + y.getShaderInfoLog(k));
    return k;
  }
  function ze(y) {
    return J(y, Gr, 1).map(function(x) {
      return { index: Ce(x, 1), ga: Pn(x, 2), label: Tn(x, 3) != null ? ve(x, 3) : void 0, displayName: Tn(x, 4) != null ? ve(x, 4) : void 0 };
    });
  }
  function Se(y) {
    return { x: Pn(y, 1), y: Pn(y, 2), z: Pn(y, 3), visibility: Tn(y, 4) != null ? Pn(y, 4) : void 0 };
  }
  function ke(y, x) {
    this.h = y, this.g = x, this.l = 0;
  }
  function Tt(y, x, k) {
    return Ln(y, x), typeof y.g.canvas.transferToImageBitmap == "function" ? Promise.resolve(y.g.canvas.transferToImageBitmap()) : k ? Promise.resolve(y.g.canvas) : typeof createImageBitmap == "function" ? createImageBitmap(y.g.canvas) : (y.i === void 0 && (y.i = document.createElement("canvas")), new Promise(function(N) {
      y.i.height = y.g.canvas.height, y.i.width = y.g.canvas.width, y.i.getContext("2d", {}).drawImage(y.g.canvas, 0, 0, y.g.canvas.width, y.g.canvas.height), N(y.i);
    }));
  }
  function Ln(y, x) {
    var k = y.g;
    if (y.o === void 0) {
      var N = Me(k, `
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`, 0), P = Me(k, `
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`, 1), j = k.createProgram();
      if (k.attachShader(j, N), k.attachShader(j, P), k.linkProgram(j), !k.getProgramParameter(j, k.LINK_STATUS))
        throw Error(`Could not compile WebGL program.

` + k.getProgramInfoLog(j));
      N = y.o = j, k.useProgram(N), P = k.getUniformLocation(N, "sampler0"), y.j = { K: k.getAttribLocation(N, "aVertex"), J: k.getAttribLocation(N, "aTex"), ma: P }, y.u = k.createBuffer(), k.bindBuffer(k.ARRAY_BUFFER, y.u), k.enableVertexAttribArray(y.j.K), k.vertexAttribPointer(y.j.K, 2, k.FLOAT, !1, 0, 0), k.bufferData(k.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), k.STATIC_DRAW), k.bindBuffer(k.ARRAY_BUFFER, null), y.s = k.createBuffer(), k.bindBuffer(k.ARRAY_BUFFER, y.s), k.enableVertexAttribArray(y.j.J), k.vertexAttribPointer(
        y.j.J,
        2,
        k.FLOAT,
        !1,
        0,
        0
      ), k.bufferData(k.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), k.STATIC_DRAW), k.bindBuffer(k.ARRAY_BUFFER, null), k.uniform1i(P, 0);
    }
    N = y.j, k.useProgram(y.o), k.canvas.width = x.width, k.canvas.height = x.height, k.viewport(0, 0, x.width, x.height), k.activeTexture(k.TEXTURE0), y.h.bindTexture2d(x.glName), k.enableVertexAttribArray(N.K), k.bindBuffer(k.ARRAY_BUFFER, y.u), k.vertexAttribPointer(N.K, 2, k.FLOAT, !1, 0, 0), k.enableVertexAttribArray(N.J), k.bindBuffer(k.ARRAY_BUFFER, y.s), k.vertexAttribPointer(
      N.J,
      2,
      k.FLOAT,
      !1,
      0,
      0
    ), k.bindFramebuffer(k.DRAW_FRAMEBUFFER ? k.DRAW_FRAMEBUFFER : k.FRAMEBUFFER, null), k.clearColor(0, 0, 0, 0), k.clear(k.COLOR_BUFFER_BIT), k.colorMask(!0, !0, !0, !0), k.drawArrays(k.TRIANGLE_FAN, 0, 4), k.disableVertexAttribArray(N.K), k.disableVertexAttribArray(N.J), k.bindBuffer(k.ARRAY_BUFFER, null), y.h.bindTexture2d(0);
  }
  function Tr(y) {
    this.g = y;
  }
  var Zu = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
  function ai(y, x) {
    return x + y;
  }
  function Ju(y, x) {
    window[y] = x;
  }
  function Cn(y) {
    var x = document.createElement("script");
    return x.setAttribute("src", y), x.setAttribute("crossorigin", "anonymous"), new Promise(function(k) {
      x.addEventListener("load", function() {
        k();
      }, !1), x.addEventListener("error", function() {
        k();
      }, !1), document.body.appendChild(x);
    });
  }
  function Na() {
    return D(function(y) {
      switch (y.g) {
        case 1:
          return y.o = 2, w(y, WebAssembly.instantiate(Zu), 4);
        case 4:
          y.g = 3, y.o = 0;
          break;
        case 2:
          return y.o = 0, y.j = null, y.return(!1);
        case 3:
          return y.return(!0);
      }
    });
  }
  function to(y) {
    if (this.g = y, this.listeners = {}, this.j = {}, this.H = {}, this.o = {}, this.u = {}, this.I = this.s = this.Z = !0, this.D = Promise.resolve(), this.Y = "", this.C = {}, this.locateFile = y && y.locateFile || ai, typeof window == "object")
      var x = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
    else if (typeof location < "u")
      x = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
    else
      throw Error("solutions can only be loaded on a web page or in a web worker");
    if (this.$ = x, y.options) {
      x = i(Object.keys(y.options));
      for (var k = x.next(); !k.done; k = x.next()) {
        k = k.value;
        var N = y.options[k].default;
        N !== void 0 && (this.j[k] = typeof N == "function" ? N() : N);
      }
    }
  }
  t = to.prototype, t.close = function() {
    return this.i && this.i.delete(), Promise.resolve();
  };
  function Q3(y) {
    var x, k, N, P, j, L, K, Q, de, Ee, Be;
    return D(function(Le) {
      switch (Le.g) {
        case 1:
          return y.Z ? (x = y.g.files === void 0 ? [] : typeof y.g.files == "function" ? y.g.files(y.j) : y.g.files, w(Le, Na(), 2)) : Le.return();
        case 2:
          if (k = Le.h, typeof window == "object")
            return Ju("createMediapipeSolutionsWasm", { locateFile: y.locateFile }), Ju("createMediapipeSolutionsPackedAssets", { locateFile: y.locateFile }), L = x.filter(function(Te) {
              return Te.data !== void 0;
            }), K = x.filter(function(Te) {
              return Te.data === void 0;
            }), Q = Promise.all(L.map(function(Te) {
              var Ge = Qu(y, Te.url);
              if (Te.path !== void 0) {
                var ft = Te.path;
                Ge = Ge.then(function(Pt) {
                  return y.overrideFile(ft, Pt), Promise.resolve(Pt);
                });
              }
              return Ge;
            })), de = Promise.all(K.map(function(Te) {
              return Te.simd === void 0 || Te.simd && k || !Te.simd && !k ? Cn(y.locateFile(Te.url, y.$)) : Promise.resolve();
            })).then(function() {
              var Te, Ge, ft;
              return D(function(Pt) {
                if (Pt.g == 1)
                  return Te = window.createMediapipeSolutionsWasm, Ge = window.createMediapipeSolutionsPackedAssets, ft = y, w(Pt, Te(Ge), 2);
                ft.h = Pt.h, Pt.g = 0;
              });
            }), Ee = function() {
              return D(function(Te) {
                return y.g.graph && y.g.graph.url ? Te = w(
                  Te,
                  Qu(y, y.g.graph.url),
                  0
                ) : (Te.g = 0, Te = void 0), Te;
              });
            }(), w(Le, Promise.all([de, Q, Ee]), 7);
          if (typeof importScripts != "function")
            throw Error("solutions can only be loaded on a web page or in a web worker");
          return N = x.filter(function(Te) {
            return Te.simd === void 0 || Te.simd && k || !Te.simd && !k;
          }).map(function(Te) {
            return y.locateFile(Te.url, y.$);
          }), importScripts.apply(null, c(N)), P = y, w(Le, createMediapipeSolutionsWasm(Module), 6);
        case 6:
          P.h = Le.h, y.l = new OffscreenCanvas(1, 1), y.h.canvas = y.l, j = y.h.GL.createContext(y.l, {
            antialias: !1,
            alpha: !1,
            ja: typeof WebGL2RenderingContext < "u" ? 2 : 1
          }), y.h.GL.makeContextCurrent(j), Le.g = 4;
          break;
        case 7:
          if (y.l = document.createElement("canvas"), Be = y.l.getContext("webgl2", {}), !Be && (Be = y.l.getContext("webgl", {}), !Be))
            return alert("Failed to create WebGL canvas context when passing video frame."), Le.return();
          y.G = Be, y.h.canvas = y.l, y.h.createContext(y.l, !0, !0, {});
        case 4:
          y.i = new y.h.SolutionWasm(), y.Z = !1, Le.g = 0;
      }
    });
  }
  function eI(y) {
    var x, k, N, P, j, L, K, Q;
    return D(function(de) {
      if (de.g == 1) {
        if (y.g.graph && y.g.graph.url && y.Y === y.g.graph.url)
          return de.return();
        if (y.s = !0, !y.g.graph || !y.g.graph.url) {
          de.g = 2;
          return;
        }
        return y.Y = y.g.graph.url, w(de, Qu(y, y.g.graph.url), 3);
      }
      for (de.g != 2 && (x = de.h, y.i.loadGraph(x)), k = i(Object.keys(y.C)), N = k.next(); !N.done; N = k.next())
        P = N.value, y.i.overrideFile(P, y.C[P]);
      if (y.C = {}, y.g.listeners)
        for (j = i(y.g.listeners), L = j.next(); !L.done; L = j.next())
          K = L.value, aI(y, K);
      Q = y.j, y.j = {}, y.setOptions(Q), de.g = 0;
    });
  }
  t.reset = function() {
    var y = this;
    return D(function(x) {
      y.i && (y.i.reset(), y.o = {}, y.u = {}), x.g = 0;
    });
  }, t.setOptions = function(y, x) {
    var k = this;
    if (x = x || this.g.options) {
      for (var N = [], P = [], j = {}, L = i(Object.keys(y)), K = L.next(); !K.done; j = { R: j.R, S: j.S }, K = L.next()) {
        var Q = K.value;
        Q in this.j && this.j[Q] === y[Q] || (this.j[Q] = y[Q], K = x[Q], K !== void 0 && (K.onChange && (j.R = K.onChange, j.S = y[Q], N.push(function(de) {
          return function() {
            var Ee;
            return D(function(Be) {
              if (Be.g == 1)
                return w(Be, de.R(de.S), 2);
              Ee = Be.h, Ee === !0 && (k.s = !0), Be.g = 0;
            });
          };
        }(j))), K.graphOptionXref && (Q = { valueNumber: K.type === 1 ? y[Q] : 0, valueBoolean: K.type === 0 ? y[Q] : !1, valueString: K.type === 2 ? y[Q] : "" }, K = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), K.graphOptionXref), Q), P.push(K))));
      }
      (N.length !== 0 || P.length !== 0) && (this.s = !0, this.B = (this.B === void 0 ? [] : this.B).concat(P), this.A = (this.A === void 0 ? [] : this.A).concat(N));
    }
  };
  function tI(y) {
    var x, k, N, P, j, L, K;
    return D(function(Q) {
      switch (Q.g) {
        case 1:
          if (!y.s)
            return Q.return();
          if (!y.A) {
            Q.g = 2;
            break;
          }
          x = i(y.A), k = x.next();
        case 3:
          if (k.done) {
            Q.g = 5;
            break;
          }
          return N = k.value, w(Q, N(), 4);
        case 4:
          k = x.next(), Q.g = 3;
          break;
        case 5:
          y.A = void 0;
        case 2:
          if (y.B) {
            for (P = new y.h.GraphOptionChangeRequestList(), j = i(y.B), L = j.next(); !L.done; L = j.next())
              K = L.value, P.push_back(K);
            y.i.changeOptions(P), P.delete(), y.B = void 0;
          }
          y.s = !1, Q.g = 0;
      }
    });
  }
  t.initialize = function() {
    var y = this;
    return D(function(x) {
      return x.g == 1 ? w(x, Q3(y), 2) : x.g != 3 ? w(x, eI(y), 3) : w(x, tI(y), 0);
    });
  };
  function Qu(y, x) {
    var k, N;
    return D(function(P) {
      return x in y.H ? P.return(y.H[x]) : (k = y.locateFile(x, ""), N = fetch(k).then(function(j) {
        return j.arrayBuffer();
      }), y.H[x] = N, P.return(N));
    });
  }
  t.overrideFile = function(y, x) {
    this.i ? this.i.overrideFile(y, x) : this.C[y] = x;
  }, t.clearOverriddenFiles = function() {
    this.C = {}, this.i && this.i.clearOverriddenFiles();
  }, t.send = function(y, x) {
    var k = this, N, P, j, L, K, Q, de, Ee, Be;
    return D(function(Le) {
      switch (Le.g) {
        case 1:
          return k.g.inputs ? (N = 1e3 * (x ?? performance.now()), w(Le, k.D, 2)) : Le.return();
        case 2:
          return w(Le, k.initialize(), 3);
        case 3:
          for (P = new k.h.PacketDataList(), j = i(Object.keys(y)), L = j.next(); !L.done; L = j.next())
            if (K = L.value, Q = k.g.inputs[K]) {
              e: {
                var Te = y[K];
                switch (Q.type) {
                  case "video":
                    var Ge = k.o[Q.stream];
                    if (Ge || (Ge = new ke(k.h, k.G), k.o[Q.stream] = Ge), Ge.l === 0 && (Ge.l = Ge.h.createTexture()), typeof HTMLVideoElement < "u" && Te instanceof HTMLVideoElement)
                      var ft = Te.videoWidth, Pt = Te.videoHeight;
                    else
                      typeof HTMLImageElement < "u" && Te instanceof HTMLImageElement ? (ft = Te.naturalWidth, Pt = Te.naturalHeight) : (ft = Te.width, Pt = Te.height);
                    Pt = { glName: Ge.l, width: ft, height: Pt }, ft = Ge.g, ft.canvas.width = Pt.width, ft.canvas.height = Pt.height, ft.activeTexture(ft.TEXTURE0), Ge.h.bindTexture2d(Ge.l), ft.texImage2D(ft.TEXTURE_2D, 0, ft.RGBA, ft.RGBA, ft.UNSIGNED_BYTE, Te), Ge.h.bindTexture2d(0), Ge = Pt;
                    break e;
                  case "detections":
                    for (Ge = k.o[Q.stream], Ge || (Ge = new Tr(k.h), k.o[Q.stream] = Ge), Ge.data || (Ge.data = new Ge.g.DetectionListData()), Ge.data.reset(Te.length), Pt = 0; Pt < Te.length; ++Pt) {
                      ft = Te[Pt];
                      var $t = Ge.data, wn = $t.setBoundingBox, mr = Pt, Qn = ft.boundingBox, ht = new Ca();
                      if (Et(ht, 1, Qn.xCenter), Et(ht, 2, Qn.yCenter), Et(ht, 3, Qn.height), Et(ht, 4, Qn.width), Et(ht, 5, Qn.rotation), Et(ht, 6, Qn.rectId), Qn = Jo(ht, ri), wn.call($t, mr, Qn), ft.landmarks)
                        for ($t = 0; $t < ft.landmarks.length; ++$t) {
                          ht = ft.landmarks[$t];
                          var ln = !!ht.visibility;
                          wn = Ge.data, mr = wn.addNormalizedLandmark, Qn = Pt, ht = Object.assign(Object.assign({}, ht), { visibility: ln ? ht.visibility : 0 }), ln = new fs(), Et(
                            ln,
                            1,
                            ht.x
                          ), Et(ln, 2, ht.y), Et(ln, 3, ht.z), ht.visibility && Et(ln, 4, ht.visibility), ht = Jo(ln, ni), mr.call(wn, Qn, ht);
                        }
                      if (ft.V)
                        for ($t = 0; $t < ft.V.length; ++$t)
                          wn = Ge.data, mr = wn.addClassification, Qn = Pt, ht = ft.V[$t], ln = new Gr(), Et(ln, 2, ht.ga), ht.index && Et(ln, 1, ht.index), ht.label && Et(ln, 3, ht.label), ht.displayName && Et(ln, 4, ht.displayName), ht = Jo(ln, ei), mr.call(wn, Qn, ht);
                    }
                    Ge = Ge.data;
                    break e;
                  default:
                    Ge = {};
                }
              }
              switch (de = Ge, Ee = Q.stream, Q.type) {
                case "video":
                  P.pushTexture2d(Object.assign(Object.assign({}, de), { stream: Ee, timestamp: N }));
                  break;
                case "detections":
                  Be = de, Be.stream = Ee, Be.timestamp = N, P.pushDetectionList(Be);
                  break;
                default:
                  throw Error("Unknown input config type: '" + Q.type + "'");
              }
            }
          return k.i.send(P), w(Le, k.D, 4);
        case 4:
          P.delete(), Le.g = 0;
      }
    });
  };
  function nI(y, x, k) {
    var N, P, j, L, K, Q, de, Ee, Be, Le, Te, Ge, ft, Pt;
    return D(function($t) {
      switch ($t.g) {
        case 1:
          if (!k)
            return $t.return(x);
          for (N = {}, P = 0, j = i(Object.keys(k)), L = j.next(); !L.done; L = j.next())
            K = L.value, Q = k[K], typeof Q != "string" && Q.type === "texture" && x[Q.stream] !== void 0 && ++P;
          1 < P && (y.I = !1), de = i(Object.keys(k)), L = de.next();
        case 2:
          if (L.done) {
            $t.g = 4;
            break;
          }
          if (Ee = L.value, Be = k[Ee], typeof Be == "string")
            return ft = N, Pt = Ee, w($t, rI(y, Ee, x[Be]), 14);
          if (Le = x[Be.stream], Be.type === "detection_list") {
            if (Le) {
              for (var wn = Le.getRectList(), mr = Le.getLandmarksList(), Qn = Le.getClassificationsList(), ht = [], ln = 0; ln < wn.size(); ++ln) {
                var Aa = Ys(wn.get(ln), Ca, ri);
                Aa = { boundingBox: { xCenter: Pn(Aa, 1), yCenter: Pn(Aa, 2), height: Pn(Aa, 3), width: Pn(Aa, 4), rotation: Pn(Aa, 5, 0), rectId: Ce(Aa, 6) }, landmarks: J(Ys(mr.get(ln), Js, Qs), fs, 1).map(Se), V: ze(Ys(Qn.get(ln), Zs, Xu)) }, ht.push(Aa);
              }
              wn = ht;
            } else
              wn = [];
            N[Ee] = wn, $t.g = 7;
            break;
          }
          if (Be.type === "proto_list") {
            if (Le) {
              for (wn = Array(Le.size()), mr = 0; mr < Le.size(); mr++)
                wn[mr] = Le.get(mr);
              Le.delete();
            } else
              wn = [];
            N[Ee] = wn, $t.g = 7;
            break;
          }
          if (Le === void 0) {
            $t.g = 3;
            break;
          }
          if (Be.type === "float_list") {
            N[Ee] = Le, $t.g = 7;
            break;
          }
          if (Be.type === "proto") {
            N[Ee] = Le, $t.g = 7;
            break;
          }
          if (Be.type !== "texture")
            throw Error("Unknown output config type: '" + Be.type + "'");
          return Te = y.u[Ee], Te || (Te = new ke(y.h, y.G), y.u[Ee] = Te), w($t, Tt(Te, Le, y.I), 13);
        case 13:
          Ge = $t.h, N[Ee] = Ge;
        case 7:
          Be.transform && N[Ee] && (N[Ee] = Be.transform(N[Ee])), $t.g = 3;
          break;
        case 14:
          ft[Pt] = $t.h;
        case 3:
          L = de.next(), $t.g = 2;
          break;
        case 4:
          return $t.return(N);
      }
    });
  }
  function rI(y, x, k) {
    var N;
    return D(function(P) {
      return typeof k == "number" || k instanceof Uint8Array || k instanceof y.h.Uint8BlobList ? P.return(k) : k instanceof y.h.Texture2dDataOut ? (N = y.u[x], N || (N = new ke(y.h, y.G), y.u[x] = N), P.return(Tt(N, k, y.I))) : P.return(void 0);
    });
  }
  function aI(y, x) {
    for (var k = x.name || "$", N = [].concat(c(x.wants)), P = new y.h.StringList(), j = i(x.wants), L = j.next(); !L.done; L = j.next())
      P.push_back(L.value);
    j = y.h.PacketListener.implement({ onResults: function(K) {
      for (var Q = {}, de = 0; de < x.wants.length; ++de)
        Q[N[de]] = K.get(de);
      var Ee = y.listeners[k];
      Ee && (y.D = nI(y, Q, x.outs).then(function(Be) {
        Be = Ee(Be);
        for (var Le = 0; Le < x.wants.length; ++Le) {
          var Te = Q[N[Le]];
          typeof Te == "object" && Te.hasOwnProperty && Te.hasOwnProperty("delete") && Te.delete();
        }
        Be && (y.D = Be);
      }));
    } }), y.i.attachMultiListener(P, j), P.delete();
  }
  t.onResults = function(y, x) {
    this.listeners[x || "$"] = y;
  }, V("Solution", to), V("OptionType", { BOOL: 0, NUMBER: 1, ia: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" });
  function Zg(y) {
    var x = this;
    y = y || {};
    var k = { url: "face_detection_short.binarypb" }, N = { type: 1, graphOptionXref: { calculatorType: "TensorsToDetectionsCalculator", calculatorName: "facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator", fieldName: "min_score_thresh" } };
    this.g = new to({
      locateFile: y.locateFile,
      files: [{ data: !0, url: "face_detection_short.binarypb" }, { data: !0, url: "face_detection_short_range.tflite" }, { simd: !0, url: "face_detection_solution_simd_wasm_bin.js" }, { simd: !1, url: "face_detection_solution_wasm_bin.js" }],
      graph: k,
      listeners: [{ wants: ["detections", "image_transformed"], outs: { image: "image_transformed", detections: { type: "detection_list", stream: "detections" } } }],
      inputs: { image: { type: "video", stream: "input_frames_gpu" } },
      options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: typeof window != "object" || window.navigator === void 0 ? !1 : "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, model: { type: 0, onChange: function(P) {
        var j, L, K, Q, de, Ee;
        return D(function(Be) {
          switch (Be.g) {
            case 1:
              j = P === "short" ? ["face_detection_short_range.tflite"] : ["face_detection_full_range_sparse.tflite"], L = i(j), K = L.next();
            case 2:
              if (K.done) {
                Be.g = 4;
                break;
              }
              return Q = K.value, de = "third_party/mediapipe/modules/face_detection/" + Q, w(Be, Qu(x.g, Q), 5);
            case 5:
              Ee = Be.h, x.g.overrideFile(de, Ee), K = L.next(), Be.g = 2;
              break;
            case 4:
              return k.url = P === "short" ? "face_detection_short.binarypb" : "face_detection_full.binarypb", N.graphOptionXref.calculatorName = P === "short" ? "facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator" : "facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator", Be.return(!0);
          }
        });
      } }, minDetectionConfidence: N }
    });
  }
  t = Zg.prototype, t.close = function() {
    return this.g.close(), Promise.resolve();
  }, t.onResults = function(y) {
    this.g.onResults(y);
  }, t.initialize = function() {
    var y = this;
    return D(function(x) {
      return w(x, y.g.initialize(), 0);
    });
  }, t.reset = function() {
    this.g.reset();
  }, t.send = function(y) {
    var x = this;
    return D(function(k) {
      return w(k, x.g.send(y), 0);
    });
  }, t.setOptions = function(y) {
    this.g.setOptions(y);
  }, V("FaceDetection", Zg), V("FACEDETECTION_LIPS", ps), V("FACEDETECTION_LEFT_EYE", hs), V("FACEDETECTION_LEFT_EYEBROW", Yu), V("FACEDETECTION_RIGHT_EYE", O), V("FACEDETECTION_RIGHT_EYEBROW", G), V("FACEDETECTION_FACE_OVAL", le), V("FACEDETECTION_CONTOURS", De), V("FACEDETECTION_TESSELATION", [
    [127, 34],
    [34, 139],
    [139, 127],
    [11, 0],
    [0, 37],
    [37, 11],
    [232, 231],
    [231, 120],
    [120, 232],
    [72, 37],
    [37, 39],
    [39, 72],
    [128, 121],
    [121, 47],
    [47, 128],
    [232, 121],
    [121, 128],
    [128, 232],
    [104, 69],
    [69, 67],
    [67, 104],
    [175, 171],
    [171, 148],
    [148, 175],
    [118, 50],
    [50, 101],
    [101, 118],
    [73, 39],
    [39, 40],
    [40, 73],
    [9, 151],
    [151, 108],
    [108, 9],
    [48, 115],
    [115, 131],
    [131, 48],
    [194, 204],
    [204, 211],
    [211, 194],
    [74, 40],
    [40, 185],
    [185, 74],
    [80, 42],
    [42, 183],
    [183, 80],
    [40, 92],
    [92, 186],
    [186, 40],
    [230, 229],
    [229, 118],
    [118, 230],
    [202, 212],
    [212, 214],
    [214, 202],
    [83, 18],
    [18, 17],
    [17, 83],
    [76, 61],
    [61, 146],
    [146, 76],
    [160, 29],
    [29, 30],
    [30, 160],
    [56, 157],
    [157, 173],
    [173, 56],
    [106, 204],
    [204, 194],
    [194, 106],
    [135, 214],
    [214, 192],
    [192, 135],
    [203, 165],
    [165, 98],
    [98, 203],
    [21, 71],
    [71, 68],
    [68, 21],
    [51, 45],
    [45, 4],
    [4, 51],
    [144, 24],
    [24, 23],
    [23, 144],
    [77, 146],
    [146, 91],
    [91, 77],
    [205, 50],
    [50, 187],
    [187, 205],
    [201, 200],
    [200, 18],
    [18, 201],
    [91, 106],
    [106, 182],
    [182, 91],
    [90, 91],
    [91, 181],
    [181, 90],
    [85, 84],
    [84, 17],
    [17, 85],
    [206, 203],
    [203, 36],
    [36, 206],
    [148, 171],
    [171, 140],
    [140, 148],
    [92, 40],
    [40, 39],
    [39, 92],
    [193, 189],
    [189, 244],
    [244, 193],
    [159, 158],
    [158, 28],
    [28, 159],
    [247, 246],
    [246, 161],
    [161, 247],
    [236, 3],
    [3, 196],
    [196, 236],
    [54, 68],
    [68, 104],
    [104, 54],
    [193, 168],
    [168, 8],
    [8, 193],
    [117, 228],
    [228, 31],
    [31, 117],
    [189, 193],
    [193, 55],
    [55, 189],
    [98, 97],
    [97, 99],
    [99, 98],
    [126, 47],
    [47, 100],
    [100, 126],
    [166, 79],
    [79, 218],
    [218, 166],
    [155, 154],
    [154, 26],
    [26, 155],
    [209, 49],
    [49, 131],
    [131, 209],
    [135, 136],
    [136, 150],
    [150, 135],
    [47, 126],
    [126, 217],
    [217, 47],
    [223, 52],
    [52, 53],
    [53, 223],
    [45, 51],
    [51, 134],
    [134, 45],
    [211, 170],
    [170, 140],
    [140, 211],
    [67, 69],
    [69, 108],
    [108, 67],
    [43, 106],
    [106, 91],
    [91, 43],
    [230, 119],
    [119, 120],
    [120, 230],
    [226, 130],
    [130, 247],
    [247, 226],
    [63, 53],
    [53, 52],
    [52, 63],
    [238, 20],
    [20, 242],
    [242, 238],
    [46, 70],
    [70, 156],
    [156, 46],
    [78, 62],
    [62, 96],
    [96, 78],
    [46, 53],
    [53, 63],
    [63, 46],
    [143, 34],
    [34, 227],
    [227, 143],
    [123, 117],
    [117, 111],
    [111, 123],
    [44, 125],
    [125, 19],
    [19, 44],
    [236, 134],
    [134, 51],
    [51, 236],
    [216, 206],
    [206, 205],
    [205, 216],
    [154, 153],
    [153, 22],
    [22, 154],
    [39, 37],
    [37, 167],
    [167, 39],
    [200, 201],
    [201, 208],
    [208, 200],
    [36, 142],
    [142, 100],
    [100, 36],
    [57, 212],
    [212, 202],
    [202, 57],
    [20, 60],
    [60, 99],
    [99, 20],
    [28, 158],
    [158, 157],
    [157, 28],
    [35, 226],
    [226, 113],
    [113, 35],
    [160, 159],
    [159, 27],
    [27, 160],
    [204, 202],
    [202, 210],
    [210, 204],
    [113, 225],
    [225, 46],
    [46, 113],
    [43, 202],
    [202, 204],
    [204, 43],
    [62, 76],
    [76, 77],
    [77, 62],
    [137, 123],
    [123, 116],
    [116, 137],
    [41, 38],
    [38, 72],
    [72, 41],
    [203, 129],
    [129, 142],
    [142, 203],
    [64, 98],
    [98, 240],
    [240, 64],
    [49, 102],
    [102, 64],
    [64, 49],
    [41, 73],
    [73, 74],
    [74, 41],
    [212, 216],
    [216, 207],
    [207, 212],
    [42, 74],
    [74, 184],
    [184, 42],
    [169, 170],
    [170, 211],
    [211, 169],
    [170, 149],
    [149, 176],
    [176, 170],
    [105, 66],
    [66, 69],
    [69, 105],
    [122, 6],
    [6, 168],
    [168, 122],
    [123, 147],
    [147, 187],
    [187, 123],
    [96, 77],
    [77, 90],
    [90, 96],
    [65, 55],
    [55, 107],
    [107, 65],
    [89, 90],
    [90, 180],
    [180, 89],
    [101, 100],
    [100, 120],
    [120, 101],
    [63, 105],
    [105, 104],
    [104, 63],
    [93, 137],
    [137, 227],
    [227, 93],
    [15, 86],
    [86, 85],
    [85, 15],
    [129, 102],
    [102, 49],
    [49, 129],
    [14, 87],
    [87, 86],
    [86, 14],
    [55, 8],
    [8, 9],
    [9, 55],
    [100, 47],
    [47, 121],
    [121, 100],
    [145, 23],
    [23, 22],
    [22, 145],
    [88, 89],
    [89, 179],
    [179, 88],
    [6, 122],
    [122, 196],
    [196, 6],
    [88, 95],
    [95, 96],
    [96, 88],
    [
      138,
      172
    ],
    [172, 136],
    [136, 138],
    [215, 58],
    [58, 172],
    [172, 215],
    [115, 48],
    [48, 219],
    [219, 115],
    [42, 80],
    [80, 81],
    [81, 42],
    [195, 3],
    [3, 51],
    [51, 195],
    [43, 146],
    [146, 61],
    [61, 43],
    [171, 175],
    [175, 199],
    [199, 171],
    [81, 82],
    [82, 38],
    [38, 81],
    [53, 46],
    [46, 225],
    [225, 53],
    [144, 163],
    [163, 110],
    [110, 144],
    [52, 65],
    [65, 66],
    [66, 52],
    [229, 228],
    [228, 117],
    [117, 229],
    [34, 127],
    [127, 234],
    [234, 34],
    [107, 108],
    [108, 69],
    [69, 107],
    [109, 108],
    [108, 151],
    [151, 109],
    [48, 64],
    [64, 235],
    [235, 48],
    [62, 78],
    [78, 191],
    [191, 62],
    [129, 209],
    [209, 126],
    [126, 129],
    [111, 35],
    [35, 143],
    [143, 111],
    [117, 123],
    [123, 50],
    [50, 117],
    [222, 65],
    [65, 52],
    [52, 222],
    [19, 125],
    [125, 141],
    [141, 19],
    [221, 55],
    [55, 65],
    [65, 221],
    [3, 195],
    [195, 197],
    [197, 3],
    [25, 7],
    [7, 33],
    [33, 25],
    [220, 237],
    [237, 44],
    [44, 220],
    [70, 71],
    [71, 139],
    [139, 70],
    [122, 193],
    [193, 245],
    [245, 122],
    [247, 130],
    [130, 33],
    [33, 247],
    [71, 21],
    [21, 162],
    [162, 71],
    [170, 169],
    [169, 150],
    [150, 170],
    [188, 174],
    [174, 196],
    [196, 188],
    [216, 186],
    [186, 92],
    [92, 216],
    [2, 97],
    [97, 167],
    [167, 2],
    [141, 125],
    [125, 241],
    [241, 141],
    [164, 167],
    [167, 37],
    [37, 164],
    [72, 38],
    [38, 12],
    [12, 72],
    [
      38,
      82
    ],
    [82, 13],
    [13, 38],
    [63, 68],
    [68, 71],
    [71, 63],
    [226, 35],
    [35, 111],
    [111, 226],
    [101, 50],
    [50, 205],
    [205, 101],
    [206, 92],
    [92, 165],
    [165, 206],
    [209, 198],
    [198, 217],
    [217, 209],
    [165, 167],
    [167, 97],
    [97, 165],
    [220, 115],
    [115, 218],
    [218, 220],
    [133, 112],
    [112, 243],
    [243, 133],
    [239, 238],
    [238, 241],
    [241, 239],
    [214, 135],
    [135, 169],
    [169, 214],
    [190, 173],
    [173, 133],
    [133, 190],
    [171, 208],
    [208, 32],
    [32, 171],
    [125, 44],
    [44, 237],
    [237, 125],
    [86, 87],
    [87, 178],
    [178, 86],
    [85, 86],
    [86, 179],
    [179, 85],
    [84, 85],
    [85, 180],
    [180, 84],
    [83, 84],
    [84, 181],
    [181, 83],
    [
      201,
      83
    ],
    [83, 182],
    [182, 201],
    [137, 93],
    [93, 132],
    [132, 137],
    [76, 62],
    [62, 183],
    [183, 76],
    [61, 76],
    [76, 184],
    [184, 61],
    [57, 61],
    [61, 185],
    [185, 57],
    [212, 57],
    [57, 186],
    [186, 212],
    [214, 207],
    [207, 187],
    [187, 214],
    [34, 143],
    [143, 156],
    [156, 34],
    [79, 239],
    [239, 237],
    [237, 79],
    [123, 137],
    [137, 177],
    [177, 123],
    [44, 1],
    [1, 4],
    [4, 44],
    [201, 194],
    [194, 32],
    [32, 201],
    [64, 102],
    [102, 129],
    [129, 64],
    [213, 215],
    [215, 138],
    [138, 213],
    [59, 166],
    [166, 219],
    [219, 59],
    [242, 99],
    [99, 97],
    [97, 242],
    [2, 94],
    [94, 141],
    [141, 2],
    [75, 59],
    [59, 235],
    [235, 75],
    [24, 110],
    [110, 228],
    [228, 24],
    [25, 130],
    [130, 226],
    [226, 25],
    [23, 24],
    [24, 229],
    [229, 23],
    [22, 23],
    [23, 230],
    [230, 22],
    [26, 22],
    [22, 231],
    [231, 26],
    [112, 26],
    [26, 232],
    [232, 112],
    [189, 190],
    [190, 243],
    [243, 189],
    [221, 56],
    [56, 190],
    [190, 221],
    [28, 56],
    [56, 221],
    [221, 28],
    [27, 28],
    [28, 222],
    [222, 27],
    [29, 27],
    [27, 223],
    [223, 29],
    [30, 29],
    [29, 224],
    [224, 30],
    [247, 30],
    [30, 225],
    [225, 247],
    [238, 79],
    [79, 20],
    [20, 238],
    [166, 59],
    [59, 75],
    [75, 166],
    [60, 75],
    [75, 240],
    [240, 60],
    [147, 177],
    [177, 215],
    [215, 147],
    [20, 79],
    [79, 166],
    [166, 20],
    [187, 147],
    [147, 213],
    [213, 187],
    [
      112,
      233
    ],
    [233, 244],
    [244, 112],
    [233, 128],
    [128, 245],
    [245, 233],
    [128, 114],
    [114, 188],
    [188, 128],
    [114, 217],
    [217, 174],
    [174, 114],
    [131, 115],
    [115, 220],
    [220, 131],
    [217, 198],
    [198, 236],
    [236, 217],
    [198, 131],
    [131, 134],
    [134, 198],
    [177, 132],
    [132, 58],
    [58, 177],
    [143, 35],
    [35, 124],
    [124, 143],
    [110, 163],
    [163, 7],
    [7, 110],
    [228, 110],
    [110, 25],
    [25, 228],
    [356, 389],
    [389, 368],
    [368, 356],
    [11, 302],
    [302, 267],
    [267, 11],
    [452, 350],
    [350, 349],
    [349, 452],
    [302, 303],
    [303, 269],
    [269, 302],
    [357, 343],
    [343, 277],
    [277, 357],
    [452, 453],
    [453, 357],
    [357, 452],
    [333, 332],
    [332, 297],
    [297, 333],
    [175, 152],
    [152, 377],
    [377, 175],
    [347, 348],
    [348, 330],
    [330, 347],
    [303, 304],
    [304, 270],
    [270, 303],
    [9, 336],
    [336, 337],
    [337, 9],
    [278, 279],
    [279, 360],
    [360, 278],
    [418, 262],
    [262, 431],
    [431, 418],
    [304, 408],
    [408, 409],
    [409, 304],
    [310, 415],
    [415, 407],
    [407, 310],
    [270, 409],
    [409, 410],
    [410, 270],
    [450, 348],
    [348, 347],
    [347, 450],
    [422, 430],
    [430, 434],
    [434, 422],
    [313, 314],
    [314, 17],
    [17, 313],
    [306, 307],
    [307, 375],
    [375, 306],
    [387, 388],
    [388, 260],
    [260, 387],
    [286, 414],
    [414, 398],
    [398, 286],
    [335, 406],
    [406, 418],
    [418, 335],
    [364, 367],
    [367, 416],
    [416, 364],
    [423, 358],
    [358, 327],
    [327, 423],
    [251, 284],
    [284, 298],
    [298, 251],
    [281, 5],
    [5, 4],
    [4, 281],
    [373, 374],
    [374, 253],
    [253, 373],
    [307, 320],
    [320, 321],
    [321, 307],
    [425, 427],
    [427, 411],
    [411, 425],
    [421, 313],
    [313, 18],
    [18, 421],
    [321, 405],
    [405, 406],
    [406, 321],
    [320, 404],
    [404, 405],
    [405, 320],
    [315, 16],
    [16, 17],
    [17, 315],
    [426, 425],
    [425, 266],
    [266, 426],
    [377, 400],
    [400, 369],
    [369, 377],
    [322, 391],
    [391, 269],
    [269, 322],
    [417, 465],
    [465, 464],
    [464, 417],
    [386, 257],
    [257, 258],
    [258, 386],
    [466, 260],
    [260, 388],
    [388, 466],
    [456, 399],
    [
      399,
      419
    ],
    [419, 456],
    [284, 332],
    [332, 333],
    [333, 284],
    [417, 285],
    [285, 8],
    [8, 417],
    [346, 340],
    [340, 261],
    [261, 346],
    [413, 441],
    [441, 285],
    [285, 413],
    [327, 460],
    [460, 328],
    [328, 327],
    [355, 371],
    [371, 329],
    [329, 355],
    [392, 439],
    [439, 438],
    [438, 392],
    [382, 341],
    [341, 256],
    [256, 382],
    [429, 420],
    [420, 360],
    [360, 429],
    [364, 394],
    [394, 379],
    [379, 364],
    [277, 343],
    [343, 437],
    [437, 277],
    [443, 444],
    [444, 283],
    [283, 443],
    [275, 440],
    [440, 363],
    [363, 275],
    [431, 262],
    [262, 369],
    [369, 431],
    [297, 338],
    [338, 337],
    [337, 297],
    [273, 375],
    [375, 321],
    [321, 273],
    [450, 451],
    [451, 349],
    [349, 450],
    [446, 342],
    [342, 467],
    [467, 446],
    [293, 334],
    [334, 282],
    [282, 293],
    [458, 461],
    [461, 462],
    [462, 458],
    [276, 353],
    [353, 383],
    [383, 276],
    [308, 324],
    [324, 325],
    [325, 308],
    [276, 300],
    [300, 293],
    [293, 276],
    [372, 345],
    [345, 447],
    [447, 372],
    [352, 345],
    [345, 340],
    [340, 352],
    [274, 1],
    [1, 19],
    [19, 274],
    [456, 248],
    [248, 281],
    [281, 456],
    [436, 427],
    [427, 425],
    [425, 436],
    [381, 256],
    [256, 252],
    [252, 381],
    [269, 391],
    [391, 393],
    [393, 269],
    [200, 199],
    [199, 428],
    [428, 200],
    [266, 330],
    [330, 329],
    [329, 266],
    [287, 273],
    [273, 422],
    [422, 287],
    [250, 462],
    [462, 328],
    [328, 250],
    [258, 286],
    [286, 384],
    [384, 258],
    [265, 353],
    [353, 342],
    [342, 265],
    [387, 259],
    [259, 257],
    [257, 387],
    [424, 431],
    [431, 430],
    [430, 424],
    [342, 353],
    [353, 276],
    [276, 342],
    [273, 335],
    [335, 424],
    [424, 273],
    [292, 325],
    [325, 307],
    [307, 292],
    [366, 447],
    [447, 345],
    [345, 366],
    [271, 303],
    [303, 302],
    [302, 271],
    [423, 266],
    [266, 371],
    [371, 423],
    [294, 455],
    [455, 460],
    [460, 294],
    [279, 278],
    [278, 294],
    [294, 279],
    [271, 272],
    [272, 304],
    [304, 271],
    [432, 434],
    [434, 427],
    [427, 432],
    [272, 407],
    [407, 408],
    [408, 272],
    [394, 430],
    [430, 431],
    [431, 394],
    [
      395,
      369
    ],
    [369, 400],
    [400, 395],
    [334, 333],
    [333, 299],
    [299, 334],
    [351, 417],
    [417, 168],
    [168, 351],
    [352, 280],
    [280, 411],
    [411, 352],
    [325, 319],
    [319, 320],
    [320, 325],
    [295, 296],
    [296, 336],
    [336, 295],
    [319, 403],
    [403, 404],
    [404, 319],
    [330, 348],
    [348, 349],
    [349, 330],
    [293, 298],
    [298, 333],
    [333, 293],
    [323, 454],
    [454, 447],
    [447, 323],
    [15, 16],
    [16, 315],
    [315, 15],
    [358, 429],
    [429, 279],
    [279, 358],
    [14, 15],
    [15, 316],
    [316, 14],
    [285, 336],
    [336, 9],
    [9, 285],
    [329, 349],
    [349, 350],
    [350, 329],
    [374, 380],
    [380, 252],
    [252, 374],
    [318, 402],
    [402, 403],
    [403, 318],
    [6, 197],
    [197, 419],
    [419, 6],
    [318, 319],
    [319, 325],
    [325, 318],
    [367, 364],
    [364, 365],
    [365, 367],
    [435, 367],
    [367, 397],
    [397, 435],
    [344, 438],
    [438, 439],
    [439, 344],
    [272, 271],
    [271, 311],
    [311, 272],
    [195, 5],
    [5, 281],
    [281, 195],
    [273, 287],
    [287, 291],
    [291, 273],
    [396, 428],
    [428, 199],
    [199, 396],
    [311, 271],
    [271, 268],
    [268, 311],
    [283, 444],
    [444, 445],
    [445, 283],
    [373, 254],
    [254, 339],
    [339, 373],
    [282, 334],
    [334, 296],
    [296, 282],
    [449, 347],
    [347, 346],
    [346, 449],
    [264, 447],
    [447, 454],
    [454, 264],
    [336, 296],
    [296, 299],
    [299, 336],
    [338, 10],
    [10, 151],
    [151, 338],
    [278, 439],
    [439, 455],
    [455, 278],
    [292, 407],
    [407, 415],
    [415, 292],
    [358, 371],
    [371, 355],
    [355, 358],
    [340, 345],
    [345, 372],
    [372, 340],
    [346, 347],
    [347, 280],
    [280, 346],
    [442, 443],
    [443, 282],
    [282, 442],
    [19, 94],
    [94, 370],
    [370, 19],
    [441, 442],
    [442, 295],
    [295, 441],
    [248, 419],
    [419, 197],
    [197, 248],
    [263, 255],
    [255, 359],
    [359, 263],
    [440, 275],
    [275, 274],
    [274, 440],
    [300, 383],
    [383, 368],
    [368, 300],
    [351, 412],
    [412, 465],
    [465, 351],
    [263, 467],
    [467, 466],
    [466, 263],
    [301, 368],
    [368, 389],
    [389, 301],
    [395, 378],
    [378, 379],
    [379, 395],
    [412, 351],
    [351, 419],
    [419, 412],
    [
      436,
      426
    ],
    [426, 322],
    [322, 436],
    [2, 164],
    [164, 393],
    [393, 2],
    [370, 462],
    [462, 461],
    [461, 370],
    [164, 0],
    [0, 267],
    [267, 164],
    [302, 11],
    [11, 12],
    [12, 302],
    [268, 12],
    [12, 13],
    [13, 268],
    [293, 300],
    [300, 301],
    [301, 293],
    [446, 261],
    [261, 340],
    [340, 446],
    [330, 266],
    [266, 425],
    [425, 330],
    [426, 423],
    [423, 391],
    [391, 426],
    [429, 355],
    [355, 437],
    [437, 429],
    [391, 327],
    [327, 326],
    [326, 391],
    [440, 457],
    [457, 438],
    [438, 440],
    [341, 382],
    [382, 362],
    [362, 341],
    [459, 457],
    [457, 461],
    [461, 459],
    [434, 430],
    [430, 394],
    [394, 434],
    [414, 463],
    [463, 362],
    [362, 414],
    [396, 369],
    [
      369,
      262
    ],
    [262, 396],
    [354, 461],
    [461, 457],
    [457, 354],
    [316, 403],
    [403, 402],
    [402, 316],
    [315, 404],
    [404, 403],
    [403, 315],
    [314, 405],
    [405, 404],
    [404, 314],
    [313, 406],
    [406, 405],
    [405, 313],
    [421, 418],
    [418, 406],
    [406, 421],
    [366, 401],
    [401, 361],
    [361, 366],
    [306, 408],
    [408, 407],
    [407, 306],
    [291, 409],
    [409, 408],
    [408, 291],
    [287, 410],
    [410, 409],
    [409, 287],
    [432, 436],
    [436, 410],
    [410, 432],
    [434, 416],
    [416, 411],
    [411, 434],
    [264, 368],
    [368, 383],
    [383, 264],
    [309, 438],
    [438, 457],
    [457, 309],
    [352, 376],
    [376, 401],
    [401, 352],
    [274, 275],
    [275, 4],
    [4, 274],
    [421, 428],
    [428, 262],
    [262, 421],
    [294, 327],
    [327, 358],
    [358, 294],
    [433, 416],
    [416, 367],
    [367, 433],
    [289, 455],
    [455, 439],
    [439, 289],
    [462, 370],
    [370, 326],
    [326, 462],
    [2, 326],
    [326, 370],
    [370, 2],
    [305, 460],
    [460, 455],
    [455, 305],
    [254, 449],
    [449, 448],
    [448, 254],
    [255, 261],
    [261, 446],
    [446, 255],
    [253, 450],
    [450, 449],
    [449, 253],
    [252, 451],
    [451, 450],
    [450, 252],
    [256, 452],
    [452, 451],
    [451, 256],
    [341, 453],
    [453, 452],
    [452, 341],
    [413, 464],
    [464, 463],
    [463, 413],
    [441, 413],
    [413, 414],
    [414, 441],
    [258, 442],
    [442, 441],
    [441, 258],
    [257, 443],
    [443, 442],
    [442, 257],
    [
      259,
      444
    ],
    [444, 443],
    [443, 259],
    [260, 445],
    [445, 444],
    [444, 260],
    [467, 342],
    [342, 445],
    [445, 467],
    [459, 458],
    [458, 250],
    [250, 459],
    [289, 392],
    [392, 290],
    [290, 289],
    [290, 328],
    [328, 460],
    [460, 290],
    [376, 433],
    [433, 435],
    [435, 376],
    [250, 290],
    [290, 392],
    [392, 250],
    [411, 416],
    [416, 433],
    [433, 411],
    [341, 463],
    [463, 464],
    [464, 341],
    [453, 464],
    [464, 465],
    [465, 453],
    [357, 465],
    [465, 412],
    [412, 357],
    [343, 412],
    [412, 399],
    [399, 343],
    [360, 363],
    [363, 440],
    [440, 360],
    [437, 399],
    [399, 456],
    [456, 437],
    [420, 456],
    [456, 363],
    [363, 420],
    [401, 435],
    [435, 288],
    [288, 401],
    [372, 383],
    [383, 353],
    [353, 372],
    [339, 255],
    [255, 249],
    [249, 339],
    [448, 261],
    [261, 255],
    [255, 448],
    [133, 243],
    [243, 190],
    [190, 133],
    [133, 155],
    [155, 112],
    [112, 133],
    [33, 246],
    [246, 247],
    [247, 33],
    [33, 130],
    [130, 25],
    [25, 33],
    [398, 384],
    [384, 286],
    [286, 398],
    [362, 398],
    [398, 414],
    [414, 362],
    [362, 463],
    [463, 341],
    [341, 362],
    [263, 359],
    [359, 467],
    [467, 263],
    [263, 249],
    [249, 255],
    [255, 263],
    [466, 467],
    [467, 260],
    [260, 466],
    [75, 60],
    [60, 166],
    [166, 75],
    [238, 239],
    [239, 79],
    [79, 238],
    [162, 127],
    [127, 139],
    [139, 162],
    [72, 11],
    [11, 37],
    [37, 72],
    [121, 232],
    [232, 120],
    [120, 121],
    [73, 72],
    [72, 39],
    [39, 73],
    [114, 128],
    [128, 47],
    [47, 114],
    [233, 232],
    [232, 128],
    [128, 233],
    [103, 104],
    [104, 67],
    [67, 103],
    [152, 175],
    [175, 148],
    [148, 152],
    [119, 118],
    [118, 101],
    [101, 119],
    [74, 73],
    [73, 40],
    [40, 74],
    [107, 9],
    [9, 108],
    [108, 107],
    [49, 48],
    [48, 131],
    [131, 49],
    [32, 194],
    [194, 211],
    [211, 32],
    [184, 74],
    [74, 185],
    [185, 184],
    [191, 80],
    [80, 183],
    [183, 191],
    [185, 40],
    [40, 186],
    [186, 185],
    [119, 230],
    [230, 118],
    [118, 119],
    [210, 202],
    [202, 214],
    [214, 210],
    [84, 83],
    [83, 17],
    [17, 84],
    [77, 76],
    [76, 146],
    [146, 77],
    [161, 160],
    [
      160,
      30
    ],
    [30, 161],
    [190, 56],
    [56, 173],
    [173, 190],
    [182, 106],
    [106, 194],
    [194, 182],
    [138, 135],
    [135, 192],
    [192, 138],
    [129, 203],
    [203, 98],
    [98, 129],
    [54, 21],
    [21, 68],
    [68, 54],
    [5, 51],
    [51, 4],
    [4, 5],
    [145, 144],
    [144, 23],
    [23, 145],
    [90, 77],
    [77, 91],
    [91, 90],
    [207, 205],
    [205, 187],
    [187, 207],
    [83, 201],
    [201, 18],
    [18, 83],
    [181, 91],
    [91, 182],
    [182, 181],
    [180, 90],
    [90, 181],
    [181, 180],
    [16, 85],
    [85, 17],
    [17, 16],
    [205, 206],
    [206, 36],
    [36, 205],
    [176, 148],
    [148, 140],
    [140, 176],
    [165, 92],
    [92, 39],
    [39, 165],
    [245, 193],
    [193, 244],
    [244, 245],
    [27, 159],
    [159, 28],
    [28, 27],
    [30, 247],
    [247, 161],
    [161, 30],
    [174, 236],
    [236, 196],
    [196, 174],
    [103, 54],
    [54, 104],
    [104, 103],
    [55, 193],
    [193, 8],
    [8, 55],
    [111, 117],
    [117, 31],
    [31, 111],
    [221, 189],
    [189, 55],
    [55, 221],
    [240, 98],
    [98, 99],
    [99, 240],
    [142, 126],
    [126, 100],
    [100, 142],
    [219, 166],
    [166, 218],
    [218, 219],
    [112, 155],
    [155, 26],
    [26, 112],
    [198, 209],
    [209, 131],
    [131, 198],
    [169, 135],
    [135, 150],
    [150, 169],
    [114, 47],
    [47, 217],
    [217, 114],
    [224, 223],
    [223, 53],
    [53, 224],
    [220, 45],
    [45, 134],
    [134, 220],
    [32, 211],
    [211, 140],
    [140, 32],
    [109, 67],
    [67, 108],
    [108, 109],
    [146, 43],
    [43, 91],
    [
      91,
      146
    ],
    [231, 230],
    [230, 120],
    [120, 231],
    [113, 226],
    [226, 247],
    [247, 113],
    [105, 63],
    [63, 52],
    [52, 105],
    [241, 238],
    [238, 242],
    [242, 241],
    [124, 46],
    [46, 156],
    [156, 124],
    [95, 78],
    [78, 96],
    [96, 95],
    [70, 46],
    [46, 63],
    [63, 70],
    [116, 143],
    [143, 227],
    [227, 116],
    [116, 123],
    [123, 111],
    [111, 116],
    [1, 44],
    [44, 19],
    [19, 1],
    [3, 236],
    [236, 51],
    [51, 3],
    [207, 216],
    [216, 205],
    [205, 207],
    [26, 154],
    [154, 22],
    [22, 26],
    [165, 39],
    [39, 167],
    [167, 165],
    [199, 200],
    [200, 208],
    [208, 199],
    [101, 36],
    [36, 100],
    [100, 101],
    [43, 57],
    [57, 202],
    [202, 43],
    [242, 20],
    [20, 99],
    [99, 242],
    [
      56,
      28
    ],
    [28, 157],
    [157, 56],
    [124, 35],
    [35, 113],
    [113, 124],
    [29, 160],
    [160, 27],
    [27, 29],
    [211, 204],
    [204, 210],
    [210, 211],
    [124, 113],
    [113, 46],
    [46, 124],
    [106, 43],
    [43, 204],
    [204, 106],
    [96, 62],
    [62, 77],
    [77, 96],
    [227, 137],
    [137, 116],
    [116, 227],
    [73, 41],
    [41, 72],
    [72, 73],
    [36, 203],
    [203, 142],
    [142, 36],
    [235, 64],
    [64, 240],
    [240, 235],
    [48, 49],
    [49, 64],
    [64, 48],
    [42, 41],
    [41, 74],
    [74, 42],
    [214, 212],
    [212, 207],
    [207, 214],
    [183, 42],
    [42, 184],
    [184, 183],
    [210, 169],
    [169, 211],
    [211, 210],
    [140, 170],
    [170, 176],
    [176, 140],
    [104, 105],
    [105, 69],
    [69, 104],
    [193, 122],
    [
      122,
      168
    ],
    [168, 193],
    [50, 123],
    [123, 187],
    [187, 50],
    [89, 96],
    [96, 90],
    [90, 89],
    [66, 65],
    [65, 107],
    [107, 66],
    [179, 89],
    [89, 180],
    [180, 179],
    [119, 101],
    [101, 120],
    [120, 119],
    [68, 63],
    [63, 104],
    [104, 68],
    [234, 93],
    [93, 227],
    [227, 234],
    [16, 15],
    [15, 85],
    [85, 16],
    [209, 129],
    [129, 49],
    [49, 209],
    [15, 14],
    [14, 86],
    [86, 15],
    [107, 55],
    [55, 9],
    [9, 107],
    [120, 100],
    [100, 121],
    [121, 120],
    [153, 145],
    [145, 22],
    [22, 153],
    [178, 88],
    [88, 179],
    [179, 178],
    [197, 6],
    [6, 196],
    [196, 197],
    [89, 88],
    [88, 96],
    [96, 89],
    [135, 138],
    [138, 136],
    [136, 135],
    [138, 215],
    [215, 172],
    [172, 138],
    [218, 115],
    [115, 219],
    [219, 218],
    [41, 42],
    [42, 81],
    [81, 41],
    [5, 195],
    [195, 51],
    [51, 5],
    [57, 43],
    [43, 61],
    [61, 57],
    [208, 171],
    [171, 199],
    [199, 208],
    [41, 81],
    [81, 38],
    [38, 41],
    [224, 53],
    [53, 225],
    [225, 224],
    [24, 144],
    [144, 110],
    [110, 24],
    [105, 52],
    [52, 66],
    [66, 105],
    [118, 229],
    [229, 117],
    [117, 118],
    [227, 34],
    [34, 234],
    [234, 227],
    [66, 107],
    [107, 69],
    [69, 66],
    [10, 109],
    [109, 151],
    [151, 10],
    [219, 48],
    [48, 235],
    [235, 219],
    [183, 62],
    [62, 191],
    [191, 183],
    [142, 129],
    [129, 126],
    [126, 142],
    [116, 111],
    [111, 143],
    [143, 116],
    [118, 117],
    [117, 50],
    [50, 118],
    [223, 222],
    [222, 52],
    [52, 223],
    [94, 19],
    [19, 141],
    [141, 94],
    [222, 221],
    [221, 65],
    [65, 222],
    [196, 3],
    [3, 197],
    [197, 196],
    [45, 220],
    [220, 44],
    [44, 45],
    [156, 70],
    [70, 139],
    [139, 156],
    [188, 122],
    [122, 245],
    [245, 188],
    [139, 71],
    [71, 162],
    [162, 139],
    [149, 170],
    [170, 150],
    [150, 149],
    [122, 188],
    [188, 196],
    [196, 122],
    [206, 216],
    [216, 92],
    [92, 206],
    [164, 2],
    [2, 167],
    [167, 164],
    [242, 141],
    [141, 241],
    [241, 242],
    [0, 164],
    [164, 37],
    [37, 0],
    [11, 72],
    [72, 12],
    [12, 11],
    [12, 38],
    [38, 13],
    [13, 12],
    [70, 63],
    [63, 71],
    [71, 70],
    [31, 226],
    [226, 111],
    [111, 31],
    [36, 101],
    [101, 205],
    [
      205,
      36
    ],
    [203, 206],
    [206, 165],
    [165, 203],
    [126, 209],
    [209, 217],
    [217, 126],
    [98, 165],
    [165, 97],
    [97, 98],
    [237, 220],
    [220, 218],
    [218, 237],
    [237, 239],
    [239, 241],
    [241, 237],
    [210, 214],
    [214, 169],
    [169, 210],
    [140, 171],
    [171, 32],
    [32, 140],
    [241, 125],
    [125, 237],
    [237, 241],
    [179, 86],
    [86, 178],
    [178, 179],
    [180, 85],
    [85, 179],
    [179, 180],
    [181, 84],
    [84, 180],
    [180, 181],
    [182, 83],
    [83, 181],
    [181, 182],
    [194, 201],
    [201, 182],
    [182, 194],
    [177, 137],
    [137, 132],
    [132, 177],
    [184, 76],
    [76, 183],
    [183, 184],
    [185, 61],
    [61, 184],
    [184, 185],
    [186, 57],
    [57, 185],
    [185, 186],
    [216, 212],
    [212, 186],
    [186, 216],
    [192, 214],
    [214, 187],
    [187, 192],
    [139, 34],
    [34, 156],
    [156, 139],
    [218, 79],
    [79, 237],
    [237, 218],
    [147, 123],
    [123, 177],
    [177, 147],
    [45, 44],
    [44, 4],
    [4, 45],
    [208, 201],
    [201, 32],
    [32, 208],
    [98, 64],
    [64, 129],
    [129, 98],
    [192, 213],
    [213, 138],
    [138, 192],
    [235, 59],
    [59, 219],
    [219, 235],
    [141, 242],
    [242, 97],
    [97, 141],
    [97, 2],
    [2, 141],
    [141, 97],
    [240, 75],
    [75, 235],
    [235, 240],
    [229, 24],
    [24, 228],
    [228, 229],
    [31, 25],
    [25, 226],
    [226, 31],
    [230, 23],
    [23, 229],
    [229, 230],
    [231, 22],
    [22, 230],
    [230, 231],
    [232, 26],
    [26, 231],
    [231, 232],
    [233, 112],
    [
      112,
      232
    ],
    [232, 233],
    [244, 189],
    [189, 243],
    [243, 244],
    [189, 221],
    [221, 190],
    [190, 189],
    [222, 28],
    [28, 221],
    [221, 222],
    [223, 27],
    [27, 222],
    [222, 223],
    [224, 29],
    [29, 223],
    [223, 224],
    [225, 30],
    [30, 224],
    [224, 225],
    [113, 247],
    [247, 225],
    [225, 113],
    [99, 60],
    [60, 240],
    [240, 99],
    [213, 147],
    [147, 215],
    [215, 213],
    [60, 20],
    [20, 166],
    [166, 60],
    [192, 187],
    [187, 213],
    [213, 192],
    [243, 112],
    [112, 244],
    [244, 243],
    [244, 233],
    [233, 245],
    [245, 244],
    [245, 128],
    [128, 188],
    [188, 245],
    [188, 114],
    [114, 174],
    [174, 188],
    [134, 131],
    [131, 220],
    [220, 134],
    [174, 217],
    [217, 236],
    [
      236,
      174
    ],
    [236, 198],
    [198, 134],
    [134, 236],
    [215, 177],
    [177, 58],
    [58, 215],
    [156, 143],
    [143, 124],
    [124, 156],
    [25, 110],
    [110, 7],
    [7, 25],
    [31, 228],
    [228, 25],
    [25, 31],
    [264, 356],
    [356, 368],
    [368, 264],
    [0, 11],
    [11, 267],
    [267, 0],
    [451, 452],
    [452, 349],
    [349, 451],
    [267, 302],
    [302, 269],
    [269, 267],
    [350, 357],
    [357, 277],
    [277, 350],
    [350, 452],
    [452, 357],
    [357, 350],
    [299, 333],
    [333, 297],
    [297, 299],
    [396, 175],
    [175, 377],
    [377, 396],
    [280, 347],
    [347, 330],
    [330, 280],
    [269, 303],
    [303, 270],
    [270, 269],
    [151, 9],
    [9, 337],
    [337, 151],
    [344, 278],
    [278, 360],
    [360, 344],
    [424, 418],
    [418, 431],
    [431, 424],
    [270, 304],
    [304, 409],
    [409, 270],
    [272, 310],
    [310, 407],
    [407, 272],
    [322, 270],
    [270, 410],
    [410, 322],
    [449, 450],
    [450, 347],
    [347, 449],
    [432, 422],
    [422, 434],
    [434, 432],
    [18, 313],
    [313, 17],
    [17, 18],
    [291, 306],
    [306, 375],
    [375, 291],
    [259, 387],
    [387, 260],
    [260, 259],
    [424, 335],
    [335, 418],
    [418, 424],
    [434, 364],
    [364, 416],
    [416, 434],
    [391, 423],
    [423, 327],
    [327, 391],
    [301, 251],
    [251, 298],
    [298, 301],
    [275, 281],
    [281, 4],
    [4, 275],
    [254, 373],
    [373, 253],
    [253, 254],
    [375, 307],
    [307, 321],
    [321, 375],
    [280, 425],
    [425, 411],
    [411, 280],
    [200, 421],
    [421, 18],
    [18, 200],
    [335, 321],
    [321, 406],
    [406, 335],
    [321, 320],
    [320, 405],
    [405, 321],
    [314, 315],
    [315, 17],
    [17, 314],
    [423, 426],
    [426, 266],
    [266, 423],
    [396, 377],
    [377, 369],
    [369, 396],
    [270, 322],
    [322, 269],
    [269, 270],
    [413, 417],
    [417, 464],
    [464, 413],
    [385, 386],
    [386, 258],
    [258, 385],
    [248, 456],
    [456, 419],
    [419, 248],
    [298, 284],
    [284, 333],
    [333, 298],
    [168, 417],
    [417, 8],
    [8, 168],
    [448, 346],
    [346, 261],
    [261, 448],
    [417, 413],
    [413, 285],
    [285, 417],
    [326, 327],
    [327, 328],
    [328, 326],
    [277, 355],
    [355, 329],
    [329, 277],
    [309, 392],
    [392, 438],
    [438, 309],
    [381, 382],
    [382, 256],
    [256, 381],
    [279, 429],
    [429, 360],
    [360, 279],
    [365, 364],
    [364, 379],
    [379, 365],
    [355, 277],
    [277, 437],
    [437, 355],
    [282, 443],
    [443, 283],
    [283, 282],
    [281, 275],
    [275, 363],
    [363, 281],
    [395, 431],
    [431, 369],
    [369, 395],
    [299, 297],
    [297, 337],
    [337, 299],
    [335, 273],
    [273, 321],
    [321, 335],
    [348, 450],
    [450, 349],
    [349, 348],
    [359, 446],
    [446, 467],
    [467, 359],
    [283, 293],
    [293, 282],
    [282, 283],
    [250, 458],
    [458, 462],
    [462, 250],
    [300, 276],
    [276, 383],
    [383, 300],
    [292, 308],
    [308, 325],
    [325, 292],
    [283, 276],
    [276, 293],
    [293, 283],
    [264, 372],
    [372, 447],
    [447, 264],
    [
      346,
      352
    ],
    [352, 340],
    [340, 346],
    [354, 274],
    [274, 19],
    [19, 354],
    [363, 456],
    [456, 281],
    [281, 363],
    [426, 436],
    [436, 425],
    [425, 426],
    [380, 381],
    [381, 252],
    [252, 380],
    [267, 269],
    [269, 393],
    [393, 267],
    [421, 200],
    [200, 428],
    [428, 421],
    [371, 266],
    [266, 329],
    [329, 371],
    [432, 287],
    [287, 422],
    [422, 432],
    [290, 250],
    [250, 328],
    [328, 290],
    [385, 258],
    [258, 384],
    [384, 385],
    [446, 265],
    [265, 342],
    [342, 446],
    [386, 387],
    [387, 257],
    [257, 386],
    [422, 424],
    [424, 430],
    [430, 422],
    [445, 342],
    [342, 276],
    [276, 445],
    [422, 273],
    [273, 424],
    [424, 422],
    [306, 292],
    [292, 307],
    [307, 306],
    [352, 366],
    [366, 345],
    [345, 352],
    [268, 271],
    [271, 302],
    [302, 268],
    [358, 423],
    [423, 371],
    [371, 358],
    [327, 294],
    [294, 460],
    [460, 327],
    [331, 279],
    [279, 294],
    [294, 331],
    [303, 271],
    [271, 304],
    [304, 303],
    [436, 432],
    [432, 427],
    [427, 436],
    [304, 272],
    [272, 408],
    [408, 304],
    [395, 394],
    [394, 431],
    [431, 395],
    [378, 395],
    [395, 400],
    [400, 378],
    [296, 334],
    [334, 299],
    [299, 296],
    [6, 351],
    [351, 168],
    [168, 6],
    [376, 352],
    [352, 411],
    [411, 376],
    [307, 325],
    [325, 320],
    [320, 307],
    [285, 295],
    [295, 336],
    [336, 285],
    [320, 319],
    [319, 404],
    [404, 320],
    [329, 330],
    [330, 349],
    [
      349,
      329
    ],
    [334, 293],
    [293, 333],
    [333, 334],
    [366, 323],
    [323, 447],
    [447, 366],
    [316, 15],
    [15, 315],
    [315, 316],
    [331, 358],
    [358, 279],
    [279, 331],
    [317, 14],
    [14, 316],
    [316, 317],
    [8, 285],
    [285, 9],
    [9, 8],
    [277, 329],
    [329, 350],
    [350, 277],
    [253, 374],
    [374, 252],
    [252, 253],
    [319, 318],
    [318, 403],
    [403, 319],
    [351, 6],
    [6, 419],
    [419, 351],
    [324, 318],
    [318, 325],
    [325, 324],
    [397, 367],
    [367, 365],
    [365, 397],
    [288, 435],
    [435, 397],
    [397, 288],
    [278, 344],
    [344, 439],
    [439, 278],
    [310, 272],
    [272, 311],
    [311, 310],
    [248, 195],
    [195, 281],
    [281, 248],
    [375, 273],
    [273, 291],
    [291, 375],
    [
      175,
      396
    ],
    [396, 199],
    [199, 175],
    [312, 311],
    [311, 268],
    [268, 312],
    [276, 283],
    [283, 445],
    [445, 276],
    [390, 373],
    [373, 339],
    [339, 390],
    [295, 282],
    [282, 296],
    [296, 295],
    [448, 449],
    [449, 346],
    [346, 448],
    [356, 264],
    [264, 454],
    [454, 356],
    [337, 336],
    [336, 299],
    [299, 337],
    [337, 338],
    [338, 151],
    [151, 337],
    [294, 278],
    [278, 455],
    [455, 294],
    [308, 292],
    [292, 415],
    [415, 308],
    [429, 358],
    [358, 355],
    [355, 429],
    [265, 340],
    [340, 372],
    [372, 265],
    [352, 346],
    [346, 280],
    [280, 352],
    [295, 442],
    [442, 282],
    [282, 295],
    [354, 19],
    [19, 370],
    [370, 354],
    [285, 441],
    [441, 295],
    [295, 285],
    [195, 248],
    [248, 197],
    [197, 195],
    [457, 440],
    [440, 274],
    [274, 457],
    [301, 300],
    [300, 368],
    [368, 301],
    [417, 351],
    [351, 465],
    [465, 417],
    [251, 301],
    [301, 389],
    [389, 251],
    [394, 395],
    [395, 379],
    [379, 394],
    [399, 412],
    [412, 419],
    [419, 399],
    [410, 436],
    [436, 322],
    [322, 410],
    [326, 2],
    [2, 393],
    [393, 326],
    [354, 370],
    [370, 461],
    [461, 354],
    [393, 164],
    [164, 267],
    [267, 393],
    [268, 302],
    [302, 12],
    [12, 268],
    [312, 268],
    [268, 13],
    [13, 312],
    [298, 293],
    [293, 301],
    [301, 298],
    [265, 446],
    [446, 340],
    [340, 265],
    [280, 330],
    [330, 425],
    [425, 280],
    [322, 426],
    [426, 391],
    [391, 322],
    [420, 429],
    [429, 437],
    [437, 420],
    [393, 391],
    [391, 326],
    [326, 393],
    [344, 440],
    [440, 438],
    [438, 344],
    [458, 459],
    [459, 461],
    [461, 458],
    [364, 434],
    [434, 394],
    [394, 364],
    [428, 396],
    [396, 262],
    [262, 428],
    [274, 354],
    [354, 457],
    [457, 274],
    [317, 316],
    [316, 402],
    [402, 317],
    [316, 315],
    [315, 403],
    [403, 316],
    [315, 314],
    [314, 404],
    [404, 315],
    [314, 313],
    [313, 405],
    [405, 314],
    [313, 421],
    [421, 406],
    [406, 313],
    [323, 366],
    [366, 361],
    [361, 323],
    [292, 306],
    [306, 407],
    [407, 292],
    [306, 291],
    [291, 408],
    [408, 306],
    [291, 287],
    [287, 409],
    [409, 291],
    [287, 432],
    [432, 410],
    [
      410,
      287
    ],
    [427, 434],
    [434, 411],
    [411, 427],
    [372, 264],
    [264, 383],
    [383, 372],
    [459, 309],
    [309, 457],
    [457, 459],
    [366, 352],
    [352, 401],
    [401, 366],
    [1, 274],
    [274, 4],
    [4, 1],
    [418, 421],
    [421, 262],
    [262, 418],
    [331, 294],
    [294, 358],
    [358, 331],
    [435, 433],
    [433, 367],
    [367, 435],
    [392, 289],
    [289, 439],
    [439, 392],
    [328, 462],
    [462, 326],
    [326, 328],
    [94, 2],
    [2, 370],
    [370, 94],
    [289, 305],
    [305, 455],
    [455, 289],
    [339, 254],
    [254, 448],
    [448, 339],
    [359, 255],
    [255, 446],
    [446, 359],
    [254, 253],
    [253, 449],
    [449, 254],
    [253, 252],
    [252, 450],
    [450, 253],
    [252, 256],
    [256, 451],
    [451, 252],
    [256, 341],
    [341, 452],
    [452, 256],
    [414, 413],
    [413, 463],
    [463, 414],
    [286, 441],
    [441, 414],
    [414, 286],
    [286, 258],
    [258, 441],
    [441, 286],
    [258, 257],
    [257, 442],
    [442, 258],
    [257, 259],
    [259, 443],
    [443, 257],
    [259, 260],
    [260, 444],
    [444, 259],
    [260, 467],
    [467, 445],
    [445, 260],
    [309, 459],
    [459, 250],
    [250, 309],
    [305, 289],
    [289, 290],
    [290, 305],
    [305, 290],
    [290, 460],
    [460, 305],
    [401, 376],
    [376, 435],
    [435, 401],
    [309, 250],
    [250, 392],
    [392, 309],
    [376, 411],
    [411, 433],
    [433, 376],
    [453, 341],
    [341, 464],
    [464, 453],
    [357, 453],
    [453, 465],
    [465, 357],
    [343, 357],
    [357, 412],
    [
      412,
      343
    ],
    [437, 343],
    [343, 399],
    [399, 437],
    [344, 360],
    [360, 440],
    [440, 344],
    [420, 437],
    [437, 456],
    [456, 420],
    [360, 420],
    [420, 363],
    [363, 360],
    [361, 401],
    [401, 288],
    [288, 361],
    [265, 372],
    [372, 353],
    [353, 265],
    [390, 339],
    [339, 249],
    [249, 390],
    [339, 448],
    [448, 255],
    [255, 339]
  ]), V("VERSION", "0.4.1646425229");
}).call($n);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FM = Xe();
FM.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => !1, (t) => {
  t && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var yr;
(function(t) {
  t[t.DT_INVALID = 0] = "DT_INVALID", t[t.DT_FLOAT = 1] = "DT_FLOAT", t[t.DT_DOUBLE = 2] = "DT_DOUBLE", t[t.DT_INT32 = 3] = "DT_INT32", t[t.DT_UINT8 = 4] = "DT_UINT8", t[t.DT_INT16 = 5] = "DT_INT16", t[t.DT_INT8 = 6] = "DT_INT8", t[t.DT_STRING = 7] = "DT_STRING", t[t.DT_COMPLEX64 = 8] = "DT_COMPLEX64", t[t.DT_INT64 = 9] = "DT_INT64", t[t.DT_BOOL = 10] = "DT_BOOL", t[t.DT_QINT8 = 11] = "DT_QINT8", t[t.DT_QUINT8 = 12] = "DT_QUINT8", t[t.DT_QINT32 = 13] = "DT_QINT32", t[t.DT_BFLOAT16 = 14] = "DT_BFLOAT16", t[t.DT_QINT16 = 15] = "DT_QINT16", t[t.DT_QUINT16 = 16] = "DT_QUINT16", t[t.DT_UINT16 = 17] = "DT_UINT16", t[t.DT_COMPLEX128 = 18] = "DT_COMPLEX128", t[t.DT_HALF = 19] = "DT_HALF", t[t.DT_RESOURCE = 20] = "DT_RESOURCE", t[t.DT_VARIANT = 21] = "DT_VARIANT", t[t.DT_UINT32 = 22] = "DT_UINT32", t[t.DT_UINT64 = 23] = "DT_UINT64", t[t.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", t[t.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", t[t.DT_INT32_REF = 103] = "DT_INT32_REF", t[t.DT_UINT8_REF = 104] = "DT_UINT8_REF", t[t.DT_INT16_REF = 105] = "DT_INT16_REF", t[t.DT_INT8_REF = 106] = "DT_INT8_REF", t[t.DT_STRING_REF = 107] = "DT_STRING_REF", t[t.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", t[t.DT_INT64_REF = 109] = "DT_INT64_REF", t[t.DT_BOOL_REF = 110] = "DT_BOOL_REF", t[t.DT_QINT8_REF = 111] = "DT_QINT8_REF", t[t.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", t[t.DT_QINT32_REF = 113] = "DT_QINT32_REF", t[t.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", t[t.DT_QINT16_REF = 115] = "DT_QINT16_REF", t[t.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", t[t.DT_UINT16_REF = 117] = "DT_UINT16_REF", t[t.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", t[t.DT_HALF_REF = 119] = "DT_HALF_REF", t[t.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", t[t.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", t[t.DT_UINT32_REF = 122] = "DT_UINT32_REF", t[t.DT_UINT64_REF = 123] = "DT_UINT64_REF";
})(yr || (yr = {}));
var lv;
(function(t) {
  (function(e) {
    e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2";
  })(t.CheckpointFormatVersion || (t.CheckpointFormatVersion = {}));
})(lv || (lv = {}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const MM = {};
function p2(t) {
  return MM[t];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _(t, e, n, r, a) {
  const s = e.inputParams[t];
  if (s && s.inputIndexStart !== void 0) {
    const i = s.inputIndexStart, c = s.inputIndexEnd === 0 ? void 0 : s.inputIndexEnd === void 0 ? i + 1 : s.inputIndexEnd, l = i < 0 ? e.inputNames.length + i : i;
    if (s.type === "tensor")
      return gn(e.inputNames[l], n, r, a);
    if (s.type === "tensors") {
      const f = e.inputs.slice(i, c);
      return e.inputNames.slice(i, c).filter((h, m) => {
        var g;
        return ((g = f[m]) === null || g === void 0 ? void 0 : g.op) !== "NoOp";
      }).map((h) => gn(h, n, r, a));
    }
    const u = gn(e.inputNames[l], n, r, a), d = u.dataSync();
    return s.type === "number" ? d[0] : xr(u.shape, d);
  }
  const o = e.attrParams[t];
  return o && o.value;
}
function gn(t, e, n, r) {
  const [a, s] = tr(t, n);
  if (r != null) {
    const i = r.getHashTableHandleByName(a);
    if (i != null)
      return i;
  }
  const o = n.currentContextIds.find((i) => !!e[qc(a, i)]);
  return o !== void 0 ? e[qc(a, o)][s] : void 0;
}
function dv(t, e, n) {
  return e[qc(t, n.currentContextId)];
}
function ca(t, e) {
  const [n, r, a] = tr(t, e);
  return [
    qc(n, e && e.currentContextId),
    r,
    a
  ];
}
function qc(t, e) {
  return e ? `${t}-${e}` : t;
}
function tr(t, e) {
  if (t === "")
    return ["", 0, void 0];
  const n = e != null && e.parseNodeNameCache != null;
  if (n) {
    const s = e.parseNodeNameCache.get(t);
    if (s != null)
      return s;
  }
  const r = t.split(":");
  let a;
  if (r.length === 1)
    a = [t, 0, void 0];
  else {
    const s = r[0], o = r.length === 3 ? r[1] : void 0, i = Number(r[r.length - 1]);
    a = [s, i, o];
  }
  return n && e.parseNodeNameCache.set(t, a), a;
}
function Sc(t, e, n) {
  let r = _("pad", t, e, n);
  if (r === "explicit") {
    r = _("explicitPaddings", t, e, n);
    const a = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let s = 0; s < 4; s++)
      a[s][0] = r[s * 2], a[s][1] = r[s * 2 + 1];
    return a;
  }
  return r;
}
function la(t) {
  return t.kept ? t : Wa(t);
}
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PM = [
  {
    tfOpName: "Add",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "AddV2",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "AddN",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "BiasAdd",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sub",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "RealDiv",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Div",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "DivNoNan",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FloorDiv",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Mul",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Maximum",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Minimum",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Pow",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "SquaredDifference",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Mod",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FloorMod",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  }
], BM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: PM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const LM = [
  {
    tfOpName: "Abs",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Acos",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Asin",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Atan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Atan2",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Ceil",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ClipByValue",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "clipValueMin",
        type: "number"
      },
      {
        start: 2,
        name: "clipValueMax",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Complex",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "real",
        type: "tensor"
      },
      {
        start: 1,
        name: "imag",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ComplexAbs",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Cos",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Cosh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Elu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Exp",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Floor",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Log",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Imag",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Neg",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Real",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Prelu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "alpha",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Relu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Relu6",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Selu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sigmoid",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sin",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sinh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sqrt",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Rsqrt",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Square",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Tan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Tanh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Sign",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Round",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Expm1",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Log1p",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Reciprocal",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Softplus",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Asinh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Acosh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Atanh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Erf",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LeakyRelu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 0.2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IsNan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IsFinite",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IsInf",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  }
], WM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: LM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zM = [
  {
    tfOpName: "EmptyTensorList",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 1,
        name: "maxNumElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LoopCond",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "pred",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Switch",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "pred",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Merge",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Enter",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "frame_name",
        name: "frameName",
        type: "string"
      },
      {
        tfName: "is_constant",
        name: "isConstant",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Exit",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "NextIteration",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArrayV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "size",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "dynamic_size",
        name: "dynamicSize",
        type: "bool"
      },
      {
        tfName: "clear_after_read",
        name: "clearAfterRead",
        type: "bool"
      },
      {
        tfName: "identical_element_shapes",
        name: "identicalElementShapes",
        type: "bool"
      },
      {
        tfName: "tensor_array_name",
        name: "name",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "TensorArrayWriteV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArrayReadV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArrayGatherV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      }
    ]
  },
  {
    tfOpName: "TensorArrayScatterV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorArrayConcatV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape_except0",
        name: "elementShapeExcept0",
        type: "shape",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorArraySplitV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 2,
        name: "lengths",
        type: "number[]"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorArraySizeV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "flowIn",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "TensorArrayCloseV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "StatelessIf",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "cond",
        type: "tensor"
      },
      {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      },
      {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "If",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "cond",
        type: "tensor"
      },
      {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      },
      {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "StatelessWhile",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "cond",
        name: "cond",
        type: "func"
      },
      {
        tfName: "body",
        name: "body",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "While",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "cond",
        name: "cond",
        type: "func"
      },
      {
        tfName: "body",
        name: "body",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "TensorListScatter",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListScatterV2",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 3,
        name: "numElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListGather",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListGetItem",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListSetItem",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListReserve",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 1,
        name: "numElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListFromTensor",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListStack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      },
      {
        tfName: "num_elements",
        name: "numElements",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListSplit",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 2,
        name: "lengths",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListConcat",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListConcatV2",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListPopBack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListPushBack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListLength",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "TensorListResize",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      }
    ]
  }
], VM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: zM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const HM = [
  {
    tfOpName: "AvgPool",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MaxPool",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: [],
        notSupported: !0
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MaxPoolWithArgmax",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "include_batch_in_index",
        name: "includeBatchInIndex",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "AvgPool3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MaxPool3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Conv1D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "stride",
        name: "stride",
        type: "number"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NWC"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "dilation",
        name: "dilation",
        type: "number",
        defaultValue: 1
      }
    ]
  },
  {
    tfOpName: "Conv2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "useCudnnOnGpu",
        name: "useCudnnOnGpu",
        type: "bool"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "_FusedConv2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "use_cudnn_on_gpu",
        name: "useCudnnOnGpu",
        type: "bool",
        defaultValue: !0
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [
          1,
          1,
          1,
          1
        ]
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
      },
      {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      }
    ]
  },
  {
    tfOpName: "Conv2DBackpropInput",
    category: "convolution",
    inputs: [
      {
        start: 2,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 0,
        name: "outputShape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "DepthwiseConv2d",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "DepthwiseConv2dNative",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "FusedDepthwiseConv2dNative",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [
          1,
          1,
          1,
          1
        ]
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }
    ]
  },
  {
    tfOpName: "Conv3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Dilation2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "rates",
        name: "dilations",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      }
    ]
  }
], jM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: HM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UM = [
  {
    tfOpName: "Fill",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      },
      {
        start: 1,
        name: "value",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LinSpace",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "start",
        type: "number"
      },
      {
        start: 1,
        name: "stop",
        type: "number"
      },
      {
        start: 2,
        name: "num",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "OneHot",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "depth",
        type: "number"
      },
      {
        start: 2,
        name: "onValue",
        type: "number",
        defaultValue: 1
      },
      {
        start: 3,
        name: "offValue",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        notSupported: !0
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Ones",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "OnesLike",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "RandomStandardNormal",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "RandomUniform",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "minval",
        name: "minval",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "maxval",
        name: "maxval",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "RandomUniformInt",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "minval",
        name: "minval",
        type: "number"
      },
      {
        tfName: "maxval",
        name: "maxval",
        type: "number"
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Range",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "start",
        type: "number"
      },
      {
        start: 1,
        name: "stop",
        type: "number"
      },
      {
        start: 2,
        name: "step",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "Tidx",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TruncatedNormal",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "means",
        name: "mean",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "stddev",
        name: "stdDev",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number"
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Zeros",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "ZerosLike",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Multinomial",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "logits",
        type: "tensor"
      },
      {
        start: 1,
        name: "numSamples",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "seed",
        name: "seed",
        type: "number"
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "output_dtype",
        name: "output_dtype",
        type: "dtype"
      }
    ]
  }
], GM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: UM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qM = [
  {
    tfOpName: "NonMaxSuppressionV2",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV3",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV4",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "T_threshold",
        name: "threshold",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "pad_to_max_output_size",
        name: "padToMaxOutputSize",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV5",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      },
      {
        start: 5,
        name: "softNmsSigma",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "Where",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ListDiff",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  }
], KM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: qM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const XM = [
  {
    tfOpName: "LowerBound",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "TopKV2",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "k",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "sorted",
        name: "sorted",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "UpperBound",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Unique",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "UniqueV2",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  }
], YM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: XM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ZM = [
  {
    tfOpName: "PlaceholderWithDefault",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "default",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "shape",
        name: "shape",
        type: "shape"
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Placeholder",
    category: "graph",
    attrs: [
      {
        tfName: "shape",
        name: "shape",
        type: "shape"
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Const",
    category: "graph"
  },
  {
    tfOpName: "Identity",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "IdentityN",
    category: "graph",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Snapshot",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Rank",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Size",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Shape",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "ShapeN",
    category: "graph",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Print",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "data",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "message",
        name: "message",
        type: "string"
      },
      {
        tfName: "first_n",
        name: "firstN",
        type: "number",
        notSupported: !0
      },
      {
        tfName: "summarize",
        name: "summarize",
        type: "number",
        defaultValue: 3
      }
    ]
  },
  {
    tfOpName: "NoOp",
    category: "graph",
    inputs: []
  },
  {
    tfOpName: "StopGradient",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "FakeQuantWithMinMaxVars",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "min",
        name: "min",
        type: "number"
      },
      {
        tfName: "max",
        name: "max",
        type: "number"
      }
    ]
  }
], JM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: ZM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const QM = [
  {
    tfOpName: "HashTable",
    category: "hash_table",
    inputs: [],
    attrs: [
      {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      },
      {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      },
      {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      },
      {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "HashTableV2",
    category: "hash_table",
    inputs: [],
    attrs: [
      {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      },
      {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      },
      {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      },
      {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LookupTableImport",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableImportV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableFind",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableFindV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LookupTableSize",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "LookupTableSizeV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "InitializeTable",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "InitializeTableV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  }
], e6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: QM
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const t6 = [
  {
    tfOpName: "ResizeBilinear",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      },
      {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "ResizeNearestNeighbor",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      },
      {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "CropAndResize",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "image",
        type: "tensor"
      },
      {
        start: 1,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 2,
        name: "boxInd",
        type: "tensor"
      },
      {
        start: 3,
        name: "cropSize",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "method",
        name: "method",
        type: "string"
      },
      {
        tfName: "extrapolation_value",
        name: "extrapolationValue",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "ImageProjectiveTransformV3",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "transforms",
        type: "tensor"
      },
      {
        start: 2,
        name: "outputShape",
        type: "number[]"
      },
      {
        start: 3,
        name: "fillValue",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "interpolation",
        name: "interpolation",
        type: "string"
      },
      {
        tfName: "fill_mode",
        name: "fillMode",
        type: "string"
      }
    ]
  }
], n6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: t6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r6 = [
  {
    tfOpName: "Equal",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "NotEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Greater",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "GreaterEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Less",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LessEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LogicalAnd",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LogicalNot",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LogicalOr",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Select",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      },
      {
        start: 1,
        name: "a",
        type: "tensor"
      },
      {
        start: 2,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "SelectV2",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      },
      {
        start: 1,
        name: "a",
        type: "tensor"
      },
      {
        start: 2,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "BitwiseAnd",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ]
  }
], a6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: r6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s6 = [
  {
    tfOpName: "_FusedMatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
      },
      {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "MatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "BatchMatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "BatchMatMulV2",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Transpose",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "perm",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Einsum",
    category: "matrices",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "equation",
        name: "equation",
        type: "string"
      },
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "MatrixBandPart",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "numLower",
        type: "tensor"
      },
      {
        start: 1,
        name: "numUpper",
        type: "tensor"
      }
    ]
  }
], o6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: s6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i6 = [
  {
    tfOpName: "EuclideanNorm",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool",
        defaultValue: !1
      }
    ]
  },
  {
    tfOpName: "FusedBatchNorm",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FusedBatchNormV2",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "FusedBatchNormV3",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "LRN",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "depth_radius",
        name: "radius",
        type: "number",
        defaultValue: 5
      },
      {
        tfName: "bias",
        name: "bias",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "beta",
        name: "beta",
        type: "number",
        defaultValue: 0.5
      }
    ]
  },
  {
    tfOpName: "Softmax",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "LogSoftmax",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  }
], u6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: i6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const c6 = [
  {
    tfOpName: "Bincount",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      },
      {
        start: 2,
        name: "weights",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "DenseBincount",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      },
      {
        start: 2,
        name: "weights",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "binary_output",
        name: "binaryOutput",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Max",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Mean",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Min",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Sum",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "All",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Any",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "ArgMax",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "ArgMin",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "Prod",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Cumprod",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      },
      {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Cumsum",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      },
      {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }
    ]
  }
], l6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: c6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const d6 = [
  {
    tfOpName: "ConcatV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        end: -1,
        name: "tensors",
        type: "tensors"
      },
      {
        start: -1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }
    ]
  },
  {
    tfOpName: "Concat",
    category: "slice_join",
    inputs: [
      {
        start: 1,
        end: 0,
        name: "tensors",
        type: "tensors"
      },
      {
        start: 0,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }
    ]
  },
  {
    tfOpName: "GatherV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "batch_dims",
        name: "batchDims",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Gather",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Reverse",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "dims",
        type: "bool[]"
      }
    ]
  },
  {
    tfOpName: "ReverseV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Slice",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "begin",
        type: "number[]"
      },
      {
        start: 2,
        name: "size",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "StridedSlice",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "begin",
        type: "number[]"
      },
      {
        start: 2,
        name: "end",
        type: "number[]"
      },
      {
        start: 3,
        name: "strides",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "begin_mask",
        name: "beginMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "end_mask",
        name: "endMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "new_axis_mask",
        name: "newAxisMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "ellipsis_mask",
        name: "ellipsisMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "shrink_axis_mask",
        name: "shrinkAxisMask",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Pack",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Unpack",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "num",
        name: "num",
        type: "number",
        defaultValue: 0,
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "Tile",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "reps",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Split",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "axis",
        type: "number",
        defaultValue: 0
      },
      {
        start: 1,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "num_split",
        name: "numOrSizeSplits",
        type: "number",
        defaultValue: 1
      }
    ]
  },
  {
    tfOpName: "SplitV",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "numOrSizeSplits",
        type: "number[]"
      },
      {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "ScatterNd",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      },
      {
        start: 2,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "GatherNd",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseToDense",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "sparseIndices",
        type: "tensor"
      },
      {
        start: 1,
        name: "outputShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "sparseValues",
        type: "tensor"
      },
      {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: !1,
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "TensorScatterUpdate",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  }
], f6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: d6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const p6 = [
  {
    tfOpName: "SparseFillEmptyRows",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      },
      {
        start: 2,
        name: "denseShape",
        type: "tensor"
      },
      {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseReshape",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "inputIndices",
        type: "tensor"
      },
      {
        start: 1,
        name: "inputShape",
        type: "tensor"
      },
      {
        start: 2,
        name: "newShape",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "SparseSegmentMean",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseSegmentSum",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }
    ]
  }
], h6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: p6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const m6 = [
  {
    tfOpName: "FFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "IFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "RFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
      }
    ]
  },
  {
    tfOpName: "IRFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
      }
    ]
  }
], g6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: m6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const y6 = [
  {
    tfOpName: "StaticRegexReplace",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "pattern",
        name: "pattern",
        type: "string"
      },
      {
        tfName: "rewrite",
        name: "rewrite",
        type: "string"
      },
      {
        tfName: "replace_global",
        name: "replaceGlobal",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "StringNGrams",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "dataSplits",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "separator",
        name: "separator",
        type: "string"
      },
      {
        tfName: "ngram_widths",
        name: "nGramWidths",
        type: "number[]"
      },
      {
        tfName: "left_pad",
        name: "leftPad",
        type: "string"
      },
      {
        tfName: "right_pad",
        name: "rightPad",
        type: "string"
      },
      {
        tfName: "pad_width",
        name: "padWidth",
        type: "number"
      },
      {
        tfName: "preserve_short_sequences",
        name: "preserveShortSequences",
        type: "bool"
      }
    ],
    outputs: [
      "ngrams",
      "ngrams_splits"
    ]
  },
  {
    tfOpName: "StringSplit",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "delimiter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "skip_empty",
        name: "skipEmpty",
        type: "bool"
      }
    ],
    outputs: [
      "indices",
      "values",
      "shape"
    ]
  },
  {
    tfOpName: "StringToHashBucketFast",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "num_buckets",
        name: "numBuckets",
        type: "number"
      }
    ]
  }
], v6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: y6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const b6 = [
  {
    tfOpName: "Cast",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "SrcT",
        name: "sdtype",
        type: "dtype",
        notSupported: !0
      },
      {
        tfName: "DstT",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "ExpandDims",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "MirrorPad",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "mode",
        name: "mode",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "Pad",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "constant_value",
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "PadV2",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      },
      {
        start: 2,
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Reshape",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "EnsureShape",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Squeeze",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        tfDeprecatedName: "squeeze_dims",
        name: "axis",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "SpaceToBatchND",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "blockShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "paddings",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "BatchToSpaceND",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "blockShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "crops",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "DepthToSpace",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "block_size",
        name: "blockSize",
        type: "number"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "BroadcastTo",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: []
  },
  {
    tfOpName: "BroadcastArgs",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "s0",
        type: "tensor"
      },
      {
        start: 1,
        name: "s1",
        type: "tensor"
      }
    ],
    attrs: []
  }
], w6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: b6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fv {
  // Singleton instance for the mapper
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  // Loads the op mapping from the JSON file.
  constructor() {
    const e = [
      BM,
      WM,
      VM,
      jM,
      GM,
      KM,
      YM,
      JM,
      e6,
      n6,
      a6,
      o6,
      u6,
      l6,
      f6,
      h6,
      g6,
      v6,
      w6
    ], n = [].concat(...e.map((r) => r.json));
    this.opMappers = n.reduce((r, a) => (r[a.tfOpName] = a, r), {});
  }
  // Converts the model inference graph from Tensorflow GraphDef to local
  // representation for TensorFlow.js API
  transformGraph(e, n = {}) {
    const r = e.node, a = [], s = [], o = [], i = r.reduce((m, g) => (m[g.name] = this.mapNode(g), g.op.startsWith("Placeholder") ? a.push(m[g.name]) : g.op === "Const" ? s.push(m[g.name]) : (g.input == null || g.input.length === 0) && o.push(m[g.name]), m), {});
    let c = [];
    const l = [];
    let u = {}, d = {};
    n != null && (u = this.mapSignatureEntries(n.inputs), d = this.mapSignatureEntries(n.outputs));
    const f = Object.keys(i);
    f.forEach((m) => {
      const g = i[m];
      g.inputNames.forEach((v, b) => {
        const [w, , S] = ca(v), I = i[w];
        if (I.outputs != null) {
          const E = I.outputs.indexOf(S);
          if (E !== -1) {
            const T = `${w}:${E}`;
            g.inputNames[b] = T;
          }
        }
        g.inputs.push(I), I.children.push(g);
      });
    }), Object.keys(d).length === 0 ? f.forEach((m) => {
      const g = i[m];
      g.children.length === 0 && l.push(g);
    }) : Object.keys(d).forEach((m) => {
      const [g] = ca(m), v = i[g];
      v != null && (v.signatureKey = d[m], l.push(v));
    }), Object.keys(u).length > 0 ? Object.keys(u).forEach((m) => {
      const [g] = ca(m), v = i[g];
      v && (v.signatureKey = u[m], c.push(v));
    }) : c = a;
    let p = {};
    e.library != null && e.library.function != null && (p = e.library.function.reduce((m, g) => (m[g.signature.name] = this.mapFunction(g), m), {}));
    const h = { nodes: i, inputs: c, outputs: l, weights: s, placeholders: a, signature: n, functions: p };
    return o.length > 0 && (h.initNodes = o), h;
  }
  mapSignatureEntries(e) {
    return Object.keys(e || {}).reduce((n, r) => (n[e[r].name] = r, n), {});
  }
  mapNode(e) {
    const n = p2(e.op) || this.opMappers[e.op] || {};
    e.attr == null && (e.attr = {});
    const r = {
      name: e.name,
      op: e.op,
      category: n.category,
      inputNames: (e.input || []).map((a) => a.startsWith("^") ? a.slice(1) : a),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: e.attr,
      outputs: n.outputs
    };
    return n.inputs != null && (r.inputParams = n.inputs.reduce((a, s) => (a[s.name] = {
      type: s.type,
      inputIndexStart: s.start,
      inputIndexEnd: s.end
    }, a), {})), n.attrs != null && (r.attrParams = n.attrs.reduce((a, s) => {
      const o = s.type;
      let i;
      switch (s.type) {
        case "string":
          i = oh(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = oh(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "string[]":
          i = ph(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = ph(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "number":
          i = uh(e.attr, s.tfName, s.defaultValue || 0), i === void 0 && s.tfDeprecatedName && (i = uh(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "number[]":
          i = fh(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = fh(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "bool":
          i = ih(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = ih(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "bool[]":
          i = mh(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = mh(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "shape":
          i = dh(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = dh(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "shape[]":
          i = hh(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = hh(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "dtype":
          i = ch(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = ch(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "dtype[]":
          i = lh(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = lh(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "func":
          i = pv(e.attr, s.tfName, s.defaultValue), i === void 0 && s.tfDeprecatedName && (i = pv(e.attr, s.tfDeprecatedName, s.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`);
      }
      return a[s.name] = { value: i, type: o }, a;
    }, {})), r;
  }
  // map the TFunctionDef to TFJS graph object
  mapFunction(e) {
    const n = e.nodeDef, r = [], a = [];
    let s = {};
    n != null && (s = n.reduce((d, f) => (d[f.name] = this.mapNode(f), f.op === "Const" && a.push(d[f.name]), d), {}));
    const o = [], i = [];
    e.signature.inputArg.forEach((d) => {
      const [f] = ca(d.name), p = {
        name: f,
        op: "Placeholder",
        inputs: [],
        inputNames: [],
        category: "graph",
        inputParams: {},
        attrParams: { dtype: { value: gg(d.type), type: "dtype" } },
        children: []
      };
      p.signatureKey = d.name, o.push(p), s[f] = p;
    }), Object.keys(s).forEach((d) => {
      const f = s[d];
      f.inputNames.forEach((p, h) => {
        const [m, , g] = ca(p), v = s[m];
        if (v.outputs != null) {
          const b = v.outputs.indexOf(g);
          if (b !== -1) {
            const w = `${m}:${b}`;
            f.inputNames[h] = w;
          }
        }
        f.inputs.push(v), v.children.push(f);
      });
    });
    const l = e.ret;
    e.signature.outputArg.forEach((d) => {
      const [f, p] = ca(l[d.name]), h = s[f];
      h != null && (h.defaultOutput = p, i.push(h));
    });
    const u = this.mapArgsToSignature(e);
    return { nodes: s, inputs: o, outputs: i, weights: a, placeholders: r, signature: u };
  }
  mapArgsToSignature(e) {
    return {
      methodName: e.signature.name,
      inputs: e.signature.inputArg.reduce((n, r) => (n[r.name] = this.mapArgToTensorInfo(r), n), {}),
      outputs: e.signature.outputArg.reduce((n, r) => (n[r.name] = this.mapArgToTensorInfo(r, e.ret), n), {})
    };
  }
  mapArgToTensorInfo(e, n) {
    let r = e.name;
    return n != null && (r = n[r]), { name: r, dtype: e.type };
  }
}
function S6(t) {
  const e = Xe().global;
  if (typeof e.atob < "u")
    return e.atob(t);
  if (typeof Buffer < "u")
    return new Buffer(t, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function h2(t, e) {
  const n = Array.isArray(t) ? String.fromCharCode.apply(null, t) : S6(t);
  return e ? n : n.toLowerCase();
}
function oh(t, e, n, r = !1) {
  const a = t[e];
  return a != null ? h2(a.s, r) : n;
}
function ih(t, e, n) {
  const r = t[e];
  return r ? r.b : n;
}
function uh(t, e, n) {
  const r = t[e] || {}, a = r.i != null ? r.i : r.f != null ? r.f : n;
  return typeof a == "number" ? a : parseInt(a, 10);
}
function gg(t) {
  switch (typeof t == "string" && (t = yr[t]), t) {
    case yr.DT_FLOAT:
    case yr.DT_HALF:
      return "float32";
    case yr.DT_INT32:
    case yr.DT_INT64:
    case yr.DT_INT8:
    case yr.DT_UINT8:
      return "int32";
    case yr.DT_BOOL:
      return "bool";
    case yr.DT_DOUBLE:
      return "float32";
    case yr.DT_STRING:
      return "string";
    default:
      return null;
  }
}
function pv(t, e, n) {
  const r = t[e];
  return r && r.func ? r.func.name : n;
}
function ch(t, e, n) {
  const r = t[e];
  return r && r.type ? gg(r.type) : n;
}
function lh(t, e, n) {
  const r = t[e];
  return r && r.list && r.list.type ? r.list.type.map((a) => gg(a)) : n;
}
function m2(t) {
  if (!t.unknownRank)
    return t.dim != null ? t.dim.map((e) => typeof e.size == "number" ? e.size : parseInt(e.size, 10)) : [];
}
function dh(t, e, n) {
  const r = t[e];
  return r && r.shape ? m2(r.shape) : n;
}
function fh(t, e, n) {
  const r = t[e];
  return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map((a) => typeof a == "number" ? a : parseInt(a, 10)) : n;
}
function ph(t, e, n, r = !1) {
  const a = t[e];
  return a && a.list && a.list.s ? a.list.s.map((s) => h2(s, r)) : n;
}
function hh(t, e, n) {
  const r = t[e];
  return r && r.list && r.list.shape ? r.list.shape.map((a) => m2(a)) : n;
}
function mh(t, e, n) {
  const r = t[e];
  return r && r.list && r.list.b ? r.list.b : n;
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class _6 {
  constructor(e, n, r) {
    this.node = e, this.tensorMap = n, this.context = r, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map((a) => this.getInput(a)), e.rawAttrs != null && (this.attrs = Object.keys(e.rawAttrs).reduce((a, s) => (a[s] = this.getAttr(s), a), {}));
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getInput(e) {
    return gn(e, this.tensorMap, this.context);
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getAttr(e, n) {
    const r = this.node.rawAttrs[e];
    if (r.tensor != null)
      return gn(e, this.tensorMap, this.context);
    if (r.i != null || r.f != null)
      return uh(this.node.rawAttrs, e, n);
    if (r.s != null)
      return oh(this.node.rawAttrs, e, n);
    if (r.b != null)
      return ih(this.node.rawAttrs, e, n);
    if (r.shape != null)
      return dh(this.node.rawAttrs, e, n);
    if (r.type != null)
      return ch(this.node.rawAttrs, e, n);
    if (r.list != null) {
      if (r.list.i != null || r.list.f != null)
        return fh(this.node.rawAttrs, e, n);
      if (r.list.s != null)
        return ph(this.node.rawAttrs, e, n);
      if (r.list.shape != null)
        return hh(this.node.rawAttrs, e, n);
      if (r.list.b != null)
        return mh(this.node.rawAttrs, e, n);
      if (r.list.type != null)
        return lh(this.node.rawAttrs, e, n);
    }
    return n;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OP_SCOPE_SUFFIX: $1,
  abs: cr,
  acos: MC,
  acosh: BC,
  add: Ae,
  addN: WC,
  all: VC,
  any: jC,
  argMax: GC,
  argMin: KC,
  asin: YC,
  asinh: JC,
  atan: eN,
  atan2: nN,
  atanh: aN,
  avgPool: K1,
  avgPool3d: fN,
  basicLSTMCell: bN,
  batchNorm: df,
  batchNorm2d: IN,
  batchNorm3d: EN,
  batchNorm4d: CN,
  batchToSpaceND: X1,
  bincount: Y1,
  bitwiseAnd: RN,
  booleanMaskAsync: yD,
  broadcastArgs: DN,
  broadcastTo: Vi,
  buffer: Qe,
  cast: zt,
  ceil: MN,
  clipByValue: Z1,
  clone: Wa,
  complex: ja,
  concat: yn,
  concat1d: LN,
  concat2d: zN,
  concat3d: HN,
  concat4d: UN,
  conv1d: KN,
  conv2d: ff,
  conv2dTranspose: ZN,
  conv3d: QN,
  conv3dTranspose: rA,
  cos: sA,
  cosh: iA,
  cosineWindow: ug,
  cumprod: cA,
  cumsum: dA,
  denseBincount: pA,
  depthToSpace: mA,
  depthwiseConv2d: Xm,
  diag: vA,
  dilation2d: wA,
  div: Ze,
  divNoNan: EA,
  dot: CA,
  dropout: AD,
  einsum: po,
  elu: ew,
  enclosingPowerOfTwo: Nw,
  ensureShape: $A,
  equal: Q1,
  erf: OA,
  euclideanNorm: jA,
  exp: ya,
  expandDims: Kr,
  expm1: KA,
  eye: rw,
  fft: og,
  fill: Ru,
  floor: aw,
  floorDiv: G1,
  fused: UD,
  gather: sw,
  gatherND: TD,
  greater: mf,
  greaterEqual: ow,
  ifft: Uc,
  imag: gf,
  image: bf,
  inTopKAsync: $D,
  irfft: _w,
  isFinite: r4,
  isInf: s4,
  isNaN: i4,
  leakyRelu: iw,
  less: nh,
  lessEqual: Ym,
  linalg: IF,
  linspace: d4,
  localResponseNormalization: p4,
  log: uu,
  log1p: uw,
  logSigmoid: w4,
  logSoftmax: x4,
  logSumExp: lw,
  logicalAnd: Vc,
  logicalNot: dw,
  logicalOr: fw,
  logicalXor: N4,
  losses: kF,
  lowerBound: R4,
  matMul: wt,
  max: So,
  maxPool: pw,
  maxPool3d: O4,
  maxPoolWithArgmax: M4,
  maximum: hw,
  mean: Hc,
  meshgrid: L4,
  min: th,
  minimum: jc,
  mirrorPad: V4,
  mod: j4,
  moments: G4,
  movingAverage: wD,
  mul: he,
  multiRNNCell: K4,
  multinomial: Y4,
  neg: Jr,
  norm: hf,
  notEqual: mw,
  oneHot: Q4,
  ones: ks,
  onesLike: tR,
  op: B,
  outerProduct: rR,
  pad: $u,
  pad1d: oR,
  pad2d: uR,
  pad3d: lR,
  pad4d: fR,
  pool: yR,
  pow: iu,
  prelu: yw,
  print: j1,
  prod: wR,
  raggedGather: _R,
  raggedRange: IR,
  raggedTensorToTensor: ER,
  rand: CR,
  randomGamma: qR,
  randomNormal: bw,
  randomStandardNormal: YR,
  randomUniform: sg,
  randomUniformInt: QR,
  range: cu,
  real: lu,
  reciprocal: n$,
  relu: vf,
  relu6: ww,
  reshape: ae,
  reverse: Ms,
  reverse1d: i$,
  reverse2d: c$,
  reverse3d: d$,
  reverse4d: p$,
  rfft: ig,
  round: Sw,
  rsqrt: g$,
  scalar: ut,
  scatterND: _D,
  searchSorted: Zm,
  selu: v$,
  separableConv2d: w$,
  setdiff1dAsync: _$,
  sigmoid: Cs,
  sign: I$,
  signal: xF,
  sin: E$,
  sinh: C$,
  slice: qe,
  slice1d: A$,
  slice2d: $$,
  slice3d: O$,
  slice4d: M$,
  softmax: B$,
  softplus: cw,
  spaceToBatchND: gw,
  sparse: EF,
  sparseToDense: kD,
  spectral: _F,
  split: du,
  sqrt: ga,
  square: Pr,
  squaredDifference: xw,
  squeeze: hn,
  stack: ba,
  step: Iw,
  stridedSlice: X$,
  string: TF,
  sub: Ke,
  sum: Dt,
  tan: Z$,
  tanh: eh,
  tensor: Mr,
  tensor1d: xn,
  tensor2d: Ns,
  tensor3d: kw,
  tensor4d: J$,
  tensor5d: Q$,
  tensor6d: eD,
  tensorScatterUpdate: rD,
  tile: Hi,
  topk: sD,
  transpose: rh,
  truncatedNormal: iD,
  unique: cD,
  unsortedSegmentSum: dD,
  unstack: qs,
  upperBound: pD,
  variable: hD,
  where: za,
  whereAsync: Cw,
  zeros: Co,
  zerosLike: lr
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const x6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [r.add(_("a", t, e, n), _("b", t, e, n))];
    case "AddN":
      return [r.addN(_("tensors", t, e, n))];
    case "FloorMod":
    case "Mod":
      return [r.mod(_("a", t, e, n), _("b", t, e, n))];
    case "Mul":
      return [r.mul(_("a", t, e, n), _("b", t, e, n))];
    case "RealDiv":
    case "Div":
      return [r.div(_("a", t, e, n), _("b", t, e, n))];
    case "DivNoNan":
      return [r.divNoNan(_("a", t, e, n), _("b", t, e, n))];
    case "FloorDiv":
      return [r.floorDiv(_("a", t, e, n), _("b", t, e, n))];
    case "Sub":
      return [r.sub(_("a", t, e, n), _("b", t, e, n))];
    case "Minimum":
      return [r.minimum(_("a", t, e, n), _("b", t, e, n))];
    case "Maximum":
      return [r.maximum(_("a", t, e, n), _("b", t, e, n))];
    case "Pow":
      return [r.pow(_("a", t, e, n), _("b", t, e, n))];
    case "SquaredDifference":
      return [r.squaredDifference(_("a", t, e, n), _("b", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const I6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "Abs":
    case "ComplexAbs":
      return [r.abs(_("x", t, e, n))];
    case "Acos":
      return [r.acos(_("x", t, e, n))];
    case "Acosh":
      return [r.acosh(_("x", t, e, n))];
    case "Asin":
      return [r.asin(_("x", t, e, n))];
    case "Asinh":
      return [r.asinh(_("x", t, e, n))];
    case "Atan":
      return [r.atan(_("x", t, e, n))];
    case "Atan2":
      return [r.atan2(_("x", t, e, n), _("y", t, e, n))];
    case "Atanh":
      return [r.atanh(_("x", t, e, n))];
    case "Ceil":
      return [r.ceil(_("x", t, e, n))];
    case "Complex":
      return [r.complex(_("real", t, e, n), _("imag", t, e, n))];
    case "Cos":
      return [r.cos(_("x", t, e, n))];
    case "Cosh":
      return [r.cosh(_("x", t, e, n))];
    case "Elu":
      return [r.elu(_("x", t, e, n))];
    case "Erf":
      return [r.erf(_("x", t, e, n))];
    case "Exp":
      return [r.exp(_("x", t, e, n))];
    case "Expm1":
      return [r.expm1(_("x", t, e, n))];
    case "Floor":
      return [r.floor(_("x", t, e, n))];
    case "Log":
      return [r.log(_("x", t, e, n))];
    case "Log1p":
      return [r.log1p(_("x", t, e, n))];
    case "Imag":
      return [r.imag(_("x", t, e, n))];
    case "Neg":
      return [r.neg(_("x", t, e, n))];
    case "Reciprocal":
      return [r.reciprocal(_("x", t, e, n))];
    case "Real":
      return [r.real(_("x", t, e, n))];
    case "Relu":
      return [r.relu(_("x", t, e, n))];
    case "Round":
      return [r.round(_("x", t, e, n))];
    case "Selu":
      return [r.selu(_("x", t, e, n))];
    case "Sigmoid":
      return [r.sigmoid(_("x", t, e, n))];
    case "Sin":
      return [r.sin(_("x", t, e, n))];
    case "Sign":
      return [r.sign(_("x", t, e, n))];
    case "Sinh":
      return [r.sinh(_("x", t, e, n))];
    case "Softplus":
      return [r.softplus(_("x", t, e, n))];
    case "Sqrt":
      return [r.sqrt(_("x", t, e, n))];
    case "Square":
      return [r.square(_("x", t, e, n))];
    case "Tanh":
      return [r.tanh(_("x", t, e, n))];
    case "Tan":
      return [r.tan(_("x", t, e, n))];
    case "ClipByValue":
      return [r.clipByValue(_("x", t, e, n), _("clipValueMin", t, e, n), _("clipValueMax", t, e, n))];
    case "Relu6":
      return [r.relu6(_("x", t, e, n))];
    case "Rsqrt":
      return [r.rsqrt(gn(t.inputNames[0], e, n))];
    case "LeakyRelu":
      return [r.leakyRelu(_("x", t, e, n), _("alpha", t, e, n))];
    case "Prelu":
      return [r.prelu(_("x", t, e, n), _("alpha", t, e, n))];
    case "IsNan":
      return [r.isNaN(gn(t.inputNames[0], e, n))];
    case "IsInf":
      return [r.isInf(gn(t.inputNames[0], e, n))];
    case "IsFinite":
      return [r.isFinite(gn(t.inputNames[0], e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vr(t, e, n = "") {
  if (!(typeof t == "number" || typeof e == "number")) {
    A(t.length === e.length, () => n + ` Shapes ${t} and ${e} must match`);
    for (let r = 0; r < t.length; r++) {
      const a = t[r], s = e[r];
      A(a < 0 || s < 0 || a === s, () => n + ` Shapes ${t} and ${e} must match`);
    }
  }
}
function hv(t) {
  return !(typeof t == "number" || t.some((e) => e < 0));
}
function gi(t, e, n) {
  let r = gh(t, n);
  const a = !hv(r);
  if (a && e.length === 0)
    throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);
  if (a && e.forEach((s) => {
    r = gh(s.shape, r);
  }), !hv(r))
    throw new Error(`Non-fully-defined elementShape: ${r}`);
  return r;
}
function gh(t, e) {
  if (typeof t == "number")
    return e;
  if (typeof e == "number")
    return t;
  if (t.length !== e.length)
    throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);
  const n = [];
  for (let r = 0; r < t.length; ++r) {
    const a = t[r], s = e[r];
    if (a >= 0 && s >= 0 && a !== s)
      throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);
    n[r] = a >= 0 ? a : s;
  }
  return n;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class k6 {
  constructor(e, n, r, a, s, o, i) {
    this.name = e, this.dtype = n, this.maxSize = r, this.elementShape = a, this.identicalElementShapes = s, this.dynamicSize = o, this.clearAfterRead = i, this.tensors = [], this.closed_ = !1, this.idTensor = ut(0), Yr(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  /**
   * Dispose the tensors and idTensor and mark the TensoryArray as closed.
   */
  clearAndClose(e) {
    this.tensors.forEach((n) => {
      (e == null || !e.has(n.tensor.id)) && n.tensor.dispose();
    }), this.tensors = [], this.closed_ = !0, this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  /**
   * Read the value at location index in the TensorArray.
   * @param index Number the index to read from.
   */
  read(e) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || e >= this.size())
      throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
    const n = this.tensors[e];
    if (n.cleared)
      throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
    return this.clearAfterRead && (n.cleared = !0), n.read = !0, n.tensor;
  }
  /**
   * Helper method to read multiple tensors from the specified indices.
   */
  readMany(e) {
    return e.map((n) => this.read(n));
  }
  /**
   * Write value into the index of the TensorArray.
   * @param index number the index to write to.
   * @param tensor
   */
  write(e, n) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || !this.dynamicSize && e >= this.maxSize)
      throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);
    const r = this.tensors[e] || {};
    if (n.dtype !== this.dtype)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);
    if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0) && (this.elementShape = n.shape), vr(this.elementShape, n.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e}.`), r.read)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);
    if (r.written)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);
    r.tensor = n, Yr(n), r.written = !0, this.tensors[e] = r;
  }
  /**
   * Helper method to write multiple tensors to the specified indices.
   */
  writeMany(e, n) {
    if (e.length !== n.length)
      throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);
    e.forEach((r, a) => this.write(r, n[a]));
  }
  /**
   * Return selected values in the TensorArray as a packed Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param [indices] number[] Optional. Taking values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size(). If not specified returns
   *    all tensors in the original order.
   * @param [dtype]
   */
  gather(e, n) {
    if (n && n !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);
    if (e)
      e = e.slice(0, this.size());
    else {
      e = [];
      for (let a = 0; a < this.size(); a++)
        e.push(a);
    }
    if (e.length === 0)
      return Mr([], [0].concat(this.elementShape));
    const r = this.readMany(e);
    return vr(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), ba(r, 0);
  }
  /**
   * Return the values in the TensorArray as a concatenated Tensor.
   */
  concat(e) {
    if (e && e !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);
    if (this.size() === 0)
      return Mr([], [0].concat(this.elementShape));
    const n = [];
    for (let a = 0; a < this.size(); a++)
      n.push(a);
    const r = this.readMany(n);
    return vr(this.elementShape, r[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`), yn(r, 0);
  }
  /**
   * Scatter the values of a Tensor in specific indices of a TensorArray.
   * @param indices nummber[] values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size().
   * @param tensor Tensor input tensor.
   */
  scatter(e, n) {
    if (n.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);
    if (e.length !== n.shape[0])
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);
    const r = Math.max(...e);
    if (!this.dynamicSize && r >= this.maxSize)
      throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);
    this.writeMany(e, qs(n, 0));
  }
  /**
   * Split the values of a Tensor into the TensorArray.
   * @param length number[] with the lengths to use when splitting value along
   *    its first dimension.
   * @param tensor Tensor, the tensor to split.
   */
  split(e, n) {
    if (n.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);
    let r = 0;
    const a = e.map((c) => (r += c, r));
    if (r !== n.shape[0])
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);
    if (!this.dynamicSize && e.length !== this.maxSize)
      throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);
    const s = r === 0 ? 0 : n.size / r, o = [];
    Je(() => {
      n = ae(n, [1, r, s]);
      for (let c = 0; c < e.length; ++c) {
        const u = [0, c === 0 ? 0 : a[c - 1], 0], d = [1, e[c], s];
        o[c] = ae(qe(n, u, d), this.elementShape);
      }
      return o;
    });
    const i = [];
    for (let c = 0; c < e.length; c++)
      i[c] = c;
    this.writeMany(i, o);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Bs {
  get id() {
    return this.idTensor.id;
  }
  /**
   *
   * @param tensors list of tensors
   * @param elementShape shape of each tensor, this can be a single number (any
   * shape is allowed) or partial shape (dim = -1).
   * @param elementDtype data type of each tensor
   * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1
   *   meaning that the size of `tensors` is unbounded.
   */
  constructor(e, n, r, a = -1) {
    this.tensors = e, this.elementShape = n, this.elementDtype = r, e?.forEach((s) => {
      if (r !== s.dtype)
        throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);
      vr(n, s.shape, "TensorList shape mismatch: "), Yr(s);
    }), this.idTensor = ut(0), this.maxNumElements = a, Yr(this.idTensor);
  }
  /**
   * Get a new TensorList containing a copy of the underlying tensor container.
   */
  copy() {
    return new Bs([...this.tensors], this.elementShape, this.elementDtype);
  }
  /**
   * Dispose the tensors and idTensor and clear the tensor list.
   */
  clearAndClose(e) {
    this.tensors.forEach((n) => {
      (e == null || !e.has(n.id)) && n.dispose();
    }), this.tensors.length = 0, this.idTensor.dispose();
  }
  /**
   * The size of the tensors in the tensor list.
   */
  size() {
    return this.tensors.length;
  }
  /**
   * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)
   * tf.Tensor.
   * @param elementShape shape of each tensor
   * @param elementDtype data type of each tensor
   * @param numElements the number of elements to stack
   */
  stack(e, n, r = -1) {
    if (n !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
    if (r !== -1 && this.tensors.length !== r)
      throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);
    vr(e, this.elementShape, "TensorList shape mismatch: ");
    const a = gi(this.elementShape, this.tensors, e);
    return Je(() => {
      const s = this.tensors.map((o) => ae(o, a));
      return ba(s, 0);
    });
  }
  /**
   * Pop a tensor from the end of the list.
   * @param elementShape shape of the tensor
   * @param elementDtype data type of the tensor
   */
  popBack(e, n) {
    if (n !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
    if (this.size() === 0)
      throw new Error("Trying to pop from an empty list.");
    const r = gi(this.elementShape, this.tensors, e), a = this.tensors.pop();
    return a.kept = !1, vr(a.shape, e, "TensorList shape mismatch: "), ae(a, r);
  }
  /**
   * Push a tensor to the end of the list.
   * @param tensor Tensor to be pushed.
   */
  pushBack(e) {
    if (e.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);
    if (vr(e.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size())
      throw new Error("Trying to push element into a full list.");
    Yr(e), this.tensors.push(e);
  }
  /**
   * Update the size of the list.
   * @param size the new size of the list.
   */
  resize(e) {
    if (e < 0)
      throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);
    if (this.maxNumElements !== -1 && e > this.maxNumElements)
      throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);
    const n = new Bs([], this.elementShape, this.elementDtype, this.maxNumElements);
    n.tensors.length = e;
    for (let r = 0; r < Math.min(this.tensors.length, e); ++r)
      n.tensors[r] = this.tensors[r];
    return n;
  }
  /**
   * Retrieve the element at the provided index
   * @param elementShape shape of the tensor
   * @param elementDtype dtype of the tensor
   * @param elementIndex index of the tensor
   */
  getItem(e, n, r) {
    if (r !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);
    if (e < 0 || e > this.tensors.length)
      throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);
    if (this.tensors[e] == null)
      throw new Error(`element at index ${e} is null.`);
    vr(this.tensors[e].shape, n, "TensorList shape mismatch: ");
    const a = gi(this.elementShape, this.tensors, n);
    return ae(this.tensors[e], a);
  }
  /**
   * Set the tensor at the index
   * @param elementIndex index of the tensor
   * @param tensor the tensor to be inserted into the list
   */
  setItem(e, n) {
    if (n.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);
    if (e < 0 || this.maxNumElements !== -1 && e >= this.maxNumElements)
      throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);
    vr(this.elementShape, n.shape, "TensorList shape mismatch: "), Yr(n), this.tensors[e] != null && (this.tensors[e].kept = !1), this.tensors[e] = n;
  }
  /**
   * Return selected values in the TensorList as a stacked Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param indices indices of tensors to gather
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  gather(e, n, r) {
    if (n !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
    vr(this.elementShape, r, "TensorList shape mismatch: "), e = e.slice(0, this.size());
    const a = gi(this.elementShape, this.tensors, r);
    return e.length === 0 ? Mr([], [0].concat(a)) : Je(() => {
      const s = e.map((o) => ae(this.tensors[o], a));
      return ba(s, 0);
    });
  }
  /**
   * Return the values in the TensorList as a concatenated Tensor.
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  concat(e, n) {
    if (e && e !== this.elementDtype)
      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);
    vr(this.elementShape, n, "TensorList shape mismatch: ");
    const r = gi(this.elementShape, this.tensors, n);
    return this.size() === 0 ? Mr([], [0].concat(r)) : Je(() => {
      const a = this.tensors.map((s) => ae(s, r));
      return yn(a, 0);
    });
  }
}
function E6(t, e, n) {
  const r = t.dtype;
  if (t.shape.length < 1)
    throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);
  if (t.dtype !== n)
    throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);
  const a = t.shape.slice(1);
  vr(a, e, "TensorList shape mismatch: ");
  const s = qs(t);
  return new Bs(s, e, r);
}
function T6(t, e, n, r) {
  return new Bs([], t, e, r);
}
function C6(t, e, n, r) {
  if (e.length !== t.shape[0])
    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);
  const a = Math.max(...e);
  if (r != null && r !== -1 && a >= r)
    throw new Error(`Max index must be < array size (${a}  vs. ${r})`);
  const s = new Bs([], n, t.dtype, r), o = qs(t, 0);
  return e.forEach((i, c) => {
    s.setItem(i, o[c]);
  }), s;
}
function N6(t, e, n) {
  let r = 0;
  const a = e.map((u) => (r += u, r));
  if (r !== t.shape[0])
    throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);
  const s = t.shape.slice(1), o = gh(s, n), i = r === 0 ? 0 : t.size / r, c = Je(() => {
    const u = [];
    t = ae(t, [1, r, i]);
    for (let d = 0; d < e.length; ++d) {
      const p = [0, d === 0 ? 0 : a[d - 1], 0], h = [1, e[d], i];
      u[d] = ae(qe(t, p, h), o);
    }
    return t.dispose(), u;
  }), l = new Bs([], n, t.dtype, e.length);
  for (let u = 0; u < c.length; u++)
    l.setItem(u, c[u]);
  return l;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const A6 = async (t, e, n) => {
  switch (t.op) {
    case "If":
    case "StatelessIf": {
      const r = _("thenBranch", t, e, n), a = _("elseBranch", t, e, n), s = _("cond", t, e, n), o = _("args", t, e, n);
      return (await s.data())[0] ? n.functionMap[r].executeFunctionAsync(o, n.tensorArrayMap, n.tensorListMap) : n.functionMap[a].executeFunctionAsync(o, n.tensorArrayMap, n.tensorListMap);
    }
    case "While":
    case "StatelessWhile": {
      const r = _("body", t, e, n), a = _("cond", t, e, n), s = _("args", t, e, n), o = await n.functionMap[a].executeFunctionAsync(s, n.tensorArrayMap, n.tensorListMap), i = s.map((u) => u.id);
      let c = await o[0].data();
      o.forEach((u) => {
        !u.kept && i.indexOf(u.id) === -1 && u.dispose();
      });
      let l = s;
      for (; c[0]; ) {
        const u = l;
        l = await n.functionMap[r].executeFunctionAsync(l, n.tensorArrayMap, n.tensorListMap);
        const d = l.map((p) => p.id);
        u.forEach((p) => {
          !p.kept && i.indexOf(p.id) === -1 && d.indexOf(p.id) === -1 && p.dispose();
        });
        const f = await n.functionMap[a].executeFunctionAsync(l, n.tensorArrayMap, n.tensorListMap);
        c = await f[0].data(), f.forEach((p) => {
          !p.kept && i.indexOf(p.id) === -1 && d.indexOf(p.id) === -1 && p.dispose();
        });
      }
      return l;
    }
    case "LoopCond": {
      const r = _("pred", t, e, n);
      return [la(r)];
    }
    case "Switch": {
      const r = _("pred", t, e, n);
      let a = _("data", t, e, n);
      return a.kept || (a = la(a)), (await r.data())[0] ? [void 0, a] : [a, void 0];
    }
    case "Merge": {
      const r = t.inputNames.find((a) => gn(a, e, n) !== void 0);
      if (r) {
        const a = gn(r, e, n);
        return [la(a)];
      }
      return;
    }
    case "Enter": {
      const r = _("frameName", t, e, n), a = _("tensor", t, e, n);
      return n.enterFrame(r), [la(a)];
    }
    case "Exit": {
      const r = _("tensor", t, e, n);
      return n.exitFrame(), [la(r)];
    }
    case "NextIteration": {
      const r = _("tensor", t, e, n);
      return n.nextIteration(), [la(r)];
    }
    case "TensorArrayV3": {
      const r = _("size", t, e, n), a = _("dtype", t, e, n), s = _("elementShape", t, e, n), o = _("dynamicSize", t, e, n), i = _("clearAfterRead", t, e, n), c = _("identicalElementShapes", t, e, n), l = _("name", t, e, n), u = new k6(l, a, r, s, c, o, i);
      return n.addTensorArray(u), [u.idTensor, ut(1)];
    }
    case "TensorArrayWriteV3": {
      const r = _("tensorArrayId", t, e, n), a = _("index", t, e, n), s = _("tensor", t, e, n), o = n.getTensorArray(r.id);
      return o.write(a, s), [o.idTensor];
    }
    case "TensorArrayReadV3": {
      const r = _("tensorArrayId", t, e, n), a = _("index", t, e, n);
      return [n.getTensorArray(r.id).read(a)];
    }
    case "TensorArrayGatherV3": {
      const r = _("tensorArrayId", t, e, n), a = _("indices", t, e, n), s = _("dtype", t, e, n);
      return [n.getTensorArray(r.id).gather(a, s)];
    }
    case "TensorArrayScatterV3": {
      const r = _("tensorArrayId", t, e, n), a = _("indices", t, e, n), s = _("tensor", t, e, n), o = n.getTensorArray(r.id);
      return o.scatter(a, s), [o.idTensor];
    }
    case "TensorArrayConcatV3": {
      const r = _("tensorArrayId", t, e, n), a = n.getTensorArray(r.id), s = _("dtype", t, e, n);
      return [a.concat(s)];
    }
    case "TensorArraySplitV3": {
      const r = _("tensorArrayId", t, e, n), a = _("tensor", t, e, n), s = _("lengths", t, e, n), o = n.getTensorArray(r.id);
      return o.split(s, a), [o.idTensor];
    }
    case "TensorArraySizeV3": {
      const r = _("tensorArrayId", t, e, n), a = n.getTensorArray(r.id);
      return [ut(a.size(), "int32")];
    }
    case "TensorArrayCloseV3": {
      const r = _("tensorArrayId", t, e, n), a = n.getTensorArray(r.id);
      return a.clearAndClose(), [a.idTensor];
    }
    case "TensorListSetItem": {
      const r = _("tensorListId", t, e, n), a = _("index", t, e, n), s = _("tensor", t, e, n), o = n.getTensorList(r.id);
      return o.setItem(a, s), [o.idTensor];
    }
    case "TensorListGetItem": {
      const r = _("tensorListId", t, e, n), a = _("index", t, e, n), s = _("elementShape", t, e, n), o = _("elementDType", t, e, n);
      return [n.getTensorList(r.id).getItem(a, s, o)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      const r = _("indices", t, e, n), a = _("tensor", t, e, n), s = _("elementShape", t, e, n), o = _("numElements", t, e, n), i = C6(a, r, s, o);
      return n.addTensorList(i), [i.idTensor];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      const r = _("elementShape", t, e, n), a = _("elementDType", t, e, n);
      let s;
      t.op === "TensorListReserve" ? s = "numElements" : s = "maxNumElements";
      const o = _(s, t, e, n), i = t.op === "TensorListReserve" ? -1 : o, c = T6(r, a, o, i);
      return n.addTensorList(c), [c.idTensor];
    }
    case "TensorListGather": {
      const r = _("tensorListId", t, e, n), a = _("indices", t, e, n), s = _("elementShape", t, e, n), o = _("elementDType", t, e, n);
      return [n.getTensorList(r.id).gather(a, o, s)];
    }
    case "TensorListStack": {
      const r = _("tensorListId", t, e, n), a = _("elementShape", t, e, n), s = _("elementDType", t, e, n), o = _("numElements", t, e, n);
      return [n.getTensorList(r.id).stack(a, s, o)];
    }
    case "TensorListFromTensor": {
      const r = _("tensor", t, e, n), a = _("elementShape", t, e, n), s = _("elementDType", t, e, n), o = E6(r, a, s);
      return n.addTensorList(o), [o.idTensor];
    }
    case "TensorListConcat":
    case "TensorListConcatV2": {
      const r = _("tensorListId", t, e, n), a = n.getTensorList(r.id), s = _("dtype", t, e, n), o = _("elementShape", t, e, n);
      return [a.concat(s, o)];
    }
    case "TensorListPushBack": {
      const r = _("tensorListId", t, e, n), a = _("tensor", t, e, n), s = n.getTensorList(r.id);
      return s.pushBack(a), [s.idTensor];
    }
    case "TensorListPopBack": {
      const r = _("tensorListId", t, e, n), a = _("elementShape", t, e, n), s = _("elementDType", t, e, n);
      return [n.getTensorList(r.id).popBack(a, s)];
    }
    case "TensorListSplit": {
      const r = _("tensor", t, e, n), a = _("elementShape", t, e, n), s = _("lengths", t, e, n), o = N6(r, s, a);
      return n.addTensorList(o), [o.idTensor];
    }
    case "TensorListLength": {
      const r = _("tensorListId", t, e, n), a = n.getTensorList(r.id);
      return [ut(a.size(), "int32")];
    }
    case "TensorListResize": {
      const r = _("tensorListId", t, e, n), a = _("size", t, e, n), o = n.getTensorList(r.id).resize(a);
      return n.addTensorList(o), [o.idTensor];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mv(t, e, n) {
  const [r, a] = _("fusedOps", t, e, n), s = r === "biasadd", o = !s, i = a === "prelu", c = r === "fusedbatchnorm", l = _("numArgs", t, e, n);
  if (s) {
    if (i && l !== 2)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    if (!i && s && l !== 1)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
  }
  if (c)
    throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  const u = _("strides", t, e, n), d = Sc(t, e, n), f = _("dataFormat", t, e, n).toUpperCase(), p = _("dilations", t, e, n);
  let [h, m] = _("args", t, e, n);
  o && (m = h, h = void 0);
  const g = _("leakyreluAlpha", t, e, n);
  return {
    stride: u,
    pad: d,
    dataFormat: f,
    dilations: p,
    biasArg: h,
    preluArg: m,
    activationFunc: a,
    leakyreluAlpha: g
  };
}
const R6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "Conv1D": {
      const a = _("stride", t, e, n), s = _("pad", t, e, n), o = _("dataFormat", t, e, n).toUpperCase(), i = _("dilation", t, e, n);
      return [r.conv1d(_("x", t, e, n), _("filter", t, e, n), a, s, o, i)];
    }
    case "Conv2D": {
      const a = _("strides", t, e, n), s = Sc(t, e, n), o = _("dataFormat", t, e, n).toUpperCase(), i = _("dilations", t, e, n);
      return [r.conv2d(_("x", t, e, n), _("filter", t, e, n), [a[1], a[2]], s, o, [i[1], i[2]])];
    }
    case "_FusedConv2D": {
      const { stride: a, pad: s, dataFormat: o, dilations: i, biasArg: c, preluArg: l, activationFunc: u, leakyreluAlpha: d } = mv(t, e, n);
      return [r.fused.conv2d({
        x: _("x", t, e, n),
        filter: _("filter", t, e, n),
        strides: [a[1], a[2]],
        pad: s,
        dataFormat: o,
        dilations: [i[1], i[2]],
        bias: c,
        activation: u,
        preluActivationWeights: l,
        leakyreluAlpha: d
      })];
    }
    case "FusedDepthwiseConv2dNative": {
      const { stride: a, pad: s, dataFormat: o, dilations: i, biasArg: c, preluArg: l, activationFunc: u, leakyreluAlpha: d } = mv(t, e, n);
      return [r.fused.depthwiseConv2d({
        x: _("x", t, e, n),
        filter: _("filter", t, e, n),
        strides: [a[1], a[2]],
        pad: s,
        dataFormat: o,
        dilations: [i[1], i[2]],
        bias: c,
        activation: u,
        preluActivationWeights: l,
        leakyreluAlpha: d
      })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      const a = _("outputShape", t, e, n), s = _("strides", t, e, n), o = Sc(t, e, n);
      return [r.conv2dTranspose(_("x", t, e, n), _("filter", t, e, n), a, [s[1], s[2]], o)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      const a = _("strides", t, e, n), s = Sc(t, e, n), o = _("dilations", t, e, n), i = _("dataFormat", t, e, n).toUpperCase();
      return [r.depthwiseConv2d(_("input", t, e, n), _("filter", t, e, n), [a[1], a[2]], s, i, [o[1], o[2]])];
    }
    case "Conv3D": {
      const a = _("strides", t, e, n), s = _("pad", t, e, n), o = _("dataFormat", t, e, n).toUpperCase(), i = _("dilations", t, e, n);
      return [r.conv3d(_("x", t, e, n), _("filter", t, e, n), [a[1], a[2], a[3]], s, o, [i[1], i[2], i[3]])];
    }
    case "AvgPool": {
      const a = _("strides", t, e, n), s = _("pad", t, e, n), o = _("kernelSize", t, e, n);
      return [r.avgPool(_("x", t, e, n), [o[1], o[2]], [a[1], a[2]], s)];
    }
    case "MaxPool": {
      const a = _("strides", t, e, n), s = _("pad", t, e, n), o = _("kernelSize", t, e, n);
      return [r.maxPool(_("x", t, e, n), [o[1], o[2]], [a[1], a[2]], s)];
    }
    case "MaxPoolWithArgmax": {
      const a = _("strides", t, e, n), s = _("pad", t, e, n), o = _("kernelSize", t, e, n), i = _("includeBatchInIndex", t, e, n), { result: c, indexes: l } = r.maxPoolWithArgmax(_("x", t, e, n), [o[1], o[2]], [a[1], a[2]], s, i);
      return [c, l];
    }
    case "AvgPool3D": {
      const a = _("strides", t, e, n), s = _("pad", t, e, n), o = _("kernelSize", t, e, n);
      return [r.avgPool3d(_("x", t, e, n), [o[1], o[2], o[3]], [a[1], a[2], a[3]], s)];
    }
    case "MaxPool3D": {
      const a = _("strides", t, e, n), s = _("pad", t, e, n), o = _("kernelSize", t, e, n);
      return [r.maxPool3d(_("x", t, e, n), [o[1], o[2], o[3]], [a[1], a[2], a[3]], s)];
    }
    case "Dilation2D": {
      const a = _("strides", t, e, n), s = _("pad", t, e, n), o = _("dilations", t, e, n), i = a[1], c = a[2], l = o[1], u = o[2];
      return [r.dilation2d(
        _("x", t, e, n),
        _("filter", t, e, n),
        [i, c],
        s,
        [l, u],
        "NHWC"
        /* dataFormat */
      )];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "Fill": {
      const a = _("shape", t, e, n), s = _("dtype", t, e, n), o = _("value", t, e, n);
      return [r.fill(a, o, s)];
    }
    case "LinSpace": {
      const a = _("start", t, e, n), s = _("stop", t, e, n), o = _("num", t, e, n);
      return [r.linspace(a, s, o)];
    }
    case "Multinomial": {
      const a = _("logits", t, e, n), s = _("numSamples", t, e, n), o = _("seed", t, e, n);
      return [r.multinomial(a, s, o)];
    }
    case "OneHot": {
      const a = _("indices", t, e, n), s = _("depth", t, e, n), o = _("onValue", t, e, n), i = _("offValue", t, e, n), c = _("dtype", t, e, n);
      return [r.oneHot(a, s, o, i, c)];
    }
    case "Ones":
      return [r.ones(_("shape", t, e, n), _("dtype", t, e, n))];
    case "OnesLike":
      return [r.onesLike(_("x", t, e, n))];
    case "RandomStandardNormal":
      return [r.randomStandardNormal(_("shape", t, e, n), _("dtype", t, e, n), _("seed", t, e, n))];
    case "RandomUniform":
      return [r.randomUniform(
        // tslint:disable-next-line:no-any
        _("shape", t, e, n),
        _("minval", t, e, n),
        _("maxval", t, e, n),
        _("dtype", t, e, n)
      )];
    case "RandomUniformInt":
      return [r.randomUniformInt(_("shape", t, e, n), _("minval", t, e, n), _("maxval", t, e, n), _("seed", t, e, n))];
    case "Range": {
      const a = _("start", t, e, n), s = _("stop", t, e, n), o = _("step", t, e, n);
      return [r.range(a, s, o, _("dtype", t, e, n))];
    }
    case "TruncatedNormal": {
      const a = _("shape", t, e, n), s = _("mean", t, e, n), o = _("stdDev", t, e, n), i = _("seed", t, e, n);
      return [r.truncatedNormal(a, s, o, _("dtype", t, e, n), i)];
    }
    case "Zeros":
      return [r.zeros(_("shape", t, e, n), _("dtype", t, e, n))];
    case "ZerosLike":
      return [r.zerosLike(_("x", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qf(t, e, n) {
  const r = _("boxes", t, e, n), a = _("scores", t, e, n), s = _("maxOutputSize", t, e, n), o = _("iouThreshold", t, e, n), i = _("scoreThreshold", t, e, n), c = _("softNmsSigma", t, e, n);
  return {
    boxes: r,
    scores: a,
    maxOutputSize: s,
    iouThreshold: o,
    scoreThreshold: i,
    softNmsSigma: c
  };
}
const D6 = async (t, e, n, r, a = bn) => {
  switch (t.op) {
    case "NonMaxSuppressionV5": {
      const { boxes: s, scores: o, maxOutputSize: i, iouThreshold: c, scoreThreshold: l, softNmsSigma: u } = Qf(t, e, n), d = await a.image.nonMaxSuppressionWithScoreAsync(s, o, i, c, l, u);
      return [d.selectedIndices, d.selectedScores];
    }
    case "NonMaxSuppressionV4": {
      const { boxes: s, scores: o, maxOutputSize: i, iouThreshold: c, scoreThreshold: l } = Qf(t, e, n), u = _("padToMaxOutputSize", t, e, n), d = await a.image.nonMaxSuppressionPaddedAsync(s, o, i, c, l, u);
      return [d.selectedIndices, d.validOutputs];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      const { boxes: s, scores: o, maxOutputSize: i, iouThreshold: c, scoreThreshold: l } = Qf(t, e, n);
      return [await a.image.nonMaxSuppressionAsync(s, o, i, c, l)];
    }
    case "Where": {
      const s = a.cast(_("condition", t, e, n), "bool"), o = [await a.whereAsync(s)];
      return s.dispose(), o;
    }
    case "ListDiff":
      return a.setdiff1dAsync(_("x", t, e, n), _("y", t, e, n));
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const O6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "LowerBound": {
      const a = _("sortedSequence", t, e, n), s = _("values", t, e, n);
      return [r.lowerBound(a, s)];
    }
    case "TopKV2": {
      const a = _("x", t, e, n), s = _("k", t, e, n), o = _("sorted", t, e, n), i = r.topk(a, s, o);
      return [i.values, i.indices];
    }
    case "UpperBound": {
      const a = _("sortedSequence", t, e, n), s = _("values", t, e, n);
      return [r.upperBound(a, s)];
    }
    case "Unique": {
      const a = _("x", t, e, n), s = r.unique(a);
      return [s.values, s.indices];
    }
    case "UniqueV2": {
      const a = _("x", t, e, n), s = _("axis", t, e, n), o = r.unique(a, s);
      return [o.values, o.indices];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "Const":
      return e[t.name];
    case "PlaceholderWithDefault":
      const a = _("default", t, e, n);
      return [gn(t.name, e, n) || a];
    case "Placeholder":
      return [gn(t.name, e, n)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      const u = _("x", t, e, n);
      return [la(u)];
    }
    case "IdentityN":
      return _("x", t, e, n).map((u) => la(u));
    case "Snapshot":
      const s = _("x", t, e, n);
      return [la(s)];
    case "Shape":
      return [r.tensor1d(_("x", t, e, n).shape, "int32")];
    case "ShapeN":
      return _("x", t, e, n).map((u) => r.tensor1d(u.shape));
    case "Size":
      return [r.scalar(_("x", t, e, n).size, "int32")];
    case "Rank":
      return [r.scalar(_("x", t, e, n).rank, "int32")];
    case "NoOp":
      return [r.scalar(1)];
    case "Print":
      const o = _("x", t, e, n), i = _("data", t, e, n), c = _("message", t, e, n), l = _("summarize", t, e, n);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(c);
      for (let u = 0; u < i.length; u++)
        console.log(Array.prototype.slice.call(i[u].dataSync()).slice(0, l));
      return [o];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class M6 {
  get id() {
    return this.handle.id;
  }
  /**
   * Constructor of HashTable. Creates a hash table.
   *
   * @param keyDType `dtype` of the table keys.
   * @param valueDType `dtype` of the table values.
   */
  constructor(e, n) {
    this.keyDType = e, this.valueDType = n, this.handle = ut(0), this.tensorMap = /* @__PURE__ */ new Map(), Yr(this.handle);
  }
  /**
   * Dispose the tensors and handle and clear the hashtable.
   */
  clearAndClose() {
    this.tensorMap.forEach((e) => e.dispose()), this.tensorMap.clear(), this.handle.dispose();
  }
  /**
   * The number of items in the hash table.
   */
  size() {
    return this.tensorMap.size;
  }
  /**
   * The number of items in the hash table as a rank-0 tensor.
   */
  tensorSize() {
    return ut(this.size(), "int32");
  }
  /**
   * Replaces the contents of the table with the specified keys and values.
   * @param keys Keys to store in the hashtable.
   * @param values Values to store in the hashtable.
   */
  async import(e, n) {
    this.checkKeyAndValueTensor(e, n);
    const r = await e.data();
    return this.tensorMap.forEach((a) => a.dispose()), this.tensorMap.clear(), Je(() => {
      const a = qs(n), s = r.length, o = a.length;
      A(s === o, () => `The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);
      for (let i = 0; i < s; i++) {
        const c = r[i], l = a[i];
        Yr(l), this.tensorMap.set(c, l);
      }
      return this.handle;
    });
  }
  /**
   * Looks up keys in a hash table, outputs the corresponding values.
   *
   * Performs batch lookups, for every element in the key tensor, `find`
   * stacks the corresponding value into the return tensor.
   *
   * If an element is not present in the table, the given `defaultValue` is
   * used.
   *
   * @param keys Keys to look up. Must have the same type as the keys of the
   *     table.
   * @param defaultValue The scalar `defaultValue` is the value output for keys
   *     not present in the table. It must also be of the same type as the
   *     table values.
   */
  async find(e, n) {
    this.checkKeyAndValueTensor(e, n);
    const r = await e.data();
    return Je(() => {
      const a = [];
      for (let s = 0; s < r.length; s++) {
        const o = r[s], i = this.findWithDefault(o, n);
        a.push(i);
      }
      return ba(a);
    });
  }
  // tslint:disable-next-line: no-any
  findWithDefault(e, n) {
    const r = this.tensorMap.get(e);
    return r ?? n;
  }
  checkKeyAndValueTensor(e, n) {
    if (e.dtype !== this.keyDType)
      throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);
    if (n.dtype !== this.valueDType)
      throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const P6 = async (t, e, n, r) => {
  switch (t.op) {
    case "HashTable":
    case "HashTableV2": {
      const a = r.getHashTableHandleByName(t.name);
      if (a != null)
        return [a];
      {
        const s = _("keyDType", t, e, n), o = _("valueDType", t, e, n), i = new M6(s, o);
        return r.addHashTable(t.name, i), [i.handle];
      }
    }
    case "InitializeTable":
    case "InitializeTableV2":
    case "LookupTableImport":
    case "LookupTableImportV2": {
      const a = _("tableHandle", t, e, n, r), s = _("keys", t, e, n), o = _("values", t, e, n);
      return [await r.getHashTableById(a.id).import(s, o)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      const a = _("tableHandle", t, e, n, r), s = _("keys", t, e, n), o = _("defaultValue", t, e, n);
      return [await r.getHashTableById(a.id).find(s, o)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      const a = _("tableHandle", t, e, n, r);
      return [r.getHashTableById(a.id).tensorSize()];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const B6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "ResizeBilinear": {
      const a = _("images", t, e, n), s = _("size", t, e, n), o = _("alignCorners", t, e, n), i = _("halfPixelCenters", t, e, n);
      return [r.image.resizeBilinear(a, [s[0], s[1]], o, i)];
    }
    case "ResizeNearestNeighbor": {
      const a = _("images", t, e, n), s = _("size", t, e, n), o = _("alignCorners", t, e, n), i = _("halfPixelCenters", t, e, n);
      return [r.image.resizeNearestNeighbor(a, [s[0], s[1]], o, i)];
    }
    case "CropAndResize": {
      const a = _("image", t, e, n), s = _("boxes", t, e, n), o = _("boxInd", t, e, n), i = _("cropSize", t, e, n), c = _("method", t, e, n), l = _("extrapolationValue", t, e, n);
      return [r.image.cropAndResize(a, s, o, i, c, l)];
    }
    case "ImageProjectiveTransformV3": {
      const a = _("images", t, e, n), s = _("transforms", t, e, n), o = _("outputShape", t, e, n), i = _("fillValue", t, e, n), c = _("interpolation", t, e, n), l = _("fillMode", t, e, n);
      return [r.image.transform(a, s, c.toLowerCase(), l.toLowerCase(), i, o)];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const L6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "Equal":
      return [r.equal(_("a", t, e, n), _("b", t, e, n))];
    case "NotEqual":
      return [r.notEqual(_("a", t, e, n), _("b", t, e, n))];
    case "Greater":
      return [r.greater(_("a", t, e, n), _("b", t, e, n))];
    case "GreaterEqual":
      return [r.greaterEqual(_("a", t, e, n), _("b", t, e, n))];
    case "Less":
      return [r.less(_("a", t, e, n), _("b", t, e, n))];
    case "LessEqual":
      return [r.lessEqual(_("a", t, e, n), _("b", t, e, n))];
    case "LogicalAnd":
      return [r.logicalAnd(_("a", t, e, n), _("b", t, e, n))];
    case "LogicalNot":
      return [r.logicalNot(_("a", t, e, n))];
    case "LogicalOr":
      return [r.logicalOr(_("a", t, e, n), _("b", t, e, n))];
    case "Select":
    case "SelectV2":
      return [r.where(_("condition", t, e, n), _("a", t, e, n), _("b", t, e, n))];
    case "BitwiseAnd":
      return [r.bitwiseAnd(_("a", t, e, n), _("b", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const W6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [r.matMul(_("a", t, e, n), _("b", t, e, n), _("transposeA", t, e, n), _("transposeB", t, e, n))];
    case "Einsum":
      return [r.einsum(_("equation", t, e, n), ..._("tensors", t, e, n))];
    case "Transpose":
      return [r.transpose(_("x", t, e, n), _("perm", t, e, n))];
    case "_FusedMatMul":
      const [a, s] = _("fusedOps", t, e, n), o = a === "biasadd", i = s === "prelu", c = _("numArgs", t, e, n), l = _("leakyreluAlpha", t, e, n);
      if (o) {
        if (i && c !== 2)
          throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!i && c !== 1)
          throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
      }
      const [u, d] = _("args", t, e, n);
      return [r.fused.matMul({
        a: _("a", t, e, n),
        b: _("b", t, e, n),
        transposeA: _("transposeA", t, e, n),
        transposeB: _("transposeB", t, e, n),
        bias: u,
        activation: s,
        preluActivationWeights: d,
        leakyreluAlpha: l
      })];
    case "MatrixBandPart":
      return [r.linalg.bandPart(_("a", t, e, n), _("numLower", t, e, n), _("numUpper", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const z6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "EuclideanNorm":
      return [r.euclideanNorm(_("x", t, e, n), _("axis", t, e, n), _("keepDims", t, e, n))];
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
      return [r.batchNorm(_("x", t, e, n), _("mean", t, e, n), _("variance", t, e, n), _("offset", t, e, n), _("scale", t, e, n), _("epsilon", t, e, n))];
    case "FusedBatchNormV3":
      return [r.batchNorm(_("x", t, e, n), _("mean", t, e, n), _("variance", t, e, n), _("offset", t, e, n), _("scale", t, e, n), _("epsilon", t, e, n))];
    case "LRN":
      return [r.localResponseNormalization(_("x", t, e, n), _("radius", t, e, n), _("bias", t, e, n), _("alpha", t, e, n), _("beta", t, e, n))];
    case "Softmax":
      return [r.softmax(_("x", t, e, n))];
    case "LogSoftmax":
      return [r.logSoftmax(_("x", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const V6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "RaggedGather": {
      const { outputNestedSplits: a, outputDenseValues: s } = r.raggedGather(_("paramsNestedSplits", t, e, n), _("paramsDenseValues", t, e, n), _("indices", t, e, n), _("outputRaggedRank", t, e, n));
      return a.concat(s);
    }
    case "RaggedRange": {
      const { rtNestedSplits: a, rtDenseValues: s } = r.raggedRange(_("starts", t, e, n), _("limits", t, e, n), _("splits", t, e, n));
      return [a, s];
    }
    case "RaggedTensorToTensor":
      return [r.raggedTensorToTensor(_("shape", t, e, n), _("values", t, e, n), _("defaultValue", t, e, n), _("rowPartitionTensors", t, e, n), _("rowPartitionTypes", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const H6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "Max": {
      const i = _("axis", t, e, n), c = _("keepDims", t, e, n);
      return [r.max(_("x", t, e, n), i, c)];
    }
    case "Mean": {
      const i = _("axis", t, e, n), c = _("keepDims", t, e, n);
      return [r.mean(_("x", t, e, n), i, c)];
    }
    case "Min": {
      const i = _("axis", t, e, n), c = _("keepDims", t, e, n);
      return [r.min(_("x", t, e, n), i, c)];
    }
    case "Sum": {
      const i = _("axis", t, e, n), c = _("keepDims", t, e, n);
      return [r.sum(_("x", t, e, n), i, c)];
    }
    case "All": {
      const i = _("axis", t, e, n), c = _("keepDims", t, e, n);
      return [r.all(_("x", t, e, n), i, c)];
    }
    case "Any": {
      const i = _("axis", t, e, n), c = _("keepDims", t, e, n);
      return [r.any(_("x", t, e, n), i, c)];
    }
    case "ArgMax": {
      const i = _("axis", t, e, n);
      return [r.argMax(_("x", t, e, n), i)];
    }
    case "ArgMin": {
      const i = _("axis", t, e, n);
      return [r.argMin(_("x", t, e, n), i)];
    }
    case "Prod": {
      const i = _("axis", t, e, n), c = _("keepDims", t, e, n);
      return [r.prod(_("x", t, e, n), i, c)];
    }
    case "Cumprod": {
      const i = _("axis", t, e, n), c = _("exclusive", t, e, n), l = _("reverse", t, e, n);
      return [r.cumprod(_("x", t, e, n), i, c, l)];
    }
    case "Cumsum": {
      const i = _("axis", t, e, n), c = _("exclusive", t, e, n), l = _("reverse", t, e, n);
      return [r.cumsum(_("x", t, e, n), i, c, l)];
    }
    case "Bincount":
      const a = _("x", t, e, n), s = _("weights", t, e, n), o = _("size", t, e, n);
      return [r.bincount(a, s, o)];
    case "DenseBincount": {
      const i = _("x", t, e, n), c = _("weights", t, e, n), l = _("size", t, e, n), u = _("binaryOutput", t, e, n);
      return [r.denseBincount(i, c, l, u)];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const j6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "ConcatV2":
    case "Concat": {
      const a = _("n", t, e, n), s = _("axis", t, e, n);
      let o = _("tensors", t, e, n);
      return o = o.slice(0, a), [r.concat(o, s)];
    }
    case "Gather": {
      const a = _("x", t, e, n), s = _("indices", t, e, n);
      return [r.gather(a, r.cast(s, "int32"), 0)];
    }
    case "GatherV2": {
      const a = _("axis", t, e, n), s = _("batchDims", t, e, n), o = _("x", t, e, n), i = _("indices", t, e, n);
      return [r.gather(o, r.cast(i, "int32"), a, s)];
    }
    case "Reverse": {
      const a = _("dims", t, e, n), s = [];
      for (let i = 0; i < a.length; i++)
        a[i] && s.push(i);
      const o = _("x", t, e, n);
      return [r.reverse(o, s)];
    }
    case "ReverseV2": {
      const a = _("axis", t, e, n), s = _("x", t, e, n);
      return [r.reverse(s, a)];
    }
    case "Slice": {
      const a = _("begin", t, e, n), s = _("size", t, e, n);
      return [r.slice(_("x", t, e, n), a, s)];
    }
    case "StridedSlice": {
      const a = _("begin", t, e, n), s = _("end", t, e, n), o = _("strides", t, e, n), i = _("beginMask", t, e, n), c = _("endMask", t, e, n), l = _("ellipsisMask", t, e, n), u = _("newAxisMask", t, e, n), d = _("shrinkAxisMask", t, e, n), f = _("x", t, e, n);
      return [r.stridedSlice(f, a, s, o, i, c, l, u, d)];
    }
    case "Pack":
      return Je(() => {
        const a = _("axis", t, e, n), s = _("tensors", t, e, n), o = s[0].shape, i = r.squeeze(s[0]).shape, c = s.map((l) => {
          const u = Ir(l.shape, o);
          if (!u && !Ir(r.squeeze(l).shape, i))
            throw new Error("the input tensors shape does not match");
          return u ? l : r.reshape(l, o);
        });
        return [r.stack(c, a)];
      });
    case "Unpack": {
      const a = _("axis", t, e, n), s = _("tensor", t, e, n);
      return r.unstack(s, a);
    }
    case "Tile": {
      const a = _("reps", t, e, n);
      return [r.tile(_("x", t, e, n), a)];
    }
    case "Split":
    case "SplitV": {
      const a = _("axis", t, e, n), s = _("numOrSizeSplits", t, e, n), o = _("x", t, e, n);
      return r.split(o, s, a);
    }
    case "ScatterNd": {
      const a = _("indices", t, e, n), s = _("values", t, e, n), o = _("shape", t, e, n);
      return [r.scatterND(a, s, o)];
    }
    case "GatherNd": {
      const a = _("x", t, e, n), s = _("indices", t, e, n);
      return [r.gatherND(a, s)];
    }
    case "SparseToDense": {
      const a = _("sparseIndices", t, e, n), s = _("outputShape", t, e, n), o = _("sparseValues", t, e, n), i = _("defaultValue", t, e, n);
      return [r.sparseToDense(a, o, s, o.dtype === i.dtype ? i : r.cast(i, o.dtype))];
    }
    case "TensorScatterUpdate": {
      const a = _("indices", t, e, n), s = _("values", t, e, n), o = _("tensor", t, e, n);
      return [r.tensorScatterUpdate(o, a, s)];
    }
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const U6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "SparseFillEmptyRows": {
      const { outputIndices: a, outputValues: s, emptyRowIndicator: o, reverseIndexMap: i } = r.sparse.sparseFillEmptyRows(_("indices", t, e, n), _("values", t, e, n), _("denseShape", t, e, n), _("defaultValue", t, e, n));
      return [
        a,
        s,
        o,
        i
      ];
    }
    case "SparseReshape": {
      const { outputIndices: a, outputShape: s } = r.sparse.sparseReshape(_("inputIndices", t, e, n), _("inputShape", t, e, n), _("newShape", t, e, n));
      return [a, s];
    }
    case "SparseSegmentMean":
      return [r.sparse.sparseSegmentMean(_("data", t, e, n), _("indices", t, e, n), _("segmentIds", t, e, n))];
    case "SparseSegmentSum":
      return [r.sparse.sparseSegmentSum(_("data", t, e, n), _("indices", t, e, n), _("segmentIds", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const G6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "FFT":
      return [r.fft(_("x", t, e, n))];
    case "IFFT":
      return [r.ifft(_("x", t, e, n))];
    case "RFFT":
      return [r.rfft(_("x", t, e, n))];
    case "IRFFT":
      return [r.irfft(_("x", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const q6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "StaticRegexReplace":
      return [r.string.staticRegexReplace(_("input", t, e, n), _("pattern", t, e, n), _("rewrite", t, e, n), _("replaceGlobal", t, e, n))];
    case "StringNGrams": {
      const { nGrams: a, nGramsSplits: s } = r.string.stringNGrams(_("data", t, e, n), _("dataSplits", t, e, n), _("separator", t, e, n), _("nGramWidths", t, e, n), _("leftPad", t, e, n), _("rightPad", t, e, n), _("padWidth", t, e, n), _("preserveShortSequences", t, e, n));
      return [a, s];
    }
    case "StringSplit": {
      const { indices: a, values: s, shape: o } = r.string.stringSplit(_("input", t, e, n), _("delimiter", t, e, n), _("skipEmpty", t, e, n));
      return [a, s, o];
    }
    case "StringToHashBucketFast":
      return [r.string.stringToHashBucketFast(_("input", t, e, n), _("numBuckets", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const K6 = (t, e, n, r = bn) => {
  switch (t.op) {
    case "Cast":
      return [r.cast(_("x", t, e, n), _("dtype", t, e, n))];
    case "ExpandDims": {
      const a = _("axis", t, e, n);
      return [r.expandDims(_("x", t, e, n), a)];
    }
    case "Squeeze": {
      const a = _("axis", t, e, n);
      return [r.squeeze(_("x", t, e, n), a)];
    }
    case "Reshape":
      return [r.reshape(_("x", t, e, n), _("shape", t, e, n))];
    case "EnsureShape":
      return [r.ensureShape(_("x", t, e, n), _("shape", t, e, n))];
    case "MirrorPad":
      return [r.mirrorPad(_("x", t, e, n), _("padding", t, e, n), _("mode", t, e, n))];
    case "PadV2":
    case "Pad":
      return [r.pad(_("x", t, e, n), _("padding", t, e, n), _("constantValue", t, e, n))];
    case "SpaceToBatchND": {
      const a = _("blockShape", t, e, n), s = _("paddings", t, e, n);
      return [r.spaceToBatchND(_("x", t, e, n), a, s)];
    }
    case "BatchToSpaceND": {
      const a = _("blockShape", t, e, n), s = _("crops", t, e, n);
      return [r.batchToSpaceND(_("x", t, e, n), a, s)];
    }
    case "DepthToSpace": {
      const a = _("blockSize", t, e, n), s = _("dataFormat", t, e, n).toUpperCase();
      return [r.depthToSpace(_("x", t, e, n), a, s)];
    }
    case "BroadcastTo":
      return [r.broadcastTo(_("x", t, e, n), _("shape", t, e, n))];
    case "BroadcastArgs":
      return [r.broadcastArgs(_("s0", t, e, n), _("s1", t, e, n))];
    default:
      throw TypeError(`Node type ${t.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gv(t, e, n, r, a = Je) {
  const s = ((o, i, c) => {
    switch (o.category) {
      case "arithmetic":
        return a(() => x6(o, i, c));
      case "basic_math":
        return a(() => I6(o, i, c));
      case "control":
        return A6(o, i, c);
      case "convolution":
        return a(() => R6(o, i, c));
      case "creation":
        return a(() => $6(o, i, c));
      case "dynamic":
        return D6(o, i, c);
      case "evaluation":
        return a(() => O6(o, i, c));
      case "image":
        return a(() => B6(o, i, c));
      case "graph":
        return a(() => F6(o, i, c));
      case "logical":
        return a(() => L6(o, i, c));
      case "matrices":
        return a(() => W6(o, i, c));
      case "normalization":
        return a(() => z6(o, i, c));
      case "ragged":
        return a(() => V6(o, i, c));
      case "reduction":
        return a(() => H6(o, i, c));
      case "slice_join":
        return a(() => j6(o, i, c));
      case "sparse":
        return a(() => U6(o, i, c));
      case "spectral":
        return a(() => G6(o, i, c));
      case "string":
        return a(() => q6(o, i, c));
      case "transformation":
        return a(() => K6(o, i, c));
      case "hash_table":
        return P6(o, i, c, r);
      case "custom":
        const l = p2(o.op);
        if (l && l.customExecutor)
          return l.customExecutor(new _6(o, i, c));
        throw TypeError(`Custom op ${o.op} is not registered.`);
      default:
        throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
    }
  })(t, e, n);
  return Ds(s) ? s.then((o) => [].concat(o)) : [].concat(s);
}
class yv {
  constructor(e = {}, n = {}, r = {}, a = {}, s) {
    this.weightMap = e, this.tensorArrayMap = n, this.tensorListMap = r, this.functionMap = a, this.parseNodeNameCache = s, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  newFrame(e, n) {
    return { id: e, frameName: n, iterationId: 0 };
  }
  /**
   * Set the current context
   * @param contexts: ExecutionContextInfo[] the current path of execution
   * frames
   */
  set currentContext(e) {
    this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
  }
  get currentContext() {
    return this.contexts;
  }
  /**
   * Returns the current context in string format.
   */
  get currentContextId() {
    return this._currentContextIds[0];
  }
  /**
   * Returns the current context and all parent contexts in string format.
   * This allow access to the nodes in the current and parent frames.
   */
  get currentContextIds() {
    return this._currentContextIds;
  }
  generateCurrentContextIds() {
    const e = [];
    for (let n = 0; n < this.contexts.length - 1; n++) {
      const r = this.contexts.slice(0, this.contexts.length - n);
      e.push(this.contextIdforContexts(r));
    }
    e.push(""), this._currentContextIds = e;
  }
  contextIdforContexts(e) {
    return e ? e.map((n) => n.id === 0 && n.iterationId === 0 ? "" : `${n.frameName}-${n.iterationId}`).join("/") : "";
  }
  /**
   * Enter a new frame, a new context is pushed on the current context list.
   * @param frameId new frame id
   */
  enterFrame(e) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }
  /**
   * Exit the current frame, the last context is removed from the current
   * context list.
   */
  exitFrame() {
    if (this.contexts && this.contexts.length > 1)
      this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
    else
      throw new Error("Cannot exit frame, the context is empty");
  }
  /**
   * Enter the next iteration of a loop, the iteration id of last context is
   * increased.
   */
  nextIteration() {
    if (this.contexts && this.contexts.length > 0) {
      this.contexts = this.contexts.slice(), this.lastId++;
      const e = Object.assign({}, this.contexts[this.contexts.length - 1]);
      e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    } else
      throw new Error("Cannot increase frame iteration, the context is empty");
  }
  getWeight(e) {
    return this.weightMap[e];
  }
  addTensorArray(e) {
    this.tensorArrayMap[e.id] = e;
  }
  getTensorArray(e) {
    return this.tensorArrayMap[e];
  }
  addTensorList(e) {
    this.tensorListMap[e.id] = e;
  }
  getTensorList(e) {
    return this.tensorListMap[e];
  }
  dispose(e) {
    for (const n in this.tensorArrayMap)
      this.tensorArrayMap[n].clearAndClose(e);
    for (const n in this.tensorListMap)
      this.tensorListMap[n].clearAndClose(e);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vv(t, e, n, r) {
  const a = /* @__PURE__ */ new Set(), s = [];
  let o = null, i = null;
  const c = /* @__PURE__ */ new Set(), l = new Set(Object.keys(t).map((f) => tr(f)[0]));
  r = r || [];
  const u = new Set(r.map((f) => tr(f.name)[0])), d = [...e];
  for (; d.length > 0; ) {
    const f = d.pop();
    if ((_s(f) || n5(f) || r5(f)) && o == null && (o = f, i = o.children.map((p) => p.name).filter((p) => a.has(p))), a.add(f.name), n[f.name] == null && !l.has(f.name) && !u.has(f.name)) {
      if (f.inputs.length === 0) {
        s.push(f.name);
        continue;
      }
      f.inputs.forEach((p) => {
        c.has(p.name) || (c.add(p.name), d.push(p));
      });
    }
  }
  return { inputs: t, outputs: e, usedNodes: a, missingInputs: s, dynamicNode: o, syncInputs: i };
}
function X6(t, e) {
  const { usedNodes: n, inputs: r } = e, a = Object.keys(r).map((g) => tr(g)[0]).map((g) => t.nodes[g]), s = t.initNodes || [], o = (g) => n.has(typeof g == "string" ? g : g.name);
  function i(g) {
    return [...new Map(g.map((v) => [v.name, v])).values()];
  }
  const c = i([
    ...a,
    ...t.weights,
    ...s
  ]).filter(o), l = i([
    ...c,
    ...Object.values(t.nodes)
  ]).filter(o), u = new Map(l.map((g) => [g.name, g])), d = {};
  for (const g of l) {
    d[g.name] = d[g.name] || 0;
    for (const v of g.children)
      o(v) || (d[v.name] = Number.POSITIVE_INFINITY), d[v.name] = (d[v.name] || 0) + 1;
  }
  const f = Object.entries(d).filter(([, g]) => g === 0).map(([g]) => g), p = [...f];
  for (; f.length > 0; ) {
    const g = f.pop(), v = u.get(g);
    for (const b of v.children.filter(o))
      --d[b.name] === 0 && (p.push(b.name), f.push(b.name));
  }
  const h = p.map((g) => u.get(g)), m = Y6(h, c);
  return Z6(m, c), m;
}
function Y6(t, e) {
  const n = new Map(t.map((o) => [o.name, o])), r = e.map((o) => o.name), a = new Set(r);
  for (; r.length > 0; ) {
    const o = r.pop(), i = n.get(o);
    for (const c of i.children)
      !n.has(c.name) || a.has(c.name) || (a.add(c.name), r.push(c.name));
  }
  return t.filter((o) => a.has(o.name));
}
class uc extends Error {
  constructor(e) {
    super(`NodesExecutionOrderError: ${e}`);
  }
}
function Z6(t, e) {
  const n = new Map(t.map((i, c) => [i.name, c])), r = new Set(e.map((i) => i.name)), a = (i) => r.has(typeof i == "string" ? i : i.name), s = new Set(t.map((i) => i.name)), o = (i) => s.has(typeof i == "string" ? i : i.name);
  for (const i of t) {
    for (const c of i.children.filter(o)) {
      if (!n.has(c.name))
        throw new uc(`Child ${c.name} of node ${i.name} is unreachable.`);
      if (n.get(i.name) > n.get(c.name))
        throw new uc(`Node ${i.name} is scheduled to run after its child ${c.name}.`);
    }
    if (!a(i))
      for (const c of i.inputs) {
        if (!n.has(c.name))
          throw new uc(`Input ${c.name} of node ${i.name} is unreachable.`);
        if (n.get(c.name) > n.get(i.name))
          throw new uc(`Node ${i.name} is scheduled to run before its input ${c.name}.`);
      }
  }
}
function J6(t) {
  const e = new Map(t.map((i, c) => [i.name, c])), n = Number.MAX_SAFE_INTEGER, r = t.map((i, c) => _s(i) ? n : c), a = (i) => {
    const c = r[e.get(i.name)];
    return c ?? -1;
  }, s = t.map((i, c) => i.children.map(a).reduce((l, u) => Math.max(l, u), r[c])), o = /* @__PURE__ */ new Map();
  for (let i = 0; i < t.length; ++i) {
    const c = s[i];
    if (c === n)
      continue;
    const l = t[i], u = t[c];
    o.has(u.name) || o.set(u.name, []), o.get(u.name).push(l);
  }
  return o;
}
const Q6 = /* @__PURE__ */ new Set([
  "Switch",
  "Merge",
  "Enter",
  "Exit",
  "NextIteration",
  "StatelessIf",
  "StatelessWhile",
  "if",
  "While"
]), e5 = /* @__PURE__ */ new Set([
  "NonMaxSuppressionV2",
  "NonMaxSuppressionV3",
  "NonMaxSuppressionV5",
  "Where"
]), t5 = /* @__PURE__ */ new Set([
  "HashTable",
  "HashTableV2",
  "LookupTableImport",
  "LookupTableImportV2",
  "LookupTableFind",
  "LookupTableFindV2",
  "LookupTableSize",
  "LookupTableSizeV2"
]);
function _s(t) {
  return Q6.has(t.op);
}
function n5(t) {
  return e5.has(t.op);
}
function r5(t) {
  return t5.has(t.op);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Kc {
  get weightIds() {
    return this.parent ? this.parent.weightIds : this._weightIds;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this._weightMap;
  }
  set weightMap(e) {
    const n = Object.keys(e).map((r) => e[r].map((a) => a.id));
    this._weightIds = [].concat(...n), this._weightMap = e;
  }
  /**
   * Set `ResourceManager` shared by executors of a model.
   * @param resourceManager: `ResourceManager` of the `GraphModel`.
   */
  set resourceManager(e) {
    this._resourceManager = e;
  }
  get inputs() {
    return this._inputs.map((e) => ({
      name: e.name,
      shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
      dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
    }));
  }
  get outputs() {
    return this._outputs.map((e) => ({
      name: e.name,
      shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
      dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
    }));
  }
  get inputNodes() {
    return this._inputs.map((e) => e.signatureKey || e.name);
  }
  get outputNodes() {
    return this._outputs.map((e) => {
      const n = e.signatureKey || e.name;
      return e.defaultOutput ? `${n}:${e.defaultOutput}` : n;
    });
  }
  get functions() {
    return Object.keys(this._functions).reduce((e, n) => (e[n] = this._functions[n].signature, e), {});
  }
  /**
   *
   * @param graph Graph the model or function graph to be executed.
   * @param parent When building function exector you need to set the parent
   * executor. Since the weights and function executor maps are set at parant
   * level, that function executor can access the function maps and weight maps
   * through the parent.
   */
  constructor(e, n) {
    this.graph = e, this.parent = n, this.compiledMap = /* @__PURE__ */ new Map(), this.parseNodeNameCache = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPARATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.keepIntermediateTensors = !1, this._outputs = e.outputs, this._inputs = e.inputs, this._initNodes = e.initNodes, this._signature = e.signature, this._functions = e.functions, e.functions != null && Object.keys(e.functions).forEach((r) => {
      this._functionExecutorMap[r] = new Kc(e.functions[r], this);
    });
  }
  getCompilationKey(e, n) {
    const r = e.map((s) => s.name).sort(), a = n.map((s) => s.name).sort();
    return r.join(this.SEPARATOR) + "--" + a.join(this.SEPARATOR);
  }
  /**
   * Compiles the inference graph and returns the minimal set of nodes that are
   * required for execution, in the correct execution order.
   * @returns {Object} compilation The compile result.
   * @returns {Node[]} compilation.orderedNodes Nodes in the correct execution
   *     order.
   * @returns {Map<string, Node[]>} compilation.nodeLiveUntilMap A map from node
   *     to disposable nodes after its execution. That is, for a node `x`,
   *     `nodeLiveUntilMap[x]` indicates all nodes whose intermediate
   *     tensors should be disposed after `x` is executed.
   */
  compile(e, n) {
    const r = vv(e, n, this.weightMap, this._initNodes), { missingInputs: a, dynamicNode: s, syncInputs: o } = r;
    if (s != null)
      throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);
    if (a.length > 0) {
      const l = n.map((d) => d.name), u = Object.keys(e);
      throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${u}]. Missing the following inputs: [${a}]`);
    }
    const i = X6(this.graph, r), c = J6(i);
    return { orderedNodes: i, nodeLiveUntilMap: c };
  }
  cloneAndKeepTensor(e) {
    if (e == null)
      return null;
    const n = e.clone();
    return Yr(n), n;
  }
  cloneTensorList(e) {
    return e ? e.map((r) => this.cloneAndKeepTensor(r)) : null;
  }
  cloneTensorMap(e) {
    return Object.fromEntries(Object.entries(e).map(([n, r]) => [n, this.cloneTensorList(r)]));
  }
  /**
   * Executes the inference for given input tensors.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model, if
   * no outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   */
  execute(e, n) {
    this.disposeIntermediateTensors(), e = this.mapInputs(e);
    const r = Object.keys(e).sort();
    this.checkInputs(e), this.checkInputShapeAndType(e), n = this.mapOutputs(n), this.checkOutputs(n);
    const a = r.map((f) => this.graph.nodes[tr(f)[0]]), s = n.map((f) => tr(f)[0]), o = new Set(s);
    let i = s.map((f) => this.graph.nodes[f]);
    i.length === 0 && (i = this._outputs);
    const c = this.getCompilationKey(a, i);
    let l = this.compiledMap.get(c);
    l == null && (l = this.compile(e, i), this.compiledMap.set(c, l));
    try {
      this.keepIntermediateTensors = Xe().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (f) {
      this.keepIntermediateTensors = !1, console.warn(f.message);
    }
    const u = {}, d = {};
    return Je(() => {
      const f = new yv(this.weightMap, u, d, this.functionExecutorMap, this.parseNodeNameCache), p = Object.assign({}, this.weightMap);
      this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), Object.keys(e).forEach((v) => {
        const [b, w] = tr(v, f), S = [];
        S[w] = e[v], p[b] = S, this.keepIntermediateTensors && (this.clonedTensorsMap[b] = this.cloneTensorList(S));
      });
      const h = this.getFrozenTensorIds(p), { orderedNodes: m, nodeLiveUntilMap: g } = l;
      for (const v of m) {
        if (p[v.name])
          continue;
        const b = gv(v, p, f, this._resourceManager);
        if (Ds(b))
          throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);
        p[v.name] = b, this.keepIntermediateTensors && (this.clonedTensorsMap[v.name] = this.cloneTensorList(b)), this.checkTensorForDisposalWithNodeLiveUntilInfo(v, p, f, h, o, g.get(v.name));
      }
      return this.parent == null && f.dispose(h), n.map((v) => gn(v, p, f));
    });
  }
  getFrozenTensorIds(e) {
    const n = [].concat.apply([], Object.keys(e).map((r) => e[r]).map((r) => r.map((a) => a.id)));
    return new Set(n);
  }
  checkTensorForDisposal(e, n, r, a, s, o, i) {
    if (!(_s(n) || o.has(e))) {
      for (const c of r[e])
        c != null && (i[c.id] = (i[c.id] || 0) + n.children.length);
      for (const c of n.inputs) {
        if (_s(c))
          continue;
        const l = dv(c.name, r, a);
        if (l != null)
          for (const u of l) {
            if (!u || u.kept || s.has(u.id))
              continue;
            const d = i[u.id];
            d === 1 ? (u.dispose(), delete i[u.id]) : d != null && i[u.id]--;
          }
      }
    }
  }
  checkTensorForDisposalWithNodeLiveUntilInfo(e, n, r, a, s, o) {
    function i(c) {
      return _s(c) || s.has(c.name);
    }
    if (!(_s(e) || o == null))
      for (const c of o) {
        if (i(c))
          continue;
        const l = dv(c.name, n, r);
        for (const u of l)
          !u || u.kept || a.has(u.id) || u.dispose();
      }
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs output node name from the Tensorflow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   */
  async executeAsync(e, n) {
    return this._executeAsync(e, n);
  }
  disposeIntermediateTensors() {
    this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach((e) => {
      for (const n of e)
        n && !n.isDisposed && n.dispose();
    }), this.clonedTensorsMap = null);
  }
  getIntermediateTensors() {
    return this.clonedTensorsMap;
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Optional. Flag for executing a function.
   * @param tensorArrayMap Optional, global TensorArray map by id. Used for
   * function execution.
   * @param tensorArrayMap Optinal global TensorList map by id. Used for
   * function execution.
   */
  async _executeAsync(e, n, r = !1, a = {}, s = {}) {
    this.disposeIntermediateTensors(), r || (e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), n = this.mapOutputs(n), this.checkOutputs(n));
    try {
      this.keepIntermediateTensors = Xe().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (f) {
      this.keepIntermediateTensors = !1, console.warn(f.message);
    }
    const o = new yv(this.weightMap, a, s, this.functionExecutorMap, this.parseNodeNameCache);
    this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap));
    const i = await this.executeWithControlFlow(e, o, n, r), c = n.map((f) => gn(f, i, o)), l = c.map((f) => f.id), u = Object.keys(e).map((f) => e[f].id), d = /* @__PURE__ */ new Set([...l, ...u, ...this.weightIds]);
    return Object.values(i).forEach((f) => {
      f.forEach((p) => {
        p && !p.isDisposed && !d.has(p.id) && p.dispose();
      });
    }), this.parent == null && o.dispose(d), c;
  }
  async executeFunctionAsync(e, n, r) {
    const a = e.reduce((s, o, i) => (s[this.inputs[i].name] = o, s), {});
    return this._executeAsync(a, this.outputNodes, !0, n, r);
  }
  /**
   * When there are control flow nodes in the graph, the graph execution use
   * ExecutionContext to keep track of the frames and loop iterators.
   * @param inputs placeholder tensors for the graph.
   * @param context the execution context object for current execution.
   * @param outputNames Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Flag for executing a function.
   */
  async executeWithControlFlow(e, n, r, a) {
    const s = Object.keys(e), o = s.map((S) => this.graph.nodes[tr(S)[0]]), i = r.map((S) => tr(S)[0]), c = new Set(i);
    let l = i.map((S) => this.graph.nodes[S]);
    l.length === 0 && (l = this._outputs);
    const { usedNodes: u, missingInputs: d, dynamicNode: f, syncInputs: p } = vv(e, l, this.weightMap, this._initNodes), h = [
      ...o,
      ...this.graph.weights,
      ...this._initNodes || []
    ].map((S) => ({ node: S, contexts: n.currentContext })), m = Object.assign({}, this.weightMap);
    Object.keys(e).forEach((S) => {
      const [I, E] = tr(S), T = [];
      T[E] = e[S], m[I] = T;
    });
    const g = {}, v = this.getFrozenTensorIds(m), b = {};
    for (; h.length > 0; ) {
      const S = this.processStack(o, h, n, m, b, v, c, g, u);
      await Promise.all(S);
    }
    f == null && !a && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
    const w = l.filter((S) => !_s(S) && !gn(S.name, m, n)).map((S) => S.name);
    if (w.length > 0) {
      let S = "";
      throw f != null && (S = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`), new Error(`Cannot compute the outputs [${w}] from the provided inputs [${s}]. Consider providing the following inputs: [${d}]. ${S}`);
    }
    return m;
  }
  processStack(e, n, r, a, s, o, i, c, l) {
    const u = [];
    for (; n.length > 0; ) {
      const d = n.pop();
      r.currentContext = d.contexts;
      let f = "";
      if (d.node.op === "Enter" && _("isConstant", d.node, a, r) && ([f] = ca(d.node.name, r)), a[d.node.name] == null) {
        const p = gv(d.node, a, r, this._resourceManager);
        f || ([f] = ca(d.node.name, r));
        const h = r.currentContext;
        Ds(p) ? u.push(p.then((m) => (a[f] = m, this.keepIntermediateTensors && (this.clonedTensorsMap[f] = this.cloneTensorList(m)), r.currentContext = h, this.checkTensorForDisposal(f, d.node, a, r, o, i, c), this.processChildNodes(d.node, n, r, a, s, l), m))) : (a[f] = p, this.keepIntermediateTensors && (this.clonedTensorsMap[f] = this.cloneTensorList(p)), this.checkTensorForDisposal(f, d.node, a, r, o, i, c), this.processChildNodes(d.node, n, r, a, s, l));
      } else
        this.processChildNodes(d.node, n, r, a, s, l);
    }
    return u;
  }
  processChildNodes(e, n, r, a, s, o) {
    e.children.forEach((i) => {
      const [c] = ca(i.name, r);
      s[c] || !o.has(i.name) || (i.op === "Merge" ? i.inputNames.some((l) => !!gn(l, a, r)) && (s[c] = !0, n.push({ contexts: r.currentContext, node: i })) : i.inputNames.every((l) => !!gn(l, a, r)) && (s[c] = !0, n.push({ contexts: r.currentContext, node: i })));
    });
  }
  /**
   * Releases the memory used by the weight tensors.
   */
  dispose() {
    Object.keys(this.weightMap).forEach((e) => this.weightMap[e].forEach((n) => n.dispose()));
  }
  checkInputShapeAndType(e) {
    Object.keys(e).forEach((n) => {
      const r = e[n], [a] = tr(n), s = this.graph.nodes[a];
      if (s.attrParams.shape && s.attrParams.shape.value) {
        const o = s.attrParams.shape.value, i = o.length === r.shape.length && r.shape.every((c, l) => o[l] === -1 || o[l] === c);
        A(i, () => `The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`);
      }
      s.attrParams.dtype && s.attrParams.dtype.value && A(r.dtype === s.attrParams.dtype.value, () => `The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`);
    });
  }
  mapInputs(e) {
    var n, r;
    const a = {};
    for (const s in e) {
      const o = (r = (n = this._signature) === null || n === void 0 ? void 0 : n.inputs) === null || r === void 0 ? void 0 : r[s];
      o != null ? a[o.name] = e[s] : a[s] = e[s];
    }
    return a;
  }
  checkInputs(e) {
    const n = Object.keys(e).filter((r) => {
      const [a] = tr(r);
      return this.graph.nodes[a] == null;
    });
    if (n.length > 0)
      throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`);
  }
  mapOutputs(e) {
    return e.map((n) => {
      var r, a;
      const s = (a = (r = this._signature) === null || r === void 0 ? void 0 : r.outputs) === null || a === void 0 ? void 0 : a[n];
      return s != null ? s.name : n;
    }, {});
  }
  checkOutputs(e) {
    e.forEach((n) => {
      const [r] = tr(n);
      if (!this.graph.nodes[r])
        throw new Error(`The output '${n}' is not found in the graph`);
    });
  }
}
class a5 {
  constructor(e = {}, n = {}) {
    this.hashTableNameToHandle = e, this.hashTableMap = n;
  }
  /**
   * Register a `HashTable` in the resource manager.
   *
   * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,
   * where id is the table handle tensor's id.
   *
   * @param name Op node name that creates the `HashTable`.
   * @param hashTable The `HashTable` to be added to resource manager.
   */
  addHashTable(e, n) {
    this.hashTableNameToHandle[e] = n.handle, this.hashTableMap[n.id] = n;
  }
  /**
   * Get the table handle by node name.
   * @param name Op node name that creates the `HashTable`. This name is also
   *     used in the inputs list of lookup and import `HashTable` ops.
   */
  getHashTableHandleByName(e) {
    return this.hashTableNameToHandle[e];
  }
  /**
   * Get the actual `HashTable` by its handle tensor's id.
   * @param id The id of the handle tensor.
   */
  getHashTableById(e) {
    return this.hashTableMap[e];
  }
  /**
   * Dispose `ResourceManager`, including its hashTables and tensors in them.
   */
  dispose() {
    for (const e in this.hashTableMap)
      this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
    for (const e in this.hashTableNameToHandle)
      this.hashTableNameToHandle[e].dispose(), delete this.hashTableNameToHandle[e];
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s5 = "?tfjs-format=file", o5 = "model.json";
class i5 {
  // Returns the version information for the tensorflow model GraphDef.
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  get modelStructuredOutputKeys() {
    return this.structuredOutputKeys;
  }
  /**
   * @param modelUrl url for the model, or an `io.IOHandler`.
   * @param weightManifestUrl url for the weight file generated by
   * scripts/convert.py script.
   * @param requestOption options for Request, which allows to send credentials
   * and custom headers.
   * @param onProgress Optional, progress callback function, fired periodically
   * before the load is completed.
   */
  constructor(e, n = {}, r = zw) {
    this.modelUrl = e, this.loadOptions = n, this.version = "n/a", this.io = r, n == null && (this.loadOptions = {}), this.resourceManager = new a5();
  }
  findIOHandler() {
    const e = this.modelUrl;
    if (e.load != null)
      this.handler = e;
    else if (this.loadOptions.requestInit != null)
      this.handler = this.io.browserHTTPRequest(e, this.loadOptions);
    else {
      const n = this.io.getLoadHandlers(e, this.loadOptions);
      if (n.length === 0)
        n.push(this.io.browserHTTPRequest(e, this.loadOptions));
      else if (n.length > 1)
        throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);
      this.handler = n[0];
    }
  }
  /**
   * Loads the model and weight files, construct the in memory weight map and
   * compile the inference graph.
   */
  load() {
    if (this.findIOHandler(), this.handler.load == null)
      throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    const e = this.handler.load();
    return Ds(e) ? e.then((n) => this.loadSync(n)) : this.loadSync(e);
  }
  /**
   * Synchronously construct the in memory weight map and
   * compile the inference graph.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  loadSync(e) {
    this.artifacts = e;
    const n = this.artifacts.modelTopology;
    let r = this.artifacts.signature;
    if (this.artifacts.userDefinedMetadata != null) {
      const s = this.artifacts.userDefinedMetadata;
      s.signature != null && (r = s.signature), s.structuredOutputKeys != null && (this.structuredOutputKeys = s.structuredOutputKeys);
    }
    this.signature = r, this.version = `${n.versions.producer}.${n.versions.minConsumer}`;
    const a = this.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
    if (this.executor = new Kc(fv.Instance.transformGraph(n, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(a), this.executor.resourceManager = this.resourceManager, e.modelInitializer != null && e.modelInitializer.node != null) {
      const s = fv.Instance.transformGraph(e.modelInitializer);
      this.initializer = new Kc(s), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e.initializerSignature;
    }
    return !0;
  }
  /**
   * Save the configuration and/or weights of the GraphModel.
   *
   * An `IOHandler` is an object that has a `save` method of the proper
   * signature defined. The `save` method manages the storing or
   * transmission of serialized data ("artifacts") that represent the
   * model's topology and weights onto or via a specific medium, such as
   * file downloads, local storage, IndexedDB in the web browser and HTTP
   * requests to a server. TensorFlow.js provides `IOHandler`
   * implementations for a number of frequently used saving mediums, such as
   * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
   * for more details.
   *
   * This method also allows you to refer to certain types of `IOHandler`s
   * as URL-like string shortcuts, such as 'localstorage://' and
   * 'indexeddb://'.
   *
   * Example 1: Save `model`'s topology and weights to browser [local
   * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
   * then load it back.
   *
   * ```js
   * const modelUrl =
   *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
   * const model = await tf.loadGraphModel(modelUrl);
   * const zeros = tf.zeros([1, 224, 224, 3]);
   * model.predict(zeros).print();
   *
   * const saveResults = await model.save('localstorage://my-model-1');
   *
   * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
   * console.log('Prediction from loaded model:');
   * model.predict(zeros).print();
   * ```
   *
   * @param handlerOrURL An instance of `IOHandler` or a URL-like,
   * scheme-based string shortcut for `IOHandler`.
   * @param config Options for saving the model.
   * @returns A `Promise` of `SaveResult`, which summarizes the result of
   * the saving, such as byte sizes of the saved artifacts for the model's
   *   topology and weight values.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async save(e, n) {
    if (typeof e == "string") {
      const r = this.io.getSaveHandlers(e);
      if (r.length === 0)
        throw new Error(`Cannot find any save handlers for URL '${e}'`);
      if (r.length > 1)
        throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);
      e = r[0];
    }
    if (e.save == null)
      throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    return e.save(this.artifacts);
  }
  addStructuredOutputNames(e) {
    if (this.structuredOutputKeys) {
      const n = e instanceof en ? [e] : e, r = {};
      return n.forEach((a, s) => r[this.structuredOutputKeys[s]] = a), r;
    }
    return e;
  }
  /**
   * Execute the inference for the input tensors.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns Inference result tensors. If the model is converted and it
   * originally had structured_outputs in tensorflow, then a NamedTensorMap
   * will be returned matching the structured_outputs. If no structured_outputs
   * are present, the output will be single `tf.Tensor` if the model has single
   * output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(e, n) {
    const r = this.execute(e, this.outputNodes);
    return this.addStructuredOutputNames(r);
  }
  /**
   * Execute the inference for the input tensors in async fashion, use this
   * method when your model contains control flow ops.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns A Promise of inference result tensors. If the model is converted
   * and it originally had structured_outputs in tensorflow, then a
   * NamedTensorMap will be returned matching the structured_outputs. If no
   * structured_outputs are present, the output will be single `tf.Tensor` if
   * the model has single output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async predictAsync(e, n) {
    const r = await this.executeAsync(e, this.outputNodes);
    return this.addStructuredOutputNames(r);
  }
  normalizeInputs(e) {
    var n;
    if (!(e instanceof en) && !Array.isArray(e)) {
      const s = (n = this.signature) === null || n === void 0 ? void 0 : n.inputs;
      if (s != null)
        for (const o in s) {
          const i = s[o];
          i.resourceId != null && (e[o] = this.resourceIdToCapturedInput[i.resourceId]);
        }
      return e;
    }
    e = Array.isArray(e) ? e : [e];
    const r = Object.keys(this.resourceIdToCapturedInput).length;
    if (e.length + r !== this.inputNodes.length)
      throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - r} non-resource placeholders, while there are ${e.length} input tensors provided.`);
    let a = 0;
    return this.inputNodes.reduce((s, o) => {
      var i, c, l;
      const u = (l = (c = (i = this.signature) === null || i === void 0 ? void 0 : i.inputs) === null || c === void 0 ? void 0 : c[o]) === null || l === void 0 ? void 0 : l.resourceId;
      return u != null ? s[o] = this.resourceIdToCapturedInput[u] : s[o] = e[a++], s;
    }, {});
  }
  normalizeOutputs(e) {
    return e = e || this.outputNodes, Array.isArray(e) ? e : [e];
  }
  executeInitializerGraph() {
    return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.execute({}, []) : this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
  }
  async executeInitializerGraphAsync() {
    return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.executeAsync({}, []) : this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
  }
  setResourceIdToCapturedInput(e) {
    if (this.resourceIdToCapturedInput = {}, this.initializerSignature) {
      const n = this.initializerSignature.outputs, r = Object.keys(n);
      for (let a = 0; a < r.length; a++) {
        const s = r[a], o = n[s];
        this.resourceIdToCapturedInput[o.resourceId] = e[a];
      }
    }
  }
  /**
   * Executes inference for the model for given input tensors.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no
   * outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   *
   * @returns A single tensor if provided with a single output or no outputs
   * are provided and there is only one default output, otherwise return a
   * tensor array. The order of the tensor array is the same as the outputs
   * if provided, otherwise the order of outputNodes attribute of the model.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  execute(e, n) {
    this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), e = this.normalizeInputs(e), n = this.normalizeOutputs(n);
    const r = this.executor.execute(e, n);
    return r.length > 1 ? r : r[0];
  }
  /**
   * Executes inference for the model for given input tensors in async
   * fashion, use this method when your model contains control flow ops.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   *
   * @returns A Promise of single tensor if provided with a single output or
   * no outputs are provided and there is only one default output, otherwise
   * return a tensor map.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async executeAsync(e, n) {
    this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()), e = this.normalizeInputs(e), n = this.normalizeOutputs(n);
    const r = await this.executor.executeAsync(e, n);
    return r.length > 1 ? r : r[0];
  }
  /**
   * Get intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  getIntermediateTensors() {
    return this.executor.getIntermediateTensors();
  }
  /**
   * Dispose intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  disposeIntermediateTensors() {
    this.executor.disposeIntermediateTensors();
  }
  convertTensorMapToTensorsMap(e) {
    return Object.keys(e).reduce((n, r) => (n[r] = [e[r]], n), {});
  }
  /**
   * Releases the memory used by the weight tensors and resourceManager.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  dispose() {
    this.executor.dispose(), this.initializer && (this.initializer.dispose(), this.resourceIdToCapturedInput && un(this.resourceIdToCapturedInput)), this.resourceManager.dispose();
  }
}
async function u5(t, e = {}, n = zw) {
  if (t == null)
    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
  e == null && (e = {}), e.fromTFHub && typeof t == "string" && (t = c5(t));
  const r = new i5(t, e, n);
  return await r.load(), r;
}
function c5(t) {
  return t.endsWith("/") || (t = t + "/"), `${t}${o5}${s5}`;
}
/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
var Ua = function() {
  return Ua = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++)
      for (var a in e = arguments[n])
        Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
    return t;
  }, Ua.apply(this, arguments);
};
function wa(t, e, n, r) {
  return new (n || (n = Promise))(function(a, s) {
    function o(l) {
      try {
        c(r.next(l));
      } catch (u) {
        s(u);
      }
    }
    function i(l) {
      try {
        c(r.throw(l));
      } catch (u) {
        s(u);
      }
    }
    function c(l) {
      var u;
      l.done ? a(l.value) : (u = l.value, u instanceof n ? u : new n(function(d) {
        d(u);
      })).then(o, i);
    }
    c((r = r.apply(t, e || [])).next());
  });
}
function Sa(t, e) {
  var n, r, a, s, o = { label: 0, sent: function() {
    if (1 & a[0])
      throw a[1];
    return a[1];
  }, trys: [], ops: [] };
  return s = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function i(c) {
    return function(l) {
      return function(u) {
        if (n)
          throw new TypeError("Generator is already executing.");
        for (; o; )
          try {
            if (n = 1, r && (a = 2 & u[0] ? r.return : u[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, u[1])).done)
              return a;
            switch (r = 0, a && (u = [2 & u[0], a.value]), u[0]) {
              case 0:
              case 1:
                a = u;
                break;
              case 4:
                return o.label++, { value: u[1], done: !1 };
              case 5:
                o.label++, r = u[1], u = [0];
                continue;
              case 7:
                u = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (a = o.trys, !((a = a.length > 0 && a[a.length - 1]) || u[0] !== 6 && u[0] !== 2)) {
                  o = 0;
                  continue;
                }
                if (u[0] === 3 && (!a || u[1] > a[0] && u[1] < a[3])) {
                  o.label = u[1];
                  break;
                }
                if (u[0] === 6 && o.label < a[1]) {
                  o.label = a[1], a = u;
                  break;
                }
                if (a && o.label < a[2]) {
                  o.label = a[2], o.ops.push(u);
                  break;
                }
                a[2] && o.ops.pop(), o.trys.pop();
                continue;
            }
            u = e.call(t, o);
          } catch (d) {
            u = [6, d], r = 0;
          } finally {
            n = a = 0;
          }
        if (5 & u[0])
          throw u[1];
        return { value: u[0] ? u[1] : void 0, done: !0 };
      }([c, l]);
    };
  }
}
var g2 = ["rightEye", "leftEye", "noseTip", "mouthCenter", "rightEarTragion", "leftEarTragion"], ep = { modelType: "short", runtime: "mediapipe", maxFaces: 1 }, l5 = function() {
  function t(e) {
    var n = this;
    this.width = 0, this.height = 0, this.selfieMode = !1, this.faceDetectorSolution = new OM.FaceDetection({ locateFile: function(r, a) {
      if (e.solutionPath) {
        var s = e.solutionPath.replace(/\/+$/, "");
        return "".concat(s, "/").concat(r);
      }
      return "".concat(a, "/").concat(r);
    } }), this.faceDetectorSolution.setOptions({ selfieMode: this.selfieMode, model: e.modelType }), this.faceDetectorSolution.onResults(function(r) {
      if (n.height = r.image.height, n.width = r.image.width, n.faces = [], r.detections !== null)
        for (var a = 0, s = r.detections; a < s.length; a++) {
          var o = s[a];
          n.faces.push(n.normalizedToAbsolute(o.landmarks, (i = o.boundingBox, c = void 0, l = void 0, u = void 0, c = i.xCenter - i.width / 2, l = c + i.width, u = i.yCenter - i.height / 2, { xMin: c, xMax: l, yMin: u, yMax: u + i.height, width: i.width, height: i.height })));
        }
      var i, c, l, u;
    });
  }
  return t.prototype.normalizedToAbsolute = function(e, n) {
    var r = this;
    return { keypoints: e.map(function(a, s) {
      return { x: a.x * r.width, y: a.y * r.height, name: g2[s] };
    }), box: { xMin: n.xMin * this.width, yMin: n.yMin * this.height, xMax: n.xMax * this.width, yMax: n.yMax * this.height, width: n.width * this.width, height: n.height * this.height } };
  }, t.prototype.estimateFaces = function(e, n) {
    return wa(this, void 0, void 0, function() {
      var r, a;
      return Sa(this, function(s) {
        switch (s.label) {
          case 0:
            return n && n.flipHorizontal && n.flipHorizontal !== this.selfieMode && (this.selfieMode = n.flipHorizontal, this.faceDetectorSolution.setOptions({ selfieMode: this.selfieMode })), e instanceof en ? (a = ImageData.bind, [4, aM(e)]) : [3, 2];
          case 1:
            return r = new (a.apply(ImageData, [void 0, s.sent(), e.shape[1], e.shape[0]]))(), [3, 3];
          case 2:
            r = e, s.label = 3;
          case 3:
            return e = r, [4, this.faceDetectorSolution.send({ image: e })];
          case 4:
            return s.sent(), [2, this.faces];
        }
      });
    });
  }, t.prototype.dispose = function() {
    this.faceDetectorSolution.close();
  }, t.prototype.reset = function() {
    this.faceDetectorSolution.reset(), this.width = 0, this.height = 0, this.faces = null, this.selfieMode = !1;
  }, t.prototype.initialize = function() {
    return this.faceDetectorSolution.initialize();
  }, t;
}();
function d5(t) {
  return wa(this, void 0, void 0, function() {
    var e, n;
    return Sa(this, function(r) {
      switch (r.label) {
        case 0:
          return e = function(a) {
            if (a == null)
              return Ua({}, ep);
            var s = Ua({}, a);
            return s.runtime = "mediapipe", s.modelType == null && (s.modelType = ep.modelType), s.maxFaces == null && (s.maxFaces = ep.maxFaces), s;
          }(t), [4, (n = new l5(e)).initialize()];
        case 1:
          return r.sent(), [2, n];
      }
    });
  });
}
function f5(t, e, n, r) {
  var a = t.width, s = t.height, o = r ? -1 : 1, i = Math.cos(t.rotation), c = Math.sin(t.rotation), l = t.xCenter, u = t.yCenter, d = 1 / e, f = 1 / n, p = new Array(16);
  return p[0] = a * i * o * d, p[1] = -s * c * d, p[2] = 0, p[3] = (-0.5 * a * i * o + 0.5 * s * c + l) * d, p[4] = a * c * o * f, p[5] = s * i * f, p[6] = 0, p[7] = (-0.5 * s * i - 0.5 * a * c * o + u) * f, p[8] = 0, p[9] = 0, p[10] = a * d, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, function(h) {
    if (h.length !== 16)
      throw new Error("Array length must be 16 but got ".concat(h.length));
    return [[h[0], h[1], h[2], h[3]], [h[4], h[5], h[6], h[7]], [h[8], h[9], h[10], h[11]], [h[12], h[13], h[14], h[15]]];
  }(p);
}
function y2(t) {
  return t instanceof en ? { height: t.shape[0], width: t.shape[1] } : { height: t.height, width: t.width };
}
function v2(t) {
  return t instanceof en ? t : sM(t);
}
function tp(t, e) {
  A(t.width !== 0, function() {
    return "".concat(e, " width cannot be 0.");
  }), A(t.height !== 0, function() {
    return "".concat(e, " height cannot be 0.");
  });
}
function p5(t, e) {
  var n = function(r, a, s, o) {
    var i = a - r, c = o - s;
    if (i === 0)
      throw new Error("Original min and max are both ".concat(r, ", range cannot be 0."));
    var l = c / i;
    return { scale: l, offset: s - r * l };
  }(0, 255, e[0], e[1]);
  return Je(function() {
    return Ae(he(t, n.scale), n.offset);
  });
}
function h5(t, e, n) {
  var r = e.outputTensorSize, a = e.keepAspectRatio, s = e.borderMode, o = e.outputTensorFloatRange, i = y2(t), c = function(f, p) {
    return p ? { xCenter: p.xCenter * f.width, yCenter: p.yCenter * f.height, width: p.width * f.width, height: p.height * f.height, rotation: p.rotation } : { xCenter: 0.5 * f.width, yCenter: 0.5 * f.height, width: f.width, height: f.height, rotation: 0 };
  }(i, n), l = function(f, p, h) {
    if (h === void 0 && (h = !1), !h)
      return { top: 0, left: 0, right: 0, bottom: 0 };
    var m = p.height, g = p.width;
    tp(p, "targetSize"), tp(f, "roi");
    var v, b, w = m / g, S = f.height / f.width, I = 0, E = 0;
    return w > S ? (v = f.width, b = f.width * w, E = (1 - S / w) / 2) : (v = f.height / w, b = f.height, I = (1 - w / S) / 2), f.width = v, f.height = b, { top: E, left: I, right: I, bottom: E };
  }(c, r, a), u = f5(c, i.width, i.height, !1), d = Je(function() {
    var f = v2(t), p = Ns(function(g, v, b) {
      return tp(b, "inputResolution"), [1 / b.width * g[0][0] * v.width, 1 / b.height * g[0][1] * v.width, g[0][3] * v.width, 1 / b.width * g[1][0] * v.height, 1 / b.height * g[1][1] * v.height, g[1][3] * v.height, 0, 0];
    }(u, i, r), [1, 8]), h = s === "zero" ? "constant" : "nearest", m = bf.transform(Kr(zt(f, "float32")), p, "bilinear", h, 0, [r.height, r.width]);
    return o != null ? p5(m, o) : m;
  });
  return { imageTensor: d, padding: l, transformationMatrix: u };
}
function bv(t) {
  t.reduceBoxesInLowestLayer == null && (t.reduceBoxesInLowestLayer = !1), t.interpolatedScaleAspectRatio == null && (t.interpolatedScaleAspectRatio = 1), t.fixedAnchorSize == null && (t.fixedAnchorSize = !1);
  for (var e = [], n = 0; n < t.numLayers; ) {
    for (var r = [], a = [], s = [], o = [], i = n; i < t.strides.length && t.strides[i] === t.strides[n]; ) {
      var c = wv(t.minScale, t.maxScale, i, t.strides.length);
      if (i === 0 && t.reduceBoxesInLowestLayer)
        s.push(1), s.push(2), s.push(0.5), o.push(0.1), o.push(c), o.push(c);
      else {
        for (var l = 0; l < t.aspectRatios.length; ++l)
          s.push(t.aspectRatios[l]), o.push(c);
        if (t.interpolatedScaleAspectRatio > 0) {
          var u = i === t.strides.length - 1 ? 1 : wv(t.minScale, t.maxScale, i + 1, t.strides.length);
          o.push(Math.sqrt(c * u)), s.push(t.interpolatedScaleAspectRatio);
        }
      }
      i++;
    }
    for (var d = 0; d < s.length; ++d) {
      var f = Math.sqrt(s[d]);
      r.push(o[d] / f), a.push(o[d] * f);
    }
    var p = 0, h = 0;
    if (t.featureMapHeight.length > 0)
      p = t.featureMapHeight[n], h = t.featureMapWidth[n];
    else {
      var m = t.strides[n];
      p = Math.ceil(t.inputSizeHeight / m), h = Math.ceil(t.inputSizeWidth / m);
    }
    for (var g = 0; g < p; ++g)
      for (var v = 0; v < h; ++v)
        for (var b = 0; b < r.length; ++b) {
          var w = { xCenter: (v + t.anchorOffsetX) / h, yCenter: (g + t.anchorOffsetY) / p, width: 0, height: 0 };
          t.fixedAnchorSize ? (w.width = 1, w.height = 1) : (w.width = a[b], w.height = r[b]), e.push(w);
        }
    n = i;
  }
  return e;
}
function wv(t, e, n, r) {
  return r === 1 ? 0.5 * (t + e) : t + (e - t) * n / (r - 1);
}
function Sv(t, e) {
  var n = e[0], r = e[1];
  return [n * t[0] + r * t[1] + t[3], n * t[4] + r * t[5] + t[7]];
}
function m5(t) {
  return Je(function() {
    var e = function(a) {
      return Je(function() {
        return [qe(a, [0, 0, 0], [1, -1, 1]), qe(a, [0, 0, 1], [1, -1, -1])];
      });
    }(t), n = e[0], r = e[1];
    return { boxes: hn(r), logits: hn(n) };
  });
}
function g5(t, e, n, r) {
  return wa(this, void 0, void 0, function() {
    var a, s, o, i, c;
    return Sa(this, function(l) {
      switch (l.label) {
        case 0:
          return t.sort(function(u, d) {
            return Math.max.apply(Math, d.score) - Math.max.apply(Math, u.score);
          }), a = Ns(t.map(function(u) {
            return [u.locationData.relativeBoundingBox.yMin, u.locationData.relativeBoundingBox.xMin, u.locationData.relativeBoundingBox.yMax, u.locationData.relativeBoundingBox.xMax];
          })), s = xn(t.map(function(u) {
            return u.score[0];
          })), [4, bf.nonMaxSuppressionAsync(a, s, e, n)];
        case 1:
          return [4, (o = l.sent()).array()];
        case 2:
          return i = l.sent(), c = t.filter(function(u, d) {
            return i.indexOf(d) > -1;
          }), un([a, s, o]), [2, c];
      }
    });
  });
}
function y5(t, e, n) {
  return wa(this, void 0, void 0, function() {
    var r, a, s, o, i;
    return Sa(this, function(c) {
      switch (c.label) {
        case 0:
          return r = t[0], a = t[1], s = function(l, u, d) {
            return Je(function() {
              var f, p, h, m;
              d.reverseOutputOrder ? (p = hn(qe(l, [0, d.boxCoordOffset + 0], [-1, 1])), f = hn(qe(l, [0, d.boxCoordOffset + 1], [-1, 1])), m = hn(qe(l, [0, d.boxCoordOffset + 2], [-1, 1])), h = hn(qe(l, [0, d.boxCoordOffset + 3], [-1, 1]))) : (f = hn(qe(l, [0, d.boxCoordOffset + 0], [-1, 1])), p = hn(qe(l, [0, d.boxCoordOffset + 1], [-1, 1])), h = hn(qe(l, [0, d.boxCoordOffset + 2], [-1, 1])), m = hn(qe(l, [0, d.boxCoordOffset + 3], [-1, 1]))), p = Ae(he(Ze(p, d.xScale), u.w), u.x), f = Ae(he(Ze(f, d.yScale), u.h), u.y), d.applyExponentialOnBoxSize ? (h = he(ya(Ze(h, d.hScale)), u.h), m = he(ya(Ze(m, d.wScale)), u.w)) : (h = he(Ze(h, d.hScale), u.h), m = he(Ze(m, d.wScale), u.h));
              var g = Ke(f, Ze(h, 2)), v = Ke(p, Ze(m, 2)), b = Ae(f, Ze(h, 2)), w = Ae(p, Ze(m, 2)), S = yn([ae(g, [d.numBoxes, 1]), ae(v, [d.numBoxes, 1]), ae(b, [d.numBoxes, 1]), ae(w, [d.numBoxes, 1])], 1);
              if (d.numKeypoints)
                for (var I = 0; I < d.numKeypoints; ++I) {
                  var E = d.keypointCoordOffset + I * d.numValuesPerKeypoint, T = void 0, R = void 0;
                  d.reverseOutputOrder ? (T = hn(qe(l, [0, E], [-1, 1])), R = hn(qe(l, [0, E + 1], [-1, 1]))) : (R = hn(qe(l, [0, E], [-1, 1])), T = hn(qe(l, [0, E + 1], [-1, 1])));
                  var $ = Ae(he(Ze(T, d.xScale), u.w), u.x), D = Ae(he(Ze(R, d.yScale), u.h), u.y);
                  S = yn([S, ae($, [d.numBoxes, 1]), ae(D, [d.numBoxes, 1])], 1);
                }
              return S;
            });
          }(a, e, n), o = Je(function() {
            var l = r;
            return n.sigmoidScore ? (n.scoreClippingThresh != null && (l = Z1(r, -n.scoreClippingThresh, n.scoreClippingThresh)), l = Cs(l)) : l;
          }), [4, v5(s, o, n)];
        case 1:
          return i = c.sent(), un([s, o]), [2, i];
      }
    });
  });
}
function v5(t, e, n) {
  return wa(this, void 0, void 0, function() {
    var r, a, s, o, i, c, l, u, d, f, p, h;
    return Sa(this, function(m) {
      switch (m.label) {
        case 0:
          return r = [], [4, t.data()];
        case 1:
          return a = m.sent(), [4, e.data()];
        case 2:
          for (s = m.sent(), o = 0; o < n.numBoxes; ++o)
            if (!(n.minScoreThresh != null && s[o] < n.minScoreThresh || (i = o * n.numCoords, c = b5(a[i + 0], a[i + 1], a[i + 2], a[i + 3], s[o], n.flipVertically, o), (l = c.locationData.relativeBoundingBox).width < 0 || l.height < 0))) {
              if (n.numKeypoints > 0)
                for ((u = c.locationData).relativeKeypoints = [], d = n.numKeypoints * n.numValuesPerKeypoint, f = 0; f < d; f += n.numValuesPerKeypoint)
                  p = i + n.keypointCoordOffset + f, h = { x: a[p + 0], y: n.flipVertically ? 1 - a[p + 1] : a[p + 1] }, u.relativeKeypoints.push(h);
              r.push(c);
            }
          return [2, r];
      }
    });
  });
}
function b5(t, e, n, r, a, s, o) {
  return { score: [a], ind: o, locationData: { relativeBoundingBox: { xMin: e, yMin: s ? 1 - n : t, xMax: r, yMax: s ? 1 - t : n, width: r - e, height: n - t } } };
}
var w5 = { reduceBoxesInLowestLayer: !1, interpolatedScaleAspectRatio: 1, featureMapHeight: [], featureMapWidth: [], numLayers: 4, minScale: 0.1484375, maxScale: 0.75, inputSizeHeight: 128, inputSizeWidth: 128, anchorOffsetX: 0.5, anchorOffsetY: 0.5, strides: [8, 16, 16, 16], aspectRatios: [1], fixedAnchorSize: !0 }, S5 = { reduceBoxesInLowestLayer: !1, interpolatedScaleAspectRatio: 0, featureMapHeight: [], featureMapWidth: [], numLayers: 1, minScale: 0.1484375, maxScale: 0.75, inputSizeHeight: 192, inputSizeWidth: 192, anchorOffsetX: 0.5, anchorOffsetY: 0.5, strides: [4], aspectRatios: [1], fixedAnchorSize: !0 }, np = { runtime: "tfjs", modelType: "short", maxFaces: 1, detectorModelUrl: "https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1" }, _5 = { applyExponentialOnBoxSize: !1, flipVertically: !1, ignoreClasses: [], numClasses: 1, numBoxes: 896, numCoords: 16, boxCoordOffset: 0, keypointCoordOffset: 4, numKeypoints: 6, numValuesPerKeypoint: 2, sigmoidScore: !0, scoreClippingThresh: 100, reverseOutputOrder: !0, xScale: 128, yScale: 128, hScale: 128, wScale: 128, minScoreThresh: 0.5 }, x5 = { applyExponentialOnBoxSize: !1, flipVertically: !1, ignoreClasses: [], numClasses: 1, numBoxes: 2304, numCoords: 16, boxCoordOffset: 0, keypointCoordOffset: 4, numKeypoints: 6, numValuesPerKeypoint: 2, sigmoidScore: !0, scoreClippingThresh: 100, reverseOutputOrder: !0, xScale: 192, yScale: 192, hScale: 192, wScale: 192, minScoreThresh: 0.6 }, I5 = 0.3, k5 = { outputTensorSize: { width: 128, height: 128 }, keepAspectRatio: !0, outputTensorFloatRange: [-1, 1], borderMode: "zero" }, E5 = { outputTensorSize: { width: 192, height: 192 }, keepAspectRatio: !0, outputTensorFloatRange: [-1, 1], borderMode: "zero" }, Xc, T5 = function() {
  function t(e, n, r) {
    this.detectorModel = n, this.maxFaces = r, e === "full" ? (this.imageToTensorConfig = E5, this.tensorsToDetectionConfig = x5, this.anchors = bv(S5)) : (this.imageToTensorConfig = k5, this.tensorsToDetectionConfig = _5, this.anchors = bv(w5));
    var a = xn(this.anchors.map(function(c) {
      return c.width;
    })), s = xn(this.anchors.map(function(c) {
      return c.height;
    })), o = xn(this.anchors.map(function(c) {
      return c.xCenter;
    })), i = xn(this.anchors.map(function(c) {
      return c.yCenter;
    }));
    this.anchorTensor = { x: o, y: i, w: a, h: s };
  }
  return t.prototype.dispose = function() {
    this.detectorModel.dispose(), un([this.anchorTensor.x, this.anchorTensor.y, this.anchorTensor.w, this.anchorTensor.h]);
  }, t.prototype.reset = function() {
  }, t.prototype.detectFaces = function(e, n) {
    return n === void 0 && (n = !1), wa(this, void 0, void 0, function() {
      var r, a, s, o, i, c, l, u, d, f, p;
      return Sa(this, function(h) {
        switch (h.label) {
          case 0:
            return e == null ? (this.reset(), [2, []]) : (r = Je(function() {
              var m = zt(v2(e), "float32");
              return n && (m = hn(bf.flipLeftRight(Kr(m, 0)), [0])), m;
            }), a = h5(r, this.imageToTensorConfig), s = a.imageTensor, o = a.transformationMatrix, i = this.detectorModel.execute(s, "Identity:0"), c = m5(i), l = c.boxes, [4, y5([u = c.logits, l], this.anchorTensor, this.tensorsToDetectionConfig)]);
          case 1:
            return (d = h.sent()).length === 0 ? (un([r, s, i, u, l]), [2, d]) : [4, g5(d, this.maxFaces, I5)];
          case 2:
            return f = h.sent(), p = function(m, g) {
              m === void 0 && (m = []);
              var v, b = (v = g, [].concat.apply([], v));
              return m.forEach(function(w) {
                var S = w.locationData;
                S.relativeKeypoints.forEach(function(D) {
                  var M = Sv(b, [D.x, D.y]), z = M[0], F = M[1];
                  D.x = z, D.y = F;
                });
                var I = S.relativeBoundingBox, E = Number.MAX_VALUE, T = Number.MAX_VALUE, R = Number.MIN_VALUE, $ = Number.MIN_VALUE;
                [[I.xMin, I.yMin], [I.xMin + I.width, I.yMin], [I.xMin + I.width, I.yMin + I.height], [I.xMin, I.yMin + I.height]].forEach(function(D) {
                  var M = Sv(b, D), z = M[0], F = M[1];
                  E = Math.min(E, z), R = Math.max(R, z), T = Math.min(T, F), $ = Math.max($, F);
                }), S.relativeBoundingBox = { xMin: E, xMax: R, yMin: T, yMax: $, width: R - E, height: $ - T };
              }), m;
            }(f, o), un([r, s, i, u, l]), [2, p];
        }
      });
    });
  }, t.prototype.estimateFaces = function(e, n) {
    return wa(this, void 0, void 0, function() {
      var r, a;
      return Sa(this, function(s) {
        return r = y2(e), a = !!n && n.flipHorizontal, [2, this.detectFaces(e, a).then(function(o) {
          return o.map(function(i) {
            for (var c = i.locationData.relativeKeypoints.map(function(h, m) {
              return Ua(Ua({}, h), { x: h.x * r.width, y: h.y * r.height, name: g2[m] });
            }), l = i.locationData.relativeBoundingBox, u = 0, d = ["width", "xMax", "xMin"]; u < d.length; u++)
              l[d[u]] *= r.width;
            for (var f = 0, p = ["height", "yMax", "yMin"]; f < p.length; f++)
              l[p[f]] *= r.height;
            return { keypoints: c, box: l };
          });
        })];
      });
    });
  }, t;
}();
function C5(t) {
  return wa(this, void 0, void 0, function() {
    var e, n, r;
    return Sa(this, function(a) {
      switch (a.label) {
        case 0:
          return e = function(s) {
            if (s == null)
              return Ua({}, np);
            var o = Ua({}, s);
            return o.modelType == null && (o.modelType = np.modelType), o.maxFaces == null && (o.maxFaces = np.maxFaces), o.detectorModelUrl == null && (o.modelType === "full" ? o.detectorModelUrl = "https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1" : o.detectorModelUrl = "https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"), o;
          }(t), n = typeof e.detectorModelUrl == "string" && e.detectorModelUrl.indexOf("https://tfhub.dev") > -1, [4, u5(e.detectorModelUrl, { fromTFHub: n })];
        case 1:
          return r = a.sent(), [2, new T5(e.modelType, r, e.maxFaces)];
      }
    });
  });
}
function N5(t, e) {
  return wa(this, void 0, void 0, function() {
    var n, r;
    return Sa(this, function(a) {
      if (t === Xc.MediaPipeFaceDetector) {
        if (r = void 0, (n = e) != null) {
          if (n.runtime === "tfjs")
            return [2, C5(n)];
          if (n.runtime === "mediapipe")
            return [2, d5(n)];
          r = n.runtime;
        }
        throw new Error("Expect modelConfig.runtime to be either 'tfjs' " + "or 'mediapipe', but got ".concat(r));
      }
      throw new Error("".concat(t, " is not a supported model name."));
    });
  });
}
(function(t) {
  t.MediaPipeFaceDetector = "MediaPipeFaceDetector";
})(Xc || (Xc = {}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var dt;
(function(t) {
  t[t.float32 = 0] = "float32", t[t.int32 = 1] = "int32", t[t.bool = 2] = "bool", t[t.string = 3] = "string", t[t.complex64 = 4] = "complex64";
})(dt || (dt = {}));
var pu;
(function(t) {
  t[t.linear = 0] = "linear", t[t.relu = 1] = "relu", t[t.relu6 = 2] = "relu6", t[t.prelu = 3] = "prelu", t[t.leakyrelu = 4] = "leakyrelu", t[t.sigmoid = 5] = "sigmoid", t[t.elu = 6] = "elu";
})(pu || (pu = {}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let b2;
function A5(t) {
  b2 = t.wasm.cwrap(eu, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function R5(t) {
  const { inputs: e, backend: n, attrs: r } = t, { a, b: s, bias: o, preluActivationWeights: i } = e;
  if (a.dtype !== "float32" || s.dtype !== "float32")
    throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");
  const { transposeA: c, transposeB: l, activation: u, leakyreluAlpha: d } = r, f = n.dataIdMap.get(a.dataId).id, p = n.dataIdMap.get(s.dataId).id;
  let h = 0;
  if (o != null) {
    const R = n.dataIdMap.get(o.dataId);
    if (R.shape.length !== 1)
      throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${R.shape.length}.`);
    h = R.id;
  }
  const m = i == null ? 0 : n.dataIdMap.get(i.dataId).id, g = pu[u];
  if (g == null)
    throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);
  const v = c ? a.shape[2] : a.shape[1], b = l ? s.shape[1] : s.shape[2], w = At(a.shape.slice(0, -2), s.shape.slice(0, -2)), S = n.makeOutput([...w, v, b], a.dtype), I = n.dataIdMap.get(S.dataId).id, E = new Uint8Array(new Int32Array(a.shape).buffer), T = new Uint8Array(new Int32Array(s.shape).buffer);
  return b2(f, E, a.shape.length, p, T, s.shape.length, c, l, g, h, m, d || 0, I), S;
}
const $5 = {
  kernelName: eu,
  backendName: "wasm",
  setupFunc: A5,
  kernelFunc: R5
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rt(t, e) {
  let n;
  function r(s) {
    n = s.wasm.cwrap(t, null, [
      "number",
      "number",
      "number"
      // out_id
    ]);
  }
  function a(s) {
    const { backend: o, inputs: { x: i } } = s, c = o.dataIdMap.get(i.dataId).id, l = o.makeOutput(i.shape, e || i.dtype), u = o.dataIdMap.get(l.dataId).id;
    return Y(l.shape) === 0 || n(c, dt[i.dtype], u), l;
  }
  return { kernelName: t, backendName: "wasm", setupFunc: r, kernelFunc: a };
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const D5 = rt(im);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const O5 = rt(pl);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F5 = rt(hl);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nn(t, e, n) {
  let r;
  function a(o) {
    r = o.wasm.cwrap(t, null, [
      "number",
      "array",
      "number",
      "number",
      "array",
      "number",
      "number",
      "number"
      // out_id
    ]);
  }
  function s(o) {
    const { backend: i, inputs: c } = o, { a: l, b: u } = c, d = i.dataIdMap.get(l.dataId).id, f = i.dataIdMap.get(u.dataId).id, p = n ?? l.dtype, h = At(l.shape, u.shape), m = i.makeOutput(h, p);
    if (Y(h) === 0)
      return m;
    const g = new Uint8Array(new Int32Array(l.shape).buffer), v = new Uint8Array(new Int32Array(u.shape).buffer), b = i.dataIdMap.get(m.dataId).id;
    return (() => r(d, g, l.shape.length, f, v, u.shape.length, dt[l.dtype], b))(), m;
  }
  return { kernelName: t, backendName: "wasm", setupFunc: a, kernelFunc: s };
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const M5 = nn(Eu);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let w2;
function P5(t) {
  w2 = t.wasm.cwrap(ml, null, [
    "array",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function B5(t) {
  const { inputs: e, backend: n } = t, r = n.makeOutput(e[0].shape, e[0].dtype);
  if (Y(r.shape) === 0)
    return r;
  const a = e.map((i) => n.dataIdMap.get(i.dataId).id), s = new Uint8Array(new Int32Array(a).buffer), o = n.dataIdMap.get(r.dataId).id;
  return w2(s, a.length, dt[r.dtype], o), r;
}
const L5 = {
  kernelName: ml,
  backendName: "wasm",
  setupFunc: P5,
  kernelFunc: B5
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xf(t) {
  const { inputs: { x: e }, backend: n } = t;
  if (e.dtype === "string")
    return Mr(n.readSync(e.dataId), e.shape, e.dtype);
  const r = n.makeOutput(e.shape, e.dtype), a = n.typedArrayFromHeap(e);
  return n.typedArrayFromHeap(r).set(a), r;
}
const W5 = {
  kernelName: ed,
  backendName: "wasm",
  kernelFunc: xf
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let S2;
function z5(t) {
  S2 = t.wasm.cwrap(vo, null, [
    "number",
    "array",
    "number",
    "number",
    "number",
    "array",
    "number"
    // perm.length
  ]);
}
function Ga(t) {
  const { inputs: e, backend: n, attrs: r } = t, [a, s] = H5(e.x.shape, r.perm);
  let o = !0;
  for (let h = 0; h < s.length; h++)
    s[h] !== h && (o = !1);
  const i = V5(e.x.shape, r.perm), c = {
    dataId: e.x.dataId,
    shape: a,
    dtype: e.x.dtype
  };
  if (o) {
    const h = xf({ inputs: e, backend: n });
    return h.shape = i, h;
  }
  const l = n.makeOutput(i, c.dtype), u = n.dataIdMap.get(c.dataId).id, d = n.dataIdMap.get(l.dataId).id, f = new Uint8Array(new Int32Array(s).buffer), p = new Uint8Array(new Int32Array(c.shape).buffer);
  return S2(u, p, c.shape.length, dt[c.dtype], d, f, s.length), l;
}
function V5(t, e) {
  const n = new Array(t.length);
  for (let r = 0; r < n.length; r++)
    n[r] = t[e[r]];
  return n;
}
function H5(t, e) {
  const n = [], r = [];
  for (let a = 0; a < t.length; ++a)
    t[a] !== 1 && n.push(t[a]), t[e[a]] !== 1 && r.push(e[a]);
  for (let a = 0; a < r.length; ++a) {
    let s = -1;
    for (let o = 0; o < r.length; ++o)
      r[o] >= a && (s === -1 || r[s] > r[o]) && (s = o);
    r[s] = a;
  }
  return [n, r];
}
const j5 = {
  kernelName: vo,
  backendName: "wasm",
  kernelFunc: Ga,
  setupFunc: z5
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qa(t, e, n) {
  const r = t.shape, a = t.shape.length, s = Vt(e, r);
  let o = s;
  const i = pr(o, a);
  let c = null, l = !1;
  if (i != null) {
    const u = new Array(a);
    for (let p = 0; p < u.length; p++)
      u[p] = r[i[p]];
    o = Mn(o.length, a), c = Ga({ inputs: { x: t }, attrs: { perm: i }, backend: n });
    const d = n.dataIdMap.get(t.dataId).id;
    n.dataIdMap.get(c.dataId).id !== d && (l = !0);
  }
  return { transposed: c, originalAxes: s, axes: o, inputWasTransposed: l };
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let _2;
function U5(t) {
  _2 = t.wasm.cwrap(gl, null, ["number, number, number"]);
}
function G5(t) {
  const { backend: e, inputs: n, attrs: r } = t, { axis: a, keepDims: s } = r, { x: o } = n;
  let c = e.dataIdMap.get(o.dataId).id, l = o;
  const { transposed: u, axes: d, originalAxes: f, inputWasTransposed: p } = Qa(o, a, e);
  if (p) {
    const w = e.dataIdMap.get(u.dataId).id;
    l = u, c = w;
  }
  const h = l.shape.length;
  Fn("all", d, h);
  const [m, g] = On(l.shape, d), v = Y(g), b = e.makeOutput(m, o.dtype);
  if (Y(l.shape) !== 0) {
    const w = e.dataIdMap.get(b.dataId).id;
    _2(c, v, w);
  }
  if (p && e.disposeData(u.dataId), s) {
    const w = vn(b.shape, f);
    b.shape = w;
  }
  return b;
}
const q5 = {
  kernelName: gl,
  backendName: "wasm",
  setupFunc: U5,
  kernelFunc: G5
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let x2;
function K5(t) {
  x2 = t.wasm.cwrap(yl, null, ["number, number, number"]);
}
function X5(t) {
  const { backend: e, inputs: n, attrs: r } = t, { axis: a, keepDims: s } = r, { x: o } = n;
  let c = e.dataIdMap.get(o.dataId).id, l = o;
  const { transposed: u, axes: d, originalAxes: f, inputWasTransposed: p } = Qa(o, a, e);
  if (p) {
    const w = e.dataIdMap.get(u.dataId).id;
    l = u, c = w;
  }
  const h = l.shape.length;
  Fn("any", d, h);
  const [m, g] = On(l.shape, d), v = Y(g), b = e.makeOutput(m, o.dtype);
  if (Y(l.shape) !== 0) {
    const w = e.dataIdMap.get(b.dataId).id;
    x2(c, v, w);
  }
  if (p && e.disposeData(u.dataId), s) {
    const w = vn(b.shape, f);
    b.shape = w;
  }
  return b;
}
const Y5 = {
  kernelName: yl,
  backendName: "wasm",
  setupFunc: K5,
  kernelFunc: X5
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I2(t) {
  let e;
  function n(a) {
    e = a.wasm.cwrap(t, null, [
      "number",
      "number",
      "number",
      "number",
      "number"
      // out_id
    ]);
  }
  function r(a) {
    const { backend: s, inputs: o, attrs: i } = a, { axis: c } = i, { x: l } = o, u = s.dataIdMap.get(l.dataId).id;
    let d = u, f = l;
    const { transposed: p, axes: h, inputWasTransposed: m } = Qa(l, c, s);
    if (m) {
      const I = s.dataIdMap.get(p.dataId).id;
      I !== u && (f = p, d = I);
    }
    const g = f.shape.slice(0, -1), v = s.makeOutput(g, "int32"), b = s.dataIdMap.get(v.dataId).id, w = Y(v.shape), S = f.shape[h[0]];
    return e(d, dt[f.dtype], w, S, b), m && s.disposeData(p.dataId), v;
  }
  return {
    kernelName: t,
    backendName: "wasm",
    setupFunc: n,
    kernelFunc: r
  };
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Z5 = I2(um);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const J5 = I2(cm);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Q5 = rt(vl);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eP = rt(bl);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tP = rt(wl);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nP = nn(_l);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rP = rt(Sl);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let k2;
function aP(t) {
  k2 = t.wasm.cwrap(xl, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function sP(t) {
  const { inputs: e, attrs: n, backend: r } = t, a = e.x, s = r.dataIdMap.get(a.dataId).id, { filterSize: o, strides: i, pad: c, dimRoundingMode: l } = n, u = Vr(a.shape, o, i, 1, c, l), d = u.filterHeight, f = u.filterWidth, p = u.padInfo.top, h = u.padInfo.right, m = u.padInfo.bottom, g = u.padInfo.left, v = u.strideHeight, b = u.strideWidth, w = u.inChannels;
  if (u.dataFormat !== "channelsLast")
    throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);
  if (u.dilationWidth !== 1 || u.dilationHeight !== 1)
    throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);
  const S = r.makeOutput(u.outShape, "float32"), I = r.dataIdMap.get(S.dataId).id;
  return k2(s, a.shape[0], a.shape[1], a.shape[2], d, f, p, h, m, g, v, b, w, I), S;
}
const oP = {
  kernelName: xl,
  backendName: "wasm",
  setupFunc: aP,
  kernelFunc: sP
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let E2;
function iP(t) {
  E2 = t.wasm.cwrap("AvgPool3D", null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function uP(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { filterSize: s, strides: o, pad: i, dimRoundingMode: c, dataFormat: l } = r, u = Ja(
    a.shape,
    s,
    o,
    /*dilations=*/
    1,
    i,
    c,
    l
  ), d = n.makeOutput(u.outShape, a.dtype);
  return E2(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    u.batchSize,
    // Since Pool3D ops (AvgPool3D and MaxPool3D) support 3D filter only, in
    // channels should always equal to out channels.
    /*channelSize=*/
    u.inChannels,
    u.inDepth,
    u.inHeight,
    u.inWidth,
    u.outDepth,
    u.outHeight,
    u.outWidth,
    u.strideDepth,
    u.strideHeight,
    u.strideWidth,
    u.dilationDepth,
    u.dilationHeight,
    u.dilationWidth,
    u.effectiveFilterDepth,
    u.effectiveFilterHeight,
    u.effectiveFilterWidth,
    u.padInfo.front,
    u.padInfo.top,
    u.padInfo.left
  ), d;
}
const cP = {
  kernelName: lm,
  backendName: "wasm",
  setupFunc: iP,
  kernelFunc: uP
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let T2;
function lP(t) {
  T2 = t.wasm.cwrap("AvgPool3DGrad", null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // filterWidth
  ]);
}
function dP(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s } = e, { filterSize: o, strides: i, pad: c, dimRoundingMode: l } = r, u = Ja(
    s.shape,
    o,
    i,
    /*dilations=*/
    1,
    c,
    l
  ), d = n.makeOutput(s.shape, s.dtype);
  return T2(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    u.batchSize,
    // Since Pool3D ops (AvgPool3D and MaxPool3D) support 3D filter only, in
    // channels should always equal to out channels.
    /*channelSize=*/
    u.inChannels,
    u.inDepth,
    u.inHeight,
    u.inWidth,
    u.outDepth,
    u.outHeight,
    u.outWidth,
    u.strideDepth,
    u.strideHeight,
    u.strideWidth,
    u.dilationDepth,
    u.dilationHeight,
    u.dilationWidth,
    u.effectiveFilterDepth,
    u.effectiveFilterHeight,
    u.effectiveFilterWidth,
    u.padInfo.front,
    u.padInfo.top,
    u.padInfo.left,
    u.filterDepth,
    u.filterHeight,
    u.filterWidth
  ), d;
}
const fP = {
  kernelName: X0,
  backendName: "wasm",
  setupFunc: lP,
  kernelFunc: dP
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let C2;
function pP(t) {
  C2 = t.wasm.cwrap("AvgPoolGrad", null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // filterWidth
  ]);
}
function hP(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s } = e, { filterSize: o, strides: i, pad: c } = r, l = Vr(
    s.shape,
    o,
    i,
    /*dilations=*/
    1,
    c
  ), u = n.makeOutput(s.shape, s.dtype);
  return C2(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(u.dataId).id,
    l.batchSize,
    // Since Pool ops (AvgPool and MaxPool) support 2D filter only, in
    // channels should always equal to out channels.
    /*channelSize=*/
    l.inChannels,
    l.inHeight,
    l.inWidth,
    l.outHeight,
    l.outWidth,
    l.strideHeight,
    l.strideWidth,
    l.dilationHeight,
    l.dilationWidth,
    l.effectiveFilterHeight,
    l.effectiveFilterWidth,
    l.padInfo.top,
    l.padInfo.left,
    l.filterHeight,
    l.filterWidth
  ), u;
}
const mP = {
  kernelName: K0,
  backendName: "wasm",
  setupFunc: pP,
  kernelFunc: hP
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jn(t) {
  const { inputs: e, attrs: n } = t, { x: r } = e, { shape: a } = n, s = Y(r.shape), o = H0(a, s);
  return A(s === Y(o), () => `new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`), t.backend.incRef(r.dataId), { dataId: r.dataId, shape: o, dtype: r.dtype };
}
const gP = {
  kernelName: Cm,
  backendName: "wasm",
  kernelFunc: jn
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let N2;
function yP(t) {
  N2 = t.wasm.cwrap(Il, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function vP(t) {
  const { inputs: e, backend: n, attrs: r } = t, { a, b: s } = e, { transposeA: o, transposeB: i } = r;
  if (a.dtype !== "float32" || s.dtype !== "float32")
    throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");
  const c = a.shape.length, l = s.shape.length, u = o ? a.shape[c - 2] : a.shape[c - 1], d = i ? s.shape[l - 1] : s.shape[l - 2], f = o ? a.shape[c - 1] : a.shape[c - 2], p = i ? s.shape[l - 2] : s.shape[l - 1], h = a.shape.slice(0, -2), m = s.shape.slice(0, -2), g = Y(h), v = Y(m), w = At(a.shape.slice(0, -2), s.shape.slice(0, -2)).concat([f, p]);
  A(u === d, () => `Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`);
  const S = o ? [g, u, f] : [g, f, u], I = i ? [v, p, d] : [v, d, p], E = jn({ inputs: { x: a }, backend: n, attrs: { shape: S } }), T = jn({ inputs: { x: s }, backend: n, attrs: { shape: I } }), R = n.dataIdMap.get(E.dataId).id, $ = n.dataIdMap.get(T.dataId).id, D = o ? E.shape[2] : E.shape[1], M = i ? T.shape[1] : T.shape[2], z = Math.max(g, v), F = n.makeOutput([z, D, M], E.dtype), V = n.dataIdMap.get(F.dataId).id, H = new Uint8Array(new Int32Array(E.shape).buffer), U = new Uint8Array(new Int32Array(T.shape).buffer);
  return N2(R, H, E.shape.length, $, U, T.shape.length, o, i, V), n.disposeData(E.dataId), n.disposeData(T.dataId), F.shape = w, F;
}
const bP = {
  kernelName: Il,
  backendName: "wasm",
  setupFunc: yP,
  kernelFunc: vP
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xe(t, e) {
  Array.isArray(t) || (t = [t]), t.forEach((n) => {
    n != null && A(n.dtype !== "complex64", () => `${e} does not support complex64 tensors in the CPU backend.`);
  });
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wP(t) {
  const e = new Float32Array(t.length);
  for (let n = 0; n < t.length; ++n)
    e[n] = Math.abs(t[n]);
  return e;
}
const SP = (t) => {
  const { x: e } = t.inputs, n = t.backend;
  xe(e, "abs");
  let r = new Float32Array(Y(e.shape));
  const a = n.data.get(e.dataId).values;
  return r = wP(a), n.makeOutput(r, e.shape, e.dtype);
}, _P = {
  kernelName: im,
  backendName: "cpu",
  kernelFunc: SP
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yt(t) {
  return (e, n, r, a, s) => {
    const o = At(e, n), i = o.length, c = Ie(o), l = Y(o), u = Dn(s, l), d = e.length, f = n.length, p = Ie(e), h = Ie(n), m = zc(e, o), g = zc(n, o);
    if (m.length + g.length === 0)
      for (let v = 0; v < u.length; ++v)
        u[v] = t(r[v % r.length], a[v % a.length]);
    else
      for (let v = 0; v < u.length; ++v) {
        const b = Bo(v, i, c), w = b.slice(-d);
        m.forEach((T) => w[T] = 0);
        const S = Zr(w, d, p), I = b.slice(-f);
        g.forEach((T) => I[T] = 0);
        const E = Zr(I, f, h);
        u[v] = t(r[S], a[E]);
      }
    return [u, o];
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nr(t) {
  const { inputs: e, backend: n } = t, { real: r, imag: a } = e, s = n.data.get(r.dataId).values, o = n.data.get(a.dataId).values, i = n.makeTensorInfo(r.shape, "complex64"), c = n.data.get(i.dataId);
  return c.complexTensorInfos = {
    real: n.makeTensorInfo(r.shape, "float32", s),
    imag: n.makeTensorInfo(a.shape, "float32", o)
  }, i;
}
const xP = {
  kernelName: Y0,
  backendName: "cpu",
  kernelFunc: nr
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yc(t, e, n = "float32") {
  if (n === "complex64") {
    const a = Yc(t, e, "float32"), s = Yc(t, e, "float32");
    return nr({ inputs: { real: a, imag: s }, backend: t });
  }
  const r = In(Y(e), n);
  return t.makeTensorInfo(e, n, r);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ea(t) {
  const { inputs: e, backend: n } = t, { x: r } = e;
  return n.incRef(r.dataId), { dataId: r.dataId, shape: r.shape, dtype: r.dtype };
}
const IP = {
  kernelName: ed,
  backendName: "cpu",
  kernelFunc: ea
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ls(t) {
  const { inputs: e, backend: n } = t, { input: r } = e, a = n.data.get(r.dataId).complexTensorInfos.real, s = n.data.get(a.dataId).values;
  return n.makeTensorInfo(a.shape, a.dtype, s);
}
const kP = {
  kernelName: d1,
  backendName: "cpu",
  kernelFunc: Ls
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EP(t, e, n, r) {
  if (r === "int32") {
    const a = Int32Array.from(t);
    return [e, "int32", a];
  }
  if (r === "bool") {
    const a = js([0], n), [s, o] = Yt((i, c) => i !== c ? 1 : 0)(e, [], t, a, "bool");
    return [o, "bool", s];
  }
  throw new Error(`Error in Cast: failed to cast ${n} to ${r}`);
}
function qa(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { dtype: s } = r;
  if (s === "complex64") {
    if (a.dtype === "complex64")
      return ea({ inputs: { x: a }, backend: n });
    const u = Yc(n, a.shape, a.dtype), d = qa({ inputs: { x: a }, backend: n, attrs: { dtype: "float32" } }), f = nr({ inputs: { real: d, imag: u }, backend: n });
    return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(d), f;
  }
  if (a.dtype === "complex64") {
    const u = Ls({ inputs: { input: a }, backend: n }), d = qa({ inputs: { x: u }, backend: n, attrs: { dtype: s } });
    return n.disposeIntermediateTensorInfo(u), d;
  }
  if (!cT(a.dtype, s)) {
    const u = ea({ inputs: { x: a }, backend: n });
    return { dataId: u.dataId, shape: u.shape, dtype: s };
  }
  const o = n.data.get(a.dataId).values, [i, c, l] = EP(o, a.shape, a.dtype, s);
  return n.makeTensorInfo(i, c, l);
}
const TP = {
  kernelName: Tl,
  backendName: "cpu",
  kernelFunc: qa
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cn(t, e, n, r) {
  return n == null ? ({ inputs: a, backend: s }) => {
    const { a: o, b: i } = a, c = s;
    xe([o, i], t);
    const l = c.data.get(o.dataId).values, u = c.data.get(i.dataId).values, d = o.dtype === "string" ? (
      // tslint:disable-next-line: no-any
      fu(l)
    ) : l, f = o.dtype === "string" ? (
      // tslint:disable-next-line: no-any
      fu(u)
    ) : u, p = r || o.dtype, [h, m] = e(o.shape, i.shape, d, f, p);
    return c.makeTensorInfo(m, p, h);
  } : ({ inputs: a, backend: s }) => {
    const { a: o, b: i } = a, c = s;
    if (o.dtype === "complex64" || i.dtype === "complex64") {
      const l = qa({ inputs: { x: o }, backend: c, attrs: { dtype: "complex64" } }), u = c.data.get(l.dataId), d = u.complexTensorInfos.real, f = u.complexTensorInfos.imag, p = c.data.get(d.dataId).values, h = c.data.get(f.dataId).values, m = qa({ inputs: { x: i }, backend: c, attrs: { dtype: "complex64" } }), g = c.data.get(m.dataId), v = g.complexTensorInfos.real, b = g.complexTensorInfos.imag, w = c.data.get(v.dataId).values, S = c.data.get(b.dataId).values, [I, E, T] = n(o.shape, i.shape, p, h, w, S), R = c.makeTensorInfo(T, "float32", I), $ = c.makeTensorInfo(T, "float32", E), D = nr({ inputs: { real: R, imag: $ }, backend: c });
      return c.disposeIntermediateTensorInfo(l), c.disposeIntermediateTensorInfo(m), c.disposeIntermediateTensorInfo(R), c.disposeIntermediateTensorInfo($), D;
    } else {
      const l = c.data.get(o.dataId).values, u = c.data.get(i.dataId).values, d = r || o.dtype, [f, p] = e(o.shape, i.shape, l, u, d);
      return c.makeTensorInfo(p, d, f);
    }
  };
}
function yg(t) {
  return (e, n, r, a, s, o) => {
    const i = At(e, n), c = Y(i), l = i.length, u = Ie(i), d = Dn("float32", c), f = Dn("float32", c), p = zc(e, i), h = zc(n, i), m = No(r, a), g = No(s, o), v = e.length, b = Ie(e), w = n.length, S = Ie(n);
    if (p.length + h.length === 0)
      for (let I = 0; I < d.length; I++) {
        const E = I % m.length, T = I % g.length, R = t(m[E * 2], m[E * 2 + 1], g[T * 2], g[T * 2 + 1]);
        d[I] = R.real, f[I] = R.imag;
      }
    else
      for (let I = 0; I < d.length; I++) {
        const E = Bo(I, l, u), T = E.slice(-v);
        p.forEach((z) => T[z] = 0);
        const R = Zr(T, v, b), $ = E.slice(-w);
        h.forEach((z) => $[z] = 0);
        const D = Zr($, w, S), M = t(m[R * 2], m[R * 2 + 1], g[D * 2], g[D * 2 + 1]);
        d[I] = M.real, f[I] = M.imag;
      }
    return [d, f, i];
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CP = Yt((t, e) => t + e), NP = yg((t, e, n, r) => ({ real: t + n, imag: e + r })), Ao = cn(Eu, CP, NP), AP = {
  kernelName: Eu,
  backendName: "cpu",
  kernelFunc: Ao
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function A2(t, e, n, r, a) {
  const s = Y(r), o = In(a, n);
  for (let i = 0; i < t.length; i++) {
    const c = t[i];
    if (c < 0)
      throw new Error("Input x must be non-negative!");
    c >= a || (s > 0 ? o[c] += e[i] : o[c] += 1);
  }
  return o;
}
function RP(t, e, n, r = !1) {
  const a = t.shape[0], s = t.shape[1], o = Qe([a, n], e.dtype);
  for (let i = 0; i < a; i++)
    for (let c = 0; c < s; c++) {
      const l = t.get(i, c);
      if (l < 0)
        throw new Error("Input x must be non-negative!");
      l >= n || (r ? o.set(1, i, l) : e.size > 0 ? o.set(o.get(i, l) + e.get(i, c), i, l) : o.set(o.get(i, l) + 1, i, l));
    }
  return o;
}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $P = Yt((t, e) => t & e), DP = cn(El, $P), OP = {
  kernelName: El,
  backendName: "cpu",
  kernelFunc: DP
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function es(t) {
  return (e, n, r) => {
    const a = tn(n, e.length);
    for (let s = 0; s < e.length; ++s)
      a[s] = t(e[s], r);
    return a;
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vt(t, e, n) {
  const r = es(e);
  return ts(t, r, n);
}
function ts(t, e, n) {
  return ({ inputs: r, attrs: a, backend: s }) => {
    const { x: o } = r;
    xe(o, t);
    const i = s, c = i.data.get(o.dataId).values;
    let l;
    if (o.dtype === "string") {
      if (!Array.isArray(c))
        throw new Error("String tensor's value was not an instance of Array");
      l = fu(c);
    } else
      l = c;
    const u = n || o.dtype, d = e(l, u, a);
    return i.makeTensorInfo(o.shape, u, d);
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FP = es((t) => Math.ceil(t)), MP = ts(Cl, FP), PP = {
  kernelName: Cl,
  backendName: "cpu",
  kernelFunc: MP
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R2(t, e, n, r) {
  const a = tn(n, Y(e));
  if (r && n !== "string") {
    let s = 0;
    t.forEach((o) => {
      const i = Y(o.shape);
      a.set(o.vals, s), s += i;
    });
  } else {
    let s = 0;
    t.forEach((o) => {
      const i = n === "string" ? fu(o.vals) : o.vals;
      let c = 0;
      for (let l = 0; l < o.shape[0]; ++l) {
        const u = l * e[1] + s;
        for (let d = 0; d < o.shape[1]; ++d)
          a[u + d] = i[c++];
      }
      s += o.shape[1];
    });
  }
  return a;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BP = Yt((t, e) => t === e ? 1 : 0), $2 = cn(jl, BP, null, "bool"), LP = {
  kernelName: jl,
  backendName: "cpu",
  kernelFunc: $2
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WP = es((t) => Math.exp(t)), D2 = ts(Ul, WP, "float32"), zP = {
  kernelName: Ul,
  backendName: "cpu",
  kernelFunc: D2
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const VP = es((t) => Math.expm1(t)), HP = ts(Gl, VP), jP = {
  kernelName: Gl,
  backendName: "cpu",
  kernelFunc: HP
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UP = es((t) => Math.floor(t)), GP = ts(Kl, UP), qP = {
  kernelName: Kl,
  backendName: "cpu",
  kernelFunc: GP
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KP = Yt((t, e) => Math.floor(t / e)), XP = cn(Xl, KP, null, "int32"), YP = {
  kernelName: Xl,
  backendName: "cpu",
  kernelFunc: XP
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZP(t, e, n, r, a, s, o, i, c) {
  const l = Qe([r, s], n);
  for (let u = 0; u < r; u++) {
    const d = [];
    let f = 0;
    for (let p = 0; p < a; p++) {
      const h = t[u * a + p];
      f += h * o[p], d.push(h);
    }
    if (f < 0 || f >= c / s)
      throw new Error(`Invalid indices: ${d} does not index into ${i}`);
    for (let p = 0; p < s; p++)
      l.values[u * s + p] = e.get(...e.indexToLoc(f * s + p));
  }
  return l;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JP(t, e, n) {
  const r = Qe(n, t.dtype);
  for (let a = 0; a < r.size; ++a) {
    const o = r.indexToLoc(a).slice(), i = o[0], c = o[2], l = e.locToIndex([i, c]);
    o[2] = e.values[l];
    const u = t.locToIndex(o);
    0 <= u && u < t.values.length && (r.values[a] = t.values[u]);
  }
  return r;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const QP = Yt((t, e) => t > e ? 1 : 0), e8 = cn(Jl, QP, null, "bool"), t8 = {
  kernelName: Jl,
  backendName: "cpu",
  kernelFunc: e8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const n8 = Yt((t, e) => t >= e ? 1 : 0), r8 = cn(Ql, n8, null, "bool"), a8 = {
  kernelName: Ql,
  backendName: "cpu",
  kernelFunc: r8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s8 = Yt((t, e) => t < e ? 1 : 0), o8 = cn(sd, s8, null, "bool"), i8 = {
  kernelName: sd,
  backendName: "cpu",
  kernelFunc: o8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const u8 = Yt((t, e) => t <= e ? 1 : 0), c8 = cn(od, u8, null, "bool"), l8 = {
  kernelName: od,
  backendName: "cpu",
  kernelFunc: c8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function d8(t, e, n) {
  const r = (e - t) / (n - 1), a = In(n, "float32");
  a[0] = t;
  for (let s = 1; s < a.length; s++)
    a[s] = a[s - 1] + r;
  return a;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const f8 = es((t) => Math.log(t)), p8 = ts(ud, f8), h8 = {
  kernelName: ud,
  backendName: "cpu",
  kernelFunc: p8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function m8(t, e, n, r) {
  const a = Dn(r, Y(n));
  for (let s = 0; s < a.length; ++s) {
    const o = s * e;
    let i = t[o];
    for (let c = 0; c < e; ++c) {
      const l = t[o + c];
      (Number.isNaN(l) || l > i) && (i = l);
    }
    a[s] = i;
  }
  return a;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const g8 = Yt((t, e) => Math.max(t, e)), y8 = cn(md, g8), v8 = {
  kernelName: md,
  backendName: "cpu",
  kernelFunc: y8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const b8 = Yt((t, e) => Math.min(t, e)), w8 = cn(bd, b8), S8 = {
  kernelName: bd,
  backendName: "cpu",
  kernelFunc: w8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const O2 = Yt((t, e) => t * e), _8 = yg((t, e, n, r) => ({
  real: t * n - e * r,
  imag: t * r + e * n
})), If = cn(xd, O2, _8), x8 = {
  kernelName: xd,
  backendName: "cpu",
  kernelFunc: If
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I8(t, e, n) {
  const r = Gm(-1, n);
  return O2([], e, r, t, n);
}
function k8(t) {
  const { inputs: e, backend: n } = t, { x: r } = e;
  xe(r, "neg");
  const a = n.data.get(r.dataId).values, [s, o] = I8(a, r.shape, r.dtype);
  return n.makeTensorInfo(o, r.dtype, s);
}
const E8 = {
  kernelName: Im,
  backendName: "cpu",
  kernelFunc: k8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const T8 = Yt((t, e) => t !== e ? 1 : 0), C8 = cn(Id, T8, null, "bool"), N8 = {
  kernelName: Id,
  backendName: "cpu",
  kernelFunc: C8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F2(t, e, n, r, a) {
  const s = e.length, o = Y(e), i = Ie(e), c = Ie(a), l = Dn(n, Y(a));
  for (let u = 0; u < o; ++u) {
    const d = Bo(u, s, i), f = new Array(d.length);
    for (let h = 0; h < f.length; h++)
      f[h] = d[r[h]];
    const p = Zr(f, s, c);
    l[p] = t[u];
  }
  return l;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gn(t) {
  const { inputs: e, attrs: n, backend: r } = t, { x: a } = e, { perm: s } = n;
  xe(a, "transpose");
  const o = a.shape.length, i = new Array(o);
  for (let d = 0; d < i.length; d++)
    i[d] = a.shape[s[d]];
  const c = r.data.get(a.dataId).values, l = F2(c, a.shape, a.dtype, s, i);
  return { dataId: r.write(l, i, a.dtype), shape: i, dtype: a.dtype };
}
const A8 = {
  kernelName: vo,
  backendName: "cpu",
  kernelFunc: Gn
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R8(t, e, n, r) {
  const [a, s] = On(t, r), o = Lo(e, "int32"), i = In(Y(a), o), c = Y(s);
  for (let l = 0; l < i.length; ++l) {
    const u = l * c;
    let d = 1;
    for (let f = 0; f < c; ++f)
      d *= n[u + f];
    i[l] = d;
  }
  return { outVals: i, outShape: a, outDtype: o };
}
function $8(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, keepDims: o } = r;
  xe(a, "prod");
  const i = a.shape.length, c = Vt(s, a.shape), l = pr(c, i);
  let u = c, d = a;
  const f = [];
  l != null && (d = Gn({ inputs: { x: a }, backend: n, attrs: { perm: l } }), f.push(d), u = Mn(u.length, i));
  const p = n.data.get(d.dataId).values, { outVals: h, outShape: m, outDtype: g } = R8(d.shape, d.dtype, p, u);
  let v = m;
  return o && (v = vn(m, c)), f.forEach((b) => n.disposeIntermediateTensorInfo(b)), n.makeTensorInfo(v, g, h);
}
const D8 = {
  kernelName: $d,
  backendName: "cpu",
  kernelFunc: $8
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function O8(t, e, n) {
  t.forEach((r, a) => {
    if (r < 0 || r >= n) {
      const s = Bo(a, e.length, Ie(e)).join(",");
      throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`);
    }
  });
}
function F8(t, e) {
  for (let n = 0; n < t.length; ++n) {
    const r = t[n], a = n === t.length - 1 ? e : t[n + 1].length;
    if (r.length === 0)
      throw new Error("Ragged splits may not be empty");
    if (r[0] < 0)
      throw new Error("Ragged splits must be non-negative");
    if (r[r.length - 1] > a)
      throw new Error("Ragged splits must not point past values");
    for (let s = 1; s < r.length; ++s)
      if (r[s - 1] > r[s])
        throw new Error("Ragged splits must be sorted in ascending order");
  }
}
function M8(t, e, n, r) {
  const a = [];
  let s = 0;
  const o = e.length - 1 + n.length, i = new Array(o).fill(null).map(() => [0]);
  F8(n, r);
  let c = 1;
  for (let l = 0; l < e.length - 1; ++l) {
    c *= e[l];
    const u = e[l + 1];
    for (let d = 1; d < c + 1; ++d)
      i[l].push(d * u);
  }
  for (let l = 0; l < t.length; ++l) {
    let u = t[l], d = t[l] + 1;
    for (let f = 0; f < n.length; ++f) {
      const p = n[f], h = f + e.length - 1;
      if (h >= 0) {
        const m = i[h], g = m[m.length - 1] - p[u];
        for (let v = u; v < d; ++v)
          i[h].push(p[v + 1] + g);
      }
      u = p[u], d = p[d];
    }
    d !== u && (a.push([u, d]), s += d - u);
  }
  return { outSplits: i, valueSlices: a, numValues: s };
}
function P8(t) {
  const e = [];
  for (let n = 0; n < t.length; ++n) {
    const r = t[n].length, a = tn("int32", r);
    e.push(a), t[n].forEach((s, o) => a[o] = s);
  }
  return e;
}
function _v(t, e) {
  const n = t.slice(0, e);
  for (; n.length < e; )
    n.push(1);
  for (let r = e; r < t.length; r++)
    n[e - 1] *= t[r];
  return n;
}
function B8(t, e, n, r, a, s) {
  const o = _v(e, 2)[1], i = _v(s, 2)[1];
  let c = 0;
  for (const l of n)
    for (let u = l[0]; u < l[1]; ++u) {
      for (let d = 0; d < r; ++d)
        a[c * i + d] = t[u * o + d];
      ++c;
    }
}
function L8(t, e, n, r, a) {
  const s = e.slice();
  s[0] = a;
  const o = tn(n, Y(s)), i = t.length, c = i === 0 ? 0 : i / e[0];
  return B8(t, e, r, c, o, s), [o, s];
}
function W8(t, e, n, r, a, s, o, i) {
  if (t.length === 0)
    throw new Error("paramsNestedSplits must be non empty");
  if (e[0].length === 0)
    throw new Error("Split tensors must not be scalars");
  const c = e[0][0] - 1;
  if (O8(s, o, c), r.length === 0)
    throw new Error("params.rank must be nonzero");
  const l = r[0], { outSplits: u, valueSlices: d, numValues: f } = M8(s, o, t, l), p = P8(u), h = L8(n, r, a, d, f);
  return [p, h[0], h[1]];
}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xv = 2147483647;
function z8(t, e, n, r, a, s, o) {
  if (e.length > 1)
    throw new Error("starts must be a scalar or vector");
  if (a.length > 1)
    throw new Error("limits must be a scalar or vector");
  if (o.length > 1)
    throw new Error("deltas must be a scalar or vector");
  const i = e.length === 0, c = a.length === 0, l = o.length === 0, u = [];
  i || u.push(e[0]), c || u.push(a[0]), l || u.push(o[0]);
  for (let g = 1; g < u.length; ++g)
    if (u[g] !== u[g - 1])
      throw new Error("starts, limits, and deltas must have the same shape");
  const d = u.length === 0 ? 1 : u[0], f = tn("int32", d + 1);
  f[0] = 0;
  for (let g = 0; g < d; ++g) {
    const v = i ? t[0] : t[g], b = c ? r[0] : r[g], w = l ? s[0] : s[g];
    if (w === 0)
      throw new Error("Requires delta != 0");
    let S;
    if (w > 0 && b < v || w < 0 && b > v)
      S = 0;
    else if (S = Math.ceil(Math.abs((b - v) / w)), S > xv)
      throw new Error(`Requires ((limit - start) / delta) <= ${xv}`);
    f[g + 1] = f[g] + S;
  }
  const p = f[d], h = tn(n, p);
  let m = 0;
  for (let g = 0; g < d; ++g) {
    const v = f[g + 1] - f[g];
    let b = i ? t[0] : t[g];
    const w = l ? s[0] : s[g];
    for (let S = 0; S < v; ++S)
      h[m++] = b, b += w;
  }
  return [f, h];
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var gr = Xr;
class Zc {
  constructor(e, n, r, a, s, o, i, c, l, u) {
    this.shape = e, this.shapeShape = n, this.values = r, this.valuesShape = a, this.valuesDType = s, this.defaultValue = o, this.defaultValueShape = i, this.rowPartitionValues = c, this.rowPartitionValuesShapes = l, this.rowPartitionTypes = lM(u), this.raggedRank = dM(this.rowPartitionTypes);
  }
  getRowPartitionTypeByDimension(e) {
    return this.rowPartitionTypes[0] === gr.FIRST_DIM_SIZE ? this.rowPartitionTypes[e + 1] : this.rowPartitionTypes[e];
  }
  // Returns the relationship between dimension and dimension + 1.
  getRowPartitionTensor(e) {
    return this.rowPartitionTypes[0] === gr.FIRST_DIM_SIZE ? this.rowPartitionValues[e + 1] : this.rowPartitionValues[e];
  }
  getMaxWidth(e) {
    const n = this.getRowPartitionTensor(e - 1);
    switch (this.getRowPartitionTypeByDimension(e - 1)) {
      case gr.VALUE_ROWIDS:
        return Zc.getMaxWidthValueRowID(n);
      case gr.ROW_SPLITS:
        return Zc.getMaxWidthRowSplit(n);
      default:
        throw new Error(`Cannot handle partition type ${gr[this.getRowPartitionTypeByDimension(e - 1)]}`);
    }
  }
  static getMaxWidthRowSplit(e) {
    const n = e.length;
    if (n === 0 || n === 1)
      return 0;
    let r = 0;
    for (let a = 0; a < n - 1; ++a) {
      const s = e[a + 1] - e[a];
      s > r && (r = s);
    }
    return r;
  }
  static getMaxWidthValueRowID(e) {
    const n = e.length;
    if (n === 0)
      return 0;
    let r = 0, a = e[0], s = 0;
    for (let o = 1; o < n; ++o) {
      const i = e[o];
      i !== a && (a = i, s = Math.max(o - r, s), r = o);
    }
    return Math.max(n - r, s);
  }
  tensorShapeFromTensor(e, n, r = !0) {
    if (n.length === 0) {
      if (e[0] === -1)
        return [];
      throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
    }
    return kv(e, r);
  }
  calculateOutputSize(e) {
    const n = this.valuesShape, r = this.defaultValueShape;
    fM(r, n);
    const a = this.tensorShapeFromTensor(this.shape, this.shapeShape), o = cM(this.raggedRank, a, n);
    o[0] < 0 && (o[0] = e);
    for (let i = 1; i <= this.raggedRank; ++i)
      o[i] < 0 && (o[i] = this.getMaxWidth(i));
    return o;
  }
  /**
   * The outputIndex represents the index in the output tensor
   * where the first element of a particular dimension would be written.
   * If it is -1, it indicates that the index is out of scope.
   * Example, given firstDimension = 10, firstDimensionOutput = 6,
   * and outputIndexMultiplier = 100:
   * result = [0 100 200 300 400 500 -1 -1 -1 -1]
   * If firstDimensionOutput = 11 instead, then:
   * result = [0 100 200 300 400 500 600 700 800 900]
   */
  calculateFirstParentOutputIndex(e, n, r) {
    const a = Math.min(e, r), s = [];
    let o = 0;
    for (let i = 0; i < a; ++i, o += n)
      s.push(o);
    for (let i = a; i < e; ++i)
      s.push(-1);
    return A(s.length === e, () => "Final length of result must be equal to firstDimension."), s;
  }
  calculateOutputIndexRowSplit(e, n, r, a) {
    const s = e.length, o = [];
    for (let i = 0; i < s - 1; ++i) {
      const c = e[i + 1] - e[i];
      let l = Math.min(a, c), u = n[i];
      u === -1 && (l = 0);
      for (let d = 0; d < l; ++d)
        o.push(u), u += r;
      for (let d = 0; d < c - l; ++d)
        o.push(-1);
    }
    if (s > 0 && o.length !== e[s - 1])
      throw new Error("Invalid row split size.");
    return o;
  }
  // Calculate the output index of the first element of a list.
  // The parentOutputIndex is the same computation for the previous list.
  // -1 indicates an element or list that is out of range.
  // The outputIndexMultiplier is the number of output indices one moves
  // forward for each column.
  // E.g., given:
  // valueRowIds:[0 1 2 2 2 3 5 5 6]
  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]
  // outputIndexMultiplier: 10
  // outputSize: 2
  // You get:
  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]
  // result[0] = parentOutputIndex[valueRowIds[0]]
  // result[1] = parentOutputIndex[valueRowIds[1]]
  // result[2] = parentOutputIndex[valueRowIds[2]]
  // result[3] = parentOutputIndex[valueRowIds[2] + 10]
  // result[4] = -1 because it is the third element the size is 2.
  // result[5] = parentOutputIndex[valueRowIds[3]]
  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1
  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1
  // result[8] = parentOutputIndex[valueRowIds[7]]
  calculateOutputIndexValueRowID(e, n, r, a) {
    const s = e.length, o = [];
    if (s === 0)
      return [];
    let i = 0, c = e[0];
    if (c >= n.length)
      throw new Error(`Got currentValueRowId=${c}, which is not less than ${n.length}`);
    let l = n[c];
    o.push(l);
    for (let u = 1; u < s; ++u) {
      const d = e[u];
      if (d === c)
        l >= 0 && (++i, i < a ? l += r : l = -1);
      else {
        if (i = 0, c = d, d >= n.length)
          throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);
        l = n[d];
      }
      o.push(l);
    }
    if (o.length !== e.length)
      throw new Error("Invalid row ids.");
    return o;
  }
  calculateOutputIndex(e, n, r, a) {
    const s = this.getRowPartitionTensor(e), o = this.getRowPartitionTypeByDimension(e);
    switch (o) {
      case gr.VALUE_ROWIDS:
        return this.calculateOutputIndexValueRowID(s, n, r, a);
      case gr.ROW_SPLITS:
        if (s.length - 1 > n.length)
          throw new Error(`Row partition size is greater than output size: ${s.length - 1} > ${n.length}`);
        return this.calculateOutputIndexRowSplit(s, n, r, a);
      default:
        throw new Error(`Unsupported partition type: ${gr[o]}`);
    }
  }
  getFirstDimensionSize() {
    const e = this.rowPartitionValues[0];
    if (this.rowPartitionTypes.length === 0)
      throw new Error("No row_partition_types given.");
    const n = this.rowPartitionTypes[0];
    switch (n) {
      case gr.FIRST_DIM_SIZE:
        return e[0];
      case gr.VALUE_ROWIDS:
        throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
      case gr.ROW_SPLITS:
        return this.rowPartitionValuesShapes[0][0] - 1;
      default:
        throw new Error(`Cannot handle type ${gr[n]}`);
    }
  }
  compute() {
    if (this.rowPartitionValues[0].length <= 0)
      throw new Error("Invalid first partition input. Tensor requires at least one element.");
    const n = this.getFirstDimensionSize(), r = this.calculateOutputSize(n), a = new Array(this.raggedRank + 1);
    a[a.length - 1] = 1;
    for (let c = a.length - 2; c >= 0; --c)
      a[c] = a[c + 1] * r[c + 1];
    const s = kv(r, !1), o = tn(this.valuesDType, Y(s));
    if (a[0] * r[0] > 0) {
      let c = this.calculateFirstParentOutputIndex(n, a[0], r[0]);
      for (let l = 1; l <= this.raggedRank; ++l)
        c = this.calculateOutputIndex(l - 1, c, a[l], r[l]);
      this.setOutput(this.raggedRank, c, o, s);
    }
    return [s, o];
  }
  setOutput(e, n, r, a) {
    if (r.length === 0)
      return;
    const s = this.values, o = r;
    let i = a.slice();
    i = i.slice(e + 1);
    const c = Y(i), l = n.length;
    let u = this.defaultValue;
    if (u.length !== c && u.length !== 1) {
      const h = this.defaultValueShape;
      Je(() => {
        const m = ae(u, h);
        u = Vi(m, i).dataSync();
      });
    }
    let d = 0, f = 0, p = 0;
    for (let h = 0; h <= l; ++h) {
      let m = h < l ? n[h] : -1;
      if (m === p) {
        ++p;
        continue;
      }
      if (f < p) {
        const g = s.subarray(d * c), v = o.subarray(f * c), b = (p - f) * c;
        Iv(v, g, b);
      }
      if (h >= l) {
        const g = r.length;
        m = Math.floor(g / c);
      }
      if (m > p)
        if (this.defaultValue.length === 1)
          o.subarray(p * c, m * c).fill(this.defaultValue[0]), p = m;
        else
          for (; m > p; ) {
            const g = o.slice(p * c);
            Iv(g, u, c), ++p;
          }
      m < 0 ? (d = h + 1, f = p) : (d = h, f = p, p = f + 1);
    }
  }
}
function Iv(t, e, n) {
  for (let r = 0; r < n; r++)
    t[r] = e[r];
}
function kv(t, e) {
  const n = [];
  for (let r of t) {
    if (r < 0) {
      if (!e)
        throw new Error(`Dimension ${r} must be >= 0`);
      if (r < -1)
        throw new Error(`Dimension ${r} must be >= -1`);
      r = -1;
    }
    n.push(r);
  }
  return n;
}
function V8(t, e, n, r, a, s, o, i, c, l) {
  return new Zc(t, e, n, r, a, s, o, i, c, l).compute();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M2(t, e, n, r) {
  const a = t === e, s = t < e && n < 0, o = e < t && n > 1;
  if (a || s || o)
    return In(0, r);
  const i = Math.abs(Math.ceil((e - t) / n)), c = In(i, r);
  e < t && n === 1 && (n = -1), c[0] = t;
  for (let l = 1; l < c.length; l++)
    c[l] = c[l - 1] + n;
  return c;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const H8 = es((t) => 1 / Math.sqrt(t)), j8 = ts(Wd, H8), U8 = {
  kernelName: Wd,
  backendName: "cpu",
  kernelFunc: j8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function go(t, e, n, r, a, s, o, i, c, l) {
  const u = [r / a, a], d = t.values, f = e.values;
  if (r === 0)
    return Qe(n, e.dtype);
  const p = c instanceof on ? c : Qe(u, e.dtype);
  typeof c == "string" || typeof c == "number" ? p.values.fill(c) : typeof c == "boolean" && p.values.fill(+c);
  for (let h = 0; h < s; h++) {
    const m = [];
    let g = 0;
    for (let v = 0; v < o; v++) {
      const b = d[h * o + v];
      m.push(b), g += b * i[v];
    }
    if (g < 0 || g >= r / a)
      throw new Error(`Invalid indices: ${m} does not index into ${n}`);
    for (let v = 0; v < a; v++)
      l ? p.values[g * a + v] += f[h * a + v] : p.values[g * a + v] = e.rank === 0 ? f[0] : f[h * a + v];
  }
  return p;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const P2 = vt(Kd, (t) => 1 / (1 + Math.exp(-t))), G8 = {
  kernelName: Kd,
  backendName: "cpu",
  kernelFunc: P2
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yh(t, e, n, r, a) {
  const s = jw(r, e, n), o = Y(n), i = Ie(r);
  if (s) {
    const d = Uw(e, i);
    return a === "string" ? t.slice(d, d + o) : t.subarray(d, d + o);
  }
  const c = a === "string" ? fu(t) : t, l = Qe(r, a, c), u = Qe(n, a);
  for (let d = 0; d < u.size; ++d) {
    const f = u.indexToLoc(d), p = f.map((h, m) => h + e[m]);
    u.set(l.get(...p), ...f);
  }
  return a === "string" ? f2(u.values) : u.values;
}
function Ws(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { begin: s, size: o } = r;
  xe(a, "slice");
  const [i, c] = Gw(a, s, o);
  iM(a, i, c);
  const l = n.data.get(a.dataId).values, u = yh(l, i, c, a.shape, a.dtype);
  return n.makeTensorInfo(c, a.dtype, u);
}
const q8 = {
  kernelName: $m,
  backendName: "cpu",
  kernelFunc: Ws
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function K8(t, e, n, r, a, s, o) {
  const i = e[0], c = s[0], l = new Array(c), u = new Array(i), d = e[1];
  if (c === 0) {
    if (i !== 0)
      throw new Error(e2(i));
    const g = tn(n, 0), v = tn(a, 0);
    return [
      g,
      [0, d],
      v,
      l,
      u
    ];
  }
  let f = !0, p = 0;
  const h = new Array(c).fill(0);
  for (let g = 0; g < i; ++g) {
    const v = t[g * d];
    if (v < 0)
      throw new Error(t2(g, v));
    if (v >= c)
      throw new Error(n2(g, v, c));
    ++h[v], f = f && v >= p, p = v;
  }
  let m = !0;
  for (let g = 0; g < c; ++g) {
    const v = h[g] === 0;
    l[g] = v, m = m && !v, h[g] = Math.max(h[g], 1), g > 0 && (h[g] += h[g - 1]);
  }
  if (m && f) {
    const g = t, v = r;
    for (let b = 0; b < i; ++b)
      u[b] = b;
    return [
      g,
      [i, d],
      v,
      l,
      u
    ];
  } else {
    const g = h[c - 1], v = tn(n, g * d), b = tn(a, g), w = new Array(c).fill(0);
    for (let S = 0; S < i; ++S) {
      const I = t[S * d], E = w[I], T = (I === 0 ? 0 : h[I - 1]) + E;
      w[I]++;
      for (let R = 0; R < d; ++R)
        v[T * d + R] = t[S * d + R];
      b[T] = r[S], u[S] = T;
    }
    for (let S = 0; S < c; ++S)
      if (w[S] === 0) {
        const E = S === 0 ? 0 : h[S - 1];
        v[E * d + 0] = S;
        for (let T = 1; T < d; ++T)
          v[E * d + T] = 0;
        b[E] = o;
      }
    return [
      v,
      [g, d],
      b,
      l,
      u
    ];
  }
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function X8(t, e, n, r, a) {
  const s = Y(r), o = e[0], i = a.length, c = [];
  let l = 1, u = -1;
  for (let g = 0; g < i; ++g) {
    const v = a[g];
    if (v === -1) {
      if (u !== -1)
        throw new Error(r2(u, g));
      u = g, c.push(1);
    } else {
      if (v < 0)
        throw new Error(a2(g, v));
      l *= v, c.push(v);
    }
  }
  if (u !== -1) {
    if (l <= 0)
      throw new Error(s2());
    const g = Math.trunc(s / l);
    if (l * g !== s)
      throw new Error(o2(r, c));
    c[u] = g;
  }
  if (Y(c) !== s)
    throw new Error(i2(r, c));
  const f = r.length, p = [];
  if (f > 0) {
    p[f - 1] = 1;
    for (let g = f - 2; g >= 0; --g)
      p[g] = p[g + 1] * r[g + 1];
  }
  const h = [];
  if (i > 0) {
    h[i - 1] = 1;
    for (let g = i - 2; g >= 0; --g)
      h[g] = h[g + 1] * c[g + 1];
  }
  const m = tn(n, o * i);
  for (let g = 0; g < o; ++g) {
    let v = 0;
    for (let b = 0; b < f; ++b)
      v += t[g * f + b] * p[b];
    for (let b = 0; b < i; ++b)
      m[g * i + b] = Math.trunc(v / h[b]), v %= h[b];
  }
  return [m, [o, i], c];
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B2(t, e, n, r, a, s = !1, o = 0) {
  const i = r.length, c = [e[0], t.length / e[0]], l = c[1], d = i > 0 ? a[i - 1] + 1 : 0;
  if (d < 0)
    throw new Error(Gc());
  const f = e.slice();
  f[0] = d;
  const p = f.reduce((w, S) => w * S, 1), h = tn(n, p);
  if (i === 0)
    return d > 0 && h.fill(o), [h, f];
  if (d <= 0)
    throw new Error(Gc());
  let m = 0, g = 1, v = 0, b = a[m];
  for (; ; ) {
    let w = 0;
    if (g < i) {
      if (w = a[g], b === w) {
        ++g;
        continue;
      }
      if (b >= w)
        throw new Error(u2());
    }
    if (b < 0 || b >= d)
      throw new Error(c2(b, d));
    b > v && h.fill(o, v * l, b * l);
    for (let S = m; S < g; ++S) {
      const I = r[S];
      if (I < 0 || I >= c[0])
        throw new Error(l2(S, r[S], c[0]));
      for (let E = 0; E < l; E++)
        h[b * l + E] += t[I * l + E];
    }
    if (s)
      for (let S = 0; S < l; S++)
        h[b * l + S] /= g - m;
    if (m = g, ++g, v = b + 1, b = w, g > i)
      break;
  }
  return v < d && h.fill(o, v * l, d * l), [h, f];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Y8 = vt(Yd, (t) => Math.sqrt(t)), Z8 = {
  kernelName: Yd,
  backendName: "cpu",
  kernelFunc: Y8
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const J8 = Yt((t, e) => {
  const n = t - e;
  return n * n;
}), Q8 = cn(tf, J8), eB = {
  kernelName: tf,
  backendName: "cpu",
  kernelFunc: Q8
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tB = es((t, e) => {
  const { pattern: n, replaceGlobal: r, rewrite: a } = e;
  return t.replace(new RegExp(n, r ? "g" : ""), a);
}), nB = ts(Bm, tB), rB = {
  kernelName: Bm,
  backendName: "cpu",
  kernelFunc: nB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aB(t, e, n, r) {
  const a = Qe(t, e.dtype);
  for (let s = 0; s < a.size; s++) {
    const o = a.indexToLoc(s), i = new Array(o.length);
    for (let c = 0; c < i.length; c++)
      i[c] = o[c] * n[c] + r[c];
    a.set(e.get(...i), ...o);
  }
  return a;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class sB {
  constructor(e, n, r, a, s, o) {
    this.separator = Ts(e), this.nGramWidths = n, this.leftPad = Ts(r), this.rightPad = Ts(a), this.padWidth = s, this.preserveShort = o;
  }
  getPadWidth(e) {
    return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
  }
  getNumNGrams(e, n) {
    const r = this.getPadWidth(n);
    return Math.max(0, e + 2 * r - n + 1);
  }
  createNGrams(e, n, r, a, s, o) {
    for (let i = 0; i < s; ++i) {
      const c = this.getPadWidth(o), l = Math.max(0, c - i), u = Math.max(0, c - (s - (i + 1))), d = o - (l + u), f = n + (l > 0 ? 0 : i - c);
      let p = 0;
      p += l * this.leftPad.length;
      for (let b = 0; b < d; ++b)
        p += e[f + b].length;
      p += u * this.rightPad.length;
      const h = l + u + d - 1;
      p += h * this.separator.length, r[a + i] = new Uint8Array(p);
      const m = r[a + i];
      let g = 0;
      const v = (b) => b.forEach((w) => m[g++] = w);
      for (let b = 0; b < l; ++b)
        v(this.leftPad), v(this.separator);
      for (let b = 0; b < d - 1; ++b)
        v(e[f + b]), v(this.separator);
      if (d > 0) {
        v(e[f + d - 1]);
        for (let b = 0; b < u; ++b)
          v(this.separator), v(this.rightPad);
      } else {
        for (let b = 0; b < u - 1; ++b)
          v(this.rightPad), v(this.separator);
        v(this.rightPad);
      }
    }
  }
  // Data and splits together form the definition of the ragged tensor,
  // where data is 1 dimensional and contains the values of the tensor
  // and splits denotes the indices at which each row starts.
  compute(e, n) {
    const r = e.length, a = n.length;
    if (a > 0) {
      let c = n[0];
      if (c !== 0)
        throw new Error(`First split value must be 0, got ${c}`);
      for (let l = 1; l < a; ++l) {
        let u = n[l] >= c;
        if (u = u && n[l] <= r, !u)
          throw new Error(`Invalid split value ${n[l]}, must be in [${c}, ${r}]`);
        c = n[l];
      }
      if (c !== r)
        throw new Error(`Last split value must be data size. Expected ${r}, got ${c}`);
    }
    const s = a - 1, o = tn("int32", a);
    if (r === 0 || a === 0) {
      const c = new Array(r);
      for (let l = 0; l <= s; ++l)
        o[l] = 0;
      return [c, o];
    }
    o[0] = 0;
    for (let c = 1; c <= s; ++c) {
      const l = n[c] - n[c - 1];
      let u = 0;
      this.nGramWidths.forEach((d) => {
        u += this.getNumNGrams(l, d);
      }), this.preserveShort && l > 0 && u === 0 && (u = 1), o[c] = o[c - 1] + u;
    }
    const i = new Array(o[s]);
    for (let c = 0; c < s; ++c) {
      const l = n[c];
      let u = o[c];
      if (this.nGramWidths.forEach((d) => {
        const f = n[c + 1] - n[c], p = this.getNumNGrams(f, d);
        this.createNGrams(e, l, i, u, p, d), u += p;
      }), this.preserveShort && u === o[c]) {
        const d = n[c + 1] - n[c];
        if (d === 0)
          continue;
        const f = d + 2 * this.padWidth, p = 1;
        this.createNGrams(e, l, i, u, p, f);
      }
    }
    return [i, o];
  }
}
function L2(t, e, n, r, a, s, o, i) {
  return new sB(n, r, a, s, o, i).compute(t, e);
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oB(t, e, n, r) {
  if (!t.length)
    return;
  if (e.length === 0) {
    for (let s = 0; s < t.length; ++s)
      r.push(t.subarray(s, s + 1));
    return;
  }
  if (e.length === 1) {
    const s = e[0];
    let o = t.indexOf(s);
    for (; o !== -1; ) {
      const i = t.subarray(0, o);
      (!n || i.length !== 0) && r.push(i), t = t.subarray(o + 1), o = t.indexOf(s);
    }
    (!n || t.length !== 0) && r.push(t);
    return;
  }
  let a = 0;
  for (let s = 0; s < t.length + 1; s++)
    if (s === t.length || e.indexOf(t[s]) !== -1) {
      const o = t.subarray(a, s);
      (!n || o.length !== 0) && r.push(o), a = s + 1;
    }
}
function W2(t, e, n) {
  const r = t.length, a = [];
  let s = 0, o = 0;
  const i = new Array(r);
  for (let f = 0; f < r; ++f) {
    const p = a.length;
    oB(t[f], e, n, a);
    const h = a.length - p;
    i[f] = h, s += h, o = Math.max(o, h);
  }
  const c = tn("int32", s * 2), l = new Array(s), u = [r, o];
  let d = 0;
  for (let f = 0; f < r; ++f)
    for (let p = 0; p < i[f]; ++p)
      c[d * 2] = f, c[d * 2 + 1] = p, l[d] = a[d], ++d;
  return [c, l, u];
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z2(t, e) {
  const n = tn("int32", t.length);
  for (let r = 0; r < t.length; ++r)
    n[r] = CT(t[r]).modulo(e).getLowBitsUnsigned();
  return n;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iB = Yt((t, e) => t - e), uB = yg((t, e, n, r) => ({ real: t - n, imag: e - r })), vg = cn(rf, iB, uB), cB = {
  kernelName: rf,
  backendName: "cpu",
  kernelFunc: vg
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lB(t, e) {
  const n = new Array(t.rank);
  for (let a = 0; a < n.length; a++)
    n[a] = t.shape[a] * e[a];
  const r = Qe(n, t.dtype);
  for (let a = 0; a < r.values.length; ++a) {
    const s = r.indexToLoc(a), o = new Array(t.rank);
    for (let c = 0; c < o.length; c++)
      o[c] = s[c] % t.shape[c];
    const i = t.locToIndex(o);
    r.values[a] = t.values[i];
  }
  return r;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Oi = (t, e) => {
  const n = e.value - t.value;
  return n === 0 ? t.index - e.index : n;
};
function V2(t, e, n = 0, r = t.length - 1) {
  for (; r > n; ) {
    if (r - n > 600) {
      const i = r - n + 1, c = e - n + 1, l = Math.log(i), u = 0.5 * Math.exp(2 * l / 3), d = 0.5 * Math.sqrt(l * u * (i - u) / i) * Math.sign(c - i / 2), f = Math.max(n, Math.floor(e - c * u / i + d)), p = Math.min(r, Math.floor(e + (i - c) * u / i + d));
      V2(t, e, f, p);
    }
    const a = t[e];
    let s = n, o = r;
    for (hi(t, n, e), Oi(t[r], a) > 0 && hi(t, n, r); s < o; ) {
      for (hi(t, s, o), s++, o--; Oi(t[s], a) < 0; )
        s = s + 1;
      for (; Oi(t[o], a) > 0; )
        o = o - 1;
    }
    Oi(t[n], a) === 0 ? hi(t, n, o) : (o = o + 1, hi(t, o, r)), o <= e && (n = o + 1), e <= o && (r = o - 1);
  }
}
function dB(t, e, n, r, a) {
  const s = e[e.length - 1], [o, i] = [t.length / s, s], c = Dn(n, o * r), l = Dn("int32", o * r);
  for (let d = 0; d < o; d++) {
    const f = d * i, p = t.subarray(f, f + i);
    let h = new Array(p.length);
    p.forEach((b, w) => h[w] = { value: b, index: w }), r < h.length && (V2(h, r), h = h.slice(0, r)), a && h.sort(Oi);
    const m = d * r, g = c.subarray(m, m + r), v = l.subarray(m, m + r);
    for (let b = 0; b < r; b++)
      g[b] = h[b].value, v[b] = h[b].index;
  }
  const u = e.slice();
  return u[u.length - 1] = r, [
    Qe(u, n, c),
    Qe(u, "int32", l)
  ];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H2(t, e, n, r) {
  const a = Vt(e, n)[0], s = [1, n[0], 1];
  for (let h = 0; h < a; h++)
    s[0] *= n[h];
  s[1] = n[a];
  for (let h = a + 1; h < n.length; h++)
    s[2] *= n[h];
  const o = /* @__PURE__ */ new Map(), i = new Int32Array(n[a]), c = new on(s, r, t), l = [], u = s[0] === 1 && s[2] === 1;
  for (let h = 0; h < n[a]; h++) {
    let m;
    if (u)
      m = t[h].toString();
    else {
      const v = [];
      for (let b = 0; b < s[0]; b++)
        for (let w = 0; w < s[2]; w++)
          v.push(c.get(b, h, w));
      m = v.join(",");
    }
    const g = o.get(m);
    if (g != null)
      i[h] = g;
    else {
      const v = o.size;
      o.set(m, v), i[h] = v, l.push(h);
    }
  }
  const d = s.slice();
  d[1] = o.size;
  const f = new on(d, r);
  l.forEach((h, m) => {
    for (let g = 0; g < s[0]; g++)
      for (let v = 0; v < s[2]; v++)
        f.set(c.get(g, h, v), g, m, v);
  });
  const p = n.slice();
  return p[a] = d[1], {
    outputValues: f.values,
    outputShape: p,
    indices: i
  };
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zs(t) {
  const { inputs: { x: e }, attrs: { begin: n, size: r }, backend: a } = t, [s, o] = Gw(e, n, r), i = jw(e.shape, s, o), c = a.readSync(e.dataId), l = a.makeOutput(o, e.dtype), u = Ie(e.shape), d = a.dataIdMap.get(l.dataId);
  if (i) {
    const h = Uw(s, u);
    return e.dtype === "string" ? d.stringBytes = c.slice(h, h + Y(o)) : a.typedArrayFromHeap(l).set(c.subarray(h, h + Y(o))), l;
  }
  if (e.dtype === "string") {
    const h = yh(c, s, o, e.shape, e.dtype);
    return d.stringBytes = h, l;
  }
  const f = a.typedArrayFromHeap(l), p = e.shape.length;
  if (p === 2)
    fB(c, u[0], f, s, o);
  else if (p === 3)
    pB(c, u[0], u[1], f, s, o);
  else if (p === 4)
    hB(c, u[0], u[1], u[2], f, s, o);
  else {
    const h = yh(c, s, o, e.shape, e.dtype);
    f.set(h);
  }
  return l;
}
function fB(t, e, n, r, a) {
  let s = 0;
  const o = r[0], i = r[1], c = o + a[0];
  for (let l = o; l < c; l++) {
    const u = l * e + i;
    n.set(t.subarray(u, u + a[1]), s), s += a[1];
  }
}
function pB(t, e, n, r, a, s) {
  let o = 0;
  const i = a[0], c = a[1], l = a[2], u = i + s[0], d = c + s[1];
  for (let f = i; f < u; f++)
    for (let p = c; p < d; p++) {
      const h = f * e + p * n + l;
      r.set(t.subarray(h, h + s[2]), o), o += s[2];
    }
}
function hB(t, e, n, r, a, s, o) {
  let i = 0;
  const c = s[0], l = s[1], u = s[2], d = c + o[0], f = l + o[1], p = u + o[2], h = s[3];
  for (let m = c; m < d; m++)
    for (let g = l; g < f; g++)
      for (let v = u; v < p; v++) {
        const b = m * e + g * n + v * r + h;
        a.set(t.subarray(b, b + o[3]), i), i += o[3];
      }
}
const mB = {
  kernelName: $m,
  backendName: "wasm",
  kernelFunc: zs
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gB(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { blockShape: s, crops: o } = r, i = s.reduce((v, b) => v * b), c = wf(a.shape, s, i), l = Sf(c.length, s.length), u = _f(a.shape, s, i), d = Yw(o, s.length), f = Zw(u, o, s.length), p = jn({ inputs: { x: a }, backend: n, attrs: { shape: c } }), h = Ga({ inputs: { x: p }, backend: n, attrs: { perm: l } }), m = jn({ inputs: { x: h }, backend: n, attrs: { shape: u } }), g = zs({
    inputs: { x: m },
    backend: n,
    attrs: { begin: d, size: f }
  });
  return n.disposeData(p.dataId), n.disposeData(h.dataId), n.disposeData(m.dataId), g;
}
const yB = {
  kernelName: dm,
  backendName: "wasm",
  kernelFunc: gB
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let j2;
function vB(t) {
  j2 = t.wasm.cwrap(kl, null, [
    "number",
    "number",
    "boolean",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function bB(t) {
  const { backend: e, inputs: n, attrs: r } = t, { x: a, weights: s } = n, { size: o } = r, i = s.shape.reduce((d, f) => d * f, 1) !== 0, c = a.shape.length === 1 ? [o] : [a.shape[0], o], l = e.makeOutput(c, s.dtype);
  function u(d) {
    return e.dataIdMap.get(d.dataId).id;
  }
  return j2(u(a), o, i, u(s), dt[s.dtype], u(l)), l;
}
const wB = {
  kernelName: kl,
  backendName: "wasm",
  setupFunc: vB,
  kernelFunc: bB
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SB = nn(El);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _B(t) {
  const { inputs: e, backend: n } = t, { s0: r, s1: a } = e, s = n.typedArrayFromHeap(r), o = n.typedArrayFromHeap(a), i = At(Array.from(s), Array.from(o));
  return n.makeOutput(
    [i.length],
    "int32",
    /*memoryOffset=*/
    void 0,
    /*values=*/
    new Int32Array(i)
  );
}
const xB = {
  kernelName: fm,
  backendName: "wasm",
  kernelFunc: _B
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ns(t) {
  const { inputs: { x: e }, attrs: { dtype: n }, backend: r } = t, a = r.makeOutput(e.shape, n), s = r.typedArrayFromHeap(e);
  return r.typedArrayFromHeap(a).set(s), a;
}
const IB = {
  kernelName: Tl,
  backendName: "wasm",
  kernelFunc: ns
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kB = rt(Cl);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let U2;
function EB(t) {
  U2 = t.wasm.cwrap(Tu, null, [
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function TB(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { clipValueMin: s, clipValueMax: o } = r, i = n.dataIdMap.get(a.dataId).id, c = n.makeOutput(a.shape, a.dtype), l = n.dataIdMap.get(c.dataId).id;
  return U2(i, s, o, l), c;
}
const CB = {
  kernelName: Tu,
  backendName: "wasm",
  setupFunc: EB,
  kernelFunc: TB
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function G2(t) {
  const { inputs: e, backend: n } = t, r = Vt(t.attrs.axis, e[0].shape)[0], a = e.map((p) => p.shape);
  Kw(a, r);
  let s = _o(e.map((p) => p.shape), r);
  const o = e.filter((p) => Y(p.shape) > 0);
  if (o.length === 1)
    return xf({ inputs: { x: o[0] }, backend: n });
  const i = n.makeOutput(s, e[0].dtype);
  if (Y(s) === 0)
    return i;
  if (o[0].dtype === "string") {
    const p = o.map((w) => {
      const I = [-1, Y(w.shape.slice(r))];
      return jn({ inputs: { x: w }, backend: n, attrs: { shape: I } });
    }), h = p.map((w) => ({ vals: n.readSync(w.dataId), shape: w.shape }));
    s = _o(
      p.map((w) => w.shape),
      1
      /* axis */
    );
    const m = p[0].shape[0] === 1, g = R2(h, s, e[0].dtype, m), v = _o(o.map((w) => w.shape), r);
    i.shape = v;
    const b = n.dataIdMap.get(i.dataId);
    return b.stringBytes = f2(g), p.forEach((w) => n.disposeData(w.dataId)), i;
  }
  const c = Y(o[0].shape.slice(0, r));
  let l = 0;
  const u = o.map((p) => {
    const h = Y(p.shape.slice(r));
    return l += h, h;
  }), d = o.map((p) => n.typedArrayFromHeap(p)), f = n.typedArrayFromHeap(i);
  for (let p = 0; p < c; p++) {
    let h = p * l;
    for (let m = 0; m < d.length; m++) {
      const g = u[m], v = p * g, b = d[m].subarray(v, v + g);
      f.set(b, h), h += g;
    }
  }
  return i;
}
const NB = {
  kernelName: pm,
  backendName: "wasm",
  kernelFunc: G2
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let q2;
function AB(t) {
  q2 = t.wasm.cwrap(Nl, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function RB(t) {
  const { inputs: e, attrs: n, backend: r } = t, { x: a, filter: s } = e, o = r.dataIdMap.get(a.dataId).id, i = r.dataIdMap.get(s.dataId).id, { strides: c, dilations: l, pad: u, dimRoundingMode: d, dataFormat: f } = n, p = zo(f), h = Kn(a.shape, s.shape, c, l, u, d, !1, p), m = h.filterHeight, g = h.filterWidth, v = h.padInfo.top, b = h.padInfo.right, w = h.padInfo.bottom, S = h.padInfo.left, I = h.dilationHeight, E = h.dilationWidth, T = h.strideHeight, R = h.strideWidth, $ = h.inChannels, D = h.outChannels, M = h.padInfo.type === "SAME" ? 1 : 0;
  if (h.dataFormat !== "channelsLast")
    throw new Error(`wasm backend Conv2D does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);
  const z = r.makeOutput(h.outShape, "float32"), F = r.dataIdMap.get(z.dataId).id;
  return q2(o, a.shape[0], a.shape[1], a.shape[2], i, m, g, v, b, w, S, M, I, E, T, R, $, D, F), z;
}
const $B = {
  kernelName: Nl,
  backendName: "wasm",
  setupFunc: AB,
  kernelFunc: RB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let K2;
function DB(t) {
  K2 = t.wasm.cwrap(Al, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function OB(t) {
  const { backend: e, inputs: n, attrs: r } = t, { dy: a, filter: s } = n, { strides: o, pad: i, dataFormat: c, dimRoundingMode: l, inputShape: u } = r, d = 1, f = zo(c), p = Kn(u, s.shape, o, d, i, l, !1, f), { batchSize: h, filterHeight: m, filterWidth: g, inChannels: v, inHeight: b, inWidth: w, outChannels: S, outHeight: I, outWidth: E, strideHeight: T, strideWidth: R } = p, $ = m - 1 - p.padInfo.top, D = g - 1 - p.padInfo.left, M = p.dataFormat === "channelsLast", z = Ie(p.inShape), F = Ie(a.shape), [V, H, U] = Ie(s.shape), Z = z[0], q = M ? z[1] : z[2], X = M ? z[2] : 1, se = M ? 1 : z[1], te = F[0], ue = M ? F[1] : F[2], ee = M ? F[2] : 1, ne = M ? 1 : F[1], oe = e.makeOutput(p.inShape, "float32"), ge = e.dataIdMap.get(oe.dataId).id, be = e.dataIdMap.get(a.dataId).id, fe = e.dataIdMap.get(s.dataId).id;
  return K2(be, fe, h, m, g, b, w, v, I, E, S, T, R, $, D, V, H, U, Z, q, X, se, te, ue, ee, ne, ge), oe;
}
const FB = {
  kernelName: Al,
  backendName: "wasm",
  setupFunc: DB,
  kernelFunc: OB
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let X2;
function MB(t) {
  X2 = t.wasm.cwrap(Rl, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function PB(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s } = e, { strides: o, pad: i, dilations: c } = r;
  if (a.dtype !== "float32")
    throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);
  if (s.dtype !== "float32")
    throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
  const l = Us(a.shape, s.shape, o, c, i), u = n.makeOutput(l.outShape, a.dtype);
  return X2(n.dataIdMap.get(a.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(u.dataId).id, l.batchSize, l.inDepth, l.inHeight, l.inWidth, l.inChannels, l.outDepth, l.outHeight, l.outWidth, l.outChannels, l.strideDepth, l.strideHeight, l.strideWidth, l.dilationDepth, l.dilationHeight, l.dilationWidth, l.filterDepth, l.filterHeight, l.filterWidth, l.padInfo.front, l.padInfo.top, l.padInfo.left), u;
}
const BB = {
  kernelName: Rl,
  backendName: "wasm",
  setupFunc: MB,
  kernelFunc: PB
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let Y2;
function LB(t) {
  Y2 = t.wasm.cwrap(hm, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function WB(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, dy: s } = e, { strides: o, pad: i, filterShape: c } = r;
  if (a.dtype !== "float32")
    throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);
  if (s.dtype !== "float32")
    throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
  const l = Us(
    a.shape,
    c,
    o,
    /*dilations=*/
    1,
    i
  ), u = n.makeOutput(l.filterShape, s.dtype);
  return Y2(n.dataIdMap.get(a.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(u.dataId).id, l.batchSize, l.inDepth, l.inHeight, l.inWidth, l.inChannels, l.outDepth, l.outHeight, l.outWidth, l.outChannels, l.strideDepth, l.strideHeight, l.strideWidth, l.dilationDepth, l.dilationHeight, l.dilationWidth, l.filterDepth, l.filterHeight, l.filterWidth, l.padInfo.front, l.padInfo.top, l.padInfo.left), u;
}
const zB = {
  kernelName: hm,
  backendName: "wasm",
  setupFunc: LB,
  kernelFunc: WB
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let Z2;
function VB(t) {
  Z2 = t.wasm.cwrap($l, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function HB(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, filter: s } = e, { pad: o, strides: i, inputShape: c } = r;
  if (a.dtype !== "float32")
    throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);
  if (s.dtype !== "float32")
    throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
  const l = Us(
    c,
    s.shape,
    i,
    /*dilations=*/
    1,
    o
  ), u = n.makeOutput(l.inShape, a.dtype);
  return Z2(n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(a.dataId).id, n.dataIdMap.get(u.dataId).id, l.batchSize, l.inDepth, l.inHeight, l.inWidth, l.inChannels, l.outDepth, l.outHeight, l.outWidth, l.outChannels, l.strideDepth, l.strideHeight, l.strideWidth, l.dilationDepth, l.dilationHeight, l.dilationWidth, l.filterDepth, l.filterHeight, l.filterWidth, l.padInfo.front, l.padInfo.top, l.padInfo.left), u;
}
const jB = {
  kernelName: $l,
  backendName: "wasm",
  setupFunc: VB,
  kernelFunc: HB
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UB = rt(Dl);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GB = rt(Ol);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var vh;
(function(t) {
  t[t.bilinear = 0] = "bilinear", t[t.nearest = 1] = "nearest";
})(vh || (vh = {}));
let J2;
function qB(t) {
  J2 = t.wasm.cwrap(Pl, null, [
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number"
    // out id
  ]);
}
function KB(t) {
  const { backend: e, inputs: n, attrs: r } = t, { method: a, extrapolationValue: s, cropSize: o } = r, { image: i, boxes: c, boxInd: l } = n, u = c.shape[0], [d, f] = o, p = [u, d, f, i.shape[3]];
  let h = e.dataIdMap.get(i.dataId), m;
  i.dtype !== "float32" && (m = ns({ backend: e, inputs: { x: i }, attrs: { dtype: "float32" } }), h = e.dataIdMap.get(m.dataId));
  const g = h.id, v = e.dataIdMap.get(c.dataId).id, b = e.dataIdMap.get(l.dataId).id, w = e.makeOutput(p, "float32"), S = e.dataIdMap.get(w.dataId).id, I = new Uint8Array(new Int32Array(i.shape).buffer);
  return J2(g, v, b, u, I, d, f, vh[a], s, S), m != null && e.disposeData(m.dataId), w;
}
const XB = {
  kernelName: Pl,
  backendName: "wasm",
  setupFunc: qB,
  kernelFunc: KB
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let Q2;
function YB(t) {
  Q2 = t.wasm.cwrap(Fl, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // dtype
  ]);
}
function ZB(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, exclusive: o, reverse: i } = r, c = a.shape.length;
  A(a.dtype === "float32" || a.dtype === "int32", () => `cumprod does not support ${a.dtype} tensors in the WASM backend`);
  const l = pr([s], c);
  let u = a;
  l !== null && (u = Ga({ inputs: { x: a }, attrs: { perm: l }, backend: n }));
  const d = Mn(1, c)[0];
  Fn("cumprod", [d], c);
  const f = n.makeOutput(u.shape, u.dtype), p = u.shape[d], h = n.dataIdMap.get(u.dataId).id, m = n.dataIdMap.get(f.dataId).id;
  Q2(h, o ? 1 : 0, i ? 1 : 0, p, m, dt[a.dtype]);
  let g = f;
  if (l !== null) {
    const v = pf(l);
    g = Ga({ inputs: { x: f }, attrs: { perm: v }, backend: n }), n.disposeData(u.dataId), n.disposeData(f.dataId);
  }
  return g;
}
const JB = {
  kernelName: Fl,
  backendName: "wasm",
  setupFunc: YB,
  kernelFunc: ZB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let eS;
function QB(t) {
  eS = t.wasm.cwrap(Ml, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // dtype
  ]);
}
function eL(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, exclusive: o, reverse: i } = r, c = a.shape.length;
  A(a.dtype === "float32" || a.dtype === "int32", () => `cumsum does not support ${a.dtype} tensors in the WASM backend`);
  const l = pr([s], c);
  let u = a;
  l !== null && (u = Ga({ inputs: { x: a }, attrs: { perm: l }, backend: n }));
  const d = Mn(1, c)[0];
  Fn("cumsum", [d], c);
  const f = n.makeOutput(u.shape, u.dtype), p = u.shape[d], h = n.dataIdMap.get(u.dataId).id, m = n.dataIdMap.get(f.dataId).id;
  eS(h, o ? 1 : 0, i ? 1 : 0, p, m, dt[a.dtype]);
  let g = f;
  if (l !== null) {
    const v = pf(l);
    g = Ga({ inputs: { x: f }, attrs: { perm: v }, backend: n }), n.disposeData(u.dataId), n.disposeData(f.dataId);
  }
  return g;
}
const tL = {
  kernelName: Ml,
  backendName: "wasm",
  setupFunc: QB,
  kernelFunc: eL
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let tS;
function nL(t) {
  tS = t.wasm.cwrap("DenseBincount", null, [
    "number",
    "array",
    "number",
    "number",
    "boolean",
    "number",
    "number",
    "boolean",
    "number"
    // outId
  ]);
}
function rL(t) {
  const { backend: e, inputs: n, attrs: r } = t, { x: a, weights: s } = n, { size: o, binaryOutput: i } = r, c = s.shape.reduce((f, p) => f * p, 1) !== 0, l = a.shape.length === 1 ? [o] : [a.shape[0], o], u = e.makeOutput(l, s.dtype);
  function d(f) {
    return e.dataIdMap.get(f.dataId).id;
  }
  return tS(d(a), new Uint8Array(new Int32Array(a.shape).buffer), a.shape.length, o, c, d(s), dt[s.dtype], i, d(u)), u;
}
const aL = {
  kernelName: mm,
  backendName: "wasm",
  setupFunc: nL,
  kernelFunc: rL
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let nS;
function sL(t) {
  nS = t.wasm.cwrap(Bl, null, [
    "number",
    "number",
    "number",
    "array",
    "number",
    "array",
    "array",
    "number",
    "number"
    // outId
  ]);
}
function oL(t) {
  const { backend: e, inputs: n, attrs: r } = t, { x: a } = n, { blockSize: s, dataFormat: o } = r, i = a.shape[0], c = o === "NHWC" ? a.shape[1] : a.shape[2], l = o === "NHWC" ? a.shape[2] : a.shape[3], u = o === "NHWC" ? a.shape[3] : a.shape[1], d = c * s, f = l * s, p = u / (s * s), h = o === "NHWC" ? [i, d, f, p] : [i, p, d, f], m = e.makeOutput(h, "float32"), v = e.dataIdMap.get(a.dataId).id, b = new Uint8Array(new Int32Array(Ie(a.shape)).buffer), w = new Uint8Array(new Int32Array(h).buffer), S = new Uint8Array(new Int32Array(Ie(h)).buffer), I = e.dataIdMap.get(m.dataId).id;
  return nS(v, s, o === "NHWC" ? 1 : 0, b, a.shape.length - 1, w, S, h.length, I), m;
}
const iL = {
  kernelName: Bl,
  backendName: "wasm",
  setupFunc: sL,
  kernelFunc: oL
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let rS;
function uL(t) {
  rS = t.wasm.cwrap(Ll, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function cL(t) {
  const { inputs: e, attrs: n, backend: r } = t, { x: a, filter: s } = e, o = r.dataIdMap.get(a.dataId).id, i = r.dataIdMap.get(s.dataId).id, { strides: c, dilations: l, pad: u, dimRoundingMode: d } = n, f = l ?? [1, 1], p = Kn(
    a.shape,
    s.shape,
    c,
    f,
    u,
    d,
    !0
    /* depthwise */
  ), h = p.filterHeight, m = p.filterWidth, g = p.padInfo.top, v = p.padInfo.right, b = p.padInfo.bottom, w = p.padInfo.left, S = p.dilationHeight, I = p.dilationWidth, E = p.strideHeight, T = p.strideWidth, R = p.inChannels, $ = p.outChannels, D = p.padInfo.type === "SAME" ? 1 : 0;
  if (p.dataFormat !== "channelsLast")
    throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);
  const M = r.makeOutput(p.outShape, "float32"), z = r.dataIdMap.get(M.dataId).id;
  return rS(o, a.shape[0], a.shape[1], a.shape[2], i, h, m, g, v, b, w, D, S, I, E, T, R, $, z), M;
}
const lL = {
  kernelName: Ll,
  backendName: "wasm",
  setupFunc: uL,
  kernelFunc: cL
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let aS;
function dL(t) {
  aS = t.wasm.cwrap("Diag", null, [
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function fL(t) {
  const { inputs: e, backend: n } = t, { x: r } = e, a = Y(r.shape), s = n.makeOutput([...r.shape, ...r.shape], r.dtype);
  return aS(n.dataIdMap.get(r.dataId).id, dt[r.dtype], a, n.dataIdMap.get(s.dataId).id), s;
}
const pL = {
  kernelName: gm,
  backendName: "wasm",
  setupFunc: dL,
  kernelFunc: fL
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let sS;
function hL(t) {
  sS = t.wasm.cwrap(Wl, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function mL(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s } = e, { strides: o, pad: i, dilations: c } = r;
  if (a.dtype !== s.dtype)
    throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);
  const l = Wo(
    a.shape,
    s.shape,
    o,
    i,
    /*dataFormat=*/
    "NHWC",
    c
  ), u = n.makeOutput(l.outShape, a.dtype);
  return sS(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(s.dataId).id,
    n.dataIdMap.get(u.dataId).id,
    dt[a.dtype],
    l.batchSize,
    /*depth=*/
    l.inChannels,
    l.inHeight,
    l.inWidth,
    l.outHeight,
    l.outWidth,
    l.strideHeight,
    l.strideWidth,
    l.dilationHeight,
    l.dilationWidth,
    l.filterHeight,
    l.filterWidth,
    l.padInfo.top,
    l.padInfo.left
  ), u;
}
const gL = {
  kernelName: Wl,
  backendName: "wasm",
  setupFunc: hL,
  kernelFunc: mL
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let oS;
function yL(t) {
  oS = t.wasm.cwrap(Dc, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function vL(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s, dy: o } = e, { strides: i, pad: c, dilations: l } = r;
  if (a.dtype !== s.dtype || a.dtype !== o.dtype)
    throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${o.dtype}`);
  const u = Wo(
    a.shape,
    s.shape,
    i,
    c,
    /*dataFormat=*/
    "NHWC",
    l
  ), d = n.makeOutput(s.shape, s.dtype);
  return oS(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(s.dataId).id,
    n.dataIdMap.get(o.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    dt[a.dtype],
    u.batchSize,
    /*depth=*/
    u.inChannels,
    u.inHeight,
    u.inWidth,
    u.outHeight,
    u.outWidth,
    u.strideHeight,
    u.strideWidth,
    u.dilationHeight,
    u.dilationWidth,
    u.filterHeight,
    u.filterWidth,
    u.padInfo.top,
    u.padInfo.left
  ), d;
}
const bL = {
  kernelName: Dc,
  backendName: "wasm",
  setupFunc: yL,
  kernelFunc: vL
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let iS;
function wL(t) {
  iS = t.wasm.cwrap($c, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function SL(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s, dy: o } = e, { strides: i, pad: c, dilations: l } = r;
  if (a.dtype !== s.dtype || a.dtype !== o.dtype)
    throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${o.dtype}`);
  const u = Wo(
    a.shape,
    s.shape,
    i,
    c,
    /*dataFormat=*/
    "NHWC",
    l
  ), d = n.makeOutput(a.shape, a.dtype);
  return iS(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(s.dataId).id,
    n.dataIdMap.get(o.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    dt[a.dtype],
    u.batchSize,
    /*depth=*/
    u.inChannels,
    u.inHeight,
    u.inWidth,
    u.outHeight,
    u.outWidth,
    u.strideHeight,
    u.strideWidth,
    u.dilationHeight,
    u.dilationWidth,
    u.filterHeight,
    u.filterWidth,
    u.padInfo.top,
    u.padInfo.left
  ), d;
}
const _L = {
  kernelName: $c,
  backendName: "wasm",
  setupFunc: wL,
  kernelFunc: SL
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xL = rt(Vl);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let uS;
function IL(t) {
  uS = t.wasm.cwrap(ym, null, [
    "number",
    "number",
    "number"
    // outId
  ]);
}
function kL(t) {
  const { inputs: e, backend: n } = t, { dy: r, y: a } = e, s = n.makeOutput(a.shape, "float32"), o = (i) => n.dataIdMap.get(i.dataId).id;
  return uS(o(a), o(r), o(s)), s;
}
const EL = {
  kernelName: ym,
  backendName: "wasm",
  setupFunc: IL,
  kernelFunc: kL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TL = !1, CL = nn(jl, TL, "bool");
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NL = rt(Hl);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AL = rt(Ul, "float32");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bh(t) {
  const { inputs: e, attrs: n, backend: r } = t, { input: a } = e, { dim: s } = n, o = a.shape.length, i = a.shape.slice();
  let c = s;
  return s < 0 && (A(-(o + 1) <= s, () => `Axis must be in the interval [${-(o + 1)}, ${o}]`), c = o + s + 1), i.splice(c, 0, 1), jn({ inputs: { x: a }, backend: r, attrs: { shape: i } });
}
const RL = {
  kernelName: vm,
  backendName: "wasm",
  kernelFunc: bh
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $L = rt(Gl, "float32");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cS(t) {
  const { attrs: { shape: e, value: n, dtype: r }, backend: a } = t, s = a.makeOutput(e, r);
  return a.typedArrayFromHeap(s).fill(n), s;
}
const DL = {
  kernelName: bm,
  backendName: "wasm",
  kernelFunc: cS
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let lS;
function OL(t) {
  lS = t.wasm.cwrap(ql, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function FL(t) {
  const { inputs: e, backend: n } = t, { image: r } = e, a = n.makeOutput(r.shape, r.dtype), s = n.dataIdMap.get(r.dataId).id, o = n.dataIdMap.get(a.dataId).id, [i, c, l, u] = r.shape;
  return lS(s, i, c, l, u, o), a;
}
const ML = {
  kernelName: ql,
  backendName: "wasm",
  kernelFunc: FL,
  setupFunc: OL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PL = rt(Kl);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BL = nn(Xl);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let dS;
function LL(t) {
  dS = t.wasm.cwrap(Yl, null, ["number", "number", "number", "number", "number", "number", "number"]);
}
function WL(t) {
  const { backend: e, inputs: n, attrs: r } = t, { varianceEpsilon: a } = r, { x: s, mean: o, variance: i, offset: c, scale: l } = n, u = e.dataIdMap.get(s.dataId).id, d = e.dataIdMap.get(o.dataId).id, f = e.dataIdMap.get(i.dataId).id, p = c != null ? e.dataIdMap.get(c.dataId).id : 0, h = l != null ? e.dataIdMap.get(l.dataId).id : 0, m = e.makeOutput(s.shape, s.dtype);
  if (Y(s.shape) === 0)
    return m;
  const g = e.dataIdMap.get(m.dataId).id;
  return dS(u, d, f, p, h, a, g), m;
}
const zL = {
  kernelName: Yl,
  backendName: "wasm",
  setupFunc: LL,
  kernelFunc: WL
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let fS;
function VL(t) {
  fS = t.wasm.cwrap(tu, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function HL(t) {
  const { inputs: e, attrs: n, backend: r } = t, { x: a, filter: s, bias: o, preluActivationWeights: i } = e, { strides: c, pad: l, dilations: u, dataFormat: d, dimRoundingMode: f, activation: p, leakyreluAlpha: h } = n, m = Kn(a.shape, s.shape, c, u, l, f), g = pu[p];
  if (g == null)
    throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);
  const v = r.dataIdMap.get(a.dataId).id, b = r.dataIdMap.get(s.dataId).id, w = m.outChannels;
  let S = 0;
  if (o != null) {
    const ee = r.dataIdMap.get(o.dataId);
    if (ee.shape.length !== 1)
      throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ee.shape.length}.`);
    if (ee.shape[0] !== w)
      throw new Error(`FusedConv2D bias shape (${ee.shape}) does not match the number of output channels (${w})`);
    S = ee.id;
  }
  const I = m.filterHeight, E = m.filterWidth, T = m.padInfo.top, R = m.padInfo.right, $ = m.padInfo.bottom, D = m.padInfo.left, M = m.dilationHeight, z = m.dilationWidth, F = m.strideHeight, V = m.strideWidth, H = m.inChannels, U = m.padInfo.type === "SAME" ? 1 : 0, Z = m.batchSize, q = m.inHeight, X = m.inWidth;
  if (d !== "NHWC")
    throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);
  const se = r.makeOutput(m.outShape, "float32"), te = r.dataIdMap.get(se.dataId).id, ue = i == null ? 0 : r.dataIdMap.get(i.dataId).id;
  return fS(v, Z, q, X, b, I, E, S, T, R, $, D, U, M, z, F, V, H, w, g, ue, h || 0, te), se;
}
const jL = {
  kernelName: tu,
  backendName: "wasm",
  setupFunc: VL,
  kernelFunc: HL
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let pS;
function UL(t) {
  pS = t.wasm.cwrap(nu, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function GL(t) {
  const { inputs: e, attrs: n, backend: r } = t, { x: a, filter: s, bias: o, preluActivationWeights: i } = e, { strides: c, pad: l, dilations: u, dataFormat: d, dimRoundingMode: f, activation: p, leakyreluAlpha: h } = n, m = Kn(
    a.shape,
    s.shape,
    c,
    u,
    l,
    f,
    !0
    /* depthwise */
  ), g = pu[p];
  if (g == null)
    throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
  const v = r.dataIdMap.get(a.dataId).id, b = r.dataIdMap.get(s.dataId).id, w = m.outChannels;
  let S = 0;
  if (o != null) {
    const ee = r.dataIdMap.get(o.dataId);
    if (ee.shape.length !== 1)
      throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ee.shape.length}.`);
    if (ee.shape[0] !== w)
      throw new Error(`FusedDepthwiseConv2D bias shape (${ee.shape}) does not match the number of output channels (${w})`);
    S = ee.id;
  }
  const I = m.filterHeight, E = m.filterWidth, T = m.padInfo.top, R = m.padInfo.right, $ = m.padInfo.bottom, D = m.padInfo.left, M = m.dilationHeight, z = m.dilationWidth, F = m.strideHeight, V = m.strideWidth, H = m.inChannels, U = m.padInfo.type === "SAME" ? 1 : 0, Z = m.batchSize, q = m.inHeight, X = m.inWidth;
  if (d !== "NHWC")
    throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);
  const se = r.makeOutput(m.outShape, "float32"), te = r.dataIdMap.get(se.dataId).id, ue = i == null ? 0 : r.dataIdMap.get(i.dataId).id;
  return pS(v, Z, q, X, b, I, E, S, T, R, $, D, U, M, z, F, V, H, w, g, ue, h || 0, te), se;
}
const qL = {
  kernelName: nu,
  backendName: "wasm",
  setupFunc: UL,
  kernelFunc: GL
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let hS;
function KL(t) {
  hS = t.wasm.cwrap(Zl, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number"
    // outId
  ]);
}
function XL(t) {
  const { backend: e, inputs: n } = t, { params: r, indices: a } = n, [s, o, i, c] = Vw(r, a), l = e.makeOutput(s, r.dtype);
  if (o === 0)
    return l;
  const u = a.shape, d = u[u.length - 1], p = e.dataIdMap.get(r.dataId).id, m = e.dataIdMap.get(a.dataId).id, g = new Uint8Array(new Int32Array(c).buffer), v = e.dataIdMap.get(l.dataId).id;
  return hS(p, dt[r.dtype], m, o, d, i, g, v), l;
}
const YL = {
  kernelName: Zl,
  backendName: "wasm",
  setupFunc: KL,
  kernelFunc: XL
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let mS;
function ZL(t) {
  mS = t.wasm.cwrap("Gather", null, [
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "array",
    "number"
    // outId
  ]);
}
function JL(t) {
  const { backend: e, inputs: n, attrs: r } = t, { x: a, indices: s } = n, { axis: o, batchDims: i } = r, c = Vt(o, a.shape)[0], l = e.readSync(s.dataId), u = a.shape[c];
  for (let $ = 0; $ < l.length; ++$) {
    const D = l[$];
    A(D <= u - 1 && D >= 0, () => `GatherV2: the index value ${D} is not in [0, ${u - 1}]`);
  }
  const d = d2(a, s, c, i), f = jn({
    inputs: { x: a },
    attrs: {
      shape: [
        d.batchSize,
        d.outerSize,
        d.dimSize,
        d.sliceSize
      ]
    },
    backend: e
  }), p = Y(s.shape), h = jn({
    inputs: { x: s },
    attrs: { shape: [d.batchSize, p / d.batchSize] },
    backend: e
  }), m = [
    d.batchSize,
    d.outerSize,
    p / d.batchSize,
    d.sliceSize
  ], g = e.makeOutput(m, a.dtype);
  if (Y(a.shape) === 0)
    return g;
  const v = f.shape.length - 1, w = e.dataIdMap.get(f.dataId).id, I = e.dataIdMap.get(h.dataId).id, E = e.dataIdMap.get(g.dataId).id, T = new Uint8Array(new Int32Array(Ie(f.shape)).buffer), R = new Uint8Array(new Int32Array(Ie(m)).buffer);
  return mS(w, dt[a.dtype], T, v, I, d.batchSize, R, E), e.disposeData(f.dataId), e.disposeData(h.dataId), g.shape = d.outputShape, g;
}
const QL = {
  kernelName: wm,
  backendName: "wasm",
  setupFunc: ZL,
  kernelFunc: JL
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const e7 = !1, t7 = nn(Jl, e7, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const n7 = !1, r7 = nn(Ql, n7, "bool");
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const a7 = rt(td, "bool");
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s7 = rt(nd, "bool");
/**
 * @license
 * Copyright 2022 The TensorFlow Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const o7 = rt(rd, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let gS;
function i7(t) {
  gS = t.wasm.cwrap(ad, null, [
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function u7(t) {
  const { inputs: { x: e }, attrs: { alpha: n }, backend: r } = t, a = r.dataIdMap.get(e.dataId).id, s = r.makeOutput(e.shape, "float32");
  if (Y(e.shape) !== 0) {
    const o = r.dataIdMap.get(s.dataId).id;
    gS(a, dt[e.dtype], n, o);
  }
  return s;
}
const c7 = {
  kernelName: ad,
  backendName: "wasm",
  setupFunc: i7,
  kernelFunc: u7
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const l7 = !1, d7 = nn(sd, l7, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const f7 = !1, p7 = nn(od, f7, "bool");
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let yS;
function h7(t) {
  yS = t.wasm.cwrap(id, null, [
    "number",
    "number",
    "number",
    "number"
    // num
  ]);
}
function m7(t) {
  const { attrs: e, backend: n } = t, { start: r, stop: a, num: s } = e, o = Math.floor(s), i = n.makeOutput([o], "float32");
  return yS(n.dataIdMap.get(i.dataId).id, r, a, o), i;
}
const g7 = {
  kernelName: id,
  backendName: "wasm",
  setupFunc: h7,
  kernelFunc: m7
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const y7 = rt(ud);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const v7 = rt(cd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const b7 = !1, w7 = nn(ld, b7, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const S7 = rt(dd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _7 = !1, x7 = nn(fd, _7, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const I7 = !1, k7 = nn(wT, I7, "bool");
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let vS;
function E7(t) {
  vS = t.wasm.cwrap(pd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // beta
  ]);
}
function T7(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { depthRadius: s, bias: o, alpha: i, beta: c } = r;
  if (a.dtype !== "float32")
    throw new Error("LRN error: x must have dtype float32");
  const l = n.makeOutput(a.shape, a.dtype);
  return vS(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(l.dataId).id,
    /*channels=*/
    a.shape[3],
    s,
    o,
    i,
    c
  ), l;
}
const C7 = {
  kernelName: pd,
  backendName: "wasm",
  setupFunc: E7,
  kernelFunc: T7
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let bS;
function N7(t) {
  bS = t.wasm.cwrap(Sm, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // beta
  ]);
}
function A7(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, y: s, dy: o } = e, { depthRadius: i, bias: c, alpha: l, beta: u } = r;
  if (a.dtype !== "float32" || s.dtype !== "float32" || o.dtype !== "float32")
    throw new Error("LRNGrad error: x, y, and dy must have dtype float32");
  const d = n.makeOutput(a.shape, a.dtype);
  return bS(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(s.dataId).id,
    n.dataIdMap.get(o.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    /*channels=*/
    o.shape[3],
    i,
    c,
    l,
    u
  ), d;
}
const R7 = {
  kernelName: Sm,
  backendName: "wasm",
  setupFunc: N7,
  kernelFunc: A7
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wS;
function $7(t) {
  wS = t.wasm.cwrap(hd, null, [
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function D7(t) {
  const { backend: e, inputs: n, attrs: r } = t, { reductionIndices: a, keepDims: s } = r, { x: o } = n;
  let c = e.dataIdMap.get(o.dataId).id, l = o;
  const { transposed: u, axes: d, originalAxes: f, inputWasTransposed: p } = Qa(o, a, e);
  if (p) {
    const w = e.dataIdMap.get(u.dataId).id;
    l = u, c = w;
  }
  const h = l.shape.length;
  Fn("max", d, h);
  const [m, g] = On(l.shape, d), v = Y(g), b = e.makeOutput(m, o.dtype);
  if (Y(l.shape) !== 0) {
    const w = e.dataIdMap.get(b.dataId).id;
    wS(c, dt[o.dtype], v, w);
  }
  if (p && e.disposeData(u.dataId), s) {
    const w = vn(b.shape, f);
    b.shape = w;
  }
  return b;
}
const O7 = {
  kernelName: hd,
  backendName: "wasm",
  setupFunc: $7,
  kernelFunc: D7
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F7 = nn(md);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let SS;
function M7(t) {
  SS = t.wasm.cwrap(gd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function P7(t) {
  const { inputs: e, attrs: n, backend: r } = t, a = e.x, s = r.dataIdMap.get(a.dataId).id;
  A(a.dtype === "float32", () => `Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);
  const { filterSize: o, strides: i, pad: c, dimRoundingMode: l } = n, u = Vr(a.shape, o, i, 1, c, l), d = u.filterHeight, f = u.filterWidth, p = u.padInfo.top, h = u.padInfo.right, m = u.padInfo.bottom, g = u.padInfo.left, v = u.dilationHeight, b = u.dilationWidth, w = u.strideHeight, S = u.strideWidth, I = u.inChannels, E = u.outChannels;
  if (u.dataFormat !== "channelsLast")
    throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);
  const T = r.makeOutput(u.outShape, "float32"), R = r.dataIdMap.get(T.dataId).id;
  return SS(s, a.shape[0], a.shape[1], a.shape[2], d, f, p, h, m, g, v, b, w, S, I, E, R), T;
}
const B7 = {
  kernelName: gd,
  backendName: "wasm",
  setupFunc: M7,
  kernelFunc: P7
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let _S;
function L7(t) {
  _S = t.wasm.cwrap("MaxPool3D", null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function W7(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { filterSize: s, strides: o, pad: i, dimRoundingMode: c, dataFormat: l } = r, u = Ja(
    a.shape,
    s,
    o,
    /*dilations=*/
    1,
    i,
    c,
    l
  ), d = n.makeOutput(u.outShape, a.dtype);
  return _S(
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    u.batchSize,
    // Since Pool3D ops (AvgPool3D and MaxPool3D) support 3D filter only, in
    // channels should always equal to out channels.
    /*channelSize=*/
    u.inChannels,
    u.inDepth,
    u.inHeight,
    u.inWidth,
    u.outDepth,
    u.outHeight,
    u.outWidth,
    u.strideDepth,
    u.strideHeight,
    u.strideWidth,
    u.dilationDepth,
    u.dilationHeight,
    u.dilationWidth,
    u.effectiveFilterDepth,
    u.effectiveFilterHeight,
    u.effectiveFilterWidth,
    u.padInfo.front,
    u.padInfo.top,
    u.padInfo.left
  ), d;
}
const z7 = {
  kernelName: _m,
  backendName: "wasm",
  setupFunc: L7,
  kernelFunc: W7
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let xS;
function V7(t) {
  xS = t.wasm.cwrap("MaxPool3DGrad", null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function H7(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s } = e, { filterSize: o, strides: i, pad: c, dimRoundingMode: l } = r, u = Ja(
    s.shape,
    o,
    i,
    /*dilations=*/
    1,
    c,
    l
  ), d = n.makeOutput(s.shape, s.dtype);
  return xS(
    n.dataIdMap.get(s.dataId).id,
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    u.batchSize,
    // Since Pool3D ops (MaxPool3D and MaxPool3D) support 3D filter only, in
    // channels should always equal to out channels.
    /*channelSize=*/
    u.inChannels,
    u.inDepth,
    u.inHeight,
    u.inWidth,
    u.outDepth,
    u.outHeight,
    u.outWidth,
    u.strideDepth,
    u.strideHeight,
    u.strideWidth,
    u.dilationDepth,
    u.dilationHeight,
    u.dilationWidth,
    u.effectiveFilterDepth,
    u.effectiveFilterHeight,
    u.effectiveFilterWidth,
    u.padInfo.front,
    u.padInfo.top,
    u.padInfo.left
  ), d;
}
const j7 = {
  kernelName: i1,
  backendName: "wasm",
  setupFunc: V7,
  kernelFunc: H7
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let IS;
function U7(t) {
  IS = t.wasm.cwrap("MaxPoolGrad", null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function G7(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s } = e, { filterSize: o, strides: i, pad: c, dimRoundingMode: l } = r, u = Vr(
    s.shape,
    o,
    i,
    /*dilations=*/
    1,
    c,
    l
  ), d = n.makeOutput(s.shape, s.dtype);
  return IS(
    n.dataIdMap.get(s.dataId).id,
    n.dataIdMap.get(a.dataId).id,
    n.dataIdMap.get(d.dataId).id,
    u.batchSize,
    // Since Pool ops (MaxPool and MaxPool) support 2D filter only, in
    // channels should always equal to out channels.
    /*channelSize=*/
    u.inChannels,
    u.inHeight,
    u.inWidth,
    u.outHeight,
    u.outWidth,
    u.strideHeight,
    u.strideWidth,
    u.dilationHeight,
    u.dilationWidth,
    u.effectiveFilterHeight,
    u.effectiveFilterWidth,
    u.padInfo.top,
    u.padInfo.left
  ), d;
}
const q7 = {
  kernelName: o1,
  backendName: "wasm",
  setupFunc: U7,
  kernelFunc: G7
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let kS;
function K7(t) {
  kS = t.wasm.cwrap("MaxPoolWithArgmax", null, [
    "number",
    "number",
    "number",
    "number",
    "boolean",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // padLeft
  ]);
}
function X7(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { filterSize: s, strides: o, pad: i, includeBatchInIndex: c } = r;
  A(a.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);
  const l = [1, 1];
  A(Er(o, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);
  const u = Vr(a.shape, s, o, [1, 1], i), d = n.makeOutput(u.outShape, a.dtype), f = n.makeOutput(u.outShape, "int32");
  return kS(n.dataIdMap.get(a.dataId).id, n.dataIdMap.get(d.dataId).id, n.dataIdMap.get(f.dataId).id, dt[a.dtype], c, u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.top, u.padInfo.left), [d, f];
}
const Y7 = {
  kernelName: xm,
  backendName: "wasm",
  setupFunc: K7,
  kernelFunc: X7
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let ES;
function Z7(t) {
  ES = t.wasm.cwrap(yd, null, ["number, number, number"]);
}
function J7(t) {
  const { backend: e, inputs: n, attrs: r } = t, { axis: a, keepDims: s } = r, { x: o } = n, i = e.dataIdMap.get(o.dataId).id;
  let c = i, l = o;
  const { transposed: u, axes: d, originalAxes: f, inputWasTransposed: p } = Qa(o, a, e);
  let h = d;
  if (p) {
    const S = e.dataIdMap.get(u.dataId).id;
    S !== i && (l = u, c = S, h = Mn(h.length, l.shape.length));
  }
  Fn("mean", h, l.shape.length);
  const [m, g] = On(l.shape, h), v = Y(g);
  let b = l;
  l.dtype !== "float32" && (b = ns({ backend: e, inputs: { x: l }, attrs: { dtype: "float32" } }), c = e.dataIdMap.get(b.dataId).id);
  const w = e.makeOutput(m, "float32");
  if (Y(l.shape) !== 0) {
    const S = e.dataIdMap.get(w.dataId).id;
    ES(c, v, S);
  }
  if (p && e.disposeData(u.dataId), s) {
    const S = vn(w.shape, f);
    w.shape = S;
  }
  return l.dtype !== "float32" && e.disposeData(b.dataId), w;
}
const Q7 = {
  kernelName: yd,
  backendName: "wasm",
  setupFunc: Z7,
  kernelFunc: J7
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let TS;
function e9(t) {
  TS = t.wasm.cwrap(vd, null, [
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function t9(t) {
  const { backend: e, inputs: n, attrs: r } = t, { axis: a, keepDims: s } = r, { x: o } = n, i = e.dataIdMap.get(o.dataId).id;
  let c = i, l = o;
  const { transposed: u, axes: d, originalAxes: f, inputWasTransposed: p } = Qa(o, a, e);
  if (p) {
    const w = e.dataIdMap.get(u.dataId).id;
    w !== i && (l = u, c = w);
  }
  const h = l.shape.length;
  Fn("min", d, h);
  const [m, g] = On(l.shape, d), v = Y(g), b = e.makeOutput(m, l.dtype);
  if (Y(l.shape) !== 0) {
    const w = e.dataIdMap.get(b.dataId).id;
    TS(c, dt[o.dtype], v, w);
  }
  if (p && e.disposeData(u.dataId), s) {
    const w = vn(b.shape, f);
    b.shape = w;
  }
  return b;
}
const n9 = {
  kernelName: vd,
  backendName: "wasm",
  setupFunc: e9,
  kernelFunc: t9
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r9 = nn(bd);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var wh;
(function(t) {
  t[t.reflect = 0] = "reflect", t[t.symmetric = 1] = "symmetric";
})(wh || (wh = {}));
let CS;
function a9(t) {
  CS = t.wasm.cwrap(wd, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "array",
    "number",
    "number"
    // outId
  ]);
}
function s9(t) {
  const { inputs: { x: e }, backend: n, attrs: { paddings: r, mode: a } } = t, s = r.map(
    (h, m) => h[0] + e.shape[m] + h[1]
    /* afterPad */
  ), o = n.dataIdMap.get(e.dataId).id, i = n.makeOutput(s, e.dtype), c = n.dataIdMap.get(i.dataId).id, l = new Uint8Array(new Int32Array(e.shape).buffer), u = r.map((h) => h[0]), d = r.map((h) => h[1]), f = new Uint8Array(new Int32Array(u).buffer), p = new Uint8Array(new Int32Array(d).buffer);
  return CS(o, l, e.shape.length, dt[e.dtype], f, p, wh[a], c), i;
}
const o9 = {
  kernelName: wd,
  backendName: "wasm",
  kernelFunc: s9,
  setupFunc: a9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let NS;
function i9(t) {
  NS = t.wasm.cwrap(Jd, null, [
    "number",
    "number",
    "number",
    "number"
    // batch
  ]);
}
function AS(t) {
  const { backend: e, inputs: { logits: n }, attrs: { dim: r } } = t, a = e.dataIdMap.get(n.dataId).id, s = e.makeOutput(n.shape, n.dtype), o = e.dataIdMap.get(s.dataId).id, i = n.shape[r], c = Y(n.shape) / i;
  return Y(s.shape) === 0 || NS(a, o, i, c), s;
}
const u9 = {
  kernelName: Jd,
  backendName: "wasm",
  setupFunc: i9,
  kernelFunc: AS
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let RS;
function c9(t) {
  RS = t.wasm.cwrap(_d, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function l9(t) {
  const { inputs: e, backend: n, attrs: r } = t, { logits: a } = e, { numSamples: s, seed: o, normalized: i } = r;
  if (a.dtype !== "float32")
    throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);
  const c = i ? a : AS({
    inputs: { logits: a },
    backend: n,
    attrs: { dim: a.shape.length - 1 }
  }), [l, u] = c.shape, d = n.makeOutput([l, s], "int32");
  return RS(n.dataIdMap.get(c.dataId).id, l, u, s, o, n.dataIdMap.get(d.dataId).id), i || n.disposeData(c.dataId), d;
}
const d9 = {
  kernelName: _d,
  backendName: "wasm",
  setupFunc: c9,
  kernelFunc: l9
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const f9 = nn(Sd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const p9 = nn(xd);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const h9 = rt(Im);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bg(t, e) {
  const n = new Int32Array(t.wasm.HEAPU8.buffer, e, 4), r = n[0], a = n[1], s = n[2], o = n[3];
  return t.wasm._free(e), { pSelectedIndices: r, selectedSize: a, pSelectedScores: s, pValidOutputs: o };
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let $S;
function m9(t) {
  $S = t.wasm.cwrap(
    kd,
    "number",
    // Result*
    [
      "number",
      "number",
      "number",
      "number",
      "number"
      // scoreThreshold
    ]
  );
}
function g9(t) {
  const { backend: e, inputs: n, attrs: r } = t, { iouThreshold: a, maxOutputSize: s, scoreThreshold: o } = r, { boxes: i, scores: c } = n, l = e.dataIdMap.get(i.dataId).id, u = e.dataIdMap.get(c.dataId).id, d = $S(l, u, s, a, o), { pSelectedIndices: f, selectedSize: p, pSelectedScores: h, pValidOutputs: m } = bg(e, d);
  return e.wasm._free(h), e.wasm._free(m), e.makeOutput([p], "int32", f);
}
const y9 = {
  kernelName: kd,
  backendName: "wasm",
  setupFunc: m9,
  kernelFunc: g9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let DS;
function v9(t) {
  DS = t.wasm.cwrap(
    Ed,
    "number",
    // Result*
    [
      "number",
      "number",
      "number",
      "number",
      "number",
      "bool"
      // padToMaxOutputSize
    ]
  );
}
function b9(t) {
  const { backend: e, inputs: n, attrs: r } = t, { iouThreshold: a, maxOutputSize: s, scoreThreshold: o, padToMaxOutputSize: i } = r, { boxes: c, scores: l } = n, u = e.dataIdMap.get(c.dataId).id, d = e.dataIdMap.get(l.dataId).id, f = DS(u, d, s, a, o, i), { pSelectedIndices: p, selectedSize: h, pSelectedScores: m, pValidOutputs: g } = bg(e, f);
  e.wasm._free(m);
  const v = e.makeOutput([h], "int32", p), b = e.makeOutput([], "int32", g);
  return [v, b];
}
const w9 = {
  kernelName: Ed,
  backendName: "wasm",
  setupFunc: v9,
  kernelFunc: b9
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let OS;
function S9(t) {
  OS = t.wasm.cwrap(
    Td,
    "number",
    // Result*
    [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
      // softNmsSigma
    ]
  );
}
function _9(t) {
  const { backend: e, inputs: n, attrs: r } = t, { iouThreshold: a, maxOutputSize: s, scoreThreshold: o, softNmsSigma: i } = r, { boxes: c, scores: l } = n, u = e.dataIdMap.get(c.dataId).id, d = e.dataIdMap.get(l.dataId).id, f = OS(u, d, s, a, o, i), { pSelectedIndices: p, selectedSize: h, pSelectedScores: m, pValidOutputs: g } = bg(e, f);
  e.wasm._free(g);
  const v = e.makeOutput([h], "int32", p), b = e.makeOutput([h], "float32", m);
  return [v, b];
}
const x9 = {
  kernelName: Td,
  backendName: "wasm",
  setupFunc: S9,
  kernelFunc: _9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const I9 = !1, k9 = nn(Id, I9, "bool");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let FS;
function E9(t) {
  FS = t.wasm.cwrap(Cd, null, [
    "number",
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function T9(t) {
  const { inputs: e, backend: n, attrs: r } = t, { indices: a } = e, { dtype: s, depth: o, onValue: i, offValue: c } = r, l = n.makeOutput([...a.shape, o], s), u = n.dataIdMap.get(l.dataId).id, f = n.dataIdMap.get(a.dataId).id;
  return FS(f, o, i, c, u), l;
}
const C9 = {
  kernelName: Cd,
  backendName: "wasm",
  setupFunc: E9,
  kernelFunc: T9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N9(t) {
  const { inputs: { x: e }, backend: n } = t, r = n.makeOutput(e.shape, e.dtype);
  return n.typedArrayFromHeap(r).fill(1), r;
}
const A9 = {
  kernelName: km,
  backendName: "wasm",
  kernelFunc: N9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R9(t) {
  const { inputs: e, backend: n, attrs: r } = t, { axis: a } = r;
  if (e.length === 1)
    return bh({ inputs: { input: e[0] }, backend: n, attrs: { dim: a } });
  const s = e[0].shape, o = e[0].dtype;
  e.forEach((u) => {
    ar(s, u.shape, "All tensors passed to stack must have matching shapes"), A(o === u.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const i = [], c = e.map((u) => {
    const d = bh({ inputs: { input: u }, backend: n, attrs: { dim: a } });
    return i.push(d), d;
  }), l = G2({ inputs: c, backend: n, attrs: { axis: a } });
  return i.forEach((u) => n.disposeData(u.dataId)), l;
}
const $9 = {
  kernelName: Em,
  backendName: "wasm",
  kernelFunc: R9
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let MS;
function D9(t) {
  MS = t.wasm.cwrap(Nd, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "array",
    "number",
    "number"
    // outId
  ]);
}
function O9(t) {
  const { inputs: { x: e }, backend: n, attrs: { paddings: r, constantValue: a } } = t, s = r.map(
    (m, g) => m[0] + e.shape[g] + m[1]
    /* afterPad */
  );
  if (Y(e.shape) === 0)
    return cS({
      backend: n,
      attrs: { shape: s, value: a, dtype: e.dtype }
    });
  const o = n.dataIdMap.get(e.dataId).id, i = n.makeOutput(s, e.dtype), l = n.dataIdMap.get(i.dataId).id, u = new Uint8Array(new Int32Array(e.shape).buffer), d = r.map((m) => m[0]), f = r.map((m) => m[1]), p = new Uint8Array(new Int32Array(d).buffer), h = new Uint8Array(new Int32Array(f).buffer);
  return MS(o, u, e.shape.length, dt[e.dtype], p, h, a, l), i;
}
const PS = {
  kernelName: Nd,
  backendName: "wasm",
  kernelFunc: O9,
  setupFunc: D9
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F9 = nn(Ad);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let BS;
function M9(t) {
  BS = t.wasm.cwrap(Rd, null, [
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function P9(t) {
  const { inputs: e, backend: n } = t, { x: r, alpha: a } = e, s = n.dataIdMap.get(r.dataId).id, o = n.dataIdMap.get(a.dataId).id;
  let i = s;
  const c = r;
  let l = c;
  c.dtype !== "float32" && (l = ns({ backend: n, inputs: { x: r }, attrs: { dtype: "float32" } }), i = n.dataIdMap.get(l.dataId).id);
  const u = n.makeOutput(r.shape, "float32"), d = n.dataIdMap.get(u.dataId).id;
  return BS(i, o, d), c.dtype !== "float32" && n.disposeData(l.dataId), u;
}
const B9 = {
  kernelName: Rd,
  backendName: "wasm",
  setupFunc: M9,
  kernelFunc: P9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let LS;
function L9(t) {
  LS = t.wasm.cwrap($d, null, [
    "number",
    "number",
    "number",
    "number"
  ]);
}
function W9(t) {
  const { backend: e, inputs: n, attrs: r } = t, { axis: a, keepDims: s } = r, { x: o } = n, i = e.dataIdMap.get(o.dataId).id;
  let c = i, l = o;
  const { transposed: u, axes: d, originalAxes: f, inputWasTransposed: p } = Qa(o, a, e);
  let h = d;
  if (p) {
    const w = e.dataIdMap.get(u.dataId).id;
    w !== i && (l = u, c = w, h = Mn(h.length, l.shape.length));
  }
  Fn("prod", h, l.shape.length);
  const [m, g] = On(l.shape, h), v = Y(g), b = e.makeOutput(m, l.dtype);
  if (Y(l.shape) !== 0) {
    const w = e.dataIdMap.get(b.dataId).id;
    LS(c, v, dt[b.dtype], w);
  }
  if (p && e.disposeData(u.dataId), s) {
    const w = vn(b.shape, f);
    b.shape = w;
  }
  return b;
}
const z9 = {
  kernelName: $d,
  backendName: "wasm",
  setupFunc: L9,
  kernelFunc: W9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const V9 = (t) => {
  const { backend: e, attrs: n } = t, { start: r, stop: a, step: s, dtype: o } = n, i = M2(r, a, s, o), c = e.makeOutput([i.length], o);
  return e.typedArrayFromHeap(c).set(i), c;
}, H9 = {
  kernelName: Tm,
  backendName: "wasm",
  kernelFunc: V9
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const j9 = nn(zl);
/**
 * @license
 * Copyright 2022 The TensorFlow Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const U9 = rt(Dd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const G9 = rt(Od);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const q9 = rt(Pd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let WS;
function K9(t) {
  WS = t.wasm.cwrap(Md, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function X9(t) {
  const { backend: e, inputs: n, attrs: r } = t, { images: a } = n, { alignCorners: s, halfPixelCenters: o, size: i } = r, [c, l] = i, [u, d, f, p] = a.shape, h = [u, c, l, p];
  let m = e.dataIdMap.get(a.dataId), g;
  m.dtype !== "float32" && (g = ns({ backend: e, inputs: { x: a }, attrs: { dtype: "float32" } }), m = e.dataIdMap.get(g.dataId));
  const v = m.id, b = e.makeOutput(h, "float32");
  if (Y(a.shape) === 0)
    return b;
  const w = e.dataIdMap.get(b.dataId).id;
  return WS(v, u, d, f, p, c, l, s ? 1 : 0, o ? 1 : 0, w), g != null && e.disposeData(g.dataId), b;
}
const Y9 = {
  kernelName: Md,
  backendName: "wasm",
  setupFunc: K9,
  kernelFunc: X9
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let zS;
function Z9(t) {
  zS = t.wasm.cwrap(Am, null, [
    "number",
    "number",
    "number",
    "array",
    "array",
    "boolean"
    // alignCorners
  ]);
}
function J9(t) {
  const { inputs: e, backend: n, attrs: r } = t, { images: a, dy: s } = e, { alignCorners: o } = r, i = n.makeOutput(a.shape, "float32");
  let c = n.dataIdMap.get(a.dataId), l;
  return c.dtype !== "float32" && (l = ns({
    backend: n,
    inputs: { x: a },
    attrs: { dtype: "float32" }
  }), c = n.dataIdMap.get(l.dataId)), zS(n.dataIdMap.get(a.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(i.dataId).id, new Uint8Array(new Int32Array(a.shape).buffer), new Uint8Array(new Int32Array(s.shape).buffer), o), l != null && n.disposeData(l.dataId), i;
}
const Q9 = {
  kernelName: Am,
  backendName: "wasm",
  setupFunc: Z9,
  kernelFunc: J9
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let VS;
function eW(t) {
  VS = t.wasm.cwrap(Fd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function tW(t) {
  const { backend: e, inputs: n, attrs: r } = t, { images: a } = n, { alignCorners: s, halfPixelCenters: o, size: i } = r, [c, l] = i, [u, d, f, p] = a.shape, h = [u, c, l, p], m = e.makeOutput(h, "float32");
  if (Y(a.shape) === 0)
    return m;
  let g = e.dataIdMap.get(a.dataId), v;
  g.dtype !== "float32" && (v = ns({
    backend: e,
    inputs: { x: a },
    attrs: { dtype: "float32" }
  }), g = e.dataIdMap.get(v.dataId));
  const b = g.id, w = e.dataIdMap.get(m.dataId).id;
  return VS(b, u, d, f, p, c, l, s ? 1 : 0, o ? 1 : 0, w), v != null && e.disposeData(v.dataId), m;
}
const nW = {
  kernelName: Fd,
  backendName: "wasm",
  setupFunc: eW,
  kernelFunc: tW
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let HS;
function rW(t) {
  HS = t.wasm.cwrap(Nm, null, [
    "number",
    "number",
    "number",
    "array",
    "array",
    "boolean"
    // alignCorners
  ]);
}
function aW(t) {
  const { inputs: e, backend: n, attrs: r } = t, { images: a, dy: s } = e, { alignCorners: o } = r, i = n.makeOutput(a.shape, "float32");
  let c = n.dataIdMap.get(a.dataId), l;
  return c.dtype !== "float32" && (l = ns({
    backend: n,
    inputs: { x: a },
    attrs: { dtype: "float32" }
  }), c = n.dataIdMap.get(l.dataId)), HS(n.dataIdMap.get(a.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(i.dataId).id, new Uint8Array(new Int32Array(a.shape).buffer), new Uint8Array(new Int32Array(s.shape).buffer), o), l != null && n.disposeData(l.dataId), i;
}
const sW = {
  kernelName: Nm,
  backendName: "wasm",
  setupFunc: rW,
  kernelFunc: aW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let jS;
function oW(t) {
  jS = t.wasm.cwrap(Bd, null, [
    "number",
    "array",
    "number",
    "array",
    "number",
    "number"
    // out_id
  ]);
}
function iW(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { dims: s } = r, o = Vt(s, a.shape);
  if (a.shape.length === 0)
    return xf({ inputs: { x: a }, backend: n });
  const i = n.makeOutput(a.shape, a.dtype), c = n.dataIdMap.get(a.dataId).id, l = n.dataIdMap.get(i.dataId).id, u = new Uint8Array(new Int32Array(o).buffer), d = new Uint8Array(new Int32Array(a.shape).buffer);
  jS(c, u, o.length, d, a.shape.length, l);
  const f = jn({ inputs: { x: i }, attrs: { shape: a.shape }, backend: n });
  return n.disposeData(i.dataId), f;
}
const uW = {
  kernelName: Bd,
  backendName: "wasm",
  kernelFunc: iW,
  setupFunc: oW
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let US;
function cW(t) {
  US = t.wasm.cwrap(cf, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number"
    // outId
  ]);
}
function lW(t) {
  const { inputs: e, backend: n, attrs: r } = t, { image: a } = e, { radians: s, fillValue: o, center: i } = r, c = n.makeOutput(a.shape, a.dtype), l = n.dataIdMap.get(a.dataId).id, u = n.dataIdMap.get(c.dataId).id, [d, f, p, h] = a.shape, [m, g] = Xw(i, f, p), v = o === 0, b = 255, w = typeof o == "number" ? [o, o, o, v ? 0 : b] : [...o, b], S = new Uint8Array(new Int32Array(w).buffer);
  return US(l, d, f, p, h, s, m, g, S, w.length, u), c;
}
const dW = {
  kernelName: cf,
  backendName: "wasm",
  kernelFunc: lW,
  setupFunc: cW
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fW = rt(Ld);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pW = rt(Wd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let GS;
function hW(t) {
  GS = t.wasm.cwrap(zd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number"
    // outId
  ]);
}
function mW(t) {
  const { backend: e, inputs: n, attrs: r } = t, { indices: a, updates: s } = n, { shape: o } = r, i = e.makeOutput(o, s.dtype);
  if (Y(o) === 0)
    return i;
  const { sliceRank: c, numUpdates: l, sliceSize: u, strides: d, outputSize: f } = Vo(s, a, o), h = e.dataIdMap.get(a.dataId).id, g = e.dataIdMap.get(s.dataId).id, v = new Uint8Array(new Int32Array(d).buffer), b = e.dataIdMap.get(i.dataId).id;
  return GS(h, g, dt[s.dtype], c, l, u, v, f, b), i;
}
const gW = {
  kernelName: zd,
  backendName: "wasm",
  setupFunc: hW,
  kernelFunc: mW
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let qS;
function yW(t) {
  qS = t.wasm.cwrap(Hd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "bool",
    "number"
    // outId
  ]);
}
function vW(t) {
  const { inputs: e, backend: n, attrs: r } = t, { sortedSequence: a, values: s } = e, { side: o } = r;
  if (a.dtype !== s.dtype)
    throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);
  const i = n.makeOutput(s.shape, "int32");
  function c(l) {
    return n.dataIdMap.get(l.dataId).id;
  }
  return qS(
    c(a),
    c(s),
    /*batchSize=*/
    a.shape[0],
    /*sequenceSize=*/
    a.shape[1],
    /*valuesSize=*/
    s.shape[1],
    /*dtype=*/
    dt[a.dtype],
    /*isSideLeft=*/
    o === "left",
    c(i)
  ), i;
}
const bW = {
  kernelName: Hd,
  backendName: "wasm",
  setupFunc: yW,
  kernelFunc: vW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let KS;
function wW(t) {
  KS = t.wasm.cwrap("SelectV2", null, [
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function SW(t) {
  const { inputs: e, backend: n } = t, { condition: r, t: a, e: s } = e, o = n.dataIdMap.get(r.dataId).id, i = n.dataIdMap.get(a.dataId).id, c = n.dataIdMap.get(s.dataId).id, l = n.makeOutput(a.shape, a.dtype), u = n.dataIdMap.get(l.dataId).id, d = r.shape.length, f = a.shape.length, p = d === 0 || d > 1 || f === 1 ? 1 : Y(a.shape.slice(1));
  return KS(o, i, c, p, u), l;
}
const _W = {
  kernelName: Rm,
  backendName: "wasm",
  kernelFunc: SW,
  setupFunc: wW
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xW = rt(jd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let XS;
function IW(t) {
  XS = t.wasm.cwrap(Kd, null, ["number", "number"]);
}
function kW(t) {
  const { backend: e, inputs: { x: n } } = t, r = e.dataIdMap.get(n.dataId).id, a = e.makeOutput(n.shape, n.dtype), s = e.dataIdMap.get(a.dataId).id;
  return Y(a.shape) === 0 || XS(r, s), a;
}
const EW = {
  kernelName: "Sigmoid",
  backendName: "wasm",
  setupFunc: IW,
  kernelFunc: kW
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TW = rt(qd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CW = rt(Ud);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NW = rt(Gd);
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AW = rt(Xd);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RW(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { blockShape: s, paddings: o } = r, i = Y(s), c = [[0, 0]];
  c.push(...o);
  for (let E = 1 + s.length; E < a.shape.length; ++E)
    c.push([0, 0]);
  const l = PS.kernelFunc({
    inputs: { x: a },
    backend: n,
    attrs: { paddings: c, constantValue: 0 }
  }), u = wf(l.shape, s, i, !1), d = Sf(u.length, s.length, !1), f = _f(l.shape, s, i, !1), m = jn({ inputs: { x: l }, backend: n, attrs: { shape: u } }), b = Ga({ inputs: { x: m }, backend: n, attrs: { perm: d } }), I = jn({ inputs: { x: b }, backend: n, attrs: { shape: f } });
  return n.disposeData(l.dataId), n.disposeData(m.dataId), n.disposeData(b.dataId), I;
}
const $W = {
  kernelName: Dm,
  backendName: "wasm",
  kernelFunc: RW
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let YS;
function DW(t) {
  YS = t.wasm.cwrap("SparseFillEmptyRows", "number", [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // exceptionValuesId
  ]);
}
function OW(t) {
  const { backend: e, inputs: n } = t, { indices: r, values: a, denseShape: s, defaultValue: o } = n, i = r.shape[0], c = r.shape[1], l = e.readSync(s.dataId)[0], u = [i + l, c], d = e.dataIdMap.get(r.dataId).id, f = e.dataIdMap.get(a.dataId).id, p = e.dataIdMap.get(o.dataId).id, h = e.makeOutput(u, r.dtype), m = e.dataIdMap.get(h.dataId).id, g = e.makeOutput(u.slice(0, 1), a.dtype), v = e.dataIdMap.get(g.dataId).id, b = e.makeOutput([l], "bool"), w = e.dataIdMap.get(b.dataId).id, S = e.makeOutput([i], r.dtype), I = e.dataIdMap.get(S.dataId).id, E = e.makeOutput([4], "int32"), T = e.dataIdMap.get(E.dataId).id, R = YS(d, f, dt[a.dtype], i, l, c, p, m, v, w, I, T), $ = e.readSync(E.dataId);
  let D;
  switch ($[0]) {
    case 1: {
      D = e2($[1]);
      break;
    }
    case 2: {
      D = t2($[1], $[2]);
      break;
    }
    case 3:
      D = n2($[1], $[2], $[3]);
      break;
    default:
      D = "";
  }
  if (e.disposeData(E.dataId), D)
    throw e.disposeData(h.dataId), e.disposeData(g.dataId), e.disposeData(b.dataId), e.disposeData(S.dataId), new Error(D);
  let M = h, z = g;
  return R !== u[0] && (M = zs({
    inputs: { x: h },
    attrs: { begin: 0, size: [R, c] },
    backend: e
  }), z = zs({
    inputs: { x: g },
    attrs: { begin: 0, size: R },
    backend: e
  }), e.disposeData(h.dataId), e.disposeData(g.dataId)), [M, z, b, S];
}
const FW = {
  kernelName: Fm,
  backendName: "wasm",
  setupFunc: DW,
  kernelFunc: OW
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let ZS;
function MW(t) {
  ZS = t.wasm.cwrap(Qd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // exceptionValuesId
  ]);
}
function PW(t) {
  const { backend: e, inputs: n } = t, { inputIndices: r, inputShape: a, newShape: s } = n;
  if (r.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);
  if (a.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);
  if (s.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
  const o = e.dataIdMap.get(r.dataId).id, i = e.dataIdMap.get(a.dataId).id, c = e.dataIdMap.get(s.dataId).id, l = r.shape[0], u = Y(s.shape), d = e.makeOutput([l, u], r.dtype), f = e.dataIdMap.get(d.dataId).id, p = e.makeOutput([u], s.dtype), h = e.dataIdMap.get(p.dataId).id, m = e.makeOutput([3], "int32"), g = e.dataIdMap.get(m.dataId).id;
  ZS(o, i, c, l, f, h, g);
  const v = e.readSync(m.dataId);
  let b;
  switch (v[0]) {
    case 0: {
      b = r2(v[1], v[2]);
      break;
    }
    case 1: {
      b = a2(v[1], v[2]);
      break;
    }
    case 2:
      b = s2();
      break;
    case 3: {
      const w = Array.from(e.readSync(a.dataId)), S = Array.from(e.readSync(p.dataId));
      b = o2(w, S);
      break;
    }
    case 4: {
      const w = Array.from(e.readSync(a.dataId)), S = Array.from(e.readSync(p.dataId));
      b = i2(w, S);
      break;
    }
    default:
      b = "";
  }
  if (e.disposeData(m.dataId), b)
    throw e.disposeData(d.dataId), e.disposeData(p.dataId), new Error(b);
  return [d, p];
}
const BW = {
  kernelName: Qd,
  backendName: "wasm",
  setupFunc: MW,
  kernelFunc: PW
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let JS;
function QS(t) {
  JS = t.wasm.cwrap("SparseSegmentReduction", null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
    // defaultValue
  ]);
}
function e_(t, e) {
  const { backend: n, inputs: r } = t, { data: a, indices: s, segmentIds: o } = r, i = s.shape[0], c = n.readSync(o.dataId, i - 1, i)[0], u = i > 0 ? c + 1 : 0;
  if (u < 0)
    throw new Error(Gc());
  const d = a.shape.slice();
  d[0] = u;
  const f = n.dataIdMap.get(a.dataId).id, p = n.dataIdMap.get(s.dataId).id, h = n.dataIdMap.get(o.dataId).id, m = n.makeOutput(d, a.dtype), g = n.dataIdMap.get(m.dataId).id, v = n.makeOutput([4], "int32"), b = n.dataIdMap.get(v.dataId).id;
  JS(f, dt[a.dtype], a.shape[0], p, h, g, b, e, 0);
  const w = n.readSync(v.dataId);
  let S;
  switch (w[0]) {
    case 0: {
      S = Gc();
      break;
    }
    case 1: {
      S = u2();
      break;
    }
    case 2:
      S = c2(w[1], w[2]);
      break;
    case 3:
      S = l2(w[1], w[2], w[3]);
      break;
    default:
      S = "";
  }
  if (n.disposeData(v.dataId), S)
    throw n.disposeData(m.dataId), new Error(S);
  return m;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LW(t) {
  return e_(t, !0);
}
const WW = {
  kernelName: Mm,
  backendName: "wasm",
  setupFunc: QS,
  kernelFunc: LW
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zW(t) {
  return e_(t, !1);
}
const VW = {
  kernelName: Pm,
  backendName: "wasm",
  setupFunc: QS,
  kernelFunc: zW
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let t_;
function HW(t) {
  t_ = t.wasm.cwrap(ef, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number"
    // outId
  ]);
}
function jW(t) {
  const { backend: e, inputs: n, attrs: r } = t, { sparseIndices: a, sparseValues: s, defaultValue: o } = n, { outputShape: i } = r, c = e.makeOutput(i, o.dtype);
  if (Y(i) === 0)
    return c;
  const { sliceRank: l, numUpdates: u, sliceSize: d, strides: f, outputSize: p } = Vo(s, a, i), h = e.dataIdMap.get(a.dataId).id, m = e.dataIdMap.get(s.dataId).id, g = e.dataIdMap.get(o.dataId).id, v = new Uint8Array(new Int32Array(f).buffer), b = e.dataIdMap.get(c.dataId).id;
  return t_(h, m, s.shape.length, g, dt[o.dtype], l, u, d, v, p, b), c;
}
const UW = {
  kernelName: ef,
  backendName: "wasm",
  setupFunc: HW,
  kernelFunc: jW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GW(t) {
  const { inputs: e, attrs: n, backend: r } = t, { x: a } = e, { numOrSizeSplits: s, axis: o } = n, i = Vt(o, a.shape)[0], c = Qw(a, s, i), l = new Array(a.shape.length).fill(0), u = a.shape.slice();
  return c.map((d) => {
    const f = [...u];
    f[i] = d;
    const p = zs({ inputs: { x: a }, attrs: { begin: l, size: f }, backend: r });
    return l[i] += d, p;
  });
}
const qW = {
  kernelName: Om,
  backendName: "wasm",
  kernelFunc: GW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KW = rt(Yd);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const XW = rt(f1);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YW = nn(tf);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let n_;
function ZW(t) {
  n_ = t.wasm.cwrap(Nu, null, [
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function JW(t) {
  const { backend: e, inputs: n, attrs: r } = t, { alpha: a } = r, { x: s } = n, o = e.dataIdMap.get(s.dataId).id, i = e.makeOutput(s.shape, s.dtype), c = e.dataIdMap.get(i.dataId).id;
  return n_(o, a, dt[s.dtype], c), i;
}
const QW = {
  kernelName: Nu,
  backendName: "wasm",
  setupFunc: ZW,
  kernelFunc: JW
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let r_;
function ez(t) {
  r_ = t.wasm.cwrap(nf, null, [
    "number",
    "array",
    "number",
    "array",
    "array",
    "array",
    "array",
    "array",
    "number",
    "number"
    // outId
  ]);
}
function tz(t) {
  const { backend: e, inputs: n, attrs: r } = t, { x: a } = n, { begin: s, end: o, strides: i, beginMask: c, endMask: l, ellipsisMask: u, newAxisMask: d, shrinkAxisMask: f } = r, { finalShapeSparse: p, finalShape: h, isIdentity: m, sliceDim0: g, isSimpleSlice: v, begin: b, end: w, strides: S } = qw(a.shape, s, o, i, c, l, u, d, f);
  let I;
  if (m)
    I = jn({ inputs: { x: a }, backend: e, attrs: { shape: h } });
  else if (g || v) {
    A(a.shape.length >= 1, () => `Input must have rank at least 1, got: ${a.shape.length}`);
    const E = Hw(b, w, S), T = zs({ inputs: { x: a }, backend: e, attrs: { begin: b, size: E } });
    I = jn({ inputs: { x: T }, backend: e, attrs: { shape: h } }), e.disposeData(T.dataId);
  } else {
    const E = e.makeOutput(p, "float32"), T = e.dataIdMap.get(a.dataId).id, R = new Uint8Array(new Int32Array(Ie(a.shape)).buffer), $ = new Uint8Array(new Int32Array(b).buffer), D = new Uint8Array(new Int32Array(w).buffer), M = new Uint8Array(new Int32Array(S).buffer), z = new Uint8Array(new Int32Array(p).buffer), F = new Uint8Array(new Int32Array(Ie(p)).buffer), V = e.dataIdMap.get(E.dataId).id;
    r_(T, R, a.shape.length, $, D, M, z, F, p.length, V), I = jn({ inputs: { x: E }, backend: e, attrs: { shape: h } }), e.disposeData(E.dataId);
  }
  return I;
}
const nz = {
  kernelName: nf,
  backendName: "wasm",
  setupFunc: ez,
  kernelFunc: tz
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rz(t) {
  const { backend: e, inputs: n, attrs: r } = t, { data: a, dataSplits: s } = n, { separator: o, nGramWidths: i, leftPad: c, rightPad: l, padWidth: u, preserveShortSequences: d } = r, f = e.readSync(a.dataId), p = e.readSync(s.dataId), [h, m] = L2(f, p, o, i, c, l, u, d), g = e.makeOutput([h.length], "string"), v = e.dataIdMap.get(g.dataId);
  v.stringBytes = h;
  const b = e.makeOutput(s.shape, "int32");
  return e.typedArrayFromHeap(b).set(m), [g, b];
}
const az = {
  kernelName: Lm,
  backendName: "wasm",
  kernelFunc: rz
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sz(t) {
  const { backend: e, inputs: n, attrs: r } = t, { input: a, delimiter: s } = n, { skipEmpty: o } = r, i = e.readSync(a.dataId), c = e.readSync(s.dataId), [l, u, d] = W2(i, c[0], o), f = u.length, p = e.makeOutput([f, 2], "int32");
  e.typedArrayFromHeap(p).set(l);
  const m = e.makeOutput([f], "string"), g = e.dataIdMap.get(m.dataId);
  g.stringBytes = u;
  const v = e.makeOutput([2], "int32");
  return e.typedArrayFromHeap(v).set(d), [p, m, v];
}
const oz = {
  kernelName: Wm,
  backendName: "wasm",
  kernelFunc: sz
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iz(t) {
  const { backend: e, inputs: n, attrs: r } = t, { input: a } = n, { numBuckets: s } = r, o = e.readSync(a.dataId), i = z2(o, s), c = e.makeOutput(a.shape, "int32");
  return e.typedArrayFromHeap(c).set(i), c;
}
const uz = {
  kernelName: zm,
  backendName: "wasm",
  kernelFunc: iz
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cz = nn(rf);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let a_;
function lz(t) {
  a_ = t.wasm.cwrap(Zd, null, [
    "number",
    "number",
    "number",
    "number"
    // out_id
  ]);
}
function dz(t) {
  const { backend: e, inputs: n, attrs: r } = t, { axis: a, keepDims: s } = r, { x: o } = n, i = e.dataIdMap.get(o.dataId).id;
  let c = i, l = o;
  const { transposed: u, axes: d, originalAxes: f, inputWasTransposed: p } = Qa(o, a, e);
  let h = d;
  if (p) {
    const w = e.dataIdMap.get(u.dataId).id;
    w !== i && (l = u, c = w, h = Mn(h.length, l.shape.length));
  }
  Fn("sum", h, l.shape.length);
  const [m, g] = On(l.shape, h), v = Y(g), b = e.makeOutput(m, l.dtype);
  if (Y(l.shape) !== 0) {
    const w = e.dataIdMap.get(b.dataId).id;
    a_(c, v, dt[b.dtype], w);
  }
  if (p && e.disposeData(u.dataId), s) {
    const w = vn(b.shape, f);
    b.shape = w;
  }
  return b;
}
const fz = {
  kernelName: Zd,
  backendName: "wasm",
  setupFunc: lz,
  kernelFunc: dz
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pz = rt(af);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hz = rt(sf);
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let s_;
function mz(t) {
  s_ = t.wasm.cwrap(Vd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number"
    // tensorId
  ]);
}
function gz(t) {
  const { backend: e, inputs: n, attrs: r } = t, { tensor: a, indices: s, updates: o } = n, i = e.makeOutput(a.shape, a.dtype);
  if (Y(a.shape) === 0)
    return i;
  const { sliceRank: c, numUpdates: l, sliceSize: u, strides: d, outputSize: f } = Vo(o, s, a.shape), h = e.dataIdMap.get(s.dataId).id, g = e.dataIdMap.get(o.dataId).id, b = e.dataIdMap.get(a.dataId).id, w = new Uint8Array(new Int32Array(d).buffer), S = e.dataIdMap.get(i.dataId).id;
  return s_(h, g, dt[o.dtype], c, l, u, w, f, S, b), i;
}
const yz = {
  kernelName: Vd,
  backendName: "wasm",
  setupFunc: mz,
  kernelFunc: gz
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let o_;
function vz(t) {
  o_ = t.wasm.cwrap(Cu, null, [
    "number",
    "array",
    "number",
    "array",
    "number",
    "number"
    // out_id
  ]);
}
function bz(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, s = n.dataIdMap.get(a.dataId).id, { reps: o } = r, i = new Array(a.shape.length);
  for (let f = 0; f < i.length; f++)
    i[f] = a.shape[f] * o[f];
  const c = new Uint8Array(new Int32Array(a.shape).buffer), l = new Uint8Array(new Int32Array(i).buffer), u = n.makeOutput(i, a.dtype), d = n.dataIdMap.get(u.dataId).id;
  return o_(s, c, a.shape.length, l, i.length, dt[u.dtype], d), u;
}
const wz = {
  kernelName: Cu,
  backendName: "wasm",
  setupFunc: vz,
  kernelFunc: bz
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let i_;
function Sz(t) {
  i_ = t.wasm.cwrap(of, null, [
    "number",
    "array",
    "number",
    "number",
    "number",
    "bool",
    "number",
    "number"
    // outIndicesId
  ]);
}
const _z = ({ inputs: t, backend: e, attrs: n }) => {
  const { x: r } = t, { k: a, sorted: s } = n, o = e.dataIdMap.get(r.dataId).id, i = new Uint8Array(new Int32Array(r.shape).buffer), c = r.shape.slice();
  c[c.length - 1] = a;
  const l = e.makeOutput(c, r.dtype), u = e.dataIdMap.get(l.dataId).id, d = e.makeOutput(c, "int32"), f = e.dataIdMap.get(d.dataId).id;
  return i_(o, i, r.shape.length, dt[r.dtype], a, s, u, f), [l, d];
}, xz = {
  kernelName: of,
  backendName: "wasm",
  setupFunc: Sz,
  kernelFunc: _z
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let u_;
function Iz(t) {
  u_ = t.wasm.cwrap(uf, null, [
    "number",
    "number",
    "bool",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number"
    // outId
  ]);
}
function kz(t) {
  const { backend: e, inputs: n, attrs: r } = t, { image: a, transforms: s } = n, { interpolation: o, fillMode: i, fillValue: c, outputShape: l } = r, [u, d, f, p] = a.shape, [h, m] = l ?? [d, f], g = [
    u,
    h,
    m,
    p
  ], v = new Uint8Array(new Int32Array(Ie(a.shape)).buffer), b = new Uint8Array(new Int32Array(Ie(g)).buffer), w = e.makeOutput(g, a.dtype), S = e.dataIdMap.get(w.dataId).id, E = e.dataIdMap.get(a.dataId).id, R = e.dataIdMap.get(s.dataId).id, $ = o === "nearest" ? 1 : 2;
  let D;
  switch (i) {
    case "constant":
      D = 1;
      break;
    case "reflect":
      D = 2;
      break;
    case "wrap":
      D = 3;
      break;
    case "nearest":
      D = 4;
      break;
    default:
      D = 1;
      break;
  }
  return u_(E, R, s.shape[0] > 1, u, h, m, p, f, d, v, a.shape.length - 1, b, g.length - 1, $, D, c, S), w;
}
const Ez = {
  kernelName: uf,
  backendName: "wasm",
  setupFunc: Iz,
  kernelFunc: kz
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tz(t) {
  const { inputs: e, attrs: n, backend: r } = t, { axis: a } = n, { x: s } = e, { outputValues: o, outputShape: i, indices: c } = H2(r.readSync(s.dataId), a, s.shape, s.dtype);
  return [
    r.makeOutput(
      i,
      s.dtype,
      /*memoryOffset=*/
      void 0,
      o
    ),
    r.makeOutput(
      [c.length],
      "int32",
      /*memoryOffset=*/
      void 0,
      c
    )
  ];
}
const Cz = {
  kernelName: Vm,
  backendName: "wasm",
  kernelFunc: Tz
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nz(t) {
  const { inputs: e, backend: n, attrs: r } = t, { value: a } = e;
  let { axis: s } = r;
  s < 0 && (s += a.shape.length);
  const o = a.shape[s], i = a.shape.length, c = new Array(i - 1);
  let l = 0;
  for (let p = 0; p < i; p++)
    p !== s && (c[l++] = a.shape[p]);
  const u = new Array(o), d = new Array(i).fill(0), f = a.shape.slice();
  f[s] = 1;
  for (let p = 0; p < u.length; p++)
    d[s] = p, u[p] = zs({ inputs: { x: a }, attrs: { begin: d, size: f }, backend: n });
  return u.map(({ dataId: p, dtype: h }) => ({ dataId: p, dtype: h, shape: c }));
}
const Az = {
  kernelName: Hm,
  backendName: "wasm",
  kernelFunc: Nz
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rz(t) {
  const { inputs: { x: e }, backend: n } = t, r = n.makeOutput(e.shape, e.dtype);
  return n.typedArrayFromHeap(r).fill(0), r;
}
const $z = {
  kernelName: jm,
  backendName: "wasm",
  kernelFunc: Rz
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Dz = [
  $5,
  D5,
  O5,
  F5,
  M5,
  L5,
  q5,
  Y5,
  Z5,
  J5,
  Q5,
  eP,
  tP,
  nP,
  rP,
  oP,
  mP,
  cP,
  fP,
  bP,
  yB,
  wB,
  SB,
  xB,
  IB,
  kB,
  CB,
  NB,
  $B,
  FB,
  BB,
  zB,
  jB,
  UB,
  GB,
  XB,
  JB,
  tL,
  aL,
  iL,
  lL,
  pL,
  gL,
  bL,
  _L,
  xL,
  EL,
  CL,
  NL,
  AL,
  RL,
  $L,
  DL,
  ML,
  PL,
  BL,
  zL,
  jL,
  qL,
  YL,
  QL,
  t7,
  r7,
  W5,
  a7,
  s7,
  o7,
  c7,
  d7,
  p7,
  g7,
  v7,
  y7,
  w7,
  S7,
  x7,
  k7,
  C7,
  R7,
  O7,
  F7,
  B7,
  z7,
  j7,
  q7,
  Y7,
  Q7,
  n9,
  r9,
  o9,
  d9,
  f9,
  p9,
  h9,
  y9,
  w9,
  x9,
  k9,
  C9,
  A9,
  $9,
  PS,
  F9,
  B9,
  z9,
  H9,
  j9,
  U9,
  G9,
  q9,
  gP,
  Y9,
  Q9,
  nW,
  sW,
  uW,
  dW,
  fW,
  pW,
  gW,
  bW,
  _W,
  xW,
  EW,
  TW,
  CW,
  NW,
  mB,
  u9,
  AW,
  $W,
  FW,
  BW,
  WW,
  VW,
  UW,
  qW,
  KW,
  XW,
  YW,
  QW,
  nz,
  az,
  oz,
  uz,
  cz,
  fz,
  pz,
  hz,
  yz,
  wz,
  xz,
  Ez,
  j5,
  Cz,
  Az,
  $z
];
for (const t of Dz)
  h1(t);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Sh = Xe();
Sh.registerFlag("WASM_HAS_SIMD_SUPPORT", async () => {
  try {
    return WebAssembly.validate(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      4,
      1,
      96,
      0,
      0,
      3,
      2,
      1,
      0,
      10,
      9,
      1,
      7,
      0,
      65,
      0,
      253,
      15,
      26,
      11
    ]));
  } catch {
    return !1;
  }
});
Sh.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", async () => {
  if (Sh.get("IS_NODE"))
    return !1;
  try {
    return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      4,
      1,
      96,
      0,
      0,
      3,
      2,
      1,
      0,
      5,
      4,
      1,
      3,
      1,
      1,
      10,
      11,
      1,
      9,
      0,
      65,
      0,
      254,
      16,
      2,
      0,
      26,
      11
    ]));
  } catch {
    return !1;
  }
});
var c_ = { exports: {} };
(function(t, e) {
  var n = (() => {
    var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
    return typeof __filename < "u" && (r = r || __filename), function(a) {
      a = a || {};
      function s() {
        return q.buffer != fe && Ue(q.buffer), we;
      }
      function o() {
        return q.buffer != fe && Ue(q.buffer), Re;
      }
      function i() {
        return q.buffer != fe && Ue(q.buffer), $e;
      }
      function c() {
        return q.buffer != fe && Ue(q.buffer), Oe;
      }
      function l() {
        return q.buffer != fe && Ue(q.buffer), We;
      }
      var u = typeof a < "u" ? a : {}, d, f;
      u.ready = new Promise(function(O, G) {
        d = O, f = G;
      });
      var p;
      typeof process < "u" && process.listeners && (p = { uncaughtException: process.listeners("uncaughtException"), unhandledRejection: process.listeners("unhandledRejection") });
      var h = Object.assign({}, u), m = (O, G) => {
        throw G;
      }, g = typeof window == "object", v = typeof importScripts == "function", b = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", w = u.ENVIRONMENT_IS_PTHREAD || !1, S = "";
      function I(O) {
        return u.locateFile ? u.locateFile(O, S) : S + O;
      }
      var E, T, R;
      function $(O) {
        if (O instanceof hr)
          return;
        H("exiting due to exception: " + O);
      }
      if (b) {
        var D = Ma, M = Ma;
        v ? S = M.dirname(S) + "/" : S = __dirname + "/", E = (G, le) => (G = Xn(G) ? new URL(G) : M.normalize(G), D.readFileSync(G, le ? void 0 : "utf8")), R = (G) => {
          var le = E(G, !0);
          return le.buffer || (le = new Uint8Array(le)), le;
        }, T = (G, le, De) => {
          G = Xn(G) ? new URL(G) : M.normalize(G), D.readFile(G, function(Me, ze) {
            Me ? De(Me) : le(ze.buffer);
          });
        }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(G) {
          if (!(G instanceof hr))
            throw G;
        }), process.on("unhandledRejection", function(G) {
          throw G;
        }), m = (G, le) => {
          if (at())
            throw process.exitCode = G, le;
          $(le), process.exit(G);
        }, u.inspect = function() {
          return "[Emscripten Module object]";
        };
        let O;
        try {
          O = Ma;
        } catch (G) {
          throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), G;
        }
        $n.Worker = O.Worker;
      } else
        (g || v) && (v ? S = self.location.href : typeof document < "u" && document.currentScript && (S = document.currentScript.src), typeof r < "u" && r && (S = r), S.indexOf("blob:") !== 0 ? S = S.substr(0, S.replace(/[?#].*/, "").lastIndexOf("/") + 1) : S = "", b || (E = (O) => {
          var G = new XMLHttpRequest();
          return G.open("GET", O, !1), G.send(null), G.responseText;
        }, v && (R = (O) => {
          var G = new XMLHttpRequest();
          return G.open("GET", O, !1), G.responseType = "arraybuffer", G.send(null), new Uint8Array(G.response);
        }), T = (O, G, le) => {
          var De = new XMLHttpRequest();
          De.open("GET", O, !0), De.responseType = "arraybuffer", De.onload = () => {
            if (De.status == 200 || De.status == 0 && De.response) {
              G(De.response);
              return;
            }
            le();
          }, De.onerror = le, De.send(null);
        }));
      b && typeof performance > "u" && ($n.performance = Ma.performance);
      var z = console.log.bind(console), F = console.warn.bind(console);
      b && (z = (O) => D.writeSync(1, O + `
`), F = (O) => D.writeSync(2, O + `
`));
      var V = u.print || z, H = u.printErr || F;
      Object.assign(u, h), h = null, u.arguments && u.arguments, u.thisProgram && u.thisProgram, u.quit && (m = u.quit);
      var U;
      u.wasmBinary && (U = u.wasmBinary);
      var Z = u.noExitRuntime || !0;
      typeof WebAssembly != "object" && En("no native wasm support detected");
      var q, X, se = !1, te;
      function ue(O, G) {
        O || En(G);
      }
      var ee = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
      function ne(O, G, le) {
        G >>>= 0;
        for (var De = G + le, Me = G; O[Me] && !(Me >= De); )
          ++Me;
        if (Me - G > 16 && O.buffer && ee)
          return ee.decode(O.buffer instanceof SharedArrayBuffer ? O.slice(G, Me) : O.subarray(G, Me));
        for (var ze = ""; G < Me; ) {
          var Se = O[G++];
          if (!(Se & 128)) {
            ze += String.fromCharCode(Se);
            continue;
          }
          var ke = O[G++] & 63;
          if ((Se & 224) == 192) {
            ze += String.fromCharCode((Se & 31) << 6 | ke);
            continue;
          }
          var Tt = O[G++] & 63;
          if ((Se & 240) == 224 ? Se = (Se & 15) << 12 | ke << 6 | Tt : Se = (Se & 7) << 18 | ke << 12 | Tt << 6 | O[G++] & 63, Se < 65536)
            ze += String.fromCharCode(Se);
          else {
            var Ln = Se - 65536;
            ze += String.fromCharCode(55296 | Ln >> 10, 56320 | Ln & 1023);
          }
        }
        return ze;
      }
      function oe(O, G) {
        return O >>>= 0, O ? ne(o(), O, G) : "";
      }
      function ge(O, G, le, De) {
        if (le >>>= 0, !(De > 0))
          return 0;
        for (var Me = le, ze = le + De - 1, Se = 0; Se < O.length; ++Se) {
          var ke = O.charCodeAt(Se);
          if (ke >= 55296 && ke <= 57343) {
            var Tt = O.charCodeAt(++Se);
            ke = 65536 + ((ke & 1023) << 10) | Tt & 1023;
          }
          if (ke <= 127) {
            if (le >= ze)
              break;
            G[le++ >>> 0] = ke;
          } else if (ke <= 2047) {
            if (le + 1 >= ze)
              break;
            G[le++ >>> 0] = 192 | ke >> 6, G[le++ >>> 0] = 128 | ke & 63;
          } else if (ke <= 65535) {
            if (le + 2 >= ze)
              break;
            G[le++ >>> 0] = 224 | ke >> 12, G[le++ >>> 0] = 128 | ke >> 6 & 63, G[le++ >>> 0] = 128 | ke & 63;
          } else {
            if (le + 3 >= ze)
              break;
            G[le++ >>> 0] = 240 | ke >> 18, G[le++ >>> 0] = 128 | ke >> 12 & 63, G[le++ >>> 0] = 128 | ke >> 6 & 63, G[le++ >>> 0] = 128 | ke & 63;
          }
        }
        return G[le >>> 0] = 0, le - Me;
      }
      function be(O, G, le) {
        return ge(O, o(), G, le);
      }
      var fe, we, Re, $e, Oe, We;
      w && (fe = u.buffer);
      function Ue(O) {
        fe = O, u.HEAP8 = we = new Int8Array(O), u.HEAP16 = new Int16Array(O), u.HEAP32 = $e = new Int32Array(O), u.HEAPU8 = Re = new Uint8Array(O), u.HEAPU16 = new Uint16Array(O), u.HEAPU32 = Oe = new Uint32Array(O), u.HEAPF32 = new Float32Array(O), u.HEAPF64 = We = new Float64Array(O);
      }
      var je = u.INITIAL_MEMORY || 16777216;
      if (w)
        q = u.wasmMemory, fe = u.buffer;
      else if (u.wasmMemory)
        q = u.wasmMemory;
      else if (q = new WebAssembly.Memory({ initial: je / 65536, maximum: 65536, shared: !0 }), !(q.buffer instanceof SharedArrayBuffer))
        throw H("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), b && H("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
      q && (fe = q.buffer), je = fe.byteLength, Ue(fe);
      var Ne, et = [], Ye = [], ct = [];
      function at() {
        return Z;
      }
      function Ht() {
        if (u.preRun)
          for (typeof u.preRun == "function" && (u.preRun = [u.preRun]); u.preRun.length; )
            Mt(u.preRun.shift());
        bt(et);
      }
      function st() {
        w || bt(Ye);
      }
      function St() {
        if (!w) {
          if (u.postRun)
            for (typeof u.postRun == "function" && (u.postRun = [u.postRun]); u.postRun.length; )
              rn(u.postRun.shift());
          bt(ct);
        }
      }
      function Mt(O) {
        et.unshift(O);
      }
      function Zt(O) {
        Ye.unshift(O);
      }
      function rn(O) {
        ct.unshift(O);
      }
      var jt = 0, pn = null;
      function kn(O) {
        jt++, u.monitorRunDependencies && u.monitorRunDependencies(jt);
      }
      function aa(O) {
        if (jt--, u.monitorRunDependencies && u.monitorRunDependencies(jt), jt == 0 && pn) {
          var G = pn;
          pn = null, G();
        }
      }
      function En(O) {
        u.onAbort && u.onAbort(O), O = "Aborted(" + O + ")", H(O), se = !0, te = 1, O += ". Build with -sASSERTIONS for more info.";
        var G = new WebAssembly.RuntimeError(O);
        throw f(G), G;
      }
      var Ia = "data:application/octet-stream;base64,";
      function or(O) {
        return O.startsWith(Ia);
      }
      function Xn(O) {
        return O.startsWith("file://");
      }
      var Lt;
      Lt = "tfjs-backend-wasm-threaded-simd.wasm", or(Lt) || (Lt = I(Lt));
      function ka(O) {
        try {
          if (O == Lt && U)
            return new Uint8Array(U);
          if (R)
            return R(O);
          throw "both async and sync fetching of the wasm failed";
        } catch (G) {
          En(G);
        }
      }
      function os() {
        if (!U && (g || v)) {
          if (typeof fetch == "function" && !Xn(Lt))
            return fetch(Lt, { credentials: "same-origin" }).then(function(O) {
              if (!O.ok)
                throw "failed to load wasm binary file at '" + Lt + "'";
              return O.arrayBuffer();
            }).catch(function() {
              return ka(Lt);
            });
          if (T)
            return new Promise(function(O, G) {
              T(Lt, function(le) {
                O(new Uint8Array(le));
              }, G);
            });
        }
        return Promise.resolve().then(function() {
          return ka(Lt);
        });
      }
      function sa() {
        var O = { env: Qo, wasi_snapshot_preview1: Qo };
        function G(Se, ke) {
          var Tt = Se.exports;
          if (u.asm = Tt, Yn(u.asm._emscripten_tls_init), Ne = u.asm.__indirect_function_table, Zt(u.asm.__wasm_call_ctors), X = ke, !w) {
            var Ln = ve.unusedWorkers.length;
            ve.unusedWorkers.forEach(function(Tr) {
              ve.loadWasmModuleToWorker(Tr, function() {
                --Ln || aa();
              });
            });
          }
        }
        w || kn();
        function le(Se) {
          G(Se.instance, Se.module);
        }
        function De(Se) {
          return os().then(function(ke) {
            return WebAssembly.instantiate(ke, O);
          }).then(function(ke) {
            return ke;
          }).then(Se, function(ke) {
            H("failed to asynchronously prepare wasm: " + ke), En(ke);
          });
        }
        function Me() {
          return !U && typeof WebAssembly.instantiateStreaming == "function" && !or(Lt) && !Xn(Lt) && !b && typeof fetch == "function" ? fetch(Lt, { credentials: "same-origin" }).then(function(Se) {
            var ke = WebAssembly.instantiateStreaming(Se, O);
            return ke.then(le, function(Tt) {
              return H("wasm streaming compile failed: " + Tt), H("falling back to ArrayBuffer instantiation"), De(le);
            });
          }) : De(le);
        }
        if (u.instantiateWasm)
          try {
            var ze = u.instantiateWasm(O, G);
            return ze;
          } catch (Se) {
            H("Module.instantiateWasm callback failed with error: " + Se), f(Se);
          }
        return Me().catch(f), {};
      }
      var is = {};
      function hr(O) {
        this.name = "ExitStatus", this.message = "Program terminated with exit(" + O + ")", this.status = O;
      }
      function oa(O) {
        var G = ve.pthreads[O];
        delete ve.pthreads[O], G.terminate(), ti(O), ve.runningWorkers.splice(ve.runningWorkers.indexOf(G), 1), G.pthread_ptr = 0;
      }
      function Tn(O) {
        var G = ve.pthreads[O];
        G.postMessage({ cmd: "cancel" });
      }
      function Et(O) {
        var G = ve.pthreads[O];
        ue(G), ve.returnWorkerToPool(G);
      }
      function jr(O) {
        var G = ve.getNewWorker();
        if (!G)
          return 6;
        ve.runningWorkers.push(G), ve.pthreads[O.pthread_ptr] = G, G.pthread_ptr = O.pthread_ptr;
        var le = { cmd: "run", start_routine: O.startRoutine, arg: O.arg, pthread_ptr: O.pthread_ptr };
        return G.runPthread = () => {
          b && G.ref(), G.postMessage(le, O.transferList), delete G.runPthread;
        }, G.loaded && G.runPthread(), 0;
      }
      function Pn(O) {
        if (w)
          return Ta(1, 1, O);
        te = O, at() || (ve.terminateAllThreads(), u.onExit && u.onExit(O), se = !0), m(O, new hr(O));
      }
      function J(O, G) {
        if (te = O, !G && w)
          throw He(O), "unwind";
        Pn(O);
      }
      var ce = J;
      function Ce(O) {
        if (O instanceof hr || O == "unwind")
          return te;
        m(1, O);
      }
      var ve = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], pthreads: {}, init: function() {
        w ? ve.initWorker() : ve.initMainThread();
      }, initMainThread: function() {
        for (var O = 8; O--; )
          ve.allocateUnusedWorker();
      }, initWorker: function() {
        Z = !1;
      }, setExitStatus: function(O) {
        te = O;
      }, terminateAllThreads: function() {
        for (var O of Object.values(ve.pthreads))
          ve.returnWorkerToPool(O);
        for (var O of ve.unusedWorkers)
          O.terminate();
        ve.unusedWorkers = [];
      }, returnWorkerToPool: function(O) {
        var G = O.pthread_ptr;
        delete ve.pthreads[G], ve.unusedWorkers.push(O), ve.runningWorkers.splice(ve.runningWorkers.indexOf(O), 1), O.pthread_ptr = 0, b && O.unref(), ti(G);
      }, receiveObjectTransfer: function(O) {
      }, threadInitTLS: function() {
        ve.tlsInitFunctions.forEach((O) => O());
      }, loadWasmModuleToWorker: function(O, G) {
        O.onmessage = (ze) => {
          var Se = ze.data, ke = Se.cmd;
          if (O.pthread_ptr && (ve.currentProxiedOperationCallerThread = O.pthread_ptr), Se.targetThread && Se.targetThread != Gr()) {
            var Tt = ve.pthreads[Se.targetThread];
            Tt ? Tt.postMessage(Se, Se.transferList) : H('Internal error! Worker sent a message "' + ke + '" to target pthread ' + Se.targetThread + ", but that thread no longer exists!"), ve.currentProxiedOperationCallerThread = void 0;
            return;
          }
          ke === "processProxyingQueue" ? Ko(Se.queue) : ke === "spawnThread" ? jr(Se) : ke === "cleanupThread" ? Et(Se.thread) : ke === "killThread" ? oa(Se.thread) : ke === "cancelThread" ? Tn(Se.thread) : ke === "loaded" ? (O.loaded = !0, b && O.unref(), G && G(O), O.runPthread && O.runPthread()) : ke === "print" ? V("Thread " + Se.threadId + ": " + Se.text) : ke === "printErr" ? H("Thread " + Se.threadId + ": " + Se.text) : ke === "alert" ? alert("Thread " + Se.threadId + ": " + Se.text) : Se.target === "setimmediate" ? O.postMessage(Se) : ke === "callHandler" ? u[Se.handler](...Se.args) : ke && H("worker sent an unknown command " + ke), ve.currentProxiedOperationCallerThread = void 0;
        }, O.onerror = (ze) => {
          var Se = "worker sent an error!";
          throw H(Se + " " + ze.filename + ":" + ze.lineno + ": " + ze.message), ze;
        }, b && (O.on("message", function(ze) {
          O.onmessage({ data: ze });
        }), O.on("error", function(ze) {
          O.onerror(ze);
        }), O.on("detachedExit", function() {
        }));
        var le = [], De = ["onExit", "onAbort", "print", "printErr"];
        for (var Me of De)
          u.hasOwnProperty(Me) && le.push(Me);
        O.postMessage({ cmd: "load", handlers: le, urlOrBlob: u.mainScriptUrlOrBlob || r, wasmMemory: q, wasmModule: X });
      }, allocateUnusedWorker: function() {
        var O, G = I("tfjs-backend-wasm-threaded-simd.worker.js");
        O = new Worker(G), ve.unusedWorkers.push(O);
      }, getNewWorker: function() {
        return ve.unusedWorkers.length == 0 && (ve.allocateUnusedWorker(), ve.loadWasmModuleToWorker(ve.unusedWorkers[0])), ve.unusedWorkers.pop();
      } };
      u.PThread = ve;
      function bt(O) {
        for (; O.length > 0; )
          O.shift()(u);
      }
      function _t() {
        var O = Gr(), G = i()[O + 52 >>> 2], le = i()[O + 56 >>> 2], De = G - le;
        ni(G, De), Qs(G);
      }
      u.establishStackSpace = _t;
      function He(O) {
        if (w)
          return Ta(2, 0, O);
        try {
          ce(O);
        } catch (G) {
          Ce(G);
        }
      }
      var Pe = [];
      function Ut(O) {
        var G = Pe[O];
        return G || (O >= Pe.length && (Pe.length = O + 1), Pe[O] = G = Ne.get(O)), G;
      }
      function Bn(O, G) {
        var le = Ut(O)(G);
        at() ? ve.setExitStatus(le) : fs(le);
      }
      u.invokeEntryPoint = Bn;
      function Yn(O) {
        ve.tlsInitFunctions.push(O);
      }
      function us(O) {
        ei(O, !v, 1, !g), ve.threadInitTLS();
      }
      function Ur(O) {
        w ? postMessage({ cmd: "cleanupThread", thread: O }) : Et(O);
      }
      function cs(O, G, le, De) {
        return w ? Ta(3, 1, O, G, le, De) : an(O, G, le, De);
      }
      function an(O, G, le, De) {
        if (typeof SharedArrayBuffer > "u")
          return H("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
        var Me = [], ze = 0;
        if (w && (Me.length === 0 || ze))
          return cs(O, G, le, De);
        var Se = { startRoutine: le, pthread_ptr: O, arg: De, transferList: Me };
        return w ? (Se.cmd = "spawnThread", postMessage(Se, Me), 0) : jr(Se);
      }
      function ir() {
        return 65536;
      }
      var ls = !0;
      function Pu() {
        return ls;
      }
      function Ko(O) {
        Atomics.store(i(), O >> 2, 1), Gr() && Xu(O), Atomics.compareExchange(i(), O >> 2, 1, 0);
      }
      u.executeNotifiedProxyingQueue = Ko;
      function $f(O, G, le, De) {
        if (O == G)
          setTimeout(() => Ko(De));
        else if (w)
          postMessage({ targetThread: O, cmd: "processProxyingQueue", queue: De });
        else {
          var Me = ve.pthreads[O];
          if (!Me)
            return;
          Me.postMessage({ cmd: "processProxyingQueue", queue: De });
        }
        return 1;
      }
      function Bu(O, G, le) {
        return -1;
      }
      function Xs() {
        En("");
      }
      function Ea(O) {
        Ea.shown || (Ea.shown = {}), Ea.shown[O] || (Ea.shown[O] = 1, b && (O = "warning: " + O), H(O));
      }
      function Lu() {
        b || v || Ea("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
      }
      function Wu() {
        return Date.now();
      }
      function zu() {
        return 4294901760;
      }
      function Df() {
        return zu();
      }
      var Xo;
      b ? Xo = () => {
        var O = process.hrtime();
        return O[0] * 1e3 + O[1] / 1e6;
      } : Xo = () => performance.timeOrigin + performance.now();
      function Of(O, G, le) {
        o().copyWithin(O >>> 0, G >>> 0, G + le >>> 0);
      }
      function Vu() {
        return b ? Ma.cpus().length : navigator.hardwareConcurrency;
      }
      function Hu(O) {
        var G = Js(), le = O();
        return Qs(G), le;
      }
      function Ta(O, G) {
        var le = arguments.length - 2, De = arguments;
        return Hu(() => {
          for (var Me = le, ze = eo(Me * 8), Se = ze >> 3, ke = 0; ke < le; ke++) {
            var Tt = De[2 + ke];
            l()[Se + ke >>> 0] = Tt;
          }
          return Zs(O, Me, ze, G);
        });
      }
      var Yo = [];
      function Ff(O, G, le) {
        Yo.length = G;
        for (var De = le >> 3, Me = 0; Me < G; Me++)
          Yo[Me] = l()[De + Me >>> 0];
        var ze = O < 0, Se = ze ? is[-O - 1] : Jn[O];
        return Se.apply(null, Yo);
      }
      function Mf(O) {
        try {
          return q.grow(O - fe.byteLength + 65535 >>> 16), Ue(q.buffer), 1;
        } catch {
        }
      }
      function ju(O) {
        var G = o().length;
        if (O = O >>> 0, O <= G)
          return !1;
        var le = zu();
        if (O > le)
          return !1;
        let De = (Tt, Ln) => Tt + (Ln - Tt % Ln) % Ln;
        for (var Me = 1; Me <= 4; Me *= 2) {
          var ze = G * (1 + 0.2 / Me);
          ze = Math.min(ze, O + 100663296);
          var Se = Math.min(le, De(Math.max(O, ze), 65536)), ke = Mf(Se);
          if (ke)
            return !0;
        }
        return !1;
      }
      function Uu() {
        throw "unwind";
      }
      function Ys(O) {
        return w ? Ta(4, 1, O) : 52;
      }
      function Zo(O, G, le, De, Me) {
        return w ? Ta(5, 1, O, G, le, De, Me) : 70;
      }
      var Jo = [null, [], []];
      function ds(O, G) {
        var le = Jo[O];
        G === 0 || G === 10 ? ((O === 1 ? V : H)(ne(le, 0)), le.length = 0) : le.push(G);
      }
      function Zn(O, G, le, De) {
        if (w)
          return Ta(6, 1, O, G, le, De);
        for (var Me = 0, ze = 0; ze < le; ze++) {
          var Se = c()[G >>> 2], ke = c()[G + 4 >>> 2];
          G += 8;
          for (var Tt = 0; Tt < ke; Tt++)
            ds(O, o()[Se + Tt >>> 0]);
          Me += ke;
        }
        return c()[De >>> 2] = Me, 0;
      }
      function Gu(O) {
        var G = u["_" + O];
        return G;
      }
      function Pf(O, G) {
        s().set(O, G >>> 0);
      }
      function qu(O, G, le, De, Me) {
        var ze = { string: (Cn) => {
          var Na = 0;
          if (Cn != null && Cn !== 0) {
            var to = (Cn.length << 2) + 1;
            Na = eo(to), be(Cn, Na, to);
          }
          return Na;
        }, array: (Cn) => {
          var Na = eo(Cn.length);
          return Pf(Cn, Na), Na;
        } };
        function Se(Cn) {
          return G === "string" ? oe(Cn) : G === "boolean" ? !!Cn : Cn;
        }
        var ke = Gu(O), Tt = [], Ln = 0;
        if (De)
          for (var Tr = 0; Tr < De.length; Tr++) {
            var Zu = ze[le[Tr]];
            Zu ? (Ln === 0 && (Ln = Js()), Tt[Tr] = Zu(De[Tr])) : Tt[Tr] = De[Tr];
          }
        var ai = ke.apply(null, Tt);
        function Ju(Cn) {
          return Ln !== 0 && Qs(Ln), Se(Cn);
        }
        return ai = Ju(ai), ai;
      }
      function Ku(O, G, le, De) {
        le = le || [];
        var Me = le.every((Se) => Se === "number" || Se === "boolean"), ze = G !== "string";
        return ze && Me && !De ? Gu(O) : function() {
          return qu(O, G, le, arguments);
        };
      }
      ve.init();
      var Jn = [null, Pn, He, cs, Ys, Zo, Zn], Qo = { __emscripten_init_main_thread_js: us, __emscripten_thread_cleanup: Ur, __pthread_create_js: an, _emscripten_default_pthread_stack_size: ir, _emscripten_get_now_is_monotonic: Pu, _emscripten_notify_task_queue: $f, _emscripten_set_offscreencanvas_size: Bu, abort: Xs, emscripten_check_blocking_allowed: Lu, emscripten_date_now: Wu, emscripten_get_heap_max: Df, emscripten_get_now: Xo, emscripten_memcpy_big: Of, emscripten_num_logical_cores: Vu, emscripten_receive_on_main_thread_js: Ff, emscripten_resize_heap: ju, emscripten_unwind_to_js_event_loop: Uu, exit: ce, fd_close: Ys, fd_seek: Zo, fd_write: Zn, memory: q || u.wasmMemory };
      sa(), u.___wasm_call_ctors = function() {
        return (u.___wasm_call_ctors = u.asm.__wasm_call_ctors).apply(null, arguments);
      }, u._init = function() {
        return (u._init = u.asm.init).apply(null, arguments);
      }, u._init_with_threads_count = function() {
        return (u._init_with_threads_count = u.asm.init_with_threads_count).apply(null, arguments);
      }, u._get_threads_count = function() {
        return (u._get_threads_count = u.asm.get_threads_count).apply(null, arguments);
      }, u._register_tensor = function() {
        return (u._register_tensor = u.asm.register_tensor).apply(null, arguments);
      }, u._dispose_data = function() {
        return (u._dispose_data = u.asm.dispose_data).apply(null, arguments);
      }, u._dispose = function() {
        return (u._dispose = u.asm.dispose).apply(null, arguments);
      }, u._Abs = function() {
        return (u._Abs = u.asm.Abs).apply(null, arguments);
      }, u._Acos = function() {
        return (u._Acos = u.asm.Acos).apply(null, arguments);
      }, u._Acosh = function() {
        return (u._Acosh = u.asm.Acosh).apply(null, arguments);
      }, u._Add = function() {
        return (u._Add = u.asm.Add).apply(null, arguments);
      }, u._AddN = function() {
        return (u._AddN = u.asm.AddN).apply(null, arguments);
      }, u._All = function() {
        return (u._All = u.asm.All).apply(null, arguments);
      }, u._Any = function() {
        return (u._Any = u.asm.Any).apply(null, arguments);
      }, u._ArgMax = function() {
        return (u._ArgMax = u.asm.ArgMax).apply(null, arguments);
      }, u._ArgMin = function() {
        return (u._ArgMin = u.asm.ArgMin).apply(null, arguments);
      }, u._Asin = function() {
        return (u._Asin = u.asm.Asin).apply(null, arguments);
      }, u._Asinh = function() {
        return (u._Asinh = u.asm.Asinh).apply(null, arguments);
      }, u._Atan = function() {
        return (u._Atan = u.asm.Atan).apply(null, arguments);
      }, u._Atan2 = function() {
        return (u._Atan2 = u.asm.Atan2).apply(null, arguments);
      }, u._Atanh = function() {
        return (u._Atanh = u.asm.Atanh).apply(null, arguments);
      }, u._AvgPool = function() {
        return (u._AvgPool = u.asm.AvgPool).apply(null, arguments);
      }, u._AvgPool3D = function() {
        return (u._AvgPool3D = u.asm.AvgPool3D).apply(null, arguments);
      }, u._AvgPool3DGrad = function() {
        return (u._AvgPool3DGrad = u.asm.AvgPool3DGrad).apply(null, arguments);
      }, u._AvgPoolGrad = function() {
        return (u._AvgPoolGrad = u.asm.AvgPoolGrad).apply(null, arguments);
      }, u._BatchMatMul = function() {
        return (u._BatchMatMul = u.asm.BatchMatMul).apply(null, arguments);
      }, u._Bincount = function() {
        return (u._Bincount = u.asm.Bincount).apply(null, arguments);
      }, u._BitwiseAnd = function() {
        return (u._BitwiseAnd = u.asm.BitwiseAnd).apply(null, arguments);
      }, u._Ceil = function() {
        return (u._Ceil = u.asm.Ceil).apply(null, arguments);
      }, u._ClipByValue = function() {
        return (u._ClipByValue = u.asm.ClipByValue).apply(null, arguments);
      }, u._Conv2D = function() {
        return (u._Conv2D = u.asm.Conv2D).apply(null, arguments);
      }, u._Conv2DBackpropInput = function() {
        return (u._Conv2DBackpropInput = u.asm.Conv2DBackpropInput).apply(null, arguments);
      }, u._Conv3D = function() {
        return (u._Conv3D = u.asm.Conv3D).apply(null, arguments);
      }, u._Conv3DBackpropFilterV2 = function() {
        return (u._Conv3DBackpropFilterV2 = u.asm.Conv3DBackpropFilterV2).apply(null, arguments);
      }, u._Conv3DBackpropInputV2 = function() {
        return (u._Conv3DBackpropInputV2 = u.asm.Conv3DBackpropInputV2).apply(null, arguments);
      }, u._Cos = function() {
        return (u._Cos = u.asm.Cos).apply(null, arguments);
      }, u._Cosh = function() {
        return (u._Cosh = u.asm.Cosh).apply(null, arguments);
      }, u._CropAndResize = function() {
        return (u._CropAndResize = u.asm.CropAndResize).apply(null, arguments);
      }, u._Cumprod = function() {
        return (u._Cumprod = u.asm.Cumprod).apply(null, arguments);
      }, u._Cumsum = function() {
        return (u._Cumsum = u.asm.Cumsum).apply(null, arguments);
      }, u._DenseBincount = function() {
        return (u._DenseBincount = u.asm.DenseBincount).apply(null, arguments);
      }, u._DepthToSpace = function() {
        return (u._DepthToSpace = u.asm.DepthToSpace).apply(null, arguments);
      }, u._DepthwiseConv2dNative = function() {
        return (u._DepthwiseConv2dNative = u.asm.DepthwiseConv2dNative).apply(null, arguments);
      }, u._Diag = function() {
        return (u._Diag = u.asm.Diag).apply(null, arguments);
      }, u._Dilation2D = function() {
        return (u._Dilation2D = u.asm.Dilation2D).apply(null, arguments);
      }, u._Dilation2DBackpropFilter = function() {
        return (u._Dilation2DBackpropFilter = u.asm.Dilation2DBackpropFilter).apply(null, arguments);
      }, u._Dilation2DBackpropInput = function() {
        return (u._Dilation2DBackpropInput = u.asm.Dilation2DBackpropInput).apply(null, arguments);
      }, u._Elu = function() {
        return (u._Elu = u.asm.Elu).apply(null, arguments);
      }, u._EluGrad = function() {
        return (u._EluGrad = u.asm.EluGrad).apply(null, arguments);
      }, u._Equal = function() {
        return (u._Equal = u.asm.Equal).apply(null, arguments);
      }, u._Erf = function() {
        return (u._Erf = u.asm.Erf).apply(null, arguments);
      }, u._Exp = function() {
        return (u._Exp = u.asm.Exp).apply(null, arguments);
      }, u._Expm1 = function() {
        return (u._Expm1 = u.asm.Expm1).apply(null, arguments);
      }, u._FlipLeftRight = function() {
        return (u._FlipLeftRight = u.asm.FlipLeftRight).apply(null, arguments);
      }, u._Floor = function() {
        return (u._Floor = u.asm.Floor).apply(null, arguments);
      }, u._FloorDiv = function() {
        return (u._FloorDiv = u.asm.FloorDiv).apply(null, arguments);
      }, u._FusedBatchNorm = function() {
        return (u._FusedBatchNorm = u.asm.FusedBatchNorm).apply(null, arguments);
      }, u._FusedConv2D = function() {
        return (u._FusedConv2D = u.asm.FusedConv2D).apply(null, arguments);
      }, u._FusedDepthwiseConv2D = function() {
        return (u._FusedDepthwiseConv2D = u.asm.FusedDepthwiseConv2D).apply(null, arguments);
      }, u._Gather = function() {
        return (u._Gather = u.asm.Gather).apply(null, arguments);
      }, u._GatherNd = function() {
        return (u._GatherNd = u.asm.GatherNd).apply(null, arguments);
      }, u._Greater = function() {
        return (u._Greater = u.asm.Greater).apply(null, arguments);
      }, u._GreaterEqual = function() {
        return (u._GreaterEqual = u.asm.GreaterEqual).apply(null, arguments);
      }, u._IsFinite = function() {
        return (u._IsFinite = u.asm.IsFinite).apply(null, arguments);
      }, u._IsInf = function() {
        return (u._IsInf = u.asm.IsInf).apply(null, arguments);
      }, u._IsNan = function() {
        return (u._IsNan = u.asm.IsNan).apply(null, arguments);
      }, u._LRN = function() {
        return (u._LRN = u.asm.LRN).apply(null, arguments);
      }, u._LRNGrad = function() {
        return (u._LRNGrad = u.asm.LRNGrad).apply(null, arguments);
      }, u._LeakyRelu = function() {
        return (u._LeakyRelu = u.asm.LeakyRelu).apply(null, arguments);
      }, u._Less = function() {
        return (u._Less = u.asm.Less).apply(null, arguments);
      }, u._LessEqual = function() {
        return (u._LessEqual = u.asm.LessEqual).apply(null, arguments);
      }, u._LinSpace = function() {
        return (u._LinSpace = u.asm.LinSpace).apply(null, arguments);
      }, u._Log = function() {
        return (u._Log = u.asm.Log).apply(null, arguments);
      }, u._Log1p = function() {
        return (u._Log1p = u.asm.Log1p).apply(null, arguments);
      }, u._LogicalAnd = function() {
        return (u._LogicalAnd = u.asm.LogicalAnd).apply(null, arguments);
      }, u._LogicalNot = function() {
        return (u._LogicalNot = u.asm.LogicalNot).apply(null, arguments);
      }, u._LogicalOr = function() {
        return (u._LogicalOr = u.asm.LogicalOr).apply(null, arguments);
      }, u._LogicalXor = function() {
        return (u._LogicalXor = u.asm.LogicalXor).apply(null, arguments);
      }, u._Max = function() {
        return (u._Max = u.asm.Max).apply(null, arguments);
      }, u._MaxPool = function() {
        return (u._MaxPool = u.asm.MaxPool).apply(null, arguments);
      }, u._MaxPool3D = function() {
        return (u._MaxPool3D = u.asm.MaxPool3D).apply(null, arguments);
      }, u._MaxPool3DGrad = function() {
        return (u._MaxPool3DGrad = u.asm.MaxPool3DGrad).apply(null, arguments);
      }, u._MaxPoolGrad = function() {
        return (u._MaxPoolGrad = u.asm.MaxPoolGrad).apply(null, arguments);
      }, u._MaxPoolWithArgmax = function() {
        return (u._MaxPoolWithArgmax = u.asm.MaxPoolWithArgmax).apply(null, arguments);
      }, u._Maximum = function() {
        return (u._Maximum = u.asm.Maximum).apply(null, arguments);
      }, u._Mean = function() {
        return (u._Mean = u.asm.Mean).apply(null, arguments);
      }, u._Min = function() {
        return (u._Min = u.asm.Min).apply(null, arguments);
      }, u._Minimum = function() {
        return (u._Minimum = u.asm.Minimum).apply(null, arguments);
      }, u._MirrorPad = function() {
        return (u._MirrorPad = u.asm.MirrorPad).apply(null, arguments);
      }, u._Mod = function() {
        return (u._Mod = u.asm.Mod).apply(null, arguments);
      }, u._Multinomial = function() {
        return (u._Multinomial = u.asm.Multinomial).apply(null, arguments);
      }, u._Multiply = function() {
        return (u._Multiply = u.asm.Multiply).apply(null, arguments);
      }, u._Neg = function() {
        return (u._Neg = u.asm.Neg).apply(null, arguments);
      }, u._NonMaxSuppressionV3 = function() {
        return (u._NonMaxSuppressionV3 = u.asm.NonMaxSuppressionV3).apply(null, arguments);
      }, u._NonMaxSuppressionV4 = function() {
        return (u._NonMaxSuppressionV4 = u.asm.NonMaxSuppressionV4).apply(null, arguments);
      }, u._NonMaxSuppressionV5 = function() {
        return (u._NonMaxSuppressionV5 = u.asm.NonMaxSuppressionV5).apply(null, arguments);
      }, u._NotEqual = function() {
        return (u._NotEqual = u.asm.NotEqual).apply(null, arguments);
      }, u._OneHot = function() {
        return (u._OneHot = u.asm.OneHot).apply(null, arguments);
      }, u._PadV2 = function() {
        return (u._PadV2 = u.asm.PadV2).apply(null, arguments);
      }, u._Pow = function() {
        return (u._Pow = u.asm.Pow).apply(null, arguments);
      }, u._Prelu = function() {
        return (u._Prelu = u.asm.Prelu).apply(null, arguments);
      }, u._Prod = function() {
        return (u._Prod = u.asm.Prod).apply(null, arguments);
      }, u._RealDiv = function() {
        return (u._RealDiv = u.asm.RealDiv).apply(null, arguments);
      }, u._Reciprocal = function() {
        return (u._Reciprocal = u.asm.Reciprocal).apply(null, arguments);
      }, u._Relu = function() {
        return (u._Relu = u.asm.Relu).apply(null, arguments);
      }, u._Relu6 = function() {
        return (u._Relu6 = u.asm.Relu6).apply(null, arguments);
      }, u._ResizeBilinear = function() {
        return (u._ResizeBilinear = u.asm.ResizeBilinear).apply(null, arguments);
      }, u._ResizeBilinearGrad = function() {
        return (u._ResizeBilinearGrad = u.asm.ResizeBilinearGrad).apply(null, arguments);
      }, u._ResizeNearestNeighbor = function() {
        return (u._ResizeNearestNeighbor = u.asm.ResizeNearestNeighbor).apply(null, arguments);
      }, u._ResizeNearestNeighborGrad = function() {
        return (u._ResizeNearestNeighborGrad = u.asm.ResizeNearestNeighborGrad).apply(null, arguments);
      }, u._Reverse = function() {
        return (u._Reverse = u.asm.Reverse).apply(null, arguments);
      }, u._RotateWithOffset = function() {
        return (u._RotateWithOffset = u.asm.RotateWithOffset).apply(null, arguments);
      }, u._Round = function() {
        return (u._Round = u.asm.Round).apply(null, arguments);
      }, u._Rsqrt = function() {
        return (u._Rsqrt = u.asm.Rsqrt).apply(null, arguments);
      }, u._ScatterNd = function() {
        return (u._ScatterNd = u.asm.ScatterNd).apply(null, arguments);
      }, u._SearchSorted = function() {
        return (u._SearchSorted = u.asm.SearchSorted).apply(null, arguments);
      }, u._SelectV2 = function() {
        return (u._SelectV2 = u.asm.SelectV2).apply(null, arguments);
      }, u._Selu = function() {
        return (u._Selu = u.asm.Selu).apply(null, arguments);
      }, u._Sigmoid = function() {
        return (u._Sigmoid = u.asm.Sigmoid).apply(null, arguments);
      }, u._Sign = function() {
        return (u._Sign = u.asm.Sign).apply(null, arguments);
      }, u._Sin = function() {
        return (u._Sin = u.asm.Sin).apply(null, arguments);
      }, u._Sinh = function() {
        return (u._Sinh = u.asm.Sinh).apply(null, arguments);
      }, u._Softmax = function() {
        return (u._Softmax = u.asm.Softmax).apply(null, arguments);
      }, u._Softplus = function() {
        return (u._Softplus = u.asm.Softplus).apply(null, arguments);
      }, u._SparseFillEmptyRows = function() {
        return (u._SparseFillEmptyRows = u.asm.SparseFillEmptyRows).apply(null, arguments);
      }, u._SparseReshape = function() {
        return (u._SparseReshape = u.asm.SparseReshape).apply(null, arguments);
      }, u._SparseSegmentReduction = function() {
        return (u._SparseSegmentReduction = u.asm.SparseSegmentReduction).apply(null, arguments);
      }, u._SparseToDense = function() {
        return (u._SparseToDense = u.asm.SparseToDense).apply(null, arguments);
      }, u._Sqrt = function() {
        return (u._Sqrt = u.asm.Sqrt).apply(null, arguments);
      }, u._Square = function() {
        return (u._Square = u.asm.Square).apply(null, arguments);
      }, u._SquaredDifference = function() {
        return (u._SquaredDifference = u.asm.SquaredDifference).apply(null, arguments);
      }, u._Step = function() {
        return (u._Step = u.asm.Step).apply(null, arguments);
      }, u._StridedSlice = function() {
        return (u._StridedSlice = u.asm.StridedSlice).apply(null, arguments);
      }, u._Sub = function() {
        return (u._Sub = u.asm.Sub).apply(null, arguments);
      }, u._Sum = function() {
        return (u._Sum = u.asm.Sum).apply(null, arguments);
      }, u._Tan = function() {
        return (u._Tan = u.asm.Tan).apply(null, arguments);
      }, u._Tanh = function() {
        return (u._Tanh = u.asm.Tanh).apply(null, arguments);
      }, u._TensorScatterUpdate = function() {
        return (u._TensorScatterUpdate = u.asm.TensorScatterUpdate).apply(null, arguments);
      }, u._Tile = function() {
        return (u._Tile = u.asm.Tile).apply(null, arguments);
      }, u._TopK = function() {
        return (u._TopK = u.asm.TopK).apply(null, arguments);
      }, u._Transform = function() {
        return (u._Transform = u.asm.Transform).apply(null, arguments);
      }, u._Transpose = function() {
        return (u._Transpose = u.asm.Transpose).apply(null, arguments);
      }, u.__FusedMatMul = function() {
        return (u.__FusedMatMul = u.asm._FusedMatMul).apply(null, arguments);
      }, u._malloc = function() {
        return (u._malloc = u.asm.malloc).apply(null, arguments);
      }, u._free = function() {
        return (u._free = u.asm.free).apply(null, arguments);
      }, u.__emscripten_tls_init = function() {
        return (u.__emscripten_tls_init = u.asm._emscripten_tls_init).apply(null, arguments);
      };
      var Gr = u._pthread_self = function() {
        return (Gr = u._pthread_self = u.asm.pthread_self).apply(null, arguments);
      };
      u.___errno_location = function() {
        return (u.___errno_location = u.asm.__errno_location).apply(null, arguments);
      };
      var ei = u.__emscripten_thread_init = function() {
        return (ei = u.__emscripten_thread_init = u.asm._emscripten_thread_init).apply(null, arguments);
      };
      u.__emscripten_thread_crashed = function() {
        return (u.__emscripten_thread_crashed = u.asm._emscripten_thread_crashed).apply(null, arguments);
      }, u._emscripten_main_thread_process_queued_calls = function() {
        return (u._emscripten_main_thread_process_queued_calls = u.asm.emscripten_main_thread_process_queued_calls).apply(null, arguments);
      }, u._emscripten_main_browser_thread_id = function() {
        return (u._emscripten_main_browser_thread_id = u.asm.emscripten_main_browser_thread_id).apply(null, arguments);
      };
      var Zs = u._emscripten_run_in_main_runtime_thread_js = function() {
        return (Zs = u._emscripten_run_in_main_runtime_thread_js = u.asm.emscripten_run_in_main_runtime_thread_js).apply(null, arguments);
      };
      u._emscripten_dispatch_to_thread_ = function() {
        return (u._emscripten_dispatch_to_thread_ = u.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
      };
      var Xu = u.__emscripten_proxy_execute_task_queue = function() {
        return (Xu = u.__emscripten_proxy_execute_task_queue = u.asm._emscripten_proxy_execute_task_queue).apply(null, arguments);
      }, ti = u.__emscripten_thread_free_data = function() {
        return (ti = u.__emscripten_thread_free_data = u.asm._emscripten_thread_free_data).apply(null, arguments);
      }, fs = u.__emscripten_thread_exit = function() {
        return (fs = u.__emscripten_thread_exit = u.asm._emscripten_thread_exit).apply(null, arguments);
      }, ni = u._emscripten_stack_set_limits = function() {
        return (ni = u._emscripten_stack_set_limits = u.asm.emscripten_stack_set_limits).apply(null, arguments);
      }, Js = u.stackSave = function() {
        return (Js = u.stackSave = u.asm.stackSave).apply(null, arguments);
      }, Qs = u.stackRestore = function() {
        return (Qs = u.stackRestore = u.asm.stackRestore).apply(null, arguments);
      }, eo = u.stackAlloc = function() {
        return (eo = u.stackAlloc = u.asm.stackAlloc).apply(null, arguments);
      };
      u.dynCall_iijjiiii = function() {
        return (u.dynCall_iijjiiii = u.asm.dynCall_iijjiiii).apply(null, arguments);
      }, u.dynCall_jiji = function() {
        return (u.dynCall_jiji = u.asm.dynCall_jiji).apply(null, arguments);
      }, u.keepRuntimeAlive = at, u.wasmMemory = q, u.cwrap = Ku, u.ExitStatus = hr, u.PThread = ve;
      var Ca;
      pn = function O() {
        Ca || ri(), Ca || (pn = O);
      };
      function ri(O) {
        if (jt > 0)
          return;
        if (w) {
          d(u), st(), startWorker(u);
          return;
        }
        if (Ht(), jt > 0)
          return;
        function G() {
          Ca || (Ca = !0, u.calledRun = !0, !se && (st(), d(u), u.onRuntimeInitialized && u.onRuntimeInitialized(), St()));
        }
        u.setStatus ? (u.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            u.setStatus("");
          }, 1), G();
        }, 1)) : G();
      }
      if (u.preInit)
        for (typeof u.preInit == "function" && (u.preInit = [u.preInit]); u.preInit.length > 0; )
          u.preInit.pop()();
      ri();
      var ps;
      p && (ps = { uncaughtException: process.listeners("uncaughtException").filter(function(O) {
        return !p.uncaughtException.indexOf(O) > -1;
      }), unhandledRejection: process.listeners("unhandledRejection").filter(function(O) {
        return !p.unhandledRejection.indexOf(O) > -1;
      }) });
      var hs;
      if (typeof WasmBackendModule < "u")
        hs = WasmBackendModule;
      else if (typeof a < "u")
        hs = a;
      else
        throw new Error("Could not find wasm module in post.js");
      if (ps) {
        var Yu = hs._dispose;
        hs._dispose = function() {
          Yu(), ps.uncaughtException.forEach(function(O) {
            process.removeListener("uncaughtException", O);
          }), ps.unhandledRejection.forEach(function(O) {
            process.removeListener("unhandledRejection", O);
          });
        };
      }
      return a.ready;
    };
  })();
  t.exports = n;
})(c_);
var l_ = c_.exports;
const d_ = /* @__PURE__ */ Vs(l_), Oz = /* @__PURE__ */ Gh({
  __proto__: null,
  default: d_
}, [l_]);
var Fz = `"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`, f_ = { exports: {} };
(function(t, e) {
  var n = (() => {
    var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
    return typeof __filename < "u" && (r = r || __filename), function(a) {
      a = a || {};
      var s = typeof a < "u" ? a : {}, o, i;
      s.ready = new Promise(function(J, ce) {
        o = J, i = ce;
      });
      var c;
      typeof process < "u" && process.listeners && (c = { uncaughtException: process.listeners("uncaughtException"), unhandledRejection: process.listeners("unhandledRejection") });
      var l = Object.assign({}, s), u = typeof window == "object", d = typeof importScripts == "function", f = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", p = "";
      function h(J) {
        return s.locateFile ? s.locateFile(J, p) : p + J;
      }
      var m, g, v;
      if (f) {
        var b = Ma, w = Ma;
        d ? p = w.dirname(p) + "/" : p = __dirname + "/", m = (J, ce) => (J = je(J) ? new URL(J) : w.normalize(J), b.readFileSync(J, ce ? void 0 : "utf8")), v = (J) => {
          var ce = m(J, !0);
          return ce.buffer || (ce = new Uint8Array(ce)), ce;
        }, g = (J, ce, Ce) => {
          J = je(J) ? new URL(J) : w.normalize(J), b.readFile(J, function(ve, bt) {
            ve ? Ce(ve) : ce(bt.buffer);
          });
        }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(J) {
          if (!(J instanceof at))
            throw J;
        }), process.on("unhandledRejection", function(J) {
          throw J;
        }), s.inspect = function() {
          return "[Emscripten Module object]";
        };
      } else
        (u || d) && (d ? p = self.location.href : typeof document < "u" && document.currentScript && (p = document.currentScript.src), r && (p = r), p.indexOf("blob:") !== 0 ? p = p.substr(0, p.replace(/[?#].*/, "").lastIndexOf("/") + 1) : p = "", m = (J) => {
          var ce = new XMLHttpRequest();
          return ce.open("GET", J, !1), ce.send(null), ce.responseText;
        }, d && (v = (J) => {
          var ce = new XMLHttpRequest();
          return ce.open("GET", J, !1), ce.responseType = "arraybuffer", ce.send(null), new Uint8Array(ce.response);
        }), g = (J, ce, Ce) => {
          var ve = new XMLHttpRequest();
          ve.open("GET", J, !0), ve.responseType = "arraybuffer", ve.onload = () => {
            if (ve.status == 200 || ve.status == 0 && ve.response) {
              ce(ve.response);
              return;
            }
            Ce();
          }, ve.onerror = Ce, ve.send(null);
        });
      var S = s.print || console.log.bind(console), I = s.printErr || console.warn.bind(console);
      Object.assign(s, l), l = null, s.arguments && s.arguments, s.thisProgram && s.thisProgram, s.quit && s.quit;
      var E;
      s.wasmBinary && (E = s.wasmBinary), s.noExitRuntime, typeof WebAssembly != "object" && Oe("no native wasm support detected");
      var T, R = !1, $ = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
      function D(J, ce, Ce) {
        ce >>>= 0;
        for (var ve = ce + Ce, bt = ce; J[bt] && !(bt >= ve); )
          ++bt;
        if (bt - ce > 16 && J.buffer && $)
          return $.decode(J.subarray(ce, bt));
        for (var _t = ""; ce < bt; ) {
          var He = J[ce++];
          if (!(He & 128)) {
            _t += String.fromCharCode(He);
            continue;
          }
          var Pe = J[ce++] & 63;
          if ((He & 224) == 192) {
            _t += String.fromCharCode((He & 31) << 6 | Pe);
            continue;
          }
          var Ut = J[ce++] & 63;
          if ((He & 240) == 224 ? He = (He & 15) << 12 | Pe << 6 | Ut : He = (He & 7) << 18 | Pe << 12 | Ut << 6 | J[ce++] & 63, He < 65536)
            _t += String.fromCharCode(He);
          else {
            var Bn = He - 65536;
            _t += String.fromCharCode(55296 | Bn >> 10, 56320 | Bn & 1023);
          }
        }
        return _t;
      }
      function M(J, ce) {
        return J >>>= 0, J ? D(U, J, ce) : "";
      }
      function z(J, ce, Ce, ve) {
        if (Ce >>>= 0, !(ve > 0))
          return 0;
        for (var bt = Ce, _t = Ce + ve - 1, He = 0; He < J.length; ++He) {
          var Pe = J.charCodeAt(He);
          if (Pe >= 55296 && Pe <= 57343) {
            var Ut = J.charCodeAt(++He);
            Pe = 65536 + ((Pe & 1023) << 10) | Ut & 1023;
          }
          if (Pe <= 127) {
            if (Ce >= _t)
              break;
            ce[Ce++ >>> 0] = Pe;
          } else if (Pe <= 2047) {
            if (Ce + 1 >= _t)
              break;
            ce[Ce++ >>> 0] = 192 | Pe >> 6, ce[Ce++ >>> 0] = 128 | Pe & 63;
          } else if (Pe <= 65535) {
            if (Ce + 2 >= _t)
              break;
            ce[Ce++ >>> 0] = 224 | Pe >> 12, ce[Ce++ >>> 0] = 128 | Pe >> 6 & 63, ce[Ce++ >>> 0] = 128 | Pe & 63;
          } else {
            if (Ce + 3 >= _t)
              break;
            ce[Ce++ >>> 0] = 240 | Pe >> 18, ce[Ce++ >>> 0] = 128 | Pe >> 12 & 63, ce[Ce++ >>> 0] = 128 | Pe >> 6 & 63, ce[Ce++ >>> 0] = 128 | Pe & 63;
          }
        }
        return ce[Ce >>> 0] = 0, Ce - bt;
      }
      function F(J, ce, Ce) {
        return z(J, U, ce, Ce);
      }
      var V, H, U, Z;
      function q(J) {
        V = J, s.HEAP8 = H = new Int8Array(J), s.HEAP16 = new Int16Array(J), s.HEAP32 = new Int32Array(J), s.HEAPU8 = U = new Uint8Array(J), s.HEAPU16 = new Uint16Array(J), s.HEAPU32 = Z = new Uint32Array(J), s.HEAPF32 = new Float32Array(J), s.HEAPF64 = new Float64Array(J);
      }
      s.INITIAL_MEMORY;
      var X = [], se = [], te = [];
      function ue() {
        if (s.preRun)
          for (typeof s.preRun == "function" && (s.preRun = [s.preRun]); s.preRun.length; )
            oe(s.preRun.shift());
        Ht(X);
      }
      function ee() {
        Ht(se);
      }
      function ne() {
        if (s.postRun)
          for (typeof s.postRun == "function" && (s.postRun = [s.postRun]); s.postRun.length; )
            be(s.postRun.shift());
        Ht(te);
      }
      function oe(J) {
        X.unshift(J);
      }
      function ge(J) {
        se.unshift(J);
      }
      function be(J) {
        te.unshift(J);
      }
      var fe = 0, we = null;
      function Re(J) {
        fe++, s.monitorRunDependencies && s.monitorRunDependencies(fe);
      }
      function $e(J) {
        if (fe--, s.monitorRunDependencies && s.monitorRunDependencies(fe), fe == 0 && we) {
          var ce = we;
          we = null, ce();
        }
      }
      function Oe(J) {
        s.onAbort && s.onAbort(J), J = "Aborted(" + J + ")", I(J), R = !0, J += ". Build with -sASSERTIONS for more info.";
        var ce = new WebAssembly.RuntimeError(J);
        throw i(ce), ce;
      }
      var We = "data:application/octet-stream;base64,";
      function Ue(J) {
        return J.startsWith(We);
      }
      function je(J) {
        return J.startsWith("file://");
      }
      var Ne;
      Ne = "tfjs-backend-wasm.wasm", Ue(Ne) || (Ne = h(Ne));
      function et(J) {
        try {
          if (J == Ne && E)
            return new Uint8Array(E);
          if (v)
            return v(J);
          throw "both async and sync fetching of the wasm failed";
        } catch (ce) {
          Oe(ce);
        }
      }
      function Ye() {
        if (!E && (u || d)) {
          if (typeof fetch == "function" && !je(Ne))
            return fetch(Ne, { credentials: "same-origin" }).then(function(J) {
              if (!J.ok)
                throw "failed to load wasm binary file at '" + Ne + "'";
              return J.arrayBuffer();
            }).catch(function() {
              return et(Ne);
            });
          if (g)
            return new Promise(function(J, ce) {
              g(Ne, function(Ce) {
                J(new Uint8Array(Ce));
              }, ce);
            });
        }
        return Promise.resolve().then(function() {
          return et(Ne);
        });
      }
      function ct() {
        var J = { env: os, wasi_snapshot_preview1: os };
        function ce(He, Pe) {
          var Ut = He.exports;
          s.asm = Ut, T = s.asm.memory, q(T.buffer), s.asm.__indirect_function_table, ge(s.asm.__wasm_call_ctors), $e();
        }
        Re();
        function Ce(He) {
          ce(He.instance);
        }
        function ve(He) {
          return Ye().then(function(Pe) {
            return WebAssembly.instantiate(Pe, J);
          }).then(function(Pe) {
            return Pe;
          }).then(He, function(Pe) {
            I("failed to asynchronously prepare wasm: " + Pe), Oe(Pe);
          });
        }
        function bt() {
          return !E && typeof WebAssembly.instantiateStreaming == "function" && !Ue(Ne) && !je(Ne) && !f && typeof fetch == "function" ? fetch(Ne, { credentials: "same-origin" }).then(function(He) {
            var Pe = WebAssembly.instantiateStreaming(He, J);
            return Pe.then(Ce, function(Ut) {
              return I("wasm streaming compile failed: " + Ut), I("falling back to ArrayBuffer instantiation"), ve(Ce);
            });
          }) : ve(Ce);
        }
        if (s.instantiateWasm)
          try {
            var _t = s.instantiateWasm(J, ce);
            return _t;
          } catch (He) {
            I("Module.instantiateWasm callback failed with error: " + He), i(He);
          }
        return bt().catch(i), {};
      }
      function at(J) {
        this.name = "ExitStatus", this.message = "Program terminated with exit(" + J + ")", this.status = J;
      }
      function Ht(J) {
        for (; J.length > 0; )
          J.shift()(s);
      }
      function st() {
        Oe("");
      }
      function St() {
        return 4294901760;
      }
      function Mt() {
        return St();
      }
      function Zt(J, ce, Ce) {
        U.copyWithin(J >>> 0, ce >>> 0, ce + Ce >>> 0);
      }
      function rn(J) {
        try {
          return T.grow(J - V.byteLength + 65535 >>> 16), q(T.buffer), 1;
        } catch {
        }
      }
      function jt(J) {
        var ce = U.length;
        J = J >>> 0;
        var Ce = St();
        if (J > Ce)
          return !1;
        let ve = (Ut, Bn) => Ut + (Bn - Ut % Bn) % Bn;
        for (var bt = 1; bt <= 4; bt *= 2) {
          var _t = ce * (1 + 0.2 / bt);
          _t = Math.min(_t, J + 100663296);
          var He = Math.min(Ce, ve(Math.max(J, _t), 65536)), Pe = rn(He);
          if (Pe)
            return !0;
        }
        return !1;
      }
      function pn(J) {
        return 52;
      }
      function kn(J, ce, Ce, ve, bt) {
        return 70;
      }
      var aa = [null, [], []];
      function En(J, ce) {
        var Ce = aa[J];
        ce === 0 || ce === 10 ? ((J === 1 ? S : I)(D(Ce, 0)), Ce.length = 0) : Ce.push(ce);
      }
      function Ia(J, ce, Ce, ve) {
        for (var bt = 0, _t = 0; _t < Ce; _t++) {
          var He = Z[ce >>> 2], Pe = Z[ce + 4 >>> 2];
          ce += 8;
          for (var Ut = 0; Ut < Pe; Ut++)
            En(J, U[He + Ut >>> 0]);
          bt += Pe;
        }
        return Z[ve >>> 2] = bt, 0;
      }
      function or(J) {
        var ce = s["_" + J];
        return ce;
      }
      function Xn(J, ce) {
        H.set(J, ce >>> 0);
      }
      function Lt(J, ce, Ce, ve, bt) {
        var _t = { string: (an) => {
          var ir = 0;
          if (an != null && an !== 0) {
            var ls = (an.length << 2) + 1;
            ir = hr(ls), F(an, ir, ls);
          }
          return ir;
        }, array: (an) => {
          var ir = hr(an.length);
          return Xn(an, ir), ir;
        } };
        function He(an) {
          return ce === "string" ? M(an) : ce === "boolean" ? !!an : an;
        }
        var Pe = or(J), Ut = [], Bn = 0;
        if (ve)
          for (var Yn = 0; Yn < ve.length; Yn++) {
            var us = _t[Ce[Yn]];
            us ? (Bn === 0 && (Bn = sa()), Ut[Yn] = us(ve[Yn])) : Ut[Yn] = ve[Yn];
          }
        var Ur = Pe.apply(null, Ut);
        function cs(an) {
          return Bn !== 0 && is(Bn), He(an);
        }
        return Ur = cs(Ur), Ur;
      }
      function ka(J, ce, Ce, ve) {
        Ce = Ce || [];
        var bt = Ce.every((He) => He === "number" || He === "boolean"), _t = ce !== "string";
        return _t && bt && !ve ? or(J) : function() {
          return Lt(J, ce, Ce, arguments);
        };
      }
      var os = { abort: st, emscripten_get_heap_max: Mt, emscripten_memcpy_big: Zt, emscripten_resize_heap: jt, fd_close: pn, fd_seek: kn, fd_write: Ia };
      ct(), s.___wasm_call_ctors = function() {
        return (s.___wasm_call_ctors = s.asm.__wasm_call_ctors).apply(null, arguments);
      }, s._init = function() {
        return (s._init = s.asm.init).apply(null, arguments);
      }, s._init_with_threads_count = function() {
        return (s._init_with_threads_count = s.asm.init_with_threads_count).apply(null, arguments);
      }, s._get_threads_count = function() {
        return (s._get_threads_count = s.asm.get_threads_count).apply(null, arguments);
      }, s._register_tensor = function() {
        return (s._register_tensor = s.asm.register_tensor).apply(null, arguments);
      }, s._dispose_data = function() {
        return (s._dispose_data = s.asm.dispose_data).apply(null, arguments);
      }, s._dispose = function() {
        return (s._dispose = s.asm.dispose).apply(null, arguments);
      }, s._Abs = function() {
        return (s._Abs = s.asm.Abs).apply(null, arguments);
      }, s._Acos = function() {
        return (s._Acos = s.asm.Acos).apply(null, arguments);
      }, s._Acosh = function() {
        return (s._Acosh = s.asm.Acosh).apply(null, arguments);
      }, s._Add = function() {
        return (s._Add = s.asm.Add).apply(null, arguments);
      }, s._AddN = function() {
        return (s._AddN = s.asm.AddN).apply(null, arguments);
      }, s._All = function() {
        return (s._All = s.asm.All).apply(null, arguments);
      }, s._Any = function() {
        return (s._Any = s.asm.Any).apply(null, arguments);
      }, s._ArgMax = function() {
        return (s._ArgMax = s.asm.ArgMax).apply(null, arguments);
      }, s._ArgMin = function() {
        return (s._ArgMin = s.asm.ArgMin).apply(null, arguments);
      }, s._Asin = function() {
        return (s._Asin = s.asm.Asin).apply(null, arguments);
      }, s._Asinh = function() {
        return (s._Asinh = s.asm.Asinh).apply(null, arguments);
      }, s._Atan = function() {
        return (s._Atan = s.asm.Atan).apply(null, arguments);
      }, s._Atan2 = function() {
        return (s._Atan2 = s.asm.Atan2).apply(null, arguments);
      }, s._Atanh = function() {
        return (s._Atanh = s.asm.Atanh).apply(null, arguments);
      }, s._AvgPool = function() {
        return (s._AvgPool = s.asm.AvgPool).apply(null, arguments);
      }, s._AvgPool3D = function() {
        return (s._AvgPool3D = s.asm.AvgPool3D).apply(null, arguments);
      }, s._AvgPool3DGrad = function() {
        return (s._AvgPool3DGrad = s.asm.AvgPool3DGrad).apply(null, arguments);
      }, s._AvgPoolGrad = function() {
        return (s._AvgPoolGrad = s.asm.AvgPoolGrad).apply(null, arguments);
      }, s._BatchMatMul = function() {
        return (s._BatchMatMul = s.asm.BatchMatMul).apply(null, arguments);
      }, s._Bincount = function() {
        return (s._Bincount = s.asm.Bincount).apply(null, arguments);
      }, s._BitwiseAnd = function() {
        return (s._BitwiseAnd = s.asm.BitwiseAnd).apply(null, arguments);
      }, s._Ceil = function() {
        return (s._Ceil = s.asm.Ceil).apply(null, arguments);
      }, s._ClipByValue = function() {
        return (s._ClipByValue = s.asm.ClipByValue).apply(null, arguments);
      }, s._Conv2D = function() {
        return (s._Conv2D = s.asm.Conv2D).apply(null, arguments);
      }, s._Conv2DBackpropInput = function() {
        return (s._Conv2DBackpropInput = s.asm.Conv2DBackpropInput).apply(null, arguments);
      }, s._Conv3D = function() {
        return (s._Conv3D = s.asm.Conv3D).apply(null, arguments);
      }, s._Conv3DBackpropFilterV2 = function() {
        return (s._Conv3DBackpropFilterV2 = s.asm.Conv3DBackpropFilterV2).apply(null, arguments);
      }, s._Conv3DBackpropInputV2 = function() {
        return (s._Conv3DBackpropInputV2 = s.asm.Conv3DBackpropInputV2).apply(null, arguments);
      }, s._Cos = function() {
        return (s._Cos = s.asm.Cos).apply(null, arguments);
      }, s._Cosh = function() {
        return (s._Cosh = s.asm.Cosh).apply(null, arguments);
      }, s._CropAndResize = function() {
        return (s._CropAndResize = s.asm.CropAndResize).apply(null, arguments);
      }, s._Cumprod = function() {
        return (s._Cumprod = s.asm.Cumprod).apply(null, arguments);
      }, s._Cumsum = function() {
        return (s._Cumsum = s.asm.Cumsum).apply(null, arguments);
      }, s._DenseBincount = function() {
        return (s._DenseBincount = s.asm.DenseBincount).apply(null, arguments);
      }, s._DepthToSpace = function() {
        return (s._DepthToSpace = s.asm.DepthToSpace).apply(null, arguments);
      }, s._DepthwiseConv2dNative = function() {
        return (s._DepthwiseConv2dNative = s.asm.DepthwiseConv2dNative).apply(null, arguments);
      }, s._Diag = function() {
        return (s._Diag = s.asm.Diag).apply(null, arguments);
      }, s._Dilation2D = function() {
        return (s._Dilation2D = s.asm.Dilation2D).apply(null, arguments);
      }, s._Dilation2DBackpropFilter = function() {
        return (s._Dilation2DBackpropFilter = s.asm.Dilation2DBackpropFilter).apply(null, arguments);
      }, s._Dilation2DBackpropInput = function() {
        return (s._Dilation2DBackpropInput = s.asm.Dilation2DBackpropInput).apply(null, arguments);
      }, s._Elu = function() {
        return (s._Elu = s.asm.Elu).apply(null, arguments);
      }, s._EluGrad = function() {
        return (s._EluGrad = s.asm.EluGrad).apply(null, arguments);
      }, s._Equal = function() {
        return (s._Equal = s.asm.Equal).apply(null, arguments);
      }, s._Erf = function() {
        return (s._Erf = s.asm.Erf).apply(null, arguments);
      }, s._Exp = function() {
        return (s._Exp = s.asm.Exp).apply(null, arguments);
      }, s._Expm1 = function() {
        return (s._Expm1 = s.asm.Expm1).apply(null, arguments);
      }, s._FlipLeftRight = function() {
        return (s._FlipLeftRight = s.asm.FlipLeftRight).apply(null, arguments);
      }, s._Floor = function() {
        return (s._Floor = s.asm.Floor).apply(null, arguments);
      }, s._FloorDiv = function() {
        return (s._FloorDiv = s.asm.FloorDiv).apply(null, arguments);
      }, s._FusedBatchNorm = function() {
        return (s._FusedBatchNorm = s.asm.FusedBatchNorm).apply(null, arguments);
      }, s._FusedConv2D = function() {
        return (s._FusedConv2D = s.asm.FusedConv2D).apply(null, arguments);
      }, s._FusedDepthwiseConv2D = function() {
        return (s._FusedDepthwiseConv2D = s.asm.FusedDepthwiseConv2D).apply(null, arguments);
      }, s._Gather = function() {
        return (s._Gather = s.asm.Gather).apply(null, arguments);
      }, s._GatherNd = function() {
        return (s._GatherNd = s.asm.GatherNd).apply(null, arguments);
      }, s._Greater = function() {
        return (s._Greater = s.asm.Greater).apply(null, arguments);
      }, s._GreaterEqual = function() {
        return (s._GreaterEqual = s.asm.GreaterEqual).apply(null, arguments);
      }, s._IsFinite = function() {
        return (s._IsFinite = s.asm.IsFinite).apply(null, arguments);
      }, s._IsInf = function() {
        return (s._IsInf = s.asm.IsInf).apply(null, arguments);
      }, s._IsNan = function() {
        return (s._IsNan = s.asm.IsNan).apply(null, arguments);
      }, s._LRN = function() {
        return (s._LRN = s.asm.LRN).apply(null, arguments);
      }, s._LRNGrad = function() {
        return (s._LRNGrad = s.asm.LRNGrad).apply(null, arguments);
      }, s._LeakyRelu = function() {
        return (s._LeakyRelu = s.asm.LeakyRelu).apply(null, arguments);
      }, s._Less = function() {
        return (s._Less = s.asm.Less).apply(null, arguments);
      }, s._LessEqual = function() {
        return (s._LessEqual = s.asm.LessEqual).apply(null, arguments);
      }, s._LinSpace = function() {
        return (s._LinSpace = s.asm.LinSpace).apply(null, arguments);
      }, s._Log = function() {
        return (s._Log = s.asm.Log).apply(null, arguments);
      }, s._Log1p = function() {
        return (s._Log1p = s.asm.Log1p).apply(null, arguments);
      }, s._LogicalAnd = function() {
        return (s._LogicalAnd = s.asm.LogicalAnd).apply(null, arguments);
      }, s._LogicalNot = function() {
        return (s._LogicalNot = s.asm.LogicalNot).apply(null, arguments);
      }, s._LogicalOr = function() {
        return (s._LogicalOr = s.asm.LogicalOr).apply(null, arguments);
      }, s._LogicalXor = function() {
        return (s._LogicalXor = s.asm.LogicalXor).apply(null, arguments);
      }, s._Max = function() {
        return (s._Max = s.asm.Max).apply(null, arguments);
      }, s._MaxPool = function() {
        return (s._MaxPool = s.asm.MaxPool).apply(null, arguments);
      }, s._MaxPool3D = function() {
        return (s._MaxPool3D = s.asm.MaxPool3D).apply(null, arguments);
      }, s._MaxPool3DGrad = function() {
        return (s._MaxPool3DGrad = s.asm.MaxPool3DGrad).apply(null, arguments);
      }, s._MaxPoolGrad = function() {
        return (s._MaxPoolGrad = s.asm.MaxPoolGrad).apply(null, arguments);
      }, s._MaxPoolWithArgmax = function() {
        return (s._MaxPoolWithArgmax = s.asm.MaxPoolWithArgmax).apply(null, arguments);
      }, s._Maximum = function() {
        return (s._Maximum = s.asm.Maximum).apply(null, arguments);
      }, s._Mean = function() {
        return (s._Mean = s.asm.Mean).apply(null, arguments);
      }, s._Min = function() {
        return (s._Min = s.asm.Min).apply(null, arguments);
      }, s._Minimum = function() {
        return (s._Minimum = s.asm.Minimum).apply(null, arguments);
      }, s._MirrorPad = function() {
        return (s._MirrorPad = s.asm.MirrorPad).apply(null, arguments);
      }, s._Mod = function() {
        return (s._Mod = s.asm.Mod).apply(null, arguments);
      }, s._Multinomial = function() {
        return (s._Multinomial = s.asm.Multinomial).apply(null, arguments);
      }, s._Multiply = function() {
        return (s._Multiply = s.asm.Multiply).apply(null, arguments);
      }, s._Neg = function() {
        return (s._Neg = s.asm.Neg).apply(null, arguments);
      }, s._NonMaxSuppressionV3 = function() {
        return (s._NonMaxSuppressionV3 = s.asm.NonMaxSuppressionV3).apply(null, arguments);
      }, s._NonMaxSuppressionV4 = function() {
        return (s._NonMaxSuppressionV4 = s.asm.NonMaxSuppressionV4).apply(null, arguments);
      }, s._NonMaxSuppressionV5 = function() {
        return (s._NonMaxSuppressionV5 = s.asm.NonMaxSuppressionV5).apply(null, arguments);
      }, s._NotEqual = function() {
        return (s._NotEqual = s.asm.NotEqual).apply(null, arguments);
      }, s._OneHot = function() {
        return (s._OneHot = s.asm.OneHot).apply(null, arguments);
      }, s._PadV2 = function() {
        return (s._PadV2 = s.asm.PadV2).apply(null, arguments);
      }, s._Pow = function() {
        return (s._Pow = s.asm.Pow).apply(null, arguments);
      }, s._Prelu = function() {
        return (s._Prelu = s.asm.Prelu).apply(null, arguments);
      }, s._Prod = function() {
        return (s._Prod = s.asm.Prod).apply(null, arguments);
      }, s._RealDiv = function() {
        return (s._RealDiv = s.asm.RealDiv).apply(null, arguments);
      }, s._Reciprocal = function() {
        return (s._Reciprocal = s.asm.Reciprocal).apply(null, arguments);
      }, s._Relu = function() {
        return (s._Relu = s.asm.Relu).apply(null, arguments);
      }, s._Relu6 = function() {
        return (s._Relu6 = s.asm.Relu6).apply(null, arguments);
      }, s._ResizeBilinear = function() {
        return (s._ResizeBilinear = s.asm.ResizeBilinear).apply(null, arguments);
      }, s._ResizeBilinearGrad = function() {
        return (s._ResizeBilinearGrad = s.asm.ResizeBilinearGrad).apply(null, arguments);
      }, s._ResizeNearestNeighbor = function() {
        return (s._ResizeNearestNeighbor = s.asm.ResizeNearestNeighbor).apply(null, arguments);
      }, s._ResizeNearestNeighborGrad = function() {
        return (s._ResizeNearestNeighborGrad = s.asm.ResizeNearestNeighborGrad).apply(null, arguments);
      }, s._Reverse = function() {
        return (s._Reverse = s.asm.Reverse).apply(null, arguments);
      }, s._RotateWithOffset = function() {
        return (s._RotateWithOffset = s.asm.RotateWithOffset).apply(null, arguments);
      }, s._Round = function() {
        return (s._Round = s.asm.Round).apply(null, arguments);
      }, s._Rsqrt = function() {
        return (s._Rsqrt = s.asm.Rsqrt).apply(null, arguments);
      }, s._ScatterNd = function() {
        return (s._ScatterNd = s.asm.ScatterNd).apply(null, arguments);
      }, s._SearchSorted = function() {
        return (s._SearchSorted = s.asm.SearchSorted).apply(null, arguments);
      }, s._SelectV2 = function() {
        return (s._SelectV2 = s.asm.SelectV2).apply(null, arguments);
      }, s._Selu = function() {
        return (s._Selu = s.asm.Selu).apply(null, arguments);
      }, s._Sigmoid = function() {
        return (s._Sigmoid = s.asm.Sigmoid).apply(null, arguments);
      }, s._Sign = function() {
        return (s._Sign = s.asm.Sign).apply(null, arguments);
      }, s._Sin = function() {
        return (s._Sin = s.asm.Sin).apply(null, arguments);
      }, s._Sinh = function() {
        return (s._Sinh = s.asm.Sinh).apply(null, arguments);
      }, s._Softmax = function() {
        return (s._Softmax = s.asm.Softmax).apply(null, arguments);
      }, s._Softplus = function() {
        return (s._Softplus = s.asm.Softplus).apply(null, arguments);
      }, s._SparseFillEmptyRows = function() {
        return (s._SparseFillEmptyRows = s.asm.SparseFillEmptyRows).apply(null, arguments);
      }, s._SparseReshape = function() {
        return (s._SparseReshape = s.asm.SparseReshape).apply(null, arguments);
      }, s._SparseSegmentReduction = function() {
        return (s._SparseSegmentReduction = s.asm.SparseSegmentReduction).apply(null, arguments);
      }, s._SparseToDense = function() {
        return (s._SparseToDense = s.asm.SparseToDense).apply(null, arguments);
      }, s._Sqrt = function() {
        return (s._Sqrt = s.asm.Sqrt).apply(null, arguments);
      }, s._Square = function() {
        return (s._Square = s.asm.Square).apply(null, arguments);
      }, s._SquaredDifference = function() {
        return (s._SquaredDifference = s.asm.SquaredDifference).apply(null, arguments);
      }, s._Step = function() {
        return (s._Step = s.asm.Step).apply(null, arguments);
      }, s._StridedSlice = function() {
        return (s._StridedSlice = s.asm.StridedSlice).apply(null, arguments);
      }, s._Sub = function() {
        return (s._Sub = s.asm.Sub).apply(null, arguments);
      }, s._Sum = function() {
        return (s._Sum = s.asm.Sum).apply(null, arguments);
      }, s._Tan = function() {
        return (s._Tan = s.asm.Tan).apply(null, arguments);
      }, s._Tanh = function() {
        return (s._Tanh = s.asm.Tanh).apply(null, arguments);
      }, s._TensorScatterUpdate = function() {
        return (s._TensorScatterUpdate = s.asm.TensorScatterUpdate).apply(null, arguments);
      }, s._Tile = function() {
        return (s._Tile = s.asm.Tile).apply(null, arguments);
      }, s._TopK = function() {
        return (s._TopK = s.asm.TopK).apply(null, arguments);
      }, s._Transform = function() {
        return (s._Transform = s.asm.Transform).apply(null, arguments);
      }, s._Transpose = function() {
        return (s._Transpose = s.asm.Transpose).apply(null, arguments);
      }, s.__FusedMatMul = function() {
        return (s.__FusedMatMul = s.asm._FusedMatMul).apply(null, arguments);
      }, s._malloc = function() {
        return (s._malloc = s.asm.malloc).apply(null, arguments);
      }, s._free = function() {
        return (s._free = s.asm.free).apply(null, arguments);
      }, s.___errno_location = function() {
        return (s.___errno_location = s.asm.__errno_location).apply(null, arguments);
      };
      var sa = s.stackSave = function() {
        return (sa = s.stackSave = s.asm.stackSave).apply(null, arguments);
      }, is = s.stackRestore = function() {
        return (is = s.stackRestore = s.asm.stackRestore).apply(null, arguments);
      }, hr = s.stackAlloc = function() {
        return (hr = s.stackAlloc = s.asm.stackAlloc).apply(null, arguments);
      };
      s.dynCall_iijjiiii = function() {
        return (s.dynCall_iijjiiii = s.asm.dynCall_iijjiiii).apply(null, arguments);
      }, s.dynCall_jiji = function() {
        return (s.dynCall_jiji = s.asm.dynCall_jiji).apply(null, arguments);
      }, s.cwrap = ka;
      var oa;
      we = function J() {
        oa || Tn(), oa || (we = J);
      };
      function Tn(J) {
        if (fe > 0 || (ue(), fe > 0))
          return;
        function ce() {
          oa || (oa = !0, s.calledRun = !0, !R && (ee(), o(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), ne()));
        }
        s.setStatus ? (s.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            s.setStatus("");
          }, 1), ce();
        }, 1)) : ce();
      }
      if (s.preInit)
        for (typeof s.preInit == "function" && (s.preInit = [s.preInit]); s.preInit.length > 0; )
          s.preInit.pop()();
      Tn();
      var Et;
      c && (Et = { uncaughtException: process.listeners("uncaughtException").filter(function(J) {
        return !c.uncaughtException.indexOf(J) > -1;
      }), unhandledRejection: process.listeners("unhandledRejection").filter(function(J) {
        return !c.unhandledRejection.indexOf(J) > -1;
      }) });
      var jr;
      if (typeof a < "u")
        jr = a;
      else if (typeof WasmBackendModuleThreadedSimd < "u")
        jr = WasmBackendModuleThreadedSimd;
      else
        throw new Error("Could not find wasm module in post.js");
      if (Et) {
        var Pn = jr._dispose;
        jr._dispose = function() {
          Pn(), Et.uncaughtException.forEach(function(J) {
            process.removeListener("uncaughtException", J);
          }), Et.unhandledRejection.forEach(function(J) {
            process.removeListener("unhandledRejection", J);
          });
        };
      }
      return a.ready;
    };
  })();
  t.exports = n;
})(f_);
var p_ = f_.exports;
const h_ = /* @__PURE__ */ Vs(p_), Mz = /* @__PURE__ */ Gh({
  __proto__: null,
  default: h_
}, [p_]);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ev = d_ || Oz, Pz = h_ || Mz;
class Bz extends rm {
  constructor(e) {
    super(), this.wasm = e, this.dataIdNextNumber = 1, this.wasm.tfjs.initWithThreadsCount(Uz), this.wasm.tfjs.getThreadsCount(), this.dataIdMap = new V0(this, Jp());
  }
  write(e, n, r) {
    const a = { id: this.dataIdNextNumber++ };
    return this.move(a, e, n, r, 1), a;
  }
  numDataIds() {
    return this.dataIdMap.numDataIds();
  }
  async time(e) {
    const n = Ha();
    return e(), { kernelMs: Ha() - n };
  }
  move(e, n, r, a, s) {
    const o = this.dataIdNextNumber++;
    if (a === "string") {
      const u = n;
      this.dataIdMap.set(e, { id: o, stringBytes: u, shape: r, dtype: a, memoryOffset: null, refCount: s });
      return;
    }
    const i = Y(r), c = i * Qi(a), l = this.wasm._malloc(c) >>> 0;
    this.dataIdMap.set(e, { id: o, memoryOffset: l, shape: r, dtype: a, refCount: s }), this.wasm.tfjs.registerTensor(o, i, l), n != null && this.wasm.HEAPU8.set(new Uint8Array(n.buffer, n.byteOffset, c), l);
  }
  async read(e) {
    return this.readSync(e);
  }
  readSync(e, n, r) {
    const { memoryOffset: a, dtype: s, shape: o, stringBytes: i } = this.dataIdMap.get(e);
    if (s === "string")
      return (n == null || n === 0) && (r == null || r >= i.length) ? i : i.slice(n, r);
    n = n || 0, r = r || Y(o);
    const c = Qi(s), l = this.wasm.HEAPU8.slice(a + n * c, a + r * c);
    return zz(l.buffer, s);
  }
  /**
   * Dispose the memory if the dataId has 0 refCount. Return true if the memory
   * is released, false otherwise.
   * @param dataId
   * @oaram force Optional, remove the data regardless of refCount
   */
  disposeData(e, n = !1) {
    if (this.dataIdMap.has(e)) {
      const r = this.dataIdMap.get(e);
      if (r.refCount--, !n && r.refCount > 0)
        return !1;
      this.wasm._free(r.memoryOffset), this.wasm.tfjs.disposeData(r.id), this.dataIdMap.delete(e);
    }
    return !0;
  }
  /** Return refCount of a `TensorData`. */
  refCount(e) {
    return this.dataIdMap.has(e) ? this.dataIdMap.get(e).refCount : 0;
  }
  incRef(e) {
    const n = this.dataIdMap.get(e);
    n != null && n.refCount++;
  }
  floatPrecision() {
    return 32;
  }
  // Returns the memory offset of a tensor. Useful for debugging and unit
  // testing.
  getMemoryOffset(e) {
    return this.dataIdMap.get(e).memoryOffset;
  }
  dispose() {
    this.wasm.tfjs.dispose(), "PThread" in this.wasm && this.wasm.PThread.terminateAllThreads(), this.wasm = null;
  }
  memory() {
    return { unreliable: !1 };
  }
  /**
   * Make a tensor info for the output of an op. If `memoryOffset` is not
   * present, this method allocates memory on the WASM heap. If `memoryOffset`
   * is present, the memory was allocated elsewhere (in c++) and we just record
   * the pointer where that memory lives.
   */
  makeOutput(e, n, r, a) {
    let s;
    if (r == null)
      s = this.write(a ?? null, e, n);
    else {
      const o = this.dataIdNextNumber++;
      s = { id: o }, this.dataIdMap.set(s, { id: o, memoryOffset: r, shape: e, dtype: n, refCount: 1 });
      const i = Y(e);
      this.wasm.tfjs.registerTensor(o, i, r);
    }
    return { dataId: s, shape: e, dtype: n };
  }
  typedArrayFromHeap({ shape: e, dtype: n, dataId: r }) {
    const a = this.wasm.HEAPU8.buffer, { memoryOffset: s } = this.dataIdMap.get(r), o = Y(e);
    switch (n) {
      case "float32":
        return new Float32Array(a, s, o);
      case "int32":
        return new Int32Array(a, s, o);
      case "bool":
        return new Uint8Array(a, s, o);
      default:
        throw new Error(`Unknown dtype ${n}`);
    }
  }
}
function Lz(t) {
  return (e, n) => (AT(t, { credentials: "same-origin" }).then((r) => {
    r.ok || e.env.a(`failed to load wasm binary file at '${t}'`), r.arrayBuffer().then((a) => {
      WebAssembly.instantiate(a, e).then((s) => {
        n(s.instance, s.module);
      });
    });
  }), {});
}
function Tv(t, e, n) {
  let r = "tfjs-backend-wasm.wasm";
  return t && e ? r = "tfjs-backend-wasm-threaded-simd.wasm" : t && (r = "tfjs-backend-wasm-simd.wasm"), ji != null && ji[r] != null ? ji[r] : n + r;
}
async function Wz() {
  const [t, e] = await Promise.all([
    Xe().getAsync("WASM_HAS_SIMD_SUPPORT"),
    Xe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")
  ]);
  return new Promise((n, r) => {
    const a = {};
    a.locateFile = (i, c) => {
      if (i.endsWith(".worker.js")) {
        const l = Fz.replace(/\n/g, "\\n"), u = new Blob([l], { type: "application/javascript" });
        return URL.createObjectURL(u);
      }
      return i.endsWith(".wasm") ? Tv(t, e, Fi ?? c) : c + i;
    }, m_ && (a.instantiateWasm = Lz(Tv(t, e, Fi ?? "")));
    let s = !1;
    a.onAbort = () => {
      if (s || _c)
        return;
      _c = !0, r({ message: "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers" });
    };
    let o;
    e && t && Hz == null ? (a.mainScriptUrlOrBlob = new Blob(["var WasmBackendModuleThreadedSimd = " + Ev.toString()], { type: "text/javascript" }), o = Ev(a)) : o = Pz(a), o.then((i) => {
      s = !0, _c = !1;
      const c = null;
      i.tfjs = {
        init: i.cwrap("init", null, []),
        initWithThreadsCount: i.cwrap("init_with_threads_count", null, ["number"]),
        getThreadsCount: i.cwrap("get_threads_count", "number", []),
        registerTensor: i.cwrap("register_tensor", null, [
          "number",
          "number",
          "number"
          // memoryOffset
        ]),
        disposeData: i.cwrap("dispose_data", c, ["number"]),
        dispose: i.cwrap("dispose", c, [])
      }, n({ wasm: i });
    }).catch(r);
  });
}
function zz(t, e) {
  switch (e) {
    case "float32":
      return new Float32Array(t);
    case "int32":
      return new Int32Array(t);
    case "bool":
      return new Uint8Array(t);
    default:
      throw new Error(`Unknown dtype ${e}`);
  }
}
const Vz = [
  "tfjs-backend-wasm.wasm",
  "tfjs-backend-wasm-simd.wasm",
  "tfjs-backend-wasm-threaded-simd.wasm"
];
let Hz = null, Fi = null, ji = {}, _c = !1, m_ = !1;
function jz(t, e = !1) {
  if (_c)
    throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
  if (typeof t == "string")
    Fi = t;
  else {
    ji = t;
    const n = Vz.filter((r) => ji[r] == null);
    if (n.length > 0)
      throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`);
  }
  m_ = e;
}
let Uz = -1;
/** @license See the LICENSE file. */
const Gz = "4.11.0";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qz = 2;
U1("wasm", async () => {
  const { wasm: t } = await Wz();
  return new Bz(t);
}, qz);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Kz = Tw;
class kf extends rm {
  nextDataId() {
    return kf.nextDataId++;
  }
  constructor() {
    super(), this.blockSize = 48, this.firstUse = !0, this.data = new V0(this, Jp());
  }
  write(e, n, r) {
    this.firstUse && (this.firstUse = !1, Xe().get("IS_NODE") && bs(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
    const a = { id: this.nextDataId() };
    return this.data.set(a, { values: e, dtype: r, refCount: 1 }), a;
  }
  /**
   * Create a data bucket in cpu backend.
   * @param shape Shape of the `TensorInfo`.
   * @param dtype DType of the `TensorInfo`.
   * @param values The value of the `TensorInfo` stored as a flattened array.
   */
  makeTensorInfo(e, n, r) {
    let a;
    if (n === "string" && r != null && r.length > 0 && fl(r[0])) {
      const s = r.map((o) => Ts(o));
      a = this.write(s, e, n);
    } else
      a = this.write(r, e, n);
    return { dataId: a, shape: e, dtype: n };
  }
  /** Return refCount of a `TensorData`. */
  refCount(e) {
    return this.data.has(e) ? this.data.get(e).refCount : 0;
  }
  /** Increase refCount of a `TensorData`. */
  incRef(e) {
    const n = this.data.get(e);
    n.refCount++;
  }
  /** Decrease refCount of a `TensorData`. */
  decRef(e) {
    if (this.data.has(e)) {
      const n = this.data.get(e);
      n.refCount--;
    }
  }
  move(e, n, r, a, s) {
    this.data.set(e, { values: n, dtype: a, refCount: s });
  }
  numDataIds() {
    return this.data.numDataIds();
  }
  async read(e) {
    return this.readSync(e);
  }
  readSync(e) {
    const { dtype: n, complexTensorInfos: r } = this.data.get(e);
    if (n === "complex64") {
      const a = this.readSync(r.real.dataId), s = this.readSync(r.imag.dataId);
      return No(a, s);
    }
    return pT(this.data.get(e).values, n);
  }
  bufferSync(e) {
    const n = this.readSync(e.dataId);
    if (e.dtype === "string")
      try {
        const r = n.map((a) => ru(a));
        return Qe(e.shape, e.dtype, r);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return Qe(e.shape, e.dtype, n);
  }
  makeOutput(e, n, r) {
    return Jp().makeTensorFromTensorInfo(this.makeTensorInfo(n, r, e), this);
  }
  /**
   * Dispose the memory if the dataId has 0 refCount. Return true if the memory
   * is released or memory is not managed in this backend, false if memory is
   * not cleared.
   * @param dataId
   * @oaram force Optional, remove the data regardless of refCount
   */
  disposeData(e, n = !1) {
    if (this.data.has(e)) {
      if (this.data.get(e).refCount--, !n && this.data.get(e).refCount > 0)
        return !1;
      const { complexTensorInfos: r } = this.data.get(e);
      r != null && (this.disposeData(r.real.dataId, !0), this.disposeData(r.imag.dataId, !0)), this.data.delete(e);
    }
    return !0;
  }
  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }
  async time(e) {
    const n = Ha();
    return e(), { kernelMs: Ha() - n };
  }
  memory() {
    return {
      // Unreliable due to automatic gc. The numbers above are cumulative.
      unreliable: !0,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }
  where(e) {
    xe([e], "where");
    const n = this.readSync(e.dataId);
    return Kz(e.shape, n);
  }
  dispose() {
  }
  floatPrecision() {
    return 32;
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return super.epsilon();
  }
}
kf.nextDataId = 0;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
U1(
  "cpu",
  () => new kf(),
  1
  /* priority */
);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const g_ = vt(Vl, (t) => t >= 0 ? t : Math.exp(t) - 1), Xz = {
  kernelName: Vl,
  backendName: "cpu",
  kernelFunc: g_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function y_(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { alpha: s } = r;
  xe([a], "leakyRelu");
  const o = Y(a.shape), i = n.data.get(a.dataId).values, c = Dn("float32", o);
  for (let l = 0; l < i.length; l++)
    c[l] = i[l] < 0 ? s * i[l] : i[l];
  return n.makeTensorInfo(a.shape, "float32", c);
}
const Yz = {
  kernelName: ad,
  backendName: "cpu",
  kernelFunc: y_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Zz = Yt((t, e) => t < 0 ? e * t : t);
function v_(t) {
  const { inputs: e, backend: n } = t, { x: r, alpha: a } = e;
  xe([r, a], "prelu");
  const s = n.data.get(r.dataId).values, o = n.data.get(a.dataId).values, [i, c] = Zz(r.shape, a.shape, s, o, "float32");
  return n.makeTensorInfo(c, "float32", i);
}
const Jz = {
  kernelName: Rd,
  backendName: "cpu",
  kernelFunc: v_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const b_ = vt(Od, (t) => Math.max(0, t)), Qz = {
  kernelName: Od,
  backendName: "cpu",
  kernelFunc: b_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const w_ = vt(Pd, (t) => Math.min(Math.max(0, t), 6)), eV = {
  kernelName: Pd,
  backendName: "cpu",
  kernelFunc: w_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jc(t, e, n, r, a) {
  if (n === "linear")
    return ea({ inputs: { x: e }, backend: t });
  if (n === "relu")
    return b_({ inputs: { x: e }, backend: t });
  if (n === "elu")
    return g_({ inputs: { x: e }, backend: t });
  if (n === "relu6")
    return w_({ inputs: { x: e }, backend: t });
  if (n === "prelu")
    return v_({ inputs: { x: e, alpha: r }, backend: t });
  if (n === "leakyrelu")
    return y_({ inputs: { x: e }, backend: t, attrs: { alpha: a } });
  if (n === "sigmoid")
    return P2({ inputs: { x: e }, backend: t });
  throw new Error(`Activation ${n} has not been implemented for the CPU backend.`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rt(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { shape: s } = r, o = Y(a.shape), i = H0(s, o), c = Y(i);
  A(o === c, () => `The new shape (${i}) has ${c} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`), n.incRef(a.dataId);
  const l = n.data.get(a.dataId);
  if (l.complexTensorInfos != null) {
    const u = l.complexTensorInfos.real, d = l.complexTensorInfos.imag;
    u.shape = i, d.shape = i;
  }
  return { dataId: a.dataId, shape: i, dtype: a.dtype };
}
const tV = {
  kernelName: Cm,
  backendName: "cpu",
  kernelFunc: Rt
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function S_(t) {
  const { inputs: e, backend: n, attrs: r } = t, { a, b: s } = e, { transposeA: o, transposeB: i } = r;
  xe([a, s], "matMul");
  const c = a.shape.length, l = s.shape.length, u = o ? a.shape[c - 2] : a.shape[c - 1], d = i ? s.shape[l - 1] : s.shape[l - 2], f = o ? a.shape[c - 1] : a.shape[c - 2], p = i ? s.shape[l - 2] : s.shape[l - 1], h = a.shape.slice(0, -2), m = s.shape.slice(0, -2), g = Y(h), v = Y(m), w = At(a.shape.slice(0, -2), s.shape.slice(0, -2)).concat([f, p]);
  A(u === d, () => `Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`);
  const S = o ? [g, u, f] : [g, f, u], I = i ? [v, p, d] : [v, d, p], E = Rt({ inputs: { x: a }, backend: n, attrs: { shape: S } }), T = Rt({ inputs: { x: s }, backend: n, attrs: { shape: I } }), R = o ? E.shape[1] : E.shape[2], $ = o ? E.shape[2] : E.shape[1], D = i ? T.shape[1] : T.shape[2], M = Math.max(g, v), z = n.data.get(E.dataId).values, F = n.data.get(T.dataId).values, V = Ie(E.shape), H = Ie(T.shape), [U, Z, q] = o ? [V[0], 1, V[1]] : [V[0], V[1], 1], [X, se, te] = i ? [1, H[1], H[0]] : [H[1], 1, H[0]], ue = $ * D, ee = Qe([M, $, D], E.dtype), ne = ee.values, oe = n.blockSize;
  for (let ge = 0; ge < M; ge++) {
    const be = ge % g, fe = ge % v;
    for (let we = 0; we < $; we += oe) {
      const Re = Math.min(we + oe, $);
      for (let $e = 0; $e < D; $e += oe) {
        const Oe = Math.min($e + oe, D);
        for (let We = 0; We < R; We += oe) {
          const Ue = Math.min(We + oe, R);
          for (let je = we; je < Re; je++)
            for (let Ne = $e; Ne < Oe; Ne++) {
              let et = 0;
              for (let Ye = We; Ye < Ue; Ye++) {
                const ct = (
                  // tslint:disable-next-line: max-line-length
                  z[be * U + je * Z + Ye * q]
                ), at = (
                  // tslint:disable-next-line: max-line-length
                  F[Ye * X + Ne * se + fe * te]
                );
                et += ct * at;
              }
              ne[ge * ue + (je * D + Ne)] += et;
            }
        }
      }
    }
  }
  return n.disposeIntermediateTensorInfo(E), n.disposeIntermediateTensorInfo(T), n.makeTensorInfo(w, ee.dtype, ee.values);
}
const nV = {
  kernelName: Il,
  backendName: "cpu",
  kernelFunc: S_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { a, b: s, bias: o, preluActivationWeights: i } = e, { transposeA: c, transposeB: l, activation: u, leakyreluAlpha: d } = r;
  let f, p, h;
  const m = [];
  f = S_({ inputs: { a, b: s }, attrs: { transposeA: c, transposeB: l }, backend: n }), o && (p = Ao({ inputs: { a: f, b: o }, backend: n }), m.push(f), f = p), u && (h = Jc(n, f, u, i, d), m.push(f), f = h);
  for (const v of m)
    n.disposeIntermediateTensorInfo(v);
  return f;
}
const aV = {
  kernelName: eu,
  backendName: "cpu",
  kernelFunc: rV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sV = vt(pl, (t) => Math.acos(t)), oV = {
  kernelName: pl,
  backendName: "cpu",
  kernelFunc: sV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iV = vt(hl, (t) => Math.acosh(t)), uV = {
  kernelName: hl,
  backendName: "cpu",
  kernelFunc: iV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cV(t) {
  const { inputs: e, backend: n } = t, r = e;
  xe(e, "addN");
  const a = r.map((i) => n.data.get(i.dataId).values), s = Qe(r[0].shape, r[0].dtype), o = s.values;
  for (let i = 0; i < r.length; i++) {
    const c = a[i];
    for (let l = 0; l < o.length; l++)
      o[l] += c[l];
  }
  return n.makeTensorInfo(s.shape, s.dtype, s.values);
}
const lV = {
  kernelName: ml,
  backendName: "cpu",
  kernelFunc: cV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, keepDims: o } = r;
  xe(a, "all");
  const i = Vt(s, a.shape);
  let c = i;
  const l = pr(c, a.shape.length);
  let u = a;
  l != null && (u = Gn({ inputs: { x: a }, backend: n, attrs: { perm: l } }), c = Mn(c.length, a.shape.length)), Fn("all", c, u.shape.length);
  const [d, f] = On(u.shape, c), p = Y(f), h = In(Y(d), u.dtype), m = n.data.get(u.dataId).values;
  for (let v = 0; v < h.length; ++v) {
    const b = v * p;
    let w = m[b];
    for (let S = 0; S < p; ++S) {
      const I = m[b + S];
      w = w && I;
    }
    h[v] = w;
  }
  l != null && n.disposeIntermediateTensorInfo(u);
  const g = n.makeTensorInfo(d, u.dtype, h);
  if (o) {
    const v = vn(d, i), b = Rt({ inputs: { x: g }, backend: n, attrs: { shape: v } });
    return n.disposeIntermediateTensorInfo(g), b;
  }
  return g;
}
const fV = {
  kernelName: gl,
  backendName: "cpu",
  kernelFunc: dV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, keepDims: o } = r;
  xe(a, "any");
  const i = Vt(s, a.shape);
  let c = i;
  const l = pr(c, a.shape.length);
  let u = a;
  l != null && (u = Gn({ inputs: { x: a }, backend: n, attrs: { perm: l } }), c = Mn(c.length, a.shape.length)), Fn("any", c, u.shape.length);
  const [d, f] = On(u.shape, c), p = Y(f), h = In(Y(d), u.dtype), m = n.data.get(u.dataId).values;
  for (let v = 0; v < h.length; ++v) {
    const b = v * p;
    let w = m[b];
    for (let S = 0; S < p; ++S) {
      const I = m[b + S];
      w = w || I;
    }
    h[v] = w;
  }
  l != null && n.disposeIntermediateTensorInfo(u);
  const g = n.makeTensorInfo(d, u.dtype, h);
  if (o) {
    const v = vn(d, i), b = Rt({ inputs: { x: g }, backend: n, attrs: { shape: v } });
    return n.disposeIntermediateTensorInfo(g), b;
  }
  return g;
}
const hV = {
  kernelName: yl,
  backendName: "cpu",
  kernelFunc: pV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s } = r;
  xe(a, "argMax");
  let o = Vt(s, a.shape);
  const i = pr(o, a.shape.length);
  let c = a;
  const l = [];
  i != null && (c = Gn({ inputs: { x: a }, backend: n, attrs: { perm: i } }), l.push(c), o = Mn(o.length, c.shape.length)), o = [o[0]], Fn("argMax", o, c.shape.length);
  const [u, d] = On(c.shape, o), f = Y(u), p = In(f, "int32"), h = Y(d), m = n.data.get(c.dataId).values;
  for (let g = 0; g < p.length; ++g) {
    const v = g * h;
    let b = m[v], w = 0;
    for (let S = 0; S < h; ++S) {
      const I = m[v + S];
      I > b && (b = I, w = S);
    }
    p[g] = w;
  }
  return l.forEach((g) => n.disposeIntermediateTensorInfo(g)), n.makeTensorInfo(u, "int32", p);
}
const gV = {
  kernelName: um,
  backendName: "cpu",
  kernelFunc: mV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s } = r;
  xe(a, "argMin");
  let o = Vt(s, a.shape);
  const i = pr(o, a.shape.length);
  let c = a;
  const l = [];
  i != null && (c = Gn({ inputs: { x: a }, backend: n, attrs: { perm: i } }), l.push(c), o = Mn(o.length, c.shape.length)), o = [o[0]], Fn("argMin", o, c.shape.length);
  const [u, d] = On(c.shape, o), f = Y(u), p = In(f, "int32"), h = Y(d), m = n.data.get(c.dataId).values;
  for (let g = 0; g < p.length; ++g) {
    const v = g * h;
    let b = m[v], w = 0;
    for (let S = 0; S < h; ++S) {
      const I = m[v + S];
      I < b && (b = I, w = S);
    }
    p[g] = w;
  }
  return l.forEach((g) => n.disposeIntermediateTensorInfo(g)), n.makeTensorInfo(u, "int32", p);
}
const vV = {
  kernelName: cm,
  backendName: "cpu",
  kernelFunc: yV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bV = vt(vl, (t) => Math.asin(t)), wV = {
  kernelName: vl,
  backendName: "cpu",
  kernelFunc: bV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SV = vt(bl, (t) => Math.asinh(t)), _V = {
  kernelName: bl,
  backendName: "cpu",
  kernelFunc: SV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xV = vt(wl, (t) => Math.atan(t)), IV = {
  kernelName: wl,
  backendName: "cpu",
  kernelFunc: xV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kV = Yt((t, e) => Math.atan2(t, e)), EV = cn(_l, kV), TV = {
  kernelName: _l,
  backendName: "cpu",
  kernelFunc: EV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CV = vt(Sl, (t) => Math.atanh(t)), NV = {
  kernelName: Sl,
  backendName: "cpu",
  kernelFunc: CV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wg(t, e, n, r, a, s) {
  const o = a.strideHeight, i = a.strideWidth, c = a.dilationHeight, l = a.dilationWidth, u = a.effectiveFilterHeight, d = a.effectiveFilterWidth, f = a.padInfo.top, p = a.padInfo.left, h = s === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = Qe(a.outShape, n), g = m.values, v = a.outShape[1] * a.outShape[2] * a.outShape[3], b = a.outShape[2] * a.outShape[3], w = a.outShape[3];
  for (let S = 0; S < a.batchSize; ++S) {
    const I = S * v, E = S * r[0];
    for (let T = 0; T < a.inChannels; ++T)
      for (let R = 0; R < a.outHeight; ++R) {
        const $ = R * o - f, D = Math.max(0, $), M = Math.min(a.inHeight, u + $), z = I + R * b;
        for (let F = 0; F < a.outWidth; ++F) {
          const V = F * i - p, H = Math.max(0, V), U = Math.min(a.inWidth, d + V);
          let Z = h, q = 0, X = 0;
          for (let te = D; te < M; te += c) {
            const ue = E + te * r[1];
            for (let ee = H; ee < U; ee += l) {
              const ne = ue + ee * r[2], oe = t[ne + T];
              s === "max" && oe > Z ? Z = oe : s === "avg" && (q += oe, X++);
            }
            if (isNaN(Z))
              break;
          }
          const se = z + F * w + T;
          g[se] = s === "avg" ? q / X : Z;
        }
      }
  }
  return m;
}
function __(t, e, n, r, a = !1, s = !1) {
  const o = Qe(r.outShape, "int32"), i = r.strideHeight, c = r.strideWidth, l = r.dilationHeight, u = r.dilationWidth, d = r.effectiveFilterHeight, f = r.effectiveFilterWidth, p = r.padInfo.top, h = r.padInfo.left, m = Qe(e, n, t);
  for (let g = 0; g < r.batchSize; ++g)
    for (let v = 0; v < r.inChannels; ++v)
      for (let b = 0; b < r.outHeight; ++b) {
        const w = b * i - p;
        let S = w;
        for (; S < 0; )
          S += l;
        const I = Math.min(r.inHeight, d + w);
        for (let E = 0; E < r.outWidth; ++E) {
          const T = E * c - h;
          let R = T;
          for (; R < 0; )
            R += u;
          const $ = Math.min(r.inWidth, f + T);
          let D = Number.NEGATIVE_INFINITY, M = -1;
          for (let z = S; z < I; z += l) {
            const F = z - w;
            for (let V = R; V < $; V += u) {
              const H = V - T, U = m.get(g, z, V, v);
              U > D && (D = U, a ? M = s ? ((g * r.inHeight + z) * r.inWidth + V) * r.inChannels + v : (z * r.inWidth + V) * r.inChannels + v : M = F * f + H);
            }
          }
          o.set(M, g, b, E, v);
        }
      }
  return o;
}
function x_(t, e, n, r, a, s) {
  const o = a.strideDepth, i = a.strideHeight, c = a.strideWidth, l = a.dilationDepth, u = a.dilationHeight, d = a.dilationWidth, f = a.effectiveFilterDepth, p = a.effectiveFilterHeight, h = a.effectiveFilterWidth, m = a.padInfo.front, g = a.padInfo.top, v = a.padInfo.left, b = s === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, w = Qe(a.outShape, n), S = w.values, I = a.outShape[1] * a.outShape[2] * a.outShape[3] * a.outShape[4], E = a.outShape[2] * a.outShape[3] * a.outShape[4], T = a.outShape[3] * a.outShape[4], R = a.outShape[4];
  for (let $ = 0; $ < a.batchSize; ++$) {
    const D = $ * I, M = $ * r[0];
    for (let z = 0; z < a.inChannels; ++z)
      for (let F = 0; F < a.outDepth; ++F) {
        const V = F * o - m;
        let H = V;
        for (; H < 0; )
          H += l;
        const U = Math.min(a.inDepth, f + V), Z = D + F * E;
        for (let q = 0; q < a.outHeight; ++q) {
          const X = q * i - g;
          let se = X;
          for (; se < 0; )
            se += u;
          const te = Math.min(a.inHeight, p + X), ue = Z + q * T;
          for (let ee = 0; ee < a.outWidth; ++ee) {
            const ne = ee * c - v;
            let oe = ne;
            for (; oe < 0; )
              oe += d;
            const ge = Math.min(a.inWidth, h + ne), be = ue + ee * R;
            let fe = b, we = 0, Re = 0;
            for (let Oe = H; Oe < U; Oe += l) {
              const We = M + Oe * r[1];
              for (let Ue = se; Ue < te; Ue += u) {
                const je = We + Ue * r[2];
                for (let Ne = oe; Ne < ge; Ne += d) {
                  const et = je + Ne * r[3], Ye = t[et + z];
                  if (s === "max" && Ye > fe ? fe = Ye : s === "avg" && (we += Ye, Re++), isNaN(fe))
                    break;
                }
                if (isNaN(fe))
                  break;
              }
              if (isNaN(fe))
                break;
            }
            const $e = be + z;
            S[$e] = s === "avg" ? we / Math.max(Re, 1) : fe;
          }
        }
      }
  }
  return w;
}
function AV(t, e) {
  const n = Qe(e.outShape, "int32"), r = e.strideDepth, a = e.strideHeight, s = e.strideWidth, o = e.dilationDepth, i = e.dilationHeight, c = e.dilationWidth, l = e.effectiveFilterDepth, u = e.effectiveFilterHeight, d = e.effectiveFilterWidth, f = e.padInfo.front, p = e.padInfo.top, h = e.padInfo.left;
  for (let m = 0; m < e.batchSize; ++m)
    for (let g = 0; g < e.inChannels; ++g)
      for (let v = 0; v < e.outDepth; ++v) {
        const b = v * r - f;
        let w = b;
        for (; w < 0; )
          w += o;
        const S = Math.min(e.inDepth, l + b);
        for (let I = 0; I < e.outHeight; ++I) {
          const E = I * a - p;
          let T = E;
          for (; T < 0; )
            T += i;
          const R = Math.min(e.inHeight, u + E);
          for (let $ = 0; $ < e.outWidth; ++$) {
            const D = $ * s - h;
            let M = D;
            for (; M < 0; )
              M += c;
            const z = Math.min(e.inWidth, d + D);
            let F = Number.NEGATIVE_INFINITY, V = -1;
            for (let H = w; H < S; H += o) {
              const U = H - b;
              for (let Z = T; Z < R; Z += i) {
                const q = Z - E;
                for (let X = M; X < z; X += c) {
                  const se = X - D, te = t.get(m, H, Z, X, g);
                  te >= F && (F = te, V = U * u * d + q * u + se);
                }
              }
            }
            n.set(V, m, v, I, $, g);
          }
        }
      }
  return n;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e;
  xe(a, "avgPool");
  const { filterSize: s, strides: o, pad: i, dimRoundingMode: c } = r, l = 1;
  A(Er(o, l), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);
  const u = Vr(a.shape, s, o, l, i, c);
  let d;
  if (u.filterWidth === 1 && u.filterHeight === 1 && Ir(u.inShape, u.outShape))
    d = ea({ inputs: { x: a }, backend: n });
  else {
    const f = n.data.get(a.dataId).values, p = Ie(a.shape), h = wg(f, a.shape, a.dtype, p, u, "avg");
    d = n.makeTensorInfo(u.outShape, a.dtype, h.values);
  }
  return d;
}
const $V = {
  kernelName: xl,
  backendName: "cpu",
  kernelFunc: RV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { filterSize: s, strides: o, pad: i, dimRoundingMode: c, dataFormat: l } = r;
  xe(a, "avgPool3d");
  const u = Ja(a.shape, s, o, 1, i, c, l), d = n.data.get(a.dataId).values, f = x_(d, a.shape, a.dtype, Ie(a.shape), u, "avg");
  return n.makeTensorInfo(f.shape, "float32", f.values);
}
const OV = {
  kernelName: lm,
  backendName: "cpu",
  kernelFunc: DV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s } = e, { filterSize: o, strides: i, pad: c, dimRoundingMode: l } = r;
  xe([a, s], "avgPool3DGrad");
  const u = Ja(s.shape, o, i, 1, c, l), d = u.strideDepth, f = u.strideHeight, p = u.strideWidth, h = u.filterDepth, m = u.filterHeight, g = u.filterWidth, v = u.dilationDepth, b = u.dilationHeight, w = u.dilationWidth, S = u.effectiveFilterDepth, I = u.effectiveFilterHeight, E = u.effectiveFilterWidth, T = S - 1 - u.padInfo.front, R = E - 1 - u.padInfo.left, $ = I - 1 - u.padInfo.top, D = Qe(s.shape, "float32"), M = 1 / (h * m * g), z = n.bufferSync(a);
  for (let F = 0; F < u.batchSize; ++F)
    for (let V = 0; V < u.inChannels; ++V)
      for (let H = 0; H < u.inDepth; ++H)
        for (let U = 0; U < u.inHeight; ++U)
          for (let Z = 0; Z < u.inWidth; ++Z) {
            const q = H - T, X = U - $, se = Z - R;
            let te = 0;
            for (let ue = 0; ue < S; ue += v) {
              const ee = (q + ue) / d;
              if (!(ee < 0 || ee >= u.outDepth || Math.floor(ee) !== ee))
                for (let ne = 0; ne < I; ne += b) {
                  const oe = (X + ne) / f;
                  if (!(oe < 0 || oe >= u.outHeight || Math.floor(oe) !== oe))
                    for (let ge = 0; ge < E; ge += w) {
                      const be = (se + ge) / p;
                      if (be < 0 || be >= u.outWidth || Math.floor(be) !== be)
                        continue;
                      const fe = z.get(F, ee, oe, be, V);
                      te += fe;
                    }
                }
            }
            D.set(te * M, F, H, U, Z, V);
          }
  return n.makeTensorInfo(D.shape, D.dtype, D.values);
}
const MV = {
  kernelName: X0,
  backendName: "cpu",
  kernelFunc: FV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s } = e, o = s;
  xe([a, s], "avgPoolGrad");
  const { filterSize: i, strides: c, pad: l } = r, u = Vr(o.shape, i, c, 1, l), d = u.strideHeight, f = u.strideWidth, p = u.filterHeight, h = u.filterWidth, m = u.dilationHeight, g = u.dilationWidth, v = u.effectiveFilterHeight, b = u.effectiveFilterWidth, w = b - 1 - u.padInfo.left, S = v - 1 - u.padInfo.top, I = Qe(o.shape, "float32"), E = 1 / (p * h), T = n.data.get(a.dataId).values, R = Qe(a.shape, "float32", T);
  for (let $ = 0; $ < u.batchSize; ++$)
    for (let D = 0; D < u.inChannels; ++D)
      for (let M = 0; M < u.inHeight; ++M)
        for (let z = 0; z < u.inWidth; ++z) {
          const F = M - S, V = z - w;
          let H = 0;
          for (let U = 0; U < v; U += m) {
            const Z = (F + U) / d;
            if (!(Z < 0 || Z >= u.outHeight || Math.floor(Z) !== Z))
              for (let q = 0; q < b; q += g) {
                const X = (V + q) / f;
                if (X < 0 || X >= u.outWidth || Math.floor(X) !== X)
                  continue;
                const se = R.get($, Z, X, D);
                H += se;
              }
          }
          I.set(H * E, $, M, z, D);
        }
  return n.makeTensorInfo(I.shape, I.dtype, I.values);
}
const BV = {
  kernelName: K0,
  backendName: "cpu",
  kernelFunc: PV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, scale: s, offset: o, mean: i, variance: c } = e;
  A(i.shape.length === c.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), A(o == null || i.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), A(s == null || i.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), xe([a, i, c, s, o], "batchNorm");
  let { varianceEpsilon: l } = r;
  l == null && (l = 1e-3);
  const u = n.data.get(a.dataId).values, d = n.data.get(i.dataId).values, f = n.data.get(c.dataId).values, p = s ? n.data.get(s.dataId).values : new Float32Array([1]), h = o ? n.data.get(o.dataId).values : new Float32Array([0]), m = new Float32Array(u.length), g = h.length, v = p.length, b = f.length, w = d.length;
  let S = 0, I = 0, E = 0, T = 0;
  for (let R = 0; R < u.length; ++R)
    m[R] = h[S++] + (u[R] - d[I++]) * p[E++] / Math.sqrt(f[T++] + l), S >= g && (S = 0), I >= w && (I = 0), E >= v && (E = 0), T >= b && (T = 0);
  return n.makeTensorInfo(a.shape, a.dtype, m);
}
const WV = {
  kernelName: Yl,
  backendName: "cpu",
  kernelFunc: LV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { blockShape: s, crops: o } = r;
  xe([a], "batchToSpaceND");
  const i = s.reduce((v, b) => v * b), c = wf(a.shape, s, i), l = Sf(c.length, s.length), u = _f(a.shape, s, i), d = Yw(o, s.length), f = Zw(u, o, s.length), p = Rt({ inputs: { x: a }, backend: n, attrs: { shape: c } }), h = Gn({ inputs: { x: p }, backend: n, attrs: { perm: l } }), m = Rt({ inputs: { x: h }, backend: n, attrs: { shape: u } }), g = Ws({
    inputs: { x: m },
    backend: n,
    attrs: { begin: d, size: f }
  });
  return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(m), g;
}
const VV = {
  kernelName: dm,
  backendName: "cpu",
  kernelFunc: zV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HV(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, weights: s } = e, { size: o } = r, i = n.data.get(a.dataId).values, c = n.data.get(s.dataId).values, l = A2(i, c, s.dtype, s.shape, o);
  return n.makeTensorInfo([o], s.dtype, l);
}
const jV = {
  kernelName: kl,
  backendName: "cpu",
  kernelFunc: HV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UV(t) {
  const { inputs: e, backend: n } = t, { s0: r, s1: a } = e, s = n.data.get(r.dataId).values, o = n.data.get(a.dataId).values, i = At(Array.from(s), Array.from(o));
  return n.makeTensorInfo([i.length], "int32", Int32Array.from(i));
}
const GV = {
  kernelName: fm,
  backendName: "cpu",
  kernelFunc: UV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qV = vt(Tu, (t, e) => {
  const n = e;
  return t > n.clipValueMax ? n.clipValueMax : t < n.clipValueMin ? n.clipValueMin : t;
}), KV = {
  kernelName: Tu,
  backendName: "cpu",
  kernelFunc: qV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const XV = (t) => {
  const { x: e } = t.inputs, n = t.backend, r = new Float32Array(Y(e.shape)), a = n.data.get(e.dataId), s = a.complexTensorInfos.real, o = a.complexTensorInfos.imag, i = n.data.get(s.dataId).values, c = n.data.get(o.dataId).values;
  for (let l = 0; l < i.length; l++) {
    const u = i[l], d = c[l];
    r[l] = Math.hypot(u, d);
  }
  return n.makeOutput(r, e.shape, "float32");
}, YV = {
  kernelName: Z0,
  backendName: "cpu",
  kernelFunc: XV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ro(t) {
  const { inputs: e, backend: n } = t, { input: r } = e, a = n.data.get(r.dataId).complexTensorInfos.imag, s = n.data.get(a.dataId).values;
  return n.makeTensorInfo(a.shape, a.dtype, s);
}
const ZV = {
  kernelName: s1,
  backendName: "cpu",
  kernelFunc: Ro
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $o(t) {
  const { inputs: e, backend: n, attrs: r } = t, { axis: a } = r, s = Vt(a, e[0].shape)[0], o = e.map((m) => m.shape);
  Kw(o, s);
  let i = _o(e.map((m) => m.shape), s);
  if (Y(i) === 0)
    return n.makeTensorInfo(i, e[0].dtype, []);
  const c = e.filter((m) => Y(m.shape) > 0);
  if (c.length === 1)
    return ea({ inputs: { x: c[0] }, backend: n });
  if (c[0].dtype === "complex64") {
    const m = c.map((S) => Ls({ inputs: { input: S }, backend: n })), g = c.map((S) => Ro({ inputs: { input: S }, backend: n })), v = $o({ inputs: m, backend: n, attrs: { axis: s } }), b = $o({ inputs: g, backend: n, attrs: { axis: s } }), w = nr({ inputs: { real: v, imag: b }, backend: n });
    return m.forEach((S) => n.disposeIntermediateTensorInfo(S)), g.forEach((S) => n.disposeIntermediateTensorInfo(S)), n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(b), w;
  }
  const l = c.map((m) => {
    const v = [-1, Y(m.shape.slice(s))];
    return Rt({ inputs: { x: m }, backend: n, attrs: { shape: v } });
  }), u = l.map((m) => ({ vals: n.data.get(m.dataId).values, shape: m.shape }));
  i = _o(
    l.map((m) => m.shape),
    1
    /* axis */
  );
  const d = l[0].shape[0] === 1, f = R2(u, i, e[0].dtype, d), p = _o(c.map((m) => m.shape), s), h = n.makeTensorInfo(p, e[0].dtype, f);
  return l.forEach((m) => n.disposeIntermediateTensorInfo(m)), h;
}
const JV = {
  kernelName: pm,
  backendName: "cpu",
  kernelFunc: $o
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I_(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s } = e, { strides: o, pad: i, dataFormat: c, dilations: l, dimRoundingMode: u } = r;
  xe([a, s], "conv2d");
  const d = zo(c), f = Kn(a.shape, s.shape, o, l, i, u, !1, d), p = f.filterHeight, h = f.filterWidth, m = f.dilationHeight, g = f.dilationWidth, v = f.padInfo.left, b = f.padInfo.top, w = f.dataFormat === "channelsLast", S = new on(f.outShape, a.dtype), I = Ie(a.shape), E = Ie(s.shape), T = I[0], R = w ? I[1] : I[2], $ = w ? I[2] : 1, D = w ? 1 : I[1], M = S.strides[0], z = w ? S.strides[1] : S.strides[2], F = w ? S.strides[2] : 1, V = w ? 1 : S.strides[1], H = n.data.get(a.dataId).values, U = n.data.get(s.dataId).values, Z = S.values;
  for (let q = 0; q < f.batchSize; ++q) {
    const X = q * T, se = q * M;
    for (let te = 0; te < f.outHeight; ++te) {
      const ue = se + te * z, ee = te * f.strideHeight - b;
      for (let ne = 0; ne < p; ++ne) {
        const oe = ee + ne * m;
        if (oe < 0 || oe >= f.inHeight)
          continue;
        const ge = ne * E[0], be = X + oe * R;
        for (let fe = 0; fe < f.outWidth; ++fe) {
          const we = ue + fe * F, Re = fe * f.strideWidth - v;
          for (let $e = 0; $e < h; ++$e) {
            const Oe = Re + $e * g;
            if (Oe < 0 || Oe >= f.inWidth)
              continue;
            const We = ge + $e * E[1], Ue = be + Oe * $;
            let je = We;
            for (let Ne = 0; Ne < f.inChannels; ++Ne) {
              const et = H[Ue + Ne * D];
              for (let Ye = 0; Ye < f.outChannels; ++Ye)
                Z[we + Ye * V] += et * U[je + Ye];
              je += f.outChannels;
            }
          }
        }
      }
    }
  }
  return n.makeTensorInfo(S.shape, S.dtype, Z);
}
const QV = {
  kernelName: Nl,
  backendName: "cpu",
  kernelFunc: I_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, dy: s } = e, { strides: o, pad: i, dataFormat: c, dimRoundingMode: l, filterShape: u } = r;
  xe([a, s], "conv2dBackpropFilter");
  const d = zo(c), f = Kn(a.shape, u, o, 1, i, l, !1, d), { strideHeight: p, strideWidth: h, filterHeight: m, filterWidth: g } = f, v = f.dataFormat === "channelsLast", b = new on(f.filterShape, "float32"), w = f.padInfo.left, S = f.padInfo.top, I = n.data.get(a.dataId).values, E = n.data.get(s.dataId).values, T = new on(a.shape, a.dtype, I), R = new on(s.shape, s.dtype, E);
  for (let $ = 0; $ < m; ++$) {
    const D = Math.max(0, Math.ceil((S - $) / p)), M = Math.min(f.outHeight, (f.inHeight + S - $) / p);
    for (let z = 0; z < g; ++z) {
      const F = Math.max(0, Math.ceil((w - z) / h)), V = Math.min(f.outWidth, (f.inWidth + w - z) / h);
      for (let H = 0; H < f.inChannels; ++H)
        for (let U = 0; U < f.outChannels; ++U) {
          let Z = 0;
          for (let q = 0; q < f.batchSize; ++q)
            for (let X = D; X < M; ++X) {
              const se = $ + X * p - S;
              for (let te = F; te < V; ++te) {
                const ue = z + te * h - w;
                v ? Z += T.get(q, se, ue, H) * R.get(q, X, te, U) : Z += T.get(q, H, se, ue) * R.get(q, U, X, te);
              }
            }
          b.set(Z, $, z, H, U);
        }
    }
  }
  return n.makeTensorInfo(b.shape, b.dtype, b.values);
}
const tH = {
  kernelName: J0,
  backendName: "cpu",
  kernelFunc: eH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, filter: s } = e, { inputShape: o, strides: i, pad: c, dataFormat: l, dimRoundingMode: u } = r;
  xe([a, s], "conv2dBackpropInput");
  const d = Ie(s.shape), f = Ie(a.shape);
  let p = zo(l);
  const h = Kn(o, s.shape, i, 1, c, u, !1, p), m = new on(h.inShape, "float32"), g = m.values, v = n.data.get(a.dataId).values, b = n.data.get(s.dataId).values, [w, S, I] = d, { batchSize: E, filterHeight: T, filterWidth: R, inChannels: $, inHeight: D, inWidth: M, outChannels: z, outHeight: F, outWidth: V, strideHeight: H, strideWidth: U } = h;
  p = h.dataFormat;
  const Z = T - 1 - h.padInfo.top, q = R - 1 - h.padInfo.left, X = p === "channelsLast", se = m.strides[0], te = X ? m.strides[1] : m.strides[2], ue = X ? m.strides[2] : 1, ee = X ? 1 : m.strides[1], ne = f[0], oe = X ? f[1] : f[2], ge = X ? f[2] : 1, be = X ? 1 : f[1];
  for (let fe = 0; fe < E; ++fe)
    for (let we = 0; we < $; ++we)
      for (let Re = 0; Re < D; ++Re) {
        const $e = Re - Z, Oe = Math.max(0, Math.ceil($e / H)), We = Math.min(F, (T + $e) / H);
        for (let Ue = 0; Ue < M; ++Ue) {
          const je = Ue - q, Ne = Math.max(0, Math.ceil(je / U)), et = Math.min(V, (R + je) / U);
          let Ye = 0;
          for (let at = Oe; at < We; ++at) {
            const Ht = at * H - $e;
            for (let st = Ne; st < et; ++st) {
              const St = st * U - je, Mt = ne * fe + oe * at + ge * st, Zt = w * (T - 1 - Ht) + S * (R - 1 - St) + I * we;
              for (let rn = 0; rn < z; ++rn) {
                const jt = v[Mt + be * rn], pn = b[Zt + rn];
                Ye += jt * pn;
              }
            }
          }
          const ct = se * fe + te * Re + ue * Ue + ee * we;
          g[ct] = Ye;
        }
      }
  return n.makeTensorInfo(m.shape, m.dtype, m.values);
}
const rH = {
  kernelName: Al,
  backendName: "cpu",
  kernelFunc: nH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s } = e, { strides: o, pad: i, dilations: c } = r;
  xe([a, s], "conv3d");
  const l = Us(a.shape, s.shape, o, c, i), { filterDepth: u, filterHeight: d, filterWidth: f, dilationDepth: p, dilationHeight: h, dilationWidth: m, padInfo: g } = l, v = g.front, b = g.left, w = g.top, S = new on(l.outShape, a.dtype), I = n.data.get(a.dataId).values, E = n.data.get(s.dataId).values, T = S.values, R = Ie(a.shape), $ = Ie(s.shape);
  for (let D = 0; D < l.batchSize; ++D) {
    const M = D * R[0], z = D * S.strides[0];
    for (let F = 0; F < l.outDepth; ++F) {
      const V = z + F * S.strides[1], H = F * l.strideDepth - v;
      for (let U = 0; U < u; ++U) {
        const Z = H + U * p;
        if (Z < 0 || Z >= l.inDepth)
          continue;
        const q = U * $[0], X = M + Z * R[1];
        for (let se = 0; se < l.outHeight; ++se) {
          const te = V + se * S.strides[2], ue = se * l.strideHeight - w;
          for (let ee = 0; ee < d; ++ee) {
            const ne = ue + ee * h;
            if (ne < 0 || ne >= l.inHeight)
              continue;
            const oe = q + ee * $[1], ge = X + ne * R[2];
            for (let be = 0; be < l.outWidth; ++be) {
              const fe = te + be * l.outChannels, we = be * l.strideWidth - b;
              for (let Re = 0; Re < f; ++Re) {
                const $e = we + Re * m;
                if ($e < 0 || $e >= l.inWidth)
                  continue;
                const Oe = oe + Re * $[2], We = ge + $e * l.inChannels;
                let Ue = Oe;
                for (let je = 0; je < l.inChannels; ++je) {
                  const Ne = I[We + je];
                  for (let et = 0; et < l.outChannels; ++et)
                    T[fe + et] += Ne * E[Ue + et];
                  Ue += l.outChannels;
                }
              }
            }
          }
        }
      }
    }
  }
  return n.makeTensorInfo(S.shape, S.dtype, S.values);
}
const sH = {
  kernelName: Rl,
  backendName: "cpu",
  kernelFunc: aH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, dy: s } = e, { strides: o, pad: i, filterShape: c } = r;
  xe([a, s], "conv3dBackpropFilterV2");
  const l = Ie(a.shape), u = Ie(s.shape), d = Us(a.shape, c, o, 1, i), f = d.strideDepth, p = d.strideHeight, h = d.strideWidth, m = d.filterDepth, g = d.filterHeight, v = d.filterWidth, b = new on(d.filterShape, "float32"), w = b.values, [S, I, E, T] = b.strides, R = n.data.get(s.dataId).values, [$, D, M, z] = u, F = n.data.get(a.dataId).values, [V, H, U, Z] = l, q = d.padInfo.front, X = d.padInfo.left, se = d.padInfo.top;
  for (let te = 0; te < m; ++te) {
    const ue = Math.max(0, Math.ceil((q - te) / f)), ee = Math.min(d.outDepth, (d.inDepth + q - te) / f), ne = te * S;
    for (let oe = 0; oe < g; ++oe) {
      const ge = Math.max(0, Math.ceil((se - oe) / p)), be = Math.min(d.outHeight, (d.inHeight + se - oe) / p), fe = oe * I + ne;
      for (let we = 0; we < v; ++we) {
        const Re = Math.max(0, Math.ceil((X - we) / h)), $e = Math.min(d.outWidth, (d.inWidth + X - we) / h), Oe = we * E + fe;
        for (let We = 0; We < d.inChannels; ++We) {
          const Ue = We * T + Oe;
          for (let je = 0; je < d.outChannels; ++je) {
            let Ne = 0;
            for (let et = 0; et < d.batchSize; ++et) {
              const Ye = et * V, ct = et * $;
              for (let at = ue; at < ee; ++at) {
                const st = (te + at * f - q) * H + Ye, St = at * D + ct;
                for (let Mt = ge; Mt < be; ++Mt) {
                  const rn = (oe + Mt * p - se) * U + st, jt = Mt * M + St;
                  for (let pn = Re; pn < $e; ++pn) {
                    const aa = (we + pn * h - X) * Z + rn, En = pn * z + jt;
                    Ne += F[aa + We] * R[En + je];
                  }
                }
              }
            }
            w[Ue + je] = Ne;
          }
        }
      }
    }
  }
  return n.makeTensorInfo(b.shape, b.dtype, b.values);
}
const iH = {
  kernelName: hm,
  backendName: "cpu",
  kernelFunc: oH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, filter: s } = e, { pad: o, strides: i, inputShape: c } = r;
  xe([a], "conv3dBackpropInputV2");
  const l = Ie(a.shape), u = Ie(s.shape), d = Us(c, s.shape, i, 1, o), f = new on(d.inShape, "float32"), p = f.values, [h, m, g, v] = f.strides, b = n.data.get(a.dataId).values, [w, S, I, E] = l, T = n.data.get(s.dataId).values, [R, $, D, M] = u, { batchSize: z, filterDepth: F, filterHeight: V, filterWidth: H, inChannels: U, inDepth: Z, inHeight: q, inWidth: X, outChannels: se, outDepth: te, outHeight: ue, outWidth: ee, strideDepth: ne, strideHeight: oe, strideWidth: ge } = d, be = F - 1 - d.padInfo.front, fe = V - 1 - d.padInfo.top, we = H - 1 - d.padInfo.left;
  for (let Re = 0; Re < z; ++Re)
    for (let $e = 0; $e < U; ++$e)
      for (let Oe = 0; Oe < Z; ++Oe) {
        const We = Oe - be, Ue = Math.max(0, Math.ceil(We / ne)), je = Math.min(te, (F + We) / ne);
        for (let Ne = 0; Ne < q; ++Ne) {
          const et = Ne - fe, Ye = Math.max(0, Math.ceil(et / oe)), ct = Math.min(ue, (V + et) / oe);
          for (let at = 0; at < X; ++at) {
            const Ht = at - we, st = Math.max(0, Math.ceil(Ht / ge)), St = Math.min(ee, (H + Ht) / ge);
            let Mt = 0;
            for (let Zt = Ue; Zt < je; ++Zt) {
              const rn = Zt * ne - We;
              for (let jt = Ye; jt < ct; ++jt) {
                const pn = jt * oe - et;
                for (let kn = st; kn < St; ++kn) {
                  const aa = kn * ge - Ht, En = w * Re + S * Zt + I * jt + E * kn, Ia = R * (F - 1 - rn) + $ * (V - 1 - pn) + D * (H - 1 - aa) + M * $e;
                  for (let or = 0; or < se; ++or) {
                    const Xn = b[En + or], Lt = T[Ia + or];
                    Mt += Xn * Lt;
                  }
                }
              }
            }
            p[h * Re + m * Oe + g * Ne + v * at + $e] = Mt;
          }
        }
      }
  return n.makeTensorInfo(f.shape, f.dtype, f.values);
}
const cH = {
  kernelName: $l,
  backendName: "cpu",
  kernelFunc: uH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lH = vt(Dl, (t) => Math.cos(t)), dH = {
  kernelName: Dl,
  backendName: "cpu",
  kernelFunc: lH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fH = vt(Ol, (t) => Math.cosh(t)), pH = {
  kernelName: Ol,
  backendName: "cpu",
  kernelFunc: fH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { image: a, boxes: s, boxInd: o } = e, { cropSize: i, method: c, extrapolationValue: l } = r, [u, d, f, p] = a.shape, h = s.shape[0], [m, g] = i, v = Qe([h, m, g, p], "float32"), b = n.data.get(s.dataId).values, w = n.data.get(o.dataId).values, S = n.data.get(a.dataId).values, I = Ie(a.shape), E = Ie(v.shape);
  for (let T = 0; T < h; T++) {
    const R = T * 4, $ = b[R], D = b[R + 1], M = b[R + 2], z = b[R + 3], F = w[T];
    if (F >= u)
      continue;
    const V = m > 1 ? (M - $) * (d - 1) / (m - 1) : 0, H = g > 1 ? (z - D) * (f - 1) / (g - 1) : 0;
    for (let U = 0; U < m; U++) {
      const Z = m > 1 ? $ * (d - 1) + U * V : 0.5 * ($ + M) * (d - 1);
      if (Z < 0 || Z > d - 1) {
        for (let q = 0; q < g; q++)
          for (let X = 0; X < p; X++) {
            const se = X + q * E[2] + U * E[1] + T * E[0];
            v.values[se] = l;
          }
        continue;
      }
      if (c === "bilinear") {
        const q = Math.floor(Z), X = Math.ceil(Z), se = Z - q;
        for (let te = 0; te < g; te++) {
          const ue = g > 1 ? D * (f - 1) + te * H : 0.5 * (D + z) * (f - 1);
          if (ue < 0 || ue > f - 1) {
            for (let ge = 0; ge < p; ge++) {
              const be = ge + te * E[2] + U * E[1] + T * E[0];
              v.values[be] = l;
            }
            continue;
          }
          const ee = Math.floor(ue), ne = Math.ceil(ue), oe = ue - ee;
          for (let ge = 0; ge < p; ge++) {
            let be = ge + ee * I[2] + q * I[1] + F * I[0];
            const fe = S[be];
            be = ge + ne * I[2] + q * I[1] + F * I[0];
            const we = S[be];
            be = ge + ee * I[2] + X * I[1] + F * I[0];
            const Re = S[be];
            be = ge + ne * I[2] + X * I[1] + F * I[0];
            const $e = S[be], Oe = fe + (we - fe) * oe, We = Re + ($e - Re) * oe;
            be = ge + te * E[2] + U * E[1] + T * E[0], v.values[be] = Oe + (We - Oe) * se;
          }
        }
      } else
        for (let q = 0; q < g; ++q) {
          const X = g > 1 ? D * (f - 1) + q * H : 0.5 * (D + z) * (f - 1);
          if (X < 0 || X > f - 1) {
            for (let ue = 0; ue < p; ue++) {
              const ee = ue + q * E[2] + U * E[1] + T * E[0];
              v.values[ee] = l;
            }
            continue;
          }
          const se = Math.round(X), te = Math.round(Z);
          for (let ue = 0; ue < p; ue++) {
            const ee = ue + se * I[2] + te * I[1] + F * I[0], ne = ue + q * E[2] + U * E[1] + T * E[0];
            v.values[ne] = S[ee];
          }
        }
    }
  }
  return n.makeTensorInfo(v.shape, v.dtype, v.values);
}
const mH = {
  kernelName: Pl,
  backendName: "cpu",
  kernelFunc: hH
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, exclusive: o, reverse: i } = r;
  xe(a, "cumprod");
  const c = pr([s], a.shape.length);
  let l = a;
  c != null && (l = Gn({ inputs: { x: a }, backend: n, attrs: { perm: c } }));
  const u = Mn(1, a.shape.length)[0];
  if (u !== l.shape.length - 1)
    throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${u}`);
  const d = Lo(l.dtype, "int32"), f = sm(Y(l.shape), d), p = n.data.get(l.dataId).values, h = l.shape[l.shape.length - 1], m = i ? (v, b) => v + h - b - 1 : (v, b) => v + b;
  for (let v = 0; v < p.length; v += h)
    for (let b = 0; b < h; b++) {
      const w = m(v, b);
      if (b === 0)
        f[w] = o ? 1 : p[w];
      else {
        const S = m(v, b - 1);
        f[w] = o ? p[S] * f[S] : p[w] * f[S];
      }
    }
  const g = n.makeTensorInfo(l.shape, d, f);
  if (c != null) {
    const v = pf(c), b = Gn({ inputs: { x: g }, backend: n, attrs: { perm: v } });
    return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(l), b;
  }
  return g;
}
const yH = {
  kernelName: Fl,
  backendName: "cpu",
  kernelFunc: gH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, exclusive: o, reverse: i } = r;
  xe(a, "cumsum");
  const c = pr([s], a.shape.length);
  let l = a;
  c != null && (l = Gn({ inputs: { x: a }, backend: n, attrs: { perm: c } }));
  const u = Mn(1, a.shape.length)[0];
  if (u !== l.shape.length - 1)
    throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${u}`);
  const d = Lo(l.dtype, "int32"), f = In(Y(l.shape), d), p = n.data.get(l.dataId).values, h = l.shape[l.shape.length - 1], m = i ? (v, b) => v + h - b - 1 : (v, b) => v + b;
  for (let v = 0; v < p.length; v += h)
    for (let b = 0; b < h; b++) {
      const w = m(v, b);
      if (b === 0)
        f[w] = o ? 0 : p[w];
      else {
        const S = m(v, b - 1);
        f[w] = o ? p[S] + f[S] : p[w] + f[S];
      }
    }
  const g = n.makeTensorInfo(l.shape, d, f);
  if (c != null) {
    const v = pf(c), b = Gn({ inputs: { x: g }, backend: n, attrs: { perm: v } });
    return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(l), b;
  }
  return g;
}
const bH = {
  kernelName: Ml,
  backendName: "cpu",
  kernelFunc: vH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, weights: s } = e, { size: o, binaryOutput: i } = r;
  if (a.shape.length === 1) {
    const c = n.data.get(a.dataId).values, l = n.data.get(s.dataId).values, u = A2(c, l, s.dtype, s.shape, o);
    return n.makeTensorInfo([o], s.dtype, u);
  } else if (a.shape.length === 2) {
    const c = n.bufferSync(a), l = n.bufferSync(s), u = RP(c, l, o, i);
    return n.makeTensorInfo(u.shape, s.dtype, u.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`);
}
const SH = {
  kernelName: mm,
  backendName: "cpu",
  kernelFunc: wH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _H(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { blockSize: s, dataFormat: o } = r;
  A(o === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);
  const i = a.shape[0], c = a.shape[1], l = a.shape[2], u = a.shape[3], d = c * s, f = l * s, p = u / (s * s), h = n.data.get(a.dataId).values, m = new Float32Array(i * d * f * p);
  let g = 0;
  for (let v = 0; v < i; ++v)
    for (let b = 0; b < d; ++b) {
      const w = Math.floor(b / s), S = b % s;
      for (let I = 0; I < f; ++I) {
        const E = Math.floor(I / s), T = I % s, R = (S * s + T) * p;
        for (let $ = 0; $ < p; ++$) {
          const M = $ + R + u * (E + l * (w + c * v));
          m[g++] = h[M];
        }
      }
    }
  return n.makeTensorInfo([i, d, f, p], a.dtype, m);
}
const xH = {
  kernelName: Bl,
  backendName: "cpu",
  kernelFunc: _H
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k_(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s } = e, { strides: o, pad: i, dilations: c, dimRoundingMode: l } = r;
  xe([a, s], "depthwiseConv2DNative");
  const u = Ie(a.shape), d = Ie(s.shape);
  let f = c;
  f == null && (f = [1, 1]), A(Er(o, f), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);
  const p = Kn(
    a.shape,
    s.shape,
    o,
    f,
    i,
    l,
    !0
    /* depthwise */
  ), { filterHeight: h, filterWidth: m, dilationHeight: g, dilationWidth: v, padInfo: b } = p, w = b.left, S = b.top, I = p.outChannels / p.inChannels, E = new on(p.outShape, a.dtype), T = n.data.get(a.dataId).values, R = n.data.get(s.dataId).values, $ = E.values;
  for (let D = 0; D < p.batchSize; ++D) {
    const M = D * u[0], z = D * E.strides[0];
    for (let F = 0; F < p.outHeight; ++F) {
      const V = z + F * E.strides[1], H = F * p.strideHeight - S;
      for (let U = 0; U < h; ++U) {
        const Z = H + U * g;
        if (Z < 0 || Z >= p.inHeight)
          continue;
        const q = U * d[0], X = M + Z * u[1];
        for (let se = 0; se < p.outWidth; ++se) {
          const te = V + se * E.strides[2], ue = se * p.strideWidth - w;
          for (let ee = 0; ee < m; ++ee) {
            const ne = ue + ee * v;
            if (ne < 0 || ne >= p.inWidth)
              continue;
            const oe = q + ee * d[1], ge = X + ne * p.inChannels;
            let be = te, fe = oe;
            for (let we = 0; we < p.inChannels; ++we) {
              const Re = T[ge + we];
              for (let $e = 0; $e < I; ++$e)
                $[be + $e] += Re * R[fe + $e];
              be += I, fe += I;
            }
          }
        }
      }
    }
  }
  return n.makeTensorInfo(E.shape, E.dtype, E.values);
}
const IH = {
  kernelName: Ll,
  backendName: "cpu",
  kernelFunc: k_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, dy: s } = e, { strides: o, dilations: i, pad: c, dimRoundingMode: l, filterShape: u } = r;
  xe([a, s], "depthwiseConv2dNativeBackpropFilter");
  const d = Kn(
    a.shape,
    u,
    o,
    i,
    c,
    l,
    !0
    /* depthwise */
  ), { strideHeight: f, strideWidth: p, filterHeight: h, filterWidth: m } = d, g = new on(d.filterShape, "float32"), v = d.padInfo.left, b = d.padInfo.top, w = d.outChannels / d.inChannels, S = n.data.get(a.dataId).values, I = new on(a.shape, a.dtype, S), E = n.data.get(s.dataId).values, T = new on(s.shape, s.dtype, E);
  for (let R = 0; R < h; ++R) {
    const $ = Math.max(0, Math.ceil((b - R) / f)), D = Math.min(d.outHeight, (d.inHeight + b - R) / f);
    for (let M = 0; M < m; ++M) {
      const z = Math.max(0, Math.ceil((v - M) / p)), F = Math.min(d.outWidth, (d.inWidth + v - M) / p);
      for (let V = 0; V < d.outChannels; ++V) {
        const H = Math.trunc(V / w), U = V % w;
        let Z = 0;
        for (let q = 0; q < d.batchSize; ++q)
          for (let X = $; X < D; ++X) {
            const se = R + X * f - b;
            for (let te = z; te < F; ++te) {
              const ue = M + te * p - v;
              Z += I.get(q, se, ue, H) * T.get(q, X, te, V);
            }
          }
        g.set(Z, R, M, H, U);
      }
    }
  }
  return n.makeTensorInfo(g.shape, g.dtype, g.values);
}
const EH = {
  kernelName: Q0,
  backendName: "cpu",
  kernelFunc: kH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, filter: s } = e, { strides: o, dilations: i, pad: c, dimRoundingMode: l, inputShape: u } = r;
  xe([a, s], "depthwiseConv2DNativeBackpropInput");
  const d = Ie(a.shape), f = Ie(s.shape), p = Kn(
    u,
    s.shape,
    o,
    i,
    c,
    l,
    !0
    /* depthwise */
  ), h = new on(p.inShape, "float32"), m = h.values, [g, v, b] = h.strides, w = n.data.get(a.dataId).values, [S, I, E] = d, T = n.data.get(s.dataId).values, [R, $, D] = f, { batchSize: M, filterHeight: z, filterWidth: F, inChannels: V, inHeight: H, inWidth: U, outChannels: Z, outHeight: q, outWidth: X, strideHeight: se, strideWidth: te } = p, ue = z - 1 - p.padInfo.top, ee = F - 1 - p.padInfo.left, ne = Z / V;
  for (let oe = 0; oe < M; ++oe)
    for (let ge = 0; ge < V; ++ge)
      for (let be = 0; be < H; ++be) {
        const fe = be - ue, we = Math.max(0, Math.ceil(fe / se)), Re = Math.min(q, (z + fe) / se);
        for (let $e = 0; $e < U; ++$e) {
          const Oe = $e - ee, We = Math.max(0, Math.ceil(Oe / te)), Ue = Math.min(X, (F + Oe) / te);
          let je = 0;
          for (let Ne = we; Ne < Re; ++Ne) {
            const et = Ne * se - fe;
            for (let Ye = We; Ye < Ue; ++Ye) {
              const ct = Ye * te - Oe, at = S * oe + I * Ne + E * Ye, Ht = R * (z - 1 - et) + $ * (F - 1 - ct) + D * ge;
              for (let st = 0; st < ne; ++st) {
                const St = ge * ne + st, Mt = w[at + St], Zt = T[Ht + st];
                je += Mt * Zt;
              }
            }
          }
          m[g * oe + v * be + b * $e + ge] = je;
        }
      }
  return n.makeTensorInfo(h.shape, h.dtype, h.values);
}
const CH = {
  kernelName: e1,
  backendName: "cpu",
  kernelFunc: TH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NH(t) {
  const { inputs: e, backend: n } = t, { x: r } = e, a = Y(r.shape), s = n.data.get(r.dataId).values, o = Qe([a, a], r.dtype), i = o.values;
  for (let l = 0; l < s.length; l++)
    i[l * a + l] = s[l];
  const c = [...r.shape, ...r.shape];
  return n.makeTensorInfo(c, o.dtype, o.values);
}
const AH = {
  kernelName: gm,
  backendName: "cpu",
  kernelFunc: NH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const RH = {
  kernelName: Wl,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e, attrs: n }) => {
    const { x: r, filter: a } = t, { strides: s, pad: o, dilations: i } = n, c = e, l = c.data.get(r.dataId).values, u = r.shape.length, d = c.data.get(a.dataId).values, f = a.shape.length, { batchSize: p, inHeight: h, inWidth: m, inChannels: g, outHeight: v, outWidth: b, padInfo: w, strideHeight: S, strideWidth: I, filterHeight: E, filterWidth: T, dilationHeight: R, dilationWidth: $, outShape: D } = Wo(r.shape, a.shape, s, o, "NHWC", i), M = Y(D), z = D.length, F = tn(r.dtype, M);
    for (let H = 0; H < p; ++H)
      for (let U = 0; U < v; ++U) {
        const Z = U * S - w.top;
        for (let q = 0; q < b; ++q) {
          const X = q * I - w.left;
          for (let se = 0; se < g; ++se) {
            let te = Number.MIN_SAFE_INTEGER;
            for (let ee = 0; ee < E; ++ee) {
              const ne = Z + ee * R;
              if (ne >= 0 && ne < h)
                for (let oe = 0; oe < T; ++oe) {
                  const ge = X + oe * $;
                  if (ge >= 0 && ge < m) {
                    const be = Zr([H, ne, ge, se], u, Ie(r.shape)), fe = Zr([ee, oe, se], f, Ie(a.shape)), we = l[be] + d[fe];
                    we > te && (te = we);
                  }
                }
            }
            const ue = Zr([H, U, q, se], z, Ie(D));
            F[ue] = te;
          }
        }
      }
    return { dataId: c.write(js(F, r.dtype), D, r.dtype), shape: D, dtype: r.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $H = {
  kernelName: Dc,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e, attrs: n }) => {
    const { x: r, filter: a, dy: s } = t, { strides: o, pad: i, dilations: c } = n, l = e, u = xr(r.shape, l.data.get(r.dataId).values), d = xr(a.shape, l.data.get(a.dataId).values), { batchSize: f, inHeight: p, inWidth: h, inChannels: m, outHeight: g, outWidth: v, padInfo: b, strideHeight: w, strideWidth: S, filterHeight: I, filterWidth: E, dilationHeight: T, dilationWidth: R, outShape: $ } = Wo(r.shape, a.shape, o, i, "NHWC", c);
    A(s.rank === $.length, () => `Error in ${Dc}, dy must have the same rank as output ${$.length}, but got ${s.rank}`);
    const D = xr($, l.data.get(s.dataId).values), M = U0(a.shape, a.dtype);
    for (let F = 0; F < f; ++F)
      for (let V = 0; V < g; ++V) {
        const H = V * w - b.top;
        for (let U = 0; U < v; ++U) {
          const Z = U * S - b.left;
          for (let q = 0; q < m; ++q) {
            let X = Number.MIN_SAFE_INTEGER, se = 0, te = 0;
            for (let ue = 0; ue < I; ++ue) {
              const ee = H + ue * T;
              if (ee >= 0 && ee < p)
                for (let ne = 0; ne < E; ++ne) {
                  const oe = Z + ne * R;
                  if (oe >= 0 && oe < h) {
                    const ge = u[F][ee][oe][q] + d[ue][ne][q];
                    ge > X && (X = ge, se = ue, te = ne);
                  }
                }
            }
            M[se][te][q] += D[F][V][U][q];
          }
        }
      }
    return { dataId: l.write(js(M, r.dtype), a.shape, a.dtype), shape: a.shape, dtype: a.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DH = {
  kernelName: $c,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e, attrs: n }) => {
    const { x: r, filter: a, dy: s } = t, { strides: o, pad: i, dilations: c } = n, l = e, u = xr(r.shape, l.data.get(r.dataId).values), d = xr(a.shape, l.data.get(a.dataId).values), { batchSize: f, inHeight: p, inWidth: h, inChannels: m, outHeight: g, outWidth: v, padInfo: b, strideHeight: w, strideWidth: S, filterHeight: I, filterWidth: E, dilationHeight: T, dilationWidth: R, outShape: $ } = Wo(r.shape, a.shape, o, i, "NHWC", c);
    A(s.rank === $.length, () => `Error in ${$c}, dy must have the same rank as output ${$.length}, but got ${s.rank}`);
    const D = xr($, l.data.get(s.dataId).values), M = U0(r.shape, r.dtype);
    for (let F = 0; F < f; ++F)
      for (let V = 0; V < g; ++V) {
        const H = V * w - b.top;
        for (let U = 0; U < v; ++U) {
          const Z = U * S - b.left;
          for (let q = 0; q < m; ++q) {
            let X = Number.MIN_SAFE_INTEGER, se = H < 0 ? 0 : H, te = Z < 0 ? 0 : Z;
            for (let ue = 0; ue < I; ++ue) {
              const ee = H + ue * T;
              if (ee >= 0 && ee < p)
                for (let ne = 0; ne < E; ++ne) {
                  const oe = Z + ne * R;
                  if (oe >= 0 && oe < h) {
                    const ge = u[F][ee][oe][q] + d[ue][ne][q];
                    ge > X && (X = ge, se = ee, te = oe);
                  }
                }
            }
            M[F][se][te][q] += D[F][V][U][q];
          }
        }
      }
    return { dataId: l.write(js(M, r.dtype), r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { image: a } = e, { canvas: s, options: o } = r, { contextOptions: i, imageOptions: c } = o || {}, l = c?.alpha || 1, u = i?.contextType || "2d";
  if (u !== "2d")
    throw new Error(`Context type ${i.contextType} is not supported by the CPU backend.`);
  const d = s.getContext(u, i?.contextAttributes || {});
  if (d == null)
    throw new Error(`Could not get the context with ${u} type.`);
  const [f, p] = a.shape.slice(0, 2), h = a.shape.length === 2 ? 1 : a.shape[2], m = n.data.get(a.dataId).values, g = a.dtype === "float32" ? 255 : 1, v = new Uint8ClampedArray(p * f * 4);
  for (let w = 0; w < f * p; ++w) {
    const S = [0, 0, 0, 255 * l];
    for (let E = 0; E < h; E++) {
      const T = m[w * h + E];
      if (a.dtype === "float32") {
        if (T < 0 || T > 1)
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${T}.`);
      } else if (a.dtype === "int32" && (T < 0 || T > 255))
        throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${T}.`);
      h === 1 ? (S[0] = T * g, S[1] = T * g, S[2] = T * g) : S[E] = T * g;
    }
    const I = w * 4;
    v[I + 0] = Math.round(S[0]), v[I + 1] = Math.round(S[1]), v[I + 2] = Math.round(S[2]), v[I + 3] = Math.round(S[3]);
  }
  s.width = p, s.height = f;
  const b = new ImageData(v, p, f);
  return d.putImageData(b, 0, 0), a;
}
const FH = {
  kernelName: t1,
  backendName: "cpu",
  kernelFunc: OH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Du(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, keepDims: o } = r;
  xe(a, "sum");
  let i;
  a.dtype === "bool" ? i = qa({ inputs: { x: a }, backend: n, attrs: { dtype: "int32" } }) : i = ea({ inputs: { x: a }, backend: n });
  const c = i.shape.length, l = Vt(s, i.shape), u = pr(l, c);
  let d = l, f = i;
  u != null && (f = Gn({ inputs: { x: i }, backend: n, attrs: { perm: u } }), d = Mn(d.length, c)), Fn("sum", d, f.shape.length);
  const [p, h] = On(f.shape, d), m = Lo(f.dtype, "int32");
  let g = Yc(n, p, m);
  const v = Y(h), b = n.data.get(g.dataId).values, w = n.data.get(f.dataId).values;
  for (let S = 0; S < b.length; ++S) {
    const I = S * v;
    let E = 0;
    for (let T = 0; T < v; ++T)
      E += w[I + T];
    b[S] = E;
  }
  if (o) {
    const S = vn(g.shape, l), I = g;
    g = Rt({ inputs: { x: g }, backend: n, attrs: { shape: S } }), n.disposeIntermediateTensorInfo(I);
  }
  return n.disposeIntermediateTensorInfo(i), u != null && n.disposeIntermediateTensorInfo(f), g;
}
const MH = {
  kernelName: Zd,
  backendName: "cpu",
  kernelFunc: Du
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PH(t) {
  const { inputs: e, backend: n, attrs: r } = t, { equation: a } = r, s = e, { allDims: o, summedDims: i, idDims: c } = CM(a, s.length);
  AM(o.length, c, s);
  const { path: l, steps: u } = RM(i, c), d = u.length;
  let f = null, p = o.length;
  const h = [];
  for (let m = 0; m < d; ++m) {
    for (const g of u[m]) {
      const { permutationIndices: v, expandDims: b } = NM(p, c[g]);
      let w;
      $M(v) ? w = s[g] : (w = Gn({ inputs: { x: s[g] }, backend: n, attrs: { perm: v } }), h.push(w));
      const S = w.shape.slice();
      for (let I = 0; I < b.length; ++I)
        S.splice(b[I], 0, 1);
      Ir(w.shape, S) || (w = Rt({ inputs: { x: w }, backend: n, attrs: { shape: S } }), h.push(w)), f === null ? f = w : (f = If({ inputs: { a: w, b: f }, backend: n }), h.push(f));
    }
    m < d - 1 && (l[m] >= 0 && (f = Du({
      inputs: { x: f },
      backend: n,
      attrs: {
        axis: l[m] - (o.length - p),
        keepDims: !1
      }
    }), h.push(f)), p--);
  }
  for (const m of h)
    m !== f && n.disposeIntermediateTensorInfo(m);
  return f;
}
const BH = {
  kernelName: n1,
  backendName: "cpu",
  kernelFunc: PH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LH(t) {
  const { inputs: e, backend: n } = t, { dy: r, y: a } = e;
  xe([r, a], "eluGrad");
  const s = new Float32Array(Y(a.shape)), o = n.data.get(a.dataId).values, i = n.data.get(r.dataId).values;
  for (let c = 0; c < o.length; ++c) {
    const l = o[c];
    l >= 0 ? s[c] = i[c] : s[c] = i[c] * (l + 1);
  }
  return n.makeTensorInfo(a.shape, "float32", s);
}
const WH = {
  kernelName: ym,
  backendName: "cpu",
  kernelFunc: LH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zH = mM, VH = gM, HH = yM, jH = vM, UH = bM, GH = wM, qH = vt(Hl, (t) => {
  const e = Math.sign(t), n = Math.abs(t), r = 1 / (1 + zH * n);
  return e * (1 - ((((GH * r + UH) * r + jH) * r + HH) * r + VH) * r * Math.exp(-n * n));
}), KH = {
  kernelName: Hl,
  backendName: "cpu",
  kernelFunc: qH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qc(t) {
  const { inputs: e, backend: n, attrs: r } = t, { input: a } = e, { dim: s } = r, o = a.shape.length, i = a.shape.slice();
  let c = s;
  return s < 0 && (A(-(o + 1) <= s, () => `Axis must be in the interval [${-(o + 1)}, ${o}]`), c = o + s + 1), i.splice(c, 0, 1), Rt({ inputs: { x: a }, backend: n, attrs: { shape: i } });
}
const XH = {
  kernelName: vm,
  backendName: "cpu",
  kernelFunc: Qc
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YH = Yt((t, e) => t / e), Sg = cn(zl, YH), _h = {
  kernelName: zl,
  backendName: "cpu",
  kernelFunc: Sg
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E_(t, e, n) {
  const r = t.shape, a = r[0], s = r[1], o = n.data.get(t.dataId), i = o.complexTensorInfos.real, c = o.complexTensorInfos.imag, l = [a, s], u = Y(l), d = Dn("float32", u), f = Dn("float32", u);
  for (let g = 0; g < a; g++) {
    const v = Ws({
      inputs: { x: i },
      backend: n,
      attrs: { begin: [g, 0], size: [1, s] }
    }), b = Ws({
      inputs: { x: c },
      backend: n,
      attrs: { begin: [g, 0], size: [1, s] }
    }), w = nr({ inputs: { real: v, imag: b }, backend: n }), { real: S, imag: I } = ZH(w, e, n), E = No(S, I);
    for (let T = 0; T < s; T++) {
      const R = Jw(E, T);
      d[g * s + T] = R.real, f[g * s + T] = R.imag;
    }
    n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(w);
  }
  const p = n.makeTensorInfo(l, "float32", d), h = n.makeTensorInfo(l, "float32", f), m = nr({ inputs: { real: p, imag: h }, backend: n });
  return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), m;
}
function ZH(t, e, n) {
  const r = Y(t.shape), a = n.data.get(t.dataId), s = n.data.get(a.complexTensorInfos.real.dataId).values, o = n.data.get(a.complexTensorInfos.imag.dataId).values;
  if (JH(r)) {
    const i = xh(s, o, r, e, n), c = [t.shape[0], t.shape[1]];
    if (e) {
      const l = n.makeTensorInfo(c, "float32", i.real), u = n.makeTensorInfo(c, "float32", i.imag), d = n.makeTensorInfo([], "float32", Gm(r, "float32")), f = ea({ inputs: { x: d }, backend: n }), p = _h.kernelFunc({ inputs: { a: l, b: d }, backend: n }), h = _h.kernelFunc({ inputs: { a: u, b: f }, backend: n }), m = n.data.get(p.dataId).values, g = n.data.get(h.dataId).values;
      return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), { real: m, imag: g };
    }
    return i;
  } else {
    const i = No(s, o), c = QH(i, r, e);
    return SM(c);
  }
}
function JH(t) {
  return (t & t - 1) === 0;
}
function xh(t, e, n, r, a) {
  if (n === 1)
    return { real: t, imag: e };
  const s = No(t, e), o = n / 2, i = _M(s), c = i.real, l = i.imag, u = [c.length], d = a.makeTensorInfo(u, "float32", c), f = a.makeTensorInfo(u, "float32", l), p = nr({ inputs: { real: d, imag: f }, backend: a }), h = xM(s), m = h.real, g = h.imag, v = [m.length], b = a.makeTensorInfo(v, "float32", m), w = a.makeTensorInfo(v, "float32", g), S = nr({ inputs: { real: b, imag: w }, backend: a }), I = xh(c, l, o, r, a), E = I.real, T = I.imag, R = [E.length], $ = a.makeTensorInfo(R, "float32", E), D = a.makeTensorInfo(R, "float32", T), M = nr({
    inputs: { real: $, imag: D },
    backend: a
  }), z = xh(m, g, o, r, a), F = z.real, V = z.imag, H = [F.length], U = a.makeTensorInfo(H, "float32", F), Z = a.makeTensorInfo(H, "float32", V), q = nr({ inputs: { real: U, imag: Z }, backend: a }), X = kM(n, r), se = [X.real.length], te = a.makeTensorInfo(se, "float32", X.real), ue = a.makeTensorInfo(se, "float32", X.imag), ee = nr({ inputs: { real: te, imag: ue }, backend: a }), ne = If({ inputs: { a: ee, b: q }, backend: a }), oe = Ao({
    inputs: { a: M, b: ne },
    backend: a
  }), ge = vg({
    inputs: { a: M, b: ne },
    backend: a
  }), be = Ls({ inputs: { input: oe }, backend: a }), fe = Ls({ inputs: { input: ge }, backend: a }), we = Ro({ inputs: { input: oe }, backend: a }), Re = Ro({ inputs: { input: ge }, backend: a }), $e = $o({
    inputs: [be, fe],
    backend: a,
    attrs: { axis: 0 }
  }), Oe = $o({
    inputs: [we, Re],
    backend: a,
    attrs: { axis: 0 }
  }), We = a.data.get($e.dataId).values, Ue = a.data.get(Oe.dataId).values;
  return a.disposeIntermediateTensorInfo(d), a.disposeIntermediateTensorInfo(f), a.disposeIntermediateTensorInfo(p), a.disposeIntermediateTensorInfo(b), a.disposeIntermediateTensorInfo(w), a.disposeIntermediateTensorInfo(S), a.disposeIntermediateTensorInfo($), a.disposeIntermediateTensorInfo(D), a.disposeIntermediateTensorInfo(M), a.disposeIntermediateTensorInfo(U), a.disposeIntermediateTensorInfo(Z), a.disposeIntermediateTensorInfo(q), a.disposeIntermediateTensorInfo(te), a.disposeIntermediateTensorInfo(ue), a.disposeIntermediateTensorInfo(ee), a.disposeIntermediateTensorInfo(ne), a.disposeIntermediateTensorInfo(oe), a.disposeIntermediateTensorInfo(ge), a.disposeIntermediateTensorInfo(be), a.disposeIntermediateTensorInfo(we), a.disposeIntermediateTensorInfo(fe), a.disposeIntermediateTensorInfo(Re), a.disposeIntermediateTensorInfo($e), a.disposeIntermediateTensorInfo(Oe), { real: We, imag: Ue };
}
function QH(t, e, n) {
  const r = new Float32Array(e * 2);
  for (let a = 0; a < e; a++) {
    let s = 0, o = 0;
    for (let i = 0; i < e; i++) {
      const c = EM(a * i, e, n), l = Jw(t, i);
      s += l.real * c.real - l.imag * c.imag, o += l.real * c.imag + l.imag * c.real;
    }
    n && (s /= e, o /= e), IM(r, s, o, a);
  }
  return r;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ej(t) {
  const { inputs: e, backend: n } = t, { input: r } = e, a = Y(r.shape), s = r.shape[r.shape.length - 1], o = a / s, i = Rt({
    inputs: { x: r },
    backend: n,
    attrs: { shape: [o, s] }
  }), c = E_(i, !1, n), l = Rt({ inputs: { x: c }, backend: n, attrs: { shape: r.shape } });
  return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(c), l;
}
const tj = {
  kernelName: r1,
  backendName: "cpu",
  kernelFunc: ej
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _g(t) {
  const { backend: e, attrs: n } = t, { shape: r, value: a, dtype: s } = n, o = s || ku(a), i = tn(o, Y(r));
  return rj(i, a, o), e.makeTensorInfo(r, o, i);
}
const nj = {
  kernelName: bm,
  backendName: "cpu",
  kernelFunc: _g
};
function rj(t, e, n) {
  t.fill(e);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aj = {
  kernelName: ql,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { image: r } = t, a = n, s = Dn(r.dtype, Y(r.shape)), [o, i, c, l] = r.shape, u = a.data.get(r.dataId).values;
    for (let f = 0; f < o; f++) {
      const p = f * c * i * l;
      for (let h = 0; h < i; h++) {
        const m = h * (c * l);
        for (let g = 0; g < c; g++) {
          const v = g * l;
          for (let b = 0; b < l; b++) {
            const w = Math.round(c - g - 1), S = p + m + v + b;
            let I = u[S];
            if (w >= 0 && w < c) {
              const E = w * l, T = p + m + E + b;
              I = u[T];
            }
            s[S] = I;
          }
        }
      }
    }
    return { dataId: a.write(s, r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s, bias: o, preluActivationWeights: i } = e, { strides: c, pad: l, dataFormat: u, dilations: d, dimRoundingMode: f, activation: p, leakyreluAlpha: h } = r;
  let m = I_({
    inputs: { x: a, filter: s },
    backend: n,
    attrs: { strides: c, pad: l, dataFormat: u, dilations: d, dimRoundingMode: f }
  });
  if (o) {
    const g = m;
    if (u === "NCHW" && o.shape.length === 1 && o.shape[0] !== 1) {
      const v = Rt({ inputs: { x: o }, backend: n, attrs: { shape: [o.shape[0], 1, 1] } });
      m = Ao({ inputs: { a: m, b: v }, backend: n }), n.disposeIntermediateTensorInfo(v);
    } else
      m = Ao({ inputs: { a: m, b: o }, backend: n });
    n.disposeIntermediateTensorInfo(g);
  }
  if (p) {
    const g = m;
    if (u === "NCHW" && p === "prelu" && i.shape.length === 1 && i.shape[0] !== 1) {
      const v = Rt({
        inputs: { x: i },
        backend: n,
        attrs: { shape: [i.shape[0], 1, 1] }
      });
      m = Jc(n, m, p, v, h), n.disposeIntermediateTensorInfo(v);
    } else
      m = Jc(n, m, p, i, h);
    n.disposeIntermediateTensorInfo(g);
  }
  return m;
}
const oj = {
  kernelName: tu,
  backendName: "cpu",
  kernelFunc: sj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ij(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, filter: s, bias: o, preluActivationWeights: i } = e, { strides: c, pad: l, dataFormat: u, dilations: d, dimRoundingMode: f, activation: p, leakyreluAlpha: h } = r;
  let m = k_({
    inputs: { x: a, filter: s },
    backend: n,
    attrs: { strides: c, pad: l, dataFormat: u, dilations: d, dimRoundingMode: f }
  });
  if (o) {
    const g = m;
    m = Ao({ inputs: { a: m, b: o }, backend: n }), n.disposeIntermediateTensorInfo(g);
  }
  if (p) {
    const g = m;
    m = Jc(n, m, p, i, h), n.disposeIntermediateTensorInfo(g);
  }
  return m;
}
const uj = {
  kernelName: nu,
  backendName: "cpu",
  kernelFunc: ij
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cj(t) {
  const { inputs: e, backend: n } = t, { params: r, indices: a } = e, s = Y(r.shape), o = a.shape, i = o[o.length - 1], [c, l, u, d] = Vw(r, a);
  if (l === 0)
    return n.makeTensorInfo(c, r.dtype, []);
  const f = n.data.get(a.dataId).values, p = n.bufferSync(r), h = ZP(f, p, r.dtype, l, i, u, d, r.shape, s);
  return n.makeTensorInfo(c, r.dtype, h.values);
}
const lj = {
  kernelName: Zl,
  backendName: "cpu",
  kernelFunc: cj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, indices: s } = e, { axis: o, batchDims: i } = r;
  xe([a, s], "gatherV2");
  const c = Vt(o, a.shape)[0], l = n.data.get(s.dataId).values, u = a.shape[c];
  for (let S = 0; S < l.length; ++S) {
    const I = l[S];
    A(I <= u - 1 && I >= 0, () => `GatherV2: the index value ${I} is not in [0, ${u - 1}]`);
  }
  let d = i;
  i == null && (d = 0);
  const f = Y(s.shape), p = d2(a, s, c, d), h = Rt({
    inputs: { x: a },
    backend: n,
    attrs: {
      shape: [
        p.batchSize,
        p.outerSize,
        p.dimSize,
        p.sliceSize
      ]
    }
  }), m = Rt({
    inputs: { x: s },
    backend: n,
    attrs: { shape: [p.batchSize, f / p.batchSize] }
  }), g = [
    p.batchSize,
    p.outerSize,
    f / p.batchSize,
    p.sliceSize
  ], v = n.bufferSync(m), b = n.bufferSync(h), w = JP(b, v, g);
  return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(m), n.makeTensorInfo(p.outputShape, w.dtype, w.values);
}
const fj = {
  kernelName: wm,
  backendName: "cpu",
  kernelFunc: dj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pj(t) {
  const { inputs: e, backend: n } = t, { input: r } = e, a = Y(r.shape), s = r.shape[r.shape.length - 1], o = a / s, i = Rt({
    inputs: { x: r },
    backend: n,
    attrs: { shape: [o, s] }
  }), c = E_(i, !0, n), l = Rt({ inputs: { x: c }, backend: n, attrs: { shape: r.shape } });
  return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(c), l;
}
const hj = {
  kernelName: a1,
  backendName: "cpu",
  kernelFunc: pj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const mj = vt(td, (t) => Number.isFinite(t) ? 1 : 0, "bool"), gj = {
  kernelName: td,
  backendName: "cpu",
  kernelFunc: mj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yj = vt(nd, (t) => Math.abs(t) === 1 / 0 ? 1 : 0, "bool"), vj = {
  kernelName: nd,
  backendName: "cpu",
  kernelFunc: yj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bj = vt(rd, (t) => Number.isNaN(t) ? 1 : 0, "bool"), wj = {
  kernelName: rd,
  backendName: "cpu",
  kernelFunc: bj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sj(t) {
  const { backend: e, attrs: n } = t, { start: r, stop: a, num: s } = n, o = d8(r, a, s);
  return e.makeTensorInfo([o.length], "float32", o);
}
const _j = {
  kernelName: id,
  backendName: "cpu",
  kernelFunc: Sj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xj = vt(cd, (t) => Math.log1p(t)), Ij = {
  kernelName: cd,
  backendName: "cpu",
  kernelFunc: xj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kj = Yt((t, e) => t && e), Ej = cn(ld, kj, null, "bool"), Tj = {
  kernelName: ld,
  backendName: "cpu",
  kernelFunc: Ej
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Cj = vt(dd, (t) => t ? 0 : 1, "bool"), Nj = {
  kernelName: dd,
  backendName: "cpu",
  kernelFunc: Cj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Aj = Yt((t, e) => t || e), Rj = cn(fd, Aj, null, "bool"), $j = {
  kernelName: fd,
  backendName: "cpu",
  kernelFunc: Rj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { depthRadius: s, bias: o, alpha: i, beta: c } = r;
  xe(a, "LRN");
  const l = a.shape[3], u = l - 1, d = n.data.get(a.dataId).values, f = Y(a.shape), p = new Float32Array(f);
  function h(m) {
    const g = m % l;
    let v = m - g + Math.max(0, g - s);
    const b = m - g + Math.min(g + s, u);
    let w = 0;
    for (; v <= b; v++) {
      const S = d[v];
      w += S * S;
    }
    return w;
  }
  for (let m = 0; m < f; m++) {
    const g = h(m), v = d[m] * Math.pow(o + i * g, -c);
    p[m] = v;
  }
  return n.makeTensorInfo(a.shape, a.dtype, p);
}
const Oj = {
  kernelName: pd,
  backendName: "cpu",
  kernelFunc: Dj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, y: s, dy: o } = e, { depthRadius: i, bias: c, alpha: l, beta: u } = r;
  xe(o, "LRNGrad");
  const d = Y(o.shape), f = o.shape[3], p = n.data.get(o.dataId).values, h = n.data.get(a.dataId).values, m = n.data.get(s.dataId).values, g = new Float32Array(d), v = d;
  for (let b = 0; b < v; b++) {
    const w = b % f, S = b - w + Math.max(0, w - i), I = b - w + Math.min(f, w + i + 1);
    let E = 0;
    for (let T = S; T < I; T++)
      E += Math.pow(h[T], 2);
    E = l * E + c;
    for (let T = S; T < I; T++) {
      let R = -2 * l * u * h[T] * m[b] / E;
      b === T && (R += Math.pow(E, -u)), R *= p[b], g[T] += R;
    }
  }
  return n.makeTensorInfo(o.shape, a.dtype, g);
}
const Mj = {
  kernelName: Sm,
  backendName: "cpu",
  kernelFunc: Fj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T_(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { reductionIndices: s, keepDims: o } = r, i = n;
  let c = a.shape;
  const l = c.length, u = Vt(s, c);
  let d = u;
  const f = pr(d, l);
  let p = i.data.get(a.dataId).values;
  if (f != null) {
    const S = new Array(l);
    for (let I = 0; I < S.length; I++)
      S[I] = c[f[I]];
    p = F2(p, c, a.dtype, f, S), d = Mn(d.length, l), c = S;
  }
  xe(a, "max"), Fn("max", d, l);
  const [h, m] = On(c, d), g = Y(m), v = m8(p, g, h, a.dtype), b = i.write(v, h, a.dtype);
  let w = h;
  return o && (w = vn(h, u)), { dataId: b, shape: w, dtype: a.dtype };
}
const Pj = {
  kernelName: hd,
  backendName: "cpu",
  kernelFunc: T_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e;
  xe(a, "maxPool");
  const { filterSize: s, strides: o, pad: i, dimRoundingMode: c } = r, l = 1;
  A(Er(o, l), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);
  const u = Vr(a.shape, s, o, l, i, c);
  let d;
  if (u.filterWidth === 1 && u.filterHeight === 1 && Ir(u.inShape, u.outShape))
    d = ea({ inputs: { x: a }, backend: n });
  else {
    const f = n.data.get(a.dataId).values, p = Ie(a.shape), h = wg(f, a.shape, a.dtype, p, u, "max");
    d = n.makeTensorInfo(u.outShape, a.dtype, h.values);
  }
  return d;
}
const Lj = {
  kernelName: gd,
  backendName: "cpu",
  kernelFunc: Bj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { filterSize: s, strides: o, pad: i, dimRoundingMode: c, dataFormat: l } = r;
  xe(a, "maxPool3d");
  const u = Ja(a.shape, s, o, 1, i, c, l), d = n.data.get(a.dataId).values, f = x_(d, a.shape, a.dtype, Ie(a.shape), u, "max");
  return n.makeTensorInfo(f.shape, "float32", f.values);
}
const zj = {
  kernelName: _m,
  backendName: "cpu",
  kernelFunc: Wj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s } = e, { filterSize: o, strides: i, pad: c, dimRoundingMode: l } = r;
  xe([a, s], "maxPool3DGrad");
  const u = Ja(s.shape, o, i, 1, c, l), d = n.bufferSync(s), f = AV(d, u), p = u.strideDepth, h = u.strideHeight, m = u.strideWidth, g = u.dilationDepth, v = u.dilationHeight, b = u.dilationWidth, w = u.effectiveFilterDepth, S = u.effectiveFilterHeight, I = u.effectiveFilterWidth, E = w - 1 - u.padInfo.front, T = I - 1 - u.padInfo.left, R = S - 1 - u.padInfo.top, $ = Qe(s.shape, "float32"), D = n.bufferSync(a);
  for (let M = 0; M < u.batchSize; ++M)
    for (let z = 0; z < u.inChannels; ++z)
      for (let F = 0; F < u.inDepth; ++F)
        for (let V = 0; V < u.inHeight; ++V)
          for (let H = 0; H < u.inWidth; ++H) {
            const U = F - E, Z = V - R, q = H - T;
            let X = 0;
            for (let se = 0; se < w; se += g) {
              const te = (U + se) / p;
              if (!(te < 0 || te >= u.outDepth || Math.floor(te) !== te))
                for (let ue = 0; ue < S; ue += v) {
                  const ee = (Z + ue) / h;
                  if (!(ee < 0 || ee >= u.outHeight || Math.floor(ee) !== ee))
                    for (let ne = 0; ne < I; ne += b) {
                      const oe = (q + ne) / m;
                      if (oe < 0 || oe >= u.outWidth || Math.floor(oe) !== oe)
                        continue;
                      const ge = w * S * I - 1 - f.get(M, te, ee, oe, z), be = se * S * I + ue * I + ne, fe = ge === be ? 1 : 0;
                      if (fe === 0)
                        continue;
                      const we = D.get(M, te, ee, oe, z);
                      X += we * fe;
                    }
                }
            }
            $.set(X, M, F, V, H, z);
          }
  return n.makeTensorInfo($.shape, $.dtype, $.values);
}
const Hj = {
  kernelName: i1,
  backendName: "cpu",
  kernelFunc: Vj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { dy: a, input: s, output: o } = e, i = s;
  xe([s, o], "maxPoolGrad");
  const { filterSize: c, strides: l, pad: u, dimRoundingMode: d } = r, f = Vr(i.shape, c, l, 1, u, d), p = n.data.get(i.dataId).values, h = Qe(f.outShape, i.dtype, __(p, i.shape, i.dtype, f).values), m = f.strideHeight, g = f.strideWidth, v = f.dilationHeight, b = f.dilationWidth, w = f.effectiveFilterHeight, S = f.effectiveFilterWidth, I = S - 1 - f.padInfo.left, E = w - 1 - f.padInfo.top, T = Qe(i.shape, "float32"), R = n.data.get(a.dataId).values, $ = Qe(a.shape, "float32", R);
  for (let D = 0; D < f.batchSize; ++D)
    for (let M = 0; M < f.inChannels; ++M)
      for (let z = 0; z < f.inHeight; ++z)
        for (let F = 0; F < f.inWidth; ++F) {
          const V = z - E, H = F - I;
          let U = 0;
          for (let Z = 0; Z < w; Z += v) {
            const q = (V + Z) / m;
            if (!(q < 0 || q >= f.outHeight || Math.floor(q) !== q))
              for (let X = 0; X < S; X += b) {
                const se = (H + X) / g;
                if (se < 0 || se >= f.outWidth || Math.floor(se) !== se)
                  continue;
                const te = w * S - 1 - h.get(D, q, se, M), ue = Z * S + X, ee = te === ue ? 1 : 0;
                if (ee === 0)
                  continue;
                const ne = $.get(D, q, se, M);
                U += ne * ee;
              }
          }
          T.set(U, D, z, F, M);
        }
  return n.makeTensorInfo(T.shape, T.dtype, T.values);
}
const Uj = {
  kernelName: o1,
  backendName: "cpu",
  kernelFunc: jj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gj(t, e, n, r, a) {
  const s = Ie(e), o = wg(t, e, n, s, a, "max"), i = __(t, e, n, a, !0, r);
  return [o.values, i.values];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qj = {
  kernelName: xm,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { x: r } = t, { filterSize: a, strides: s, pad: o, includeBatchInIndex: i } = e, c = n;
    xe(r, "MaxPoolWithArgmax");
    const l = c.data.get(r.dataId).values, u = Vr(r.shape, a, s, [1, 1], o), [d, f] = Gj(l, r.shape, r.dtype, i, u), p = c.write(d, u.outShape, r.dtype), h = c.write(f, u.outShape, r.dtype);
    return [
      { dataId: p, shape: u.outShape, dtype: r.dtype },
      { dataId: h, shape: u.outShape, dtype: "int32" }
    ];
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, keepDims: o } = r, i = Vt(s, a.shape), l = On(a.shape, i)[1], u = Y(l), d = [], f = n.makeTensorInfo([], "float32", new Float32Array([u]));
  d.push(f);
  const p = qa({ inputs: { x: a }, backend: n, attrs: { dtype: "float32" } });
  d.push(p);
  const h = Sg({ inputs: { a: p, b: f }, backend: n });
  d.push(h);
  const m = Du({ inputs: { x: h }, backend: n, attrs: { axis: s, keepDims: o } });
  return d.forEach((g) => n.disposeIntermediateTensorInfo(g)), m;
}
const Xj = {
  kernelName: yd,
  backendName: "cpu",
  kernelFunc: Kj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { axis: s, keepDims: o } = r;
  xe(a, "min");
  const i = Vt(s, a.shape);
  let c = i;
  const l = pr(c, a.shape.length);
  let u = a;
  l != null && (u = Gn({ inputs: { x: a }, backend: n, attrs: { perm: l } }), c = Mn(c.length, a.shape.length)), Fn("min", c, u.shape.length);
  const [d, f] = On(u.shape, c), p = Y(f), h = In(Y(d), u.dtype), m = n.data.get(u.dataId).values;
  for (let v = 0; v < h.length; ++v) {
    const b = v * p;
    let w = m[b];
    for (let S = 0; S < p; ++S) {
      const I = m[b + S];
      (Number.isNaN(I) || I < w) && (w = I);
    }
    h[v] = w;
  }
  l != null && n.disposeIntermediateTensorInfo(u);
  const g = n.makeTensorInfo(d, u.dtype, h);
  if (o) {
    const v = vn(d, i), b = Rt({ inputs: { x: g }, backend: n, attrs: { shape: v } });
    return n.disposeIntermediateTensorInfo(g), b;
  }
  return g;
}
const Zj = {
  kernelName: vd,
  backendName: "cpu",
  kernelFunc: Yj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jj(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { paddings: s, mode: o } = r;
  xe(a, "mirrorPad");
  const i = s.map(
    (w, S) => w[0] + a.shape[S] + w[1]
    /* afterPad */
  ), c = s.map((w) => w[0]), l = s.map((w, S) => w[0] + a.shape[S]), u = o === "reflect" ? 0 : 1, d = n.data.get(a.dataId).values, f = a.shape.length, p = Ie(a.shape), h = Y(i), m = i.length, g = Ie(i), v = Dn(a.dtype, h);
  for (let w = 0; w < h; w++) {
    let S = Bo(w, m, g);
    for (let E = 0; E < m; E++)
      S[E] < c[E] ? S[E] = c[E] * 2 - S[E] - u : S[E] >= l[E] && (S[E] = (l[E] - 1) * 2 - S[E] + u);
    S = S.map((E, T) => E - c[T]);
    const I = Zr(S, f, p);
    v[w] = d[I];
  }
  return { dataId: n.write(v, i, a.dtype), shape: i, dtype: a.dtype };
}
const Qj = {
  kernelName: wd,
  backendName: "cpu",
  kernelFunc: Jj
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eU = Yt((t, e) => {
  const n = t % e;
  return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;
}), tU = cn(Sd, eU), nU = {
  kernelName: Sd,
  backendName: "cpu",
  kernelFunc: tU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function C_(t) {
  const { inputs: e, backend: n, attrs: r } = t, { logits: a } = e, { dim: s } = r, o = a.shape.length;
  let i = s;
  if (i === -1 && (i = o - 1), i !== o - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);
  const c = Vt([i], a.shape), l = T_({
    inputs: { x: a },
    backend: n,
    attrs: { reductionIndices: c, keepDims: !1 }
  }), u = vn(l.shape, c), d = Rt({ inputs: { x: l }, backend: n, attrs: { shape: u } }), f = vg({ inputs: { a, b: d }, backend: n }), p = D2({ inputs: { x: f }, backend: n }), h = Du({ inputs: { x: p }, backend: n, attrs: { axis: c, keepDims: !1 } }), m = Rt({ inputs: { x: h }, backend: n, attrs: { shape: u } }), g = Sg({ inputs: { a: p, b: m }, backend: n });
  return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(m), g;
}
const rU = {
  kernelName: Jd,
  backendName: "cpu",
  kernelFunc: C_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { logits: a } = e, { numSamples: s, seed: o, normalized: i } = r;
  xe(a, "multinomial");
  const c = i ? a : C_({ inputs: { logits: a }, backend: n, attrs: { dim: -1 } }), l = c.shape[0], u = c.shape[1], d = n.data.get(c.dataId).values, f = [l, s], p = In(Y(f), "int32");
  for (let h = 0; h < l; ++h) {
    const m = h * u, g = new Float32Array(u - 1);
    g[0] = d[m];
    for (let w = 1; w < g.length; ++w)
      g[w] = g[w - 1] + d[m + w];
    const v = yf.alea(o.toString()), b = h * s;
    for (let w = 0; w < s; ++w) {
      const S = v();
      p[b + w] = g.length;
      for (let I = 0; I < g.length; I++)
        if (S < g[I]) {
          p[b + w] = I;
          break;
        }
    }
  }
  return i || n.disposeIntermediateTensorInfo(c), n.makeTensorInfo(f, "int32", p);
}
const sU = {
  kernelName: _d,
  backendName: "cpu",
  kernelFunc: aU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oU = $w;
function iU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { boxes: a, scores: s } = e, { maxOutputSize: o, iouThreshold: i, scoreThreshold: c } = r;
  xe(a, "NonMaxSuppression");
  const l = n.data.get(a.dataId).values, u = n.data.get(s.dataId).values, { selectedIndices: d } = oU(l, u, o, i, c);
  return n.makeTensorInfo([d.length], "int32", new Int32Array(d));
}
const uU = {
  kernelName: kd,
  backendName: "cpu",
  kernelFunc: iU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cU = Dw;
function lU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { boxes: a, scores: s } = e, { maxOutputSize: o, iouThreshold: i, scoreThreshold: c, padToMaxOutputSize: l } = r;
  xe(a, "NonMaxSuppressionPadded");
  const u = n.data.get(a.dataId).values, d = n.data.get(s.dataId).values, { selectedIndices: f, validOutputs: p } = cU(u, d, o, i, c, l);
  return [
    n.makeTensorInfo([f.length], "int32", new Int32Array(f)),
    n.makeTensorInfo([], "int32", new Int32Array([p]))
  ];
}
const dU = {
  kernelName: Ed,
  backendName: "cpu",
  kernelFunc: lU
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fU = Ow;
function pU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { boxes: a, scores: s } = e, { maxOutputSize: o, iouThreshold: i, scoreThreshold: c, softNmsSigma: l } = r;
  xe(a, "NonMaxSuppressionWithScore");
  const u = n.data.get(a.dataId).values, d = n.data.get(s.dataId).values, f = o, p = i, h = c, m = l, { selectedIndices: g, selectedScores: v } = fU(u, d, f, p, h, m);
  return [
    n.makeTensorInfo([g.length], "int32", new Int32Array(g)),
    n.makeTensorInfo([v.length], "float32", new Float32Array(v))
  ];
}
const hU = {
  kernelName: Td,
  backendName: "cpu",
  kernelFunc: pU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { indices: a } = e, { dtype: s, depth: o, onValue: i, offValue: c } = r;
  xe(a, "oneHot");
  const l = Y(a.shape), u = new Float32Array(l * o);
  u.fill(c);
  const d = n.data.get(a.dataId).values;
  for (let f = 0; f < l; ++f)
    d[f] >= 0 && d[f] < o && (u[f * o + d[f]] = i);
  return n.makeTensorInfo([...a.shape, o], s, u);
}
const gU = {
  kernelName: Cd,
  backendName: "cpu",
  kernelFunc: mU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function el(t) {
  const { inputs: e, backend: n } = t, { x: r } = e;
  if (r.dtype === "string")
    throw new Error("zerosLike is not supported for string tensors");
  if (r.dtype === "complex64") {
    const a = Ls({ inputs: { input: r }, backend: n }), s = el({ inputs: { x: a }, backend: n }), o = Ro({ inputs: { input: r }, backend: n }), i = el({ inputs: { x: o }, backend: n }), c = nr({ inputs: { real: s, imag: i }, backend: n });
    return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(s), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(i), c;
  } else
    return _g({ backend: n, attrs: { shape: r.shape, value: 0, dtype: r.dtype } });
}
const yU = {
  kernelName: jm,
  backendName: "cpu",
  kernelFunc: el
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N_(t) {
  const { inputs: e, backend: n } = t, { x: r } = e;
  if (r.dtype === "string")
    throw new Error("onesLike is not supported for string tensors");
  if (r.dtype === "complex64") {
    const a = Ls({ inputs: { input: r }, backend: n }), s = N_({ inputs: { x: a }, backend: n }), o = Ro({ inputs: { input: r }, backend: n }), i = el({ inputs: { x: o }, backend: n }), c = nr({ inputs: { real: s, imag: i }, backend: n });
    return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(s), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(i), c;
  } else
    return _g({ backend: n, attrs: { shape: r.shape, value: 1, dtype: r.dtype } });
}
const vU = {
  kernelName: km,
  backendName: "cpu",
  kernelFunc: N_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function A_(t) {
  const { inputs: e, backend: n, attrs: r } = t, { axis: a } = r;
  if (e.length === 1)
    return Qc({ inputs: { input: e[0] }, backend: n, attrs: { dim: a } });
  const s = e[0].shape, o = e[0].dtype;
  e.forEach((u) => {
    ar(s, u.shape, "All tensors passed to stack must have matching shapes"), A(o === u.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const i = [], c = e.map((u) => {
    const d = Qc({ inputs: { input: u }, backend: n, attrs: { dim: a } });
    return i.push(d), d;
  }), l = $o({ inputs: c, backend: n, attrs: { axis: a } });
  return i.forEach((u) => n.disposeIntermediateTensorInfo(u)), l;
}
const bU = {
  kernelName: Em,
  backendName: "cpu",
  kernelFunc: A_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { paddings: s, constantValue: o } = r;
  xe(a, "pad");
  const i = s.map(
    (b, w) => b[0] + a.shape[w] + b[1]
    /* afterPad */
  ), c = s.map((b) => b[0]), l = n.data.get(a.dataId).values, u = Y(a.shape), d = a.shape.length, f = Ie(a.shape), p = Y(i), h = i.length, m = Ie(i), g = Dn(a.dtype, p);
  o !== 0 && g.fill(o);
  for (let b = 0; b < u; b++) {
    const S = Bo(b, d, f).map((E, T) => E + c[T]), I = Zr(S, h, m);
    g[I] = l[b];
  }
  return { dataId: n.write(g, i, a.dtype), shape: i, dtype: a.dtype };
}
const R_ = {
  kernelName: Nd,
  backendName: "cpu",
  kernelFunc: wU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SU = Yt((t, e) => Math.pow(t, e)), _U = cn(Ad, SU), xU = {
  kernelName: Ad,
  backendName: "cpu",
  kernelFunc: _U
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { paramsNestedSplits: a, paramsDenseValues: s, indices: o } = e, i = a.map((g) => n.data.get(g.dataId).values), c = a.map((g) => g.shape), l = n.data.get(s.dataId).values, u = n.data.get(o.dataId).values, [d, f, p] = W8(i, c, l, s.shape, s.dtype, u, o.shape), h = d.map((g) => n.makeTensorInfo([g.length], "int32", g)), m = n.makeTensorInfo(p, s.dtype, f);
  return h.concat([m]);
}
const kU = {
  kernelName: u1,
  backendName: "cpu",
  kernelFunc: IU
};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EU(t) {
  const { inputs: e, backend: n } = t, { starts: r, limits: a, deltas: s } = e, o = n.data.get(r.dataId).values, i = n.data.get(a.dataId).values, c = n.data.get(s.dataId).values, [l, u] = z8(o, r.shape, r.dtype, i, a.shape, c, s.shape), d = n.makeTensorInfo([l.length], "int32", l), f = n.makeTensorInfo([u.length], r.dtype, u);
  return [d, f];
}
const TU = {
  kernelName: c1,
  backendName: "cpu",
  kernelFunc: EU
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { shape: a, values: s, defaultValue: o, rowPartitionTensors: i } = e, { rowPartitionTypes: c } = r, l = n.data.get(a.dataId).values, u = n.data.get(s.dataId).values, d = n.data.get(o.dataId).values, f = i.map((g) => n.data.get(g.dataId).values), p = i.map((g) => g.shape), [h, m] = V8(l, a.shape, u, s.shape, s.dtype, d, o.shape, f, p, c);
  return n.makeTensorInfo(h, s.dtype, m);
}
const NU = {
  kernelName: l1,
  backendName: "cpu",
  kernelFunc: CU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AU(t) {
  const { backend: e, attrs: n } = t, { start: r, stop: a, dtype: s, step: o } = n, i = M2(r, a, o, s);
  return e.makeTensorInfo([i.length], s, i);
}
const RU = {
  kernelName: Tm,
  backendName: "cpu",
  kernelFunc: AU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $U = vt(Dd, (t) => 1 / t), DU = {
  kernelName: Dd,
  backendName: "cpu",
  kernelFunc: $U
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { images: a } = e, { alignCorners: s, halfPixelCenters: o, size: i } = r;
  xe(a, "resizeBilinear");
  const c = Ie(a.shape), [l, u] = i, [d, f, p, h] = a.shape, m = n.data.get(a.dataId).values, g = new Float32Array(Y([d, l, u, h])), v = [
    s && l > 1 ? f - 1 : f,
    s && u > 1 ? p - 1 : p
  ], b = [
    s && l > 1 ? l - 1 : l,
    s && u > 1 ? u - 1 : u
  ];
  let w = 0;
  const S = v[0] / b[0], I = v[1] / b[1];
  for (let E = 0; E < d; E++)
    for (let T = 0; T < l; T++) {
      let R;
      o ? R = S * (T + 0.5) - 0.5 : R = S * T;
      const $ = Math.max(0, Math.floor(R)), D = R - $, M = Math.min(f - 1, Math.ceil(R)), z = E * c[0] + $ * c[1], F = E * c[0] + M * c[1];
      for (let V = 0; V < u; V++) {
        let H;
        o ? H = I * (V + 0.5) - 0.5 : H = I * V;
        const U = Math.max(0, Math.floor(H)), Z = H - U, q = Math.min(p - 1, Math.ceil(H)), X = z + U * c[2], se = F + U * c[2], te = z + q * c[2], ue = F + q * c[2];
        for (let ee = 0; ee < h; ee++) {
          const ne = m[X + ee], oe = m[se + ee], ge = m[te + ee], be = m[ue + ee], fe = ne + (ge - ne) * Z, we = oe + (be - oe) * Z, Re = fe + (we - fe) * D;
          g[w++] = Re;
        }
      }
    }
  return n.makeTensorInfo([d, l, u, h], "float32", g);
}
const FU = {
  kernelName: Md,
  backendName: "cpu",
  kernelFunc: OU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { images: a, dy: s } = e, { alignCorners: o } = r;
  xe([s, a], "resizeBilinearGrad");
  const i = Ie(a.shape), [c, l, u, d] = a.shape, [, f, p] = s.shape, h = new Float32Array(c * l * u * d), m = [
    o && f > 1 ? l - 1 : l,
    o && p > 1 ? u - 1 : u
  ], g = [
    o && f > 1 ? f - 1 : f,
    o && p > 1 ? p - 1 : p
  ], v = m[0] / g[0], b = m[1] / g[1], w = n.data.get(s.dataId).values;
  let S = 0;
  for (let I = 0; I < c; I++) {
    const E = I * i[0];
    for (let T = 0; T < f; T++) {
      const R = T * v, $ = Math.floor(R), D = Math.min(Math.ceil(R), l - 1), M = E + $ * i[1], z = E + D * i[1], F = R - $, V = 1 - F;
      for (let H = 0; H < p; H++) {
        const U = H * b, Z = Math.floor(U), q = Math.min(Math.ceil(U), u - 1), X = U - Z, se = 1 - X, te = M + Z * i[2], ue = M + q * i[2], ee = z + Z * i[2], ne = z + q * i[2], oe = V * se, ge = V * X, be = F * se, fe = F * X;
        for (let we = 0; we < d; we++) {
          const Re = w[S++];
          h[te + we] += Re * oe, h[ue + we] += Re * ge, h[ee + we] += Re * be, h[ne + we] += Re * fe;
        }
      }
    }
  }
  return n.makeTensorInfo([c, u, l, d], "float32", h);
}
const PU = {
  kernelName: Am,
  backendName: "cpu",
  kernelFunc: MU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { images: a } = e, { alignCorners: s, halfPixelCenters: o, size: i } = r;
  xe(a, "resizeNearestNeighbor");
  const c = Ie(a.shape), [l, u] = i, [d, f, p, h] = a.shape, m = n.data.get(a.dataId).values, g = new Float32Array(d * l * u * h), v = [
    s && l > 1 ? f - 1 : f,
    s && u > 1 ? p - 1 : p
  ], b = [
    s && l > 1 ? l - 1 : l,
    s && u > 1 ? u - 1 : u
  ], w = v[0] / b[0], S = v[1] / b[1];
  let I = 0;
  for (let E = 0; E < d; E++) {
    const T = E * c[0];
    for (let R = 0; R < l; R++) {
      const $ = o ? w * (R + 0.5) : w * R;
      let D = Math.min(f - 1, s ? Math.round($) : Math.floor($));
      o && (D = Math.max(0, D));
      const M = T + D * c[1];
      for (let z = 0; z < u; z++) {
        const F = o ? S * (z + 0.5) : S * z;
        let V = Math.min(p - 1, s ? Math.round(F) : Math.floor(F));
        o && (V = Math.max(0, V));
        const H = M + V * c[2];
        for (let U = 0; U < h; U++) {
          const Z = m[H + U];
          g[I++] = Z;
        }
      }
    }
  }
  return n.makeTensorInfo([d, l, u, h], a.dtype, g);
}
const LU = {
  kernelName: Fd,
  backendName: "cpu",
  kernelFunc: BU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { images: a, dy: s } = e, { alignCorners: o } = r;
  xe([s, a], "resizeNearestNeighborGrad");
  const i = Ie(a.shape), c = Ie(s.shape), [l, u, d, f] = a.shape, [, p, h] = s.shape, m = new Float32Array(l * u * d * f), g = n.data.get(s.dataId).values, v = [
    o && p > 1 ? u - 1 : u,
    o && h > 1 ? d - 1 : d
  ], b = [
    o && p > 1 ? p - 1 : p,
    o && h > 1 ? h - 1 : h
  ], w = v[0] / b[0], S = v[1] / b[1], I = 1 / w, E = 1 / S, T = Math.ceil(I) * 2 + 2, R = Math.ceil(E) * 2 + 2;
  for (let $ = 0; $ < l; $++) {
    const D = $ * i[0];
    for (let M = 0; M < u; M++) {
      const z = D + M * i[1], F = Math.floor(M * I), V = Math.floor(F - T / 2);
      for (let H = 0; H < d; H++) {
        const U = z + H * i[2], Z = Math.floor(H * E), q = Math.floor(Z - R / 2);
        for (let X = 0; X < f; X++) {
          let se = 0;
          for (let te = 0; te < T; te++) {
            const ue = te + V;
            if (ue < 0 || ue >= p)
              continue;
            const ee = D + ue * c[1], ne = ue * w, oe = Math.min(u - 1, o ? Math.round(ne) : Math.floor(ne));
            if (M === oe)
              for (let ge = 0; ge < R; ge++) {
                const be = ge + q;
                if (be < 0 || be >= h)
                  continue;
                const fe = ee + be * c[2], we = be * S, Re = Math.min(d - 1, o ? Math.round(we) : Math.floor(we));
                H === Re && (se += g[fe + X]);
              }
          }
          m[U + X] = se;
        }
      }
    }
  }
  return n.makeTensorInfo(a.shape, a.dtype, m);
}
const zU = {
  kernelName: Nm,
  backendName: "cpu",
  kernelFunc: WU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { dims: s } = r;
  xe(a, "reverse");
  const o = a.shape.length, i = Vt(s, a.shape);
  if (o === 0)
    return ea({ inputs: { x: a }, backend: n });
  const c = new on(a.shape, a.dtype), l = n.bufferSync(a);
  for (let u = 0; u < c.size; u++) {
    const d = c.indexToLoc(u), f = d.slice();
    i.forEach((p) => f[p] = a.shape[p] - 1 - f[p]), c.set(l.get(...f), ...d);
  }
  return n.makeTensorInfo(c.shape, c.dtype, c.values);
}
const HU = {
  kernelName: Bd,
  backendName: "cpu",
  kernelFunc: VU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jU = {
  kernelName: cf,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, attrs: e, backend: n }) => {
    const { image: r } = t, { radians: a, fillValue: s, center: o } = e, i = n, c = Dn(r.dtype, Y(r.shape)), [l, u, d, f] = r.shape, [p, h] = Xw(o, u, d), m = 255, g = Math.sin(a), v = Math.cos(a), b = i.data.get(r.dataId).values;
    for (let S = 0; S < l; S++) {
      const I = S * d * u * f;
      for (let E = 0; E < u; E++) {
        const T = E * (d * f);
        for (let R = 0; R < d; R++) {
          const $ = R * f;
          for (let D = 0; D < f; D++) {
            const M = [l, E, R, D], z = M[2], F = M[1];
            let V = (z - p) * v - (F - h) * g, H = (z - p) * g + (F - h) * v;
            V = Math.round(V + p), H = Math.round(H + h);
            let U = s;
            if (typeof s != "number" && (D === 3 ? U = m : U = s[D]), V >= 0 && V < d && H >= 0 && H < u) {
              const q = H * (d * f), X = V * f, se = I + q + X + D;
              U = b[se];
            }
            const Z = I + T + $ + D;
            c[Z] = U;
          }
        }
      }
    }
    return { dataId: i.write(c, r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UU = vt(Ld, (t) => {
  const e = Math.floor(t);
  return t - e < 0.5 ? Math.floor(t) : t - e > 0.5 ? Math.ceil(t) : e % 2 === 0 ? e : e + 1;
}), GU = {
  kernelName: Ld,
  backendName: "cpu",
  kernelFunc: UU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { indices: a, updates: s } = e, { shape: o } = r, { sliceRank: i, numUpdates: c, sliceSize: l, strides: u, outputSize: d } = Vo(s, a, o), f = !0, p = n.bufferSync(a), h = n.bufferSync(s), m = go(p, h, o, d, l, c, i, u, 0, f);
  return n.makeTensorInfo(o, m.dtype, m.values);
}
const KU = {
  kernelName: zd,
  backendName: "cpu",
  kernelFunc: qU
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XU(t, e) {
  let n = 0, r = t.length, a = 0;
  for (; n < r; )
    a = Math.floor((n + r) / 2), t[a] < e ? n = a + 1 : r = a;
  return r;
}
function YU(t, e) {
  let n = 0, r = t.length, a = 0;
  for (; n < r; )
    a = Math.floor((n + r) / 2), t[a] <= e ? n = a + 1 : r = a;
  return r;
}
function ZU(t, e, n, r, a, s) {
  const o = tn("int32", n * a);
  for (let i = 0; i < n; ++i) {
    const c = t.slice(i * r, (i + 1) * r), l = i * a;
    for (let u = 0; u < a; ++u)
      o[l + u] = s === "left" ? XU(c, e[u + l]) : YU(c, e[u + l]);
  }
  return o;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JU(t) {
  const { inputs: e, backend: n, attrs: r } = t, { sortedSequence: a, values: s } = e, { side: o } = r, i = n.data.get(a.dataId).values, c = n.data.get(s.dataId).values, l = ZU(i, c, a.shape[0], a.shape[1], s.shape[1], o);
  return n.makeTensorInfo(s.shape, "int32", l);
}
const QU = {
  kernelName: Hd,
  backendName: "cpu",
  kernelFunc: JU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eG(t) {
  const { inputs: e, backend: n } = t, { condition: r, t: a, e: s } = e;
  xe([r, a, s], "select");
  const o = r.shape.length, i = n.data.get(r.dataId).values, c = n.data.get(a.dataId).values, l = n.data.get(s.dataId).values, u = Lo(a.dtype, s.dtype), d = In(Y(a.shape), u);
  let f = 0;
  const p = o === 0 || o > 1 || a.shape.length === 1 ? 1 : Y(a.shape.slice(1));
  for (let h = 0; h < i.length; h++)
    for (let m = 0; m < p; m++)
      i[h] === 1 ? d[f++] = c[h] : d[f++] = l[h];
  return n.makeTensorInfo(a.shape, u, d);
}
const tG = {
  kernelName: Rm,
  backendName: "cpu",
  kernelFunc: eG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nG = pM, rG = hM, aG = vt(jd, (t) => t >= 0 ? rG * t : nG * (Math.exp(t) - 1)), sG = {
  kernelName: jd,
  backendName: "cpu",
  kernelFunc: aG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oG = vt(qd, (t) => t < 0 ? -1 : t > 0 ? 1 : 0), iG = {
  kernelName: qd,
  backendName: "cpu",
  kernelFunc: oG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uG = vt(Ud, (t) => Math.sin(t)), cG = {
  kernelName: Ud,
  backendName: "cpu",
  kernelFunc: uG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lG = vt(Gd, (t) => Math.sinh(t)), dG = {
  kernelName: Gd,
  backendName: "cpu",
  kernelFunc: lG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fG = 11920928955078125e-23, Cv = Math.log(fG) + 2, pG = vt(Xd, (t) => {
  const e = t > -Cv, n = t < Cv, r = Math.exp(t);
  let a;
  return n ? a = r : e ? a = t : a = Math.log(1 + r), a;
}), hG = {
  kernelName: Xd,
  backendName: "cpu",
  kernelFunc: pG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { blockShape: s, paddings: o } = r;
  xe([a], "spaceToBatchND");
  const i = Y(s), c = [[0, 0]];
  c.push(...o);
  for (let E = 1 + s.length; E < a.shape.length; ++E)
    c.push([0, 0]);
  const l = R_.kernelFunc({
    inputs: { x: a },
    backend: n,
    attrs: { paddings: c, constantValue: 0 }
  }), u = wf(l.shape, s, i, !1), d = Sf(u.length, s.length, !1), f = _f(l.shape, s, i, !1), m = Rt({ inputs: { x: l }, backend: n, attrs: { shape: u } }), b = Gn({ inputs: { x: m }, backend: n, attrs: { perm: d } }), I = Rt({ inputs: { x: b }, backend: n, attrs: { shape: f } });
  return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(b), I;
}
const gG = {
  kernelName: Dm,
  backendName: "cpu",
  kernelFunc: mG
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yG(t) {
  const { inputs: e, backend: n } = t, { indices: r, values: a, denseShape: s, defaultValue: o } = e;
  if (s.shape.length !== 1)
    throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);
  if (r.shape.length !== 2)
    throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);
  if (a.shape.length !== 1)
    throw new Error(`Values must be a vector, saw:
        ${a.shape}`);
  if (o.shape.length !== 0)
    throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);
  const i = n.data.get(r.dataId).values, c = n.data.get(a.dataId).values, l = n.data.get(s.dataId).values, u = n.data.get(o.dataId).values[0], [d, f, p, h, m] = K8(i, r.shape, r.dtype, c, a.dtype, l, u);
  return [
    n.makeTensorInfo(f, r.dtype, d),
    n.makeTensorInfo([f[0]], a.dtype, p),
    n.makeTensorInfo([h.length], "bool", new Uint8Array(h.map((g) => Number(g)))),
    n.makeTensorInfo([m.length], r.dtype, new Int32Array(m))
  ];
}
const vG = {
  kernelName: Fm,
  backendName: "cpu",
  kernelFunc: yG
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bG(t) {
  const { inputs: e, backend: n } = t, { inputIndices: r, inputShape: a, newShape: s } = e;
  if (r.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);
  if (a.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);
  if (s.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
  const o = Array.from(n.data.get(a.dataId).values), i = n.data.get(r.dataId).values, c = Array.from(n.data.get(s.dataId).values), [l, u, d] = X8(i, r.shape, r.dtype, o, c);
  return [
    n.makeTensorInfo(u, r.dtype, l),
    n.makeTensorInfo([d.length], s.dtype, new Int32Array(d))
  ];
}
const wG = {
  kernelName: Qd,
  backendName: "cpu",
  kernelFunc: bG
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SG(t) {
  const { inputs: e, backend: n } = t, { data: r, indices: a, segmentIds: s } = e;
  if (r.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (a.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);
  if (s.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);
  if (a.shape[0] !== s.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  const o = n.data.get(r.dataId).values, i = n.data.get(a.dataId).values, c = n.data.get(s.dataId).values, [l, u] = B2(o, r.shape, r.dtype, i, c, !0);
  return n.makeTensorInfo(u, r.dtype, l);
}
const _G = {
  kernelName: Mm,
  backendName: "cpu",
  kernelFunc: SG
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xG(t) {
  const { inputs: e, backend: n } = t, { data: r, indices: a, segmentIds: s } = e;
  if (r.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (a.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);
  if (s.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);
  if (a.shape[0] !== s.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  const o = n.data.get(r.dataId).values, i = n.data.get(a.dataId).values, c = n.data.get(s.dataId).values, [l, u] = B2(o, r.shape, r.dtype, i, c);
  return n.makeTensorInfo(u, r.dtype, l);
}
const IG = {
  kernelName: Pm,
  backendName: "cpu",
  kernelFunc: xG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { sparseIndices: a, sparseValues: s, defaultValue: o } = e, { outputShape: i } = r, { sliceRank: c, numUpdates: l, sliceSize: u, strides: d, outputSize: f } = Vo(s, a, i), p = !1, h = n.bufferSync(a);
  let m;
  switch (s.dtype) {
    case "bool": {
      const g = n.bufferSync(s), v = !!n.data.get(o.dataId).values[0];
      m = go(h, g, i, f, u, l, c, d, v, p);
      break;
    }
    case "float32": {
      const g = n.bufferSync(s), v = n.data.get(o.dataId).values[0];
      m = go(h, g, i, f, u, l, c, d, v, p);
      break;
    }
    case "int32": {
      const g = n.bufferSync(s), v = n.data.get(o.dataId).values[0];
      m = go(h, g, i, f, u, l, c, d, v, p);
      break;
    }
    case "string": {
      const g = n.bufferSync(s), v = ru(n.data.get(o.dataId).values[0]);
      m = go(h, g, i, f, u, l, c, d, v, p);
      break;
    }
    default:
      throw new Error(`Unsupported type ${s.dtype}`);
  }
  return n.makeTensorInfo(i, m.dtype, m.values);
}
const EG = {
  kernelName: ef,
  backendName: "cpu",
  kernelFunc: kG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { numOrSizeSplits: s, axis: o } = r, i = Vt(o, a.shape)[0], c = Qw(a, s, i), l = new Array(a.shape.length).fill(0), u = a.shape.slice();
  return c.map((d) => {
    const f = [...u];
    f[i] = d;
    const p = Ws({ inputs: { x: a }, backend: n, attrs: { begin: l, size: f } });
    return l[i] += d, p;
  });
}
const CG = {
  kernelName: Om,
  backendName: "cpu",
  kernelFunc: TG
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NG = {
  kernelName: f1,
  backendName: "cpu",
  kernelFunc: ({ inputs: t, backend: e }) => {
    const { x: n } = t, r = e;
    xe(n, "square");
    const a = r.data.get(n.dataId).values, s = new Float32Array(a.length);
    for (let i = 0; i < a.length; ++i) {
      const c = a[i];
      s[i] = c * c;
    }
    return { dataId: r.write(s, n.shape, n.dtype), shape: n.shape, dtype: n.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AG = vt(Nu, (t, e) => {
  const n = e;
  return isNaN(t) ? NaN : t > 0 ? 1 : n.alpha;
}), RG = {
  kernelName: Nu,
  backendName: "cpu",
  kernelFunc: AG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $G(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { begin: s, end: o, strides: i, beginMask: c, endMask: l, ellipsisMask: u, newAxisMask: d, shrinkAxisMask: f } = r;
  xe(a, "stridedSlice");
  const { finalShapeSparse: p, finalShape: h, isIdentity: m, sliceDim0: g, isSimpleSlice: v, begin: b, end: w, strides: S } = qw(a.shape, s, o, i, c, l, u, d, f);
  let I;
  if (m)
    I = Rt({ inputs: { x: a }, backend: n, attrs: { shape: h } });
  else if (g || v) {
    A(a.shape.length >= 1, () => `Input must have rank at least 1, got: ${a.shape.length}`);
    const E = Hw(b, w, S), T = Ws({ inputs: { x: a }, backend: n, attrs: { begin: b, size: E } });
    I = Rt({ inputs: { x: T }, backend: n, attrs: { shape: h } }), n.disposeIntermediateTensorInfo(T);
  } else {
    const E = n.bufferSync(a), T = aB(p, E, S, b);
    I = n.makeTensorInfo(h, T.dtype, T.values);
  }
  return I;
}
const DG = {
  kernelName: nf,
  backendName: "cpu",
  kernelFunc: $G
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { separator: a, nGramWidths: s, leftPad: o, rightPad: i, padWidth: c, preserveShortSequences: l } = r, { data: u, dataSplits: d } = e, f = n.data.get(u.dataId).values, p = n.data.get(d.dataId).values, [h, m] = L2(f, p, a, s, o, i, c, l);
  return [
    n.makeTensorInfo([h.length], "string", h),
    n.makeTensorInfo(d.shape, "int32", m)
  ];
}
const FG = {
  kernelName: Lm,
  backendName: "cpu",
  kernelFunc: OG
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { skipEmpty: a } = r, { input: s, delimiter: o } = e;
  if (s.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (s.shape.length !== 1)
    throw new Error(`Input must be a vector, got shape: ${s.shape}`);
  if (o.shape.length !== 0)
    throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);
  const i = n.data.get(s.dataId).values, c = n.data.get(o.dataId).values[0], [l, u, d] = W2(i, c, a), f = u.length;
  return [
    n.makeTensorInfo([f, 2], "int32", l),
    n.makeTensorInfo([f], "string", u),
    n.makeTensorInfo([2], "int32", new Int32Array(d))
  ];
}
const PG = {
  kernelName: Wm,
  backendName: "cpu",
  kernelFunc: MG
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { numBuckets: a } = r, { input: s } = e;
  if (s.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (a <= 0)
    throw new Error("Number of buckets must be at least 1");
  const o = n.data.get(s.dataId).values, i = z2(o, a);
  return n.makeTensorInfo(s.shape, "int32", i);
}
const LG = {
  kernelName: zm,
  backendName: "cpu",
  kernelFunc: BG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WG = vt(af, (t) => Math.tan(t)), zG = {
  kernelName: af,
  backendName: "cpu",
  kernelFunc: WG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const VG = vt(sf, (t) => Math.tanh(t)), HG = {
  kernelName: sf,
  backendName: "cpu",
  kernelFunc: VG
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jG(t) {
  const { inputs: e, backend: n } = t, { tensor: r, indices: a, updates: s } = e, { sliceRank: o, numUpdates: i, sliceSize: c, strides: l, outputSize: u } = Vo(s, a, r.shape), d = !1, f = n.bufferSync(a), p = n.bufferSync(s), h = n.bufferSync(r), m = go(f, p, r.shape, u, c, i, o, l, h, d);
  return n.makeTensorInfo(r.shape, m.dtype, m.values);
}
const UG = {
  kernelName: Vd,
  backendName: "cpu",
  kernelFunc: jG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { reps: s } = r;
  xe(a, "tile");
  const o = lB(n.bufferSync(a), s);
  return n.makeTensorInfo(o.shape, o.dtype, o.values);
}
const qG = {
  kernelName: Cu,
  backendName: "cpu",
  kernelFunc: GG
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KG(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a } = e, { k: s, sorted: o } = r;
  xe(a, "topk");
  const i = n.data.get(a.dataId).values, [c, l] = dB(i, a.shape, a.dtype, s, o);
  return [
    n.makeTensorInfo(c.shape, c.dtype, c.values),
    n.makeTensorInfo(l.shape, l.dtype, l.values)
  ];
}
const XG = {
  kernelName: of,
  backendName: "cpu",
  kernelFunc: KG
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YG(t) {
  const { inputs: e, attrs: n, backend: r } = t, { image: a, transforms: s } = e, { interpolation: o, fillMode: i, fillValue: c, outputShape: l } = n, [u, d, f, p] = a.shape, [h, m] = l ?? [d, f], g = [u, h, m, p], v = Ie(a.shape), b = v[0], w = v[1], S = v[2], I = Ie(g), E = I[0], T = I[1], R = I[2], $ = Dn(a.dtype, Y(g));
  $.fill(c);
  const D = r.data.get(a.dataId).values, M = r.data.get(s.dataId).values;
  for (let F = 0; F < u; ++F) {
    const V = s.shape[0] === 1 ? M : M.subarray(F * 8, F * 8 + 8);
    for (let H = 0; H < h; ++H)
      for (let U = 0; U < m; ++U)
        for (let Z = 0; Z < p; ++Z) {
          let q;
          const X = V[6] * U + V[7] * H + 1;
          if (X === 0)
            continue;
          const se = (V[0] * U + V[1] * H + V[2]) / X, te = (V[3] * U + V[4] * H + V[5]) / X, ue = Nv(se, f, i), ee = Nv(te, d, i);
          switch (o) {
            case "nearest":
              q = nq(D, d, f, b, w, S, F, ee, ue, Z, c);
              break;
            case "bilinear":
              q = rq(D, d, f, b, w, S, F, ee, ue, Z, c);
              break;
            default:
              throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`);
          }
          const ne = F * E + H * T + U * R + Z;
          $[ne] = q;
        }
    return r.makeTensorInfo(g, a.dtype, $);
  }
  return { dataId: r.write($, g, a.dtype), shape: a.shape, dtype: a.dtype };
}
const ZG = {
  kernelName: uf,
  backendName: "cpu",
  kernelFunc: YG
};
function Nv(t, e, n) {
  switch (n) {
    case "reflect":
      return JG(t, e);
    case "wrap":
      return QG(t, e);
    case "nearest":
      return tq(t, e);
    case "constant":
    default:
      return eq(t);
  }
}
function JG(t, e) {
  let n = t;
  if (n < 0)
    if (e <= 1)
      n = 0;
    else {
      const r = 2 * e;
      n < r && (n = r * Math.trunc(-n / r) + n), n = n < -e ? n + r : -n - 1;
    }
  else if (n > e - 1)
    if (e <= 1)
      n = 0;
    else {
      const r = 2 * e;
      n -= r * Math.trunc(n / r), n >= e && (n = r - n - 1);
    }
  return am(0, n, e - 1);
}
function QG(t, e) {
  let n = t;
  if (n < 0)
    if (e <= 1)
      n = 0;
    else {
      const r = e - 1;
      n += e * (Math.trunc(-n / r) + 1);
    }
  else if (n > e - 1)
    if (e <= 1)
      n = 0;
    else {
      const r = e - 1;
      n -= e * Math.trunc(n / r);
    }
  return am(0, n, e - 1);
}
function eq(t, e) {
  return t;
}
function tq(t, e) {
  return am(0, t, e - 1);
}
function Mi(t, e, n, r, a, s, o, i, c, l, u) {
  const d = o * r + i * a + c * s + l;
  return 0 <= i && i < e && 0 <= c && c < n ? t[d] : u;
}
function nq(t, e, n, r, a, s, o, i, c, l, u) {
  const d = Math.round(i), f = Math.round(c);
  return Mi(t, e, n, r, a, s, o, d, f, l, u);
}
function rq(t, e, n, r, a, s, o, i, c, l, u) {
  const d = Math.floor(i), f = Math.floor(c), p = d + 1, h = f + 1, m = (h - c) * Mi(t, e, n, r, a, s, o, d, f, l, u) + (c - f) * Mi(t, e, n, r, a, s, o, d, h, l, u), g = (h - c) * Mi(t, e, n, r, a, s, o, p, f, l, u) + (c - f) * Mi(t, e, n, r, a, s, o, p, h, l, u);
  return (p - i) * m + (i - d) * g;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aq(t) {
  const { inputs: e, attrs: n, backend: r } = t, { axis: a } = n, { x: s } = e;
  xe(s, "unique");
  const o = r.data.get(s.dataId).values, { outputValues: i, outputShape: c, indices: l } = H2(o, a, s.shape, s.dtype);
  return [
    r.makeTensorInfo(c, s.dtype, i),
    r.makeTensorInfo([l.length], "int32", l)
  ];
}
const sq = {
  kernelName: Vm,
  backendName: "cpu",
  kernelFunc: aq
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oq(t) {
  const { inputs: e, backend: n, attrs: r } = t, { value: a } = e;
  let { axis: s } = r;
  s < 0 && (s += a.shape.length);
  const o = a.shape.length, i = a.shape[s], c = new Array(o - 1);
  let l = 0;
  for (let p = 0; p < o; p++)
    p !== s && (c[l++] = a.shape[p]);
  const u = new Array(o).fill(0), d = a.shape.slice();
  d[s] = 1;
  const f = new Array(i);
  for (let p = 0; p < f.length; p++) {
    u[s] = p;
    const h = Ws({ inputs: { x: a }, backend: n, attrs: { begin: u, size: d } });
    f[p] = Rt({ inputs: { x: h }, backend: n, attrs: { shape: c } }), n.disposeIntermediateTensorInfo(h);
  }
  return f;
}
const iq = {
  kernelName: Hm,
  backendName: "cpu",
  kernelFunc: oq
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uq(t) {
  const { inputs: e, backend: n, attrs: r } = t, { x: a, segmentIds: s } = e, { numSegments: o } = r;
  xe(a, "unsortedSegmentSum");
  const i = a.shape.length, c = s.shape.length, l = [], u = [], d = i - c;
  let f = s;
  for (let h = 0; h < d; ++h) {
    const m = Qc({ inputs: { input: f }, backend: n, attrs: { dim: h + 1 } });
    f = m, u.push(m);
  }
  for (let h = 0; h < o; ++h) {
    const m = Gm(h, "int32"), g = n.makeTensorInfo([], "int32", m), v = $2({ inputs: { a: g, b: f }, backend: n }), b = qa({ inputs: { x: v }, backend: n, attrs: { dtype: "float32" } }), w = If({ inputs: { a: b, b: a }, backend: n }), S = Du({ inputs: { x: w }, backend: n, attrs: { axis: 0, keepDims: !1 } });
    l.push(S), u.push(g), u.push(v), u.push(b), u.push(w), u.push(S);
  }
  const p = A_({ inputs: l, backend: n, attrs: { axis: 0 } });
  return u.forEach((h) => n.disposeIntermediateTensorInfo(h)), p;
}
const cq = {
  kernelName: p1,
  backendName: "cpu",
  kernelFunc: uq
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lq = [
  aV,
  _P,
  oV,
  uV,
  AP,
  lV,
  fV,
  hV,
  gV,
  vV,
  wV,
  _V,
  IV,
  TV,
  NV,
  $V,
  OV,
  MV,
  BV,
  nV,
  WV,
  VV,
  jV,
  OP,
  GV,
  TP,
  PP,
  KV,
  xP,
  YV,
  JV,
  QV,
  tH,
  rH,
  sH,
  iH,
  cH,
  dH,
  pH,
  mH,
  yH,
  bH,
  SH,
  xH,
  IH,
  EH,
  CH,
  AH,
  RH,
  $H,
  DH,
  FH,
  BH,
  Xz,
  WH,
  LP,
  KH,
  zP,
  XH,
  jP,
  tj,
  nj,
  aj,
  qP,
  YP,
  oj,
  uj,
  lj,
  fj,
  t8,
  a8,
  IP,
  hj,
  ZV,
  gj,
  vj,
  wj,
  Yz,
  i8,
  l8,
  _j,
  h8,
  Ij,
  Tj,
  Nj,
  $j,
  Oj,
  Mj,
  Pj,
  v8,
  Lj,
  zj,
  Hj,
  Uj,
  qj,
  Xj,
  Zj,
  S8,
  Qj,
  nU,
  sU,
  x8,
  E8,
  uU,
  dU,
  hU,
  N8,
  gU,
  vU,
  bU,
  R_,
  xU,
  Jz,
  D8,
  kU,
  TU,
  NU,
  RU,
  kP,
  _h,
  DU,
  Qz,
  eV,
  tV,
  FU,
  PU,
  LU,
  zU,
  HU,
  jU,
  GU,
  U8,
  KU,
  QU,
  tG,
  sG,
  G8,
  iG,
  cG,
  dG,
  q8,
  rU,
  hG,
  gG,
  vG,
  wG,
  _G,
  IG,
  EG,
  CG,
  Z8,
  NG,
  eB,
  rB,
  RG,
  DG,
  FG,
  PG,
  LG,
  cB,
  MH,
  zG,
  HG,
  UG,
  qG,
  XG,
  ZG,
  A8,
  sq,
  iq,
  cq,
  yU
];
for (const t of lq)
  h1(t);
function dq() {
  try {
    return !!window.WebAssembly && (!!window.WebAssembly.compile || !!window.WebAssembly.compileStreaming);
  } catch {
    return !1;
  }
}
var fq = "1.0.2", pq = "https://cdn.liveness.rekognition.amazonaws.com/face-detection/tensorflow-models/blazeface/".concat(fq, "/model/model.json"), hq = "https://cdn.liveness.rekognition.amazonaws.com/face-detection/tensorflow/tfjs-backend-wasm/".concat(Gz, "/"), mq = (
  /** @class */
  function(t) {
    oI(e, t);
    function e(n, r) {
      var a = t.call(this) || this;
      return a.faceModelUrl = r ?? pq, a.binaryPath = n ?? hq, a;
    }
    return e.prototype.loadModels = function() {
      return ot(this, void 0, void 0, function() {
        var n;
        return tt(this, function(r) {
          switch (r.label) {
            case 0:
              return dq() ? [4, this._loadWebAssemblyBackend()] : [3, 2];
            case 1:
              return r.sent(), [3, 4];
            case 2:
              return [4, this._loadCPUBackend()];
            case 3:
              r.sent(), r.label = 4;
            case 4:
              return r.trys.push([4, 7, , 8]), [4, NC()];
            case 5:
              return r.sent(), n = this, [4, N5(Xc.MediaPipeFaceDetector, {
                runtime: "tfjs",
                detectorModelUrl: this.faceModelUrl
              })];
            case 6:
              return n._model = r.sent(), [3, 8];
            case 7:
              throw r.sent(), new Error("There was an error loading the blazeface model. If you are using a custom blazeface model url ensure that it is a fully qualified url that returns a json file.");
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.detectFaces = function(n) {
      return ot(this, void 0, void 0, function() {
        var r, a, s, o, i = this;
        return tt(this, function(c) {
          switch (c.label) {
            case 0:
              return r = !0, [4, this._model.estimateFaces(n, {
                flipHorizontal: r
              })];
            case 1:
              return a = c.sent(), s = Date.now(), o = a.map(function(l) {
                var u = l.box, d = l.keypoints, f = u.xMin, p = u.yMin, h = u.width, m = u.height, g = i._getCoordinate(d, "rightEye"), v = i._getCoordinate(d, "leftEye"), b = i._getCoordinate(d, "noseTip"), w = i._getCoordinate(d, "mouthCenter"), S = i._getCoordinate(d, "rightEarTragion"), I = i._getCoordinate(d, "leftEarTragion"), E = [90];
                return {
                  top: p,
                  left: f,
                  width: h,
                  height: m,
                  timestampMs: s,
                  probability: E[0],
                  // probability in reality is [number] but is typed as number | Tensor.1d
                  rightEye: g,
                  leftEye: v,
                  mouth: w,
                  nose: b,
                  rightEar: S,
                  leftEar: I
                };
              }), [2, o];
          }
        });
      });
    }, e.prototype._getCoordinate = function(n, r) {
      var a = n.find(function(s) {
        return s.name === r;
      });
      return [a.x, a.y];
    }, e.prototype._loadWebAssemblyBackend = function() {
      return ot(this, void 0, void 0, function() {
        var n = this;
        return tt(this, function(r) {
          switch (r.label) {
            case 0:
              return r.trys.push([0, 2, , 3]), jz(this.binaryPath), [4, ZI(function() {
                return ot(n, void 0, void 0, function() {
                  var a;
                  return tt(this, function(s) {
                    switch (s.label) {
                      case 0:
                        return [4, tv("wasm")];
                      case 1:
                        if (a = s.sent(), !a)
                          throw new Error("Initialization of backend wasm failed");
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }, [])];
            case 1:
              return r.sent(), this.modelBackend = "wasm", [3, 3];
            case 2:
              throw r.sent(), new Error('There was an error loading the TFJS WASM backend. If you are using a custom WASM path ensure that it ends with "/" and that it is not the full URL as @tensorflow/tfjs-backend-wasm will append the wasm binary file name. Read more: https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/src/backend_wasm.ts#L475.');
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype._loadCPUBackend = function() {
      return ot(this, void 0, void 0, function() {
        return tt(this, function(n) {
          switch (n.label) {
            case 0:
              return [4, tv("cpu")];
            case 1:
              return n.sent(), this.modelBackend = "cpu", [
                2
                /*return*/
              ];
          }
        });
      });
    }, e;
  }(HE)
), gq = (
  /** @class */
  function() {
    function t(e) {
      if (typeof MediaRecorder > "u")
        throw Error("MediaRecorder is not supported by this browser");
      this._stream = e, this._chunks = [], this._recorder = new MediaRecorder(e, { bitsPerSecond: 1e6 }), this._setupCallbacks();
    }
    return t.prototype.getState = function() {
      return this._recorder.state;
    }, t.prototype.start = function(e) {
      this.clearRecordedData(), this.recordingStartApiTimestamp = Date.now(), this._recorder.start(e);
    }, t.prototype.stop = function() {
      return ot(this, void 0, void 0, function() {
        return tt(this, function(e) {
          return this.getState() === "recording" && this._recorder.stop(), [2, this._recorderStopped];
        });
      });
    }, t.prototype.pause = function() {
      this._recorder.pause();
    }, t.prototype.clearRecordedData = function() {
      this._chunks = [];
    }, t.prototype.dispatch = function(e) {
      this._recorder.dispatchEvent(e);
    }, t.prototype.getVideoChunkSize = function() {
      return this._chunks.length;
    }, t.prototype._setupCallbacks = function() {
      var e = this;
      this.videoStream = new ReadableStream({
        start: function(n) {
          e._recorder && (e._recorder.ondataavailable = function(r) {
            r.data && r.data.size > 0 && (e._chunks.length === 0 && (e.firstChunkTimestamp = Date.now()), e._chunks.push(r.data), n.enqueue(r.data));
          }, e._recorder.addEventListener("clientSesssionInfo", function(r) {
            n.enqueue(r.data.clientInfo);
          }), e._recorder.addEventListener("stopVideo", function() {
            n.enqueue("stopVideo");
          }), e._recorder.addEventListener("endStream", function() {
            n.close();
          }), e._recorder.addEventListener("endStreamWithCode", function(r) {
            n.enqueue({
              type: "endStreamWithCode",
              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
              code: r.data.code
            });
          }));
        }
      }), this.recorderStarted = new Promise(function(n) {
        e._recorder.onstart = function() {
          e.recorderStartTimestamp = Date.now(), n();
        };
      }), this._recorderStopped = new Promise(function(n) {
        e._recorder.onstop = function() {
          e.recorderEndTimestamp = Date.now(), n();
        };
      }), this._recorder.onerror = function() {
        e.getState() !== "stopped" && e.stop();
      };
    }, t;
  }()
);
function yq(t) {
  const e = t.signer, n = t.signer, r = t.eventStreamPayloadHandlerProvider({
    ...t,
    messageSigner: n
  });
  return {
    ...t,
    eventSigner: e,
    eventStreamPayloadHandler: r
  };
}
var Av;
(function(t) {
  t.HEADER = "header", t.QUERY = "query";
})(Av || (Av = {}));
var Rv;
(function(t) {
  t.HEADER = "header", t.QUERY = "query";
})(Rv || (Rv = {}));
var hu;
(function(t) {
  t.HTTP = "http", t.HTTPS = "https";
})(hu || (hu = {}));
var tl;
(function(t) {
  t.MD5 = "md5", t.CRC32 = "crc32", t.CRC32C = "crc32c", t.SHA1 = "sha1", t.SHA256 = "sha256";
})(tl || (tl = {}));
var $v;
(function(t) {
  t[t.HEADER = 0] = "HEADER", t[t.TRAILER = 1] = "TRAILER";
})($v || ($v = {}));
const Ih = "__smithy_context";
var Dv;
(function(t) {
  t.PROFILE = "profile", t.SSO_SESSION = "sso-session", t.SERVICES = "services";
})(Dv || (Dv = {}));
var Ov;
(function(t) {
  t.HTTP_0_9 = "http/0.9", t.HTTP_1_0 = "http/1.0", t.TDS_8_0 = "tds/8.0";
})(Ov || (Ov = {}));
let $_ = class D_ {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new D_({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = vq(e.query)), e;
  }
};
function vq(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
const bq = (t) => (e, n) => async (r) => {
  const { request: a } = r;
  return $_.isInstance(a) ? t.eventStreamPayloadHandler.handle(e, r, n) : e(r);
}, wq = {
  tags: ["EVENT_STREAM", "SIGNATURE", "HANDLE"],
  name: "eventStreamHandlingMiddleware",
  relation: "after",
  toMiddleware: "awsAuthMiddleware",
  override: !0
}, Sq = (t) => async (e) => {
  const { request: n } = e;
  return $_.isInstance(n) ? (n.headers = {
    ...n.headers,
    "Content-Type": "application/vnd.amazon.eventstream",
    "x-amz-content-sha256": "STREAMING-AWS4-HMAC-SHA256-EVENTS"
  }, t({
    ...e,
    request: n
  })) : t(e);
}, _q = {
  step: "build",
  tags: ["EVENT_STREAM", "HEADER", "CONTENT_TYPE", "CONTENT_SHA256"],
  name: "eventStreamHeaderMiddleware",
  override: !0
}, xq = (t) => ({
  applyToStack: (e) => {
    e.addRelativeTo(bq(t), wq), e.add(Sq, _q);
  }
});
let Iq = class O_ {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new O_({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = kq(e.query)), e;
  }
};
function kq(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
const Eq = (t) => (e) => async (n) => {
  if (!Iq.isInstance(n.request))
    return e(n);
  const { request: r } = n, { handlerProtocol: a = "" } = t.requestHandler.metadata || {};
  if (a.indexOf("h2") >= 0 && !r.headers[":authority"])
    delete r.headers.host, r.headers[":authority"] = "";
  else if (!r.headers.host) {
    let s = r.hostname;
    r.port != null && (s += `:${r.port}`), r.headers.host = s;
  }
  return e(n);
}, Tq = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: !0
}, Cq = (t) => ({
  applyToStack: (e) => {
    e.add(Eq(t), Tq);
  }
}), Nq = () => (t, e) => async (n) => {
  try {
    const r = await t(n), { clientName: a, commandName: s, logger: o, dynamoDbDocumentClientOptions: i = {} } = e, { overrideInputFilterSensitiveLog: c, overrideOutputFilterSensitiveLog: l } = i, u = c ?? e.inputFilterSensitiveLog, d = l ?? e.outputFilterSensitiveLog, { $metadata: f, ...p } = r.output;
    return o?.info?.({
      clientName: a,
      commandName: s,
      input: u(n.input),
      output: d(p),
      metadata: f
    }), r;
  } catch (r) {
    const { clientName: a, commandName: s, logger: o, dynamoDbDocumentClientOptions: i = {} } = e, { overrideInputFilterSensitiveLog: c } = i, l = c ?? e.inputFilterSensitiveLog;
    throw o?.error?.({
      clientName: a,
      commandName: s,
      input: l(n.input),
      error: r,
      metadata: r.$metadata
    }), r;
  }
}, Aq = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: !0
}, Rq = (t) => ({
  applyToStack: (e) => {
    e.add(Nq(), Aq);
  }
});
let $q = class F_ {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new F_({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = Dq(e.query)), e;
  }
};
function Dq(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
const Fv = "X-Amzn-Trace-Id", Oq = "AWS_LAMBDA_FUNCTION_NAME", Fq = "_X_AMZN_TRACE_ID", Mq = (t) => (e) => async (n) => {
  const { request: r } = n;
  if (!$q.isInstance(r) || t.runtime !== "node" || r.headers.hasOwnProperty(Fv))
    return e(n);
  const a = process.env[Oq], s = process.env[Fq], o = (i) => typeof i == "string" && i.length > 0;
  return o(a) && o(s) && (r.headers[Fv] = s), e({
    ...n,
    request: r
  });
}, Pq = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: !0,
  priority: "low"
}, Bq = (t) => ({
  applyToStack: (e) => {
    e.add(Mq(t), Pq);
  }
}), M_ = (t, e, n) => {
  let r, a, s, o = !1;
  const i = async () => {
    a || (a = t());
    try {
      r = await a, s = !0, o = !1;
    } finally {
      a = void 0;
    }
    return r;
  };
  return e === void 0 ? async (c) => ((!s || c?.forceRefresh) && (r = await i()), r) : async (c) => ((!s || c?.forceRefresh) && (r = await i()), o ? r : n && !n(r) ? (o = !0, r) : (e(r) && await i(), r));
};
var rp = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var kh = function(t, e) {
  return kh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (n[a] = r[a]);
  }, kh(t, e);
};
function Lq(t, e) {
  kh(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Eh = function() {
  return Eh = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Eh.apply(this, arguments);
};
function Wq(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function zq(t, e, n, r) {
  var a = arguments.length, s = a < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var i = t.length - 1; i >= 0; i--)
      (o = t[i]) && (s = (a < 3 ? o(s) : a > 3 ? o(e, n, s) : o(e, n)) || s);
  return a > 3 && s && Object.defineProperty(e, n, s), s;
}
function Vq(t, e) {
  return function(n, r) {
    e(n, r, t);
  };
}
function Hq(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function jq(t, e, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function i(u) {
      try {
        l(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      u.done ? s(u.value) : a(u.value).then(i, c);
    }
    l((r = r.apply(t, e || [])).next());
  });
}
function Uq(t, e) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, o;
  return o = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function i(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, a && (s = l[0] & 2 ? a.return : l[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, l[1])).done)
          return s;
        switch (a = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return n.label++, { value: l[1], done: !1 };
          case 5:
            n.label++, a = l[1], l = [0];
            continue;
          case 7:
            l = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              n = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              n.label = l[1];
              break;
            }
            if (l[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = l;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(l);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        l = e.call(t, n);
      } catch (u) {
        l = [6, u], a = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function Gq(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}
function qq(t, e) {
  for (var n in t)
    n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n]);
}
function Th(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function P_(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), a, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (i) {
    o = { error: i };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function Kq() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(P_(arguments[e]));
  return t;
}
function Xq() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), a = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, i = s.length; o < i; o++, a++)
      r[a] = s[o];
  return r;
}
function mu(t) {
  return this instanceof mu ? (this.v = t, this) : new mu(t);
}
function Yq(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), a, s = [];
  return a = {}, o("next"), o("throw"), o("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function o(f) {
    r[f] && (a[f] = function(p) {
      return new Promise(function(h, m) {
        s.push([f, p, h, m]) > 1 || i(f, p);
      });
    });
  }
  function i(f, p) {
    try {
      c(r[f](p));
    } catch (h) {
      d(s[0][3], h);
    }
  }
  function c(f) {
    f.value instanceof mu ? Promise.resolve(f.value.v).then(l, u) : d(s[0][2], f);
  }
  function l(f) {
    i("next", f);
  }
  function u(f) {
    i("throw", f);
  }
  function d(f, p) {
    f(p), s.shift(), s.length && i(s[0][0], s[0][1]);
  }
}
function Zq(t) {
  var e, n;
  return e = {}, r("next"), r("throw", function(a) {
    throw a;
  }), r("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function r(a, s) {
    e[a] = t[a] ? function(o) {
      return (n = !n) ? { value: mu(t[a](o)), done: a === "return" } : s ? s(o) : o;
    } : s;
  }
}
function Jq(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Th == "function" ? Th(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = t[s] && function(o) {
      return new Promise(function(i, c) {
        o = t[s](o), a(i, c, o.done, o.value);
      });
    };
  }
  function a(s, o, i, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: i });
    }, o);
  }
}
function Qq(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function eK(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return e.default = t, e;
}
function tK(t) {
  return t && t.__esModule ? t : { default: t };
}
function nK(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function rK(t, e, n) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, n), n;
}
const aK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return Eh;
  },
  __asyncDelegator: Zq,
  __asyncGenerator: Yq,
  __asyncValues: Jq,
  __await: mu,
  __awaiter: jq,
  __classPrivateFieldGet: nK,
  __classPrivateFieldSet: rK,
  __createBinding: Gq,
  __decorate: zq,
  __exportStar: qq,
  __extends: Lq,
  __generator: Uq,
  __importDefault: tK,
  __importStar: eK,
  __makeTemplateObject: Qq,
  __metadata: Hq,
  __param: Vq,
  __read: P_,
  __rest: Wq,
  __spread: Kq,
  __spreadArrays: Xq,
  __values: Th
}, Symbol.toStringTag, { value: "Module" })), B_ = /* @__PURE__ */ _a(aK);
var yi = {}, Mv;
function sK() {
  if (Mv)
    return yi;
  Mv = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.AwsCrc32 = void 0;
  var t = B_, e = xu(), n = L_(), r = (
    /** @class */
    function() {
      function a() {
        this.crc32 = new n.Crc32();
      }
      return a.prototype.update = function(s) {
        (0, e.isEmptyData)(s) || this.crc32.update((0, e.convertToBuffer)(s));
      }, a.prototype.digest = function() {
        return t.__awaiter(this, void 0, void 0, function() {
          return t.__generator(this, function(s) {
            return [2, (0, e.numToUint8)(this.crc32.digest())];
          });
        });
      }, a.prototype.reset = function() {
        this.crc32 = new n.Crc32();
      }, a;
    }()
  );
  return yi.AwsCrc32 = r, yi;
}
var Pv;
function L_() {
  return Pv || (Pv = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AwsCrc32 = t.Crc32 = t.crc32 = void 0;
    var e = B_, n = xu();
    function r(c) {
      return new a().update(c).digest();
    }
    t.crc32 = r;
    var a = (
      /** @class */
      function() {
        function c() {
          this.checksum = 4294967295;
        }
        return c.prototype.update = function(l) {
          var u, d;
          try {
            for (var f = e.__values(l), p = f.next(); !p.done; p = f.next()) {
              var h = p.value;
              this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ h) & 255];
            }
          } catch (m) {
            u = { error: m };
          } finally {
            try {
              p && !p.done && (d = f.return) && d.call(f);
            } finally {
              if (u)
                throw u.error;
            }
          }
          return this;
        }, c.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, c;
      }()
    );
    t.Crc32 = a;
    var s = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ], o = (0, n.uint32ArrayFrom)(s), i = sK();
    Object.defineProperty(t, "AwsCrc32", { enumerable: !0, get: function() {
      return i.AwsCrc32;
    } });
  }(rp)), rp;
}
var W_ = L_();
const z_ = {}, Ch = {};
for (let t = 0; t < 256; t++) {
  let e = t.toString(16).toLowerCase();
  e.length === 1 && (e = `0${e}`), z_[t] = e, Ch[e] = t;
}
function V_(t) {
  if (t.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  const e = new Uint8Array(t.length / 2);
  for (let n = 0; n < t.length; n += 2) {
    const r = t.slice(n, n + 2).toLowerCase();
    if (r in Ch)
      e[n / 2] = Ch[r];
    else
      throw new Error(`Cannot decode unrecognized sequence ${r} as hexadecimal`);
  }
  return e;
}
function br(t) {
  let e = "";
  for (let n = 0; n < t.byteLength; n++)
    e += z_[t[n]];
  return e;
}
class Ui {
  constructor(e) {
    if (this.bytes = e, e.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(e) {
    if (e > 9223372036854776e3 || e < -9223372036854776e3)
      throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);
    const n = new Uint8Array(8);
    for (let r = 7, a = Math.abs(Math.round(e)); r > -1 && a > 0; r--, a /= 256)
      n[r] = a;
    return e < 0 && Bv(n), new Ui(n);
  }
  valueOf() {
    const e = this.bytes.slice(0), n = e[0] & 128;
    return n && Bv(e), parseInt(br(e), 16) * (n ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function Bv(t) {
  for (let e = 0; e < 8; e++)
    t[e] ^= 255;
  for (let e = 7; e > -1 && (t[e]++, t[e] === 0); e--)
    ;
}
class H_ {
  constructor(e, n) {
    this.toUtf8 = e, this.fromUtf8 = n;
  }
  format(e) {
    const n = [];
    for (const s of Object.keys(e)) {
      const o = this.fromUtf8(s);
      n.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(e[s]));
    }
    const r = new Uint8Array(n.reduce((s, o) => s + o.byteLength, 0));
    let a = 0;
    for (const s of n)
      r.set(s, a), a += s.byteLength;
    return r;
  }
  formatHeaderValue(e) {
    switch (e.type) {
      case "boolean":
        return Uint8Array.from([e.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, e.value]);
      case "short":
        const n = new DataView(new ArrayBuffer(3));
        return n.setUint8(0, 3), n.setInt16(1, e.value, !1), new Uint8Array(n.buffer);
      case "integer":
        const r = new DataView(new ArrayBuffer(5));
        return r.setUint8(0, 4), r.setInt32(1, e.value, !1), new Uint8Array(r.buffer);
      case "long":
        const a = new Uint8Array(9);
        return a[0] = 5, a.set(e.value.bytes, 1), a;
      case "binary":
        const s = new DataView(new ArrayBuffer(3 + e.value.byteLength));
        s.setUint8(0, 6), s.setUint16(1, e.value.byteLength, !1);
        const o = new Uint8Array(s.buffer);
        return o.set(e.value, 3), o;
      case "string":
        const i = this.fromUtf8(e.value), c = new DataView(new ArrayBuffer(3 + i.byteLength));
        c.setUint8(0, 7), c.setUint16(1, i.byteLength, !1);
        const l = new Uint8Array(c.buffer);
        return l.set(i, 3), l;
      case "timestamp":
        const u = new Uint8Array(9);
        return u[0] = 8, u.set(Ui.fromNumber(e.value.valueOf()).bytes, 1), u;
      case "uuid":
        if (!hK.test(e.value))
          throw new Error(`Invalid UUID received: ${e.value}`);
        const d = new Uint8Array(17);
        return d[0] = 9, d.set(V_(e.value.replace(/\-/g, "")), 1), d;
    }
  }
  parse(e) {
    const n = {};
    let r = 0;
    for (; r < e.byteLength; ) {
      const a = e.getUint8(r++), s = this.toUtf8(new Uint8Array(e.buffer, e.byteOffset + r, a));
      switch (r += a, e.getUint8(r++)) {
        case 0:
          n[s] = {
            type: Wv,
            value: !0
          };
          break;
        case 1:
          n[s] = {
            type: Wv,
            value: !1
          };
          break;
        case 2:
          n[s] = {
            type: oK,
            value: e.getInt8(r++)
          };
          break;
        case 3:
          n[s] = {
            type: iK,
            value: e.getInt16(r, !1)
          }, r += 2;
          break;
        case 4:
          n[s] = {
            type: uK,
            value: e.getInt32(r, !1)
          }, r += 4;
          break;
        case 5:
          n[s] = {
            type: cK,
            value: new Ui(new Uint8Array(e.buffer, e.byteOffset + r, 8))
          }, r += 8;
          break;
        case 6:
          const o = e.getUint16(r, !1);
          r += 2, n[s] = {
            type: lK,
            value: new Uint8Array(e.buffer, e.byteOffset + r, o)
          }, r += o;
          break;
        case 7:
          const i = e.getUint16(r, !1);
          r += 2, n[s] = {
            type: dK,
            value: this.toUtf8(new Uint8Array(e.buffer, e.byteOffset + r, i))
          }, r += i;
          break;
        case 8:
          n[s] = {
            type: fK,
            value: new Date(new Ui(new Uint8Array(e.buffer, e.byteOffset + r, 8)).valueOf())
          }, r += 8;
          break;
        case 9:
          const c = new Uint8Array(e.buffer, e.byteOffset + r, 16);
          r += 16, n[s] = {
            type: pK,
            value: `${br(c.subarray(0, 4))}-${br(c.subarray(4, 6))}-${br(c.subarray(6, 8))}-${br(c.subarray(8, 10))}-${br(c.subarray(10))}`
          };
          break;
        default:
          throw new Error("Unrecognized header type tag");
      }
    }
    return n;
  }
}
var Lv;
(function(t) {
  t[t.boolTrue = 0] = "boolTrue", t[t.boolFalse = 1] = "boolFalse", t[t.byte = 2] = "byte", t[t.short = 3] = "short", t[t.integer = 4] = "integer", t[t.long = 5] = "long", t[t.byteArray = 6] = "byteArray", t[t.string = 7] = "string", t[t.timestamp = 8] = "timestamp", t[t.uuid = 9] = "uuid";
})(Lv || (Lv = {}));
const Wv = "boolean", oK = "byte", iK = "short", uK = "integer", cK = "long", lK = "binary", dK = "string", fK = "timestamp", pK = "uuid", hK = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/, j_ = 4, $a = j_ * 2, vs = 4, mK = $a + vs * 2;
function gK({ byteLength: t, byteOffset: e, buffer: n }) {
  if (t < mK)
    throw new Error("Provided message too short to accommodate event stream message overhead");
  const r = new DataView(n, e, t), a = r.getUint32(0, !1);
  if (t !== a)
    throw new Error("Reported message length does not match received message length");
  const s = r.getUint32(j_, !1), o = r.getUint32($a, !1), i = r.getUint32(t - vs, !1), c = new W_.Crc32().update(new Uint8Array(n, e, $a));
  if (o !== c.digest())
    throw new Error(`The prelude checksum specified in the message (${o}) does not match the calculated CRC32 checksum (${c.digest()})`);
  if (c.update(new Uint8Array(n, e + $a, t - ($a + vs))), i !== c.digest())
    throw new Error(`The message checksum (${c.digest()}) did not match the expected value of ${i}`);
  return {
    headers: new DataView(n, e + $a + vs, s),
    body: new Uint8Array(n, e + $a + vs + s, a - s - ($a + vs + vs))
  };
}
class U_ {
  constructor(e, n) {
    this.headerMarshaller = new H_(e, n), this.messageBuffer = [], this.isEndOfStream = !1;
  }
  feed(e) {
    this.messageBuffer.push(this.decode(e));
  }
  endOfStream() {
    this.isEndOfStream = !0;
  }
  getMessage() {
    const e = this.messageBuffer.pop(), n = this.isEndOfStream;
    return {
      getMessage() {
        return e;
      },
      isEndOfStream() {
        return n;
      }
    };
  }
  getAvailableMessages() {
    const e = this.messageBuffer;
    this.messageBuffer = [];
    const n = this.isEndOfStream;
    return {
      getMessages() {
        return e;
      },
      isEndOfStream() {
        return n;
      }
    };
  }
  encode({ headers: e, body: n }) {
    const r = this.headerMarshaller.format(e), a = r.byteLength + n.byteLength + 16, s = new Uint8Array(a), o = new DataView(s.buffer, s.byteOffset, s.byteLength), i = new W_.Crc32();
    return o.setUint32(0, a, !1), o.setUint32(4, r.byteLength, !1), o.setUint32(8, i.update(s.subarray(0, 8)).digest(), !1), s.set(r, 12), s.set(n, r.byteLength + 12), o.setUint32(a - 4, i.update(s.subarray(8, a - 4)).digest(), !1), s;
  }
  decode(e) {
    const { headers: n, body: r } = gK(e);
    return { headers: this.headerMarshaller.parse(n), body: r };
  }
  formatHeaders(e) {
    return this.headerMarshaller.format(e);
  }
}
class yK {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.inputStream)
      yield this.options.decoder.decode(e);
  }
}
class vK {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.messageStream)
      yield this.options.encoder.encode(e);
    this.options.includeEndFrame && (yield new Uint8Array(0));
  }
}
class bK {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.messageStream) {
      const n = await this.options.deserializer(e);
      n !== void 0 && (yield n);
    }
  }
}
class wK {
  constructor(e) {
    this.options = e;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const e of this.options.inputStream)
      yield this.options.serializer(e);
  }
}
const SK = (t) => t[Ih] || (t[Ih] = {}), Br = (t) => {
  if (typeof t == "function")
    return t;
  const e = Promise.resolve(t);
  return () => e;
}, _K = "X-Amz-Algorithm", xK = "X-Amz-Credential", G_ = "X-Amz-Date", IK = "X-Amz-SignedHeaders", kK = "X-Amz-Expires", q_ = "X-Amz-Signature", K_ = "X-Amz-Security-Token", X_ = "authorization", Y_ = G_.toLowerCase(), EK = "date", TK = [X_, Y_, EK], CK = q_.toLowerCase(), Nh = "x-amz-content-sha256", NK = K_.toLowerCase(), AK = {
  authorization: !0,
  "cache-control": !0,
  connection: !0,
  expect: !0,
  from: !0,
  "keep-alive": !0,
  "max-forwards": !0,
  pragma: !0,
  referer: !0,
  te: !0,
  trailer: !0,
  "transfer-encoding": !0,
  upgrade: !0,
  "user-agent": !0,
  "x-amzn-trace-id": !0
}, RK = /^proxy-/, $K = /^sec-/, ap = "AWS4-HMAC-SHA256", DK = "AWS4-HMAC-SHA256-PAYLOAD", OK = "UNSIGNED-PAYLOAD", FK = 50, Z_ = "aws4_request", MK = 60 * 60 * 24 * 7, cc = {}, sp = [], op = (t, e, n) => `${t}/${e}/${n}/${Z_}`, PK = async (t, e, n, r, a) => {
  const s = await zv(t, e.secretAccessKey, e.accessKeyId), o = `${n}:${r}:${a}:${br(s)}:${e.sessionToken}`;
  if (o in cc)
    return cc[o];
  for (sp.push(o); sp.length > FK; )
    delete cc[sp.shift()];
  let i = `AWS4${e.secretAccessKey}`;
  for (const c of [n, r, a, Z_])
    i = await zv(t, i, c);
  return cc[o] = i;
}, zv = (t, e, n) => {
  const r = new t(e);
  return r.update(Bi(n)), r.digest();
}, Vv = ({ headers: t }, e, n) => {
  const r = {};
  for (const a of Object.keys(t).sort()) {
    if (t[a] == null)
      continue;
    const s = a.toLowerCase();
    (s in AK || e?.has(s) || RK.test(s) || $K.test(s)) && (!n || n && !n.has(s)) || (r[s] = t[a].trim().replace(/\s+/g, " "));
  }
  return r;
}, Es = (t) => encodeURIComponent(t).replace(/[!'()*]/g, BK), BK = (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`, LK = ({ query: t = {} }) => {
  const e = [], n = {};
  for (const r of Object.keys(t).sort()) {
    if (r.toLowerCase() === CK)
      continue;
    e.push(r);
    const a = t[r];
    typeof a == "string" ? n[r] = `${Es(r)}=${Es(a)}` : Array.isArray(a) && (n[r] = a.slice(0).reduce((s, o) => s.concat([`${Es(r)}=${Es(o)}`]), []).sort().join("&"));
  }
  return e.map((r) => n[r]).filter((r) => r).join("&");
}, WK = (t) => typeof ArrayBuffer == "function" && t instanceof ArrayBuffer || Object.prototype.toString.call(t) === "[object ArrayBuffer]", ip = async ({ headers: t, body: e }, n) => {
  for (const r of Object.keys(t))
    if (r.toLowerCase() === Nh)
      return t[r];
  if (e == null)
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  if (typeof e == "string" || ArrayBuffer.isView(e) || WK(e)) {
    const r = new n();
    return r.update(Bi(e)), br(await r.digest());
  }
  return OK;
}, zK = (t, e) => {
  t = t.toLowerCase();
  for (const n of Object.keys(e))
    if (t === n.toLowerCase())
      return !0;
  return !1;
}, J_ = ({ headers: t, query: e, ...n }) => ({
  ...n,
  headers: { ...t },
  query: e ? VK(e) : void 0
}), VK = (t) => Object.keys(t).reduce((e, n) => {
  const r = t[n];
  return {
    ...e,
    [n]: Array.isArray(r) ? [...r] : r
  };
}, {}), HK = (t, e = {}) => {
  const { headers: n, query: r = {} } = typeof t.clone == "function" ? t.clone() : J_(t);
  for (const a of Object.keys(n)) {
    const s = a.toLowerCase();
    s.slice(0, 6) === "x-amz-" && !e.unhoistableHeaders?.has(s) && (r[a] = n[a], delete n[a]);
  }
  return {
    ...t,
    headers: n,
    query: r
  };
}, Hv = (t) => {
  t = typeof t.clone == "function" ? t.clone() : J_(t);
  for (const e of Object.keys(t.headers))
    TK.indexOf(e.toLowerCase()) > -1 && delete t.headers[e];
  return t;
}, jK = (t) => UK(t).toISOString().replace(/\.\d{3}Z$/, "Z"), UK = (t) => typeof t == "number" ? new Date(t * 1e3) : typeof t == "string" ? Number(t) ? new Date(Number(t) * 1e3) : new Date(t) : t;
class jv {
  constructor({ applyChecksum: e, credentials: n, region: r, service: a, sha256: s, uriEscapePath: o = !0 }) {
    this.headerMarshaller = new H_(qh, _u), this.service = a, this.sha256 = s, this.uriEscapePath = o, this.applyChecksum = typeof e == "boolean" ? e : !0, this.regionProvider = Br(r), this.credentialProvider = Br(n);
  }
  async presign(e, n = {}) {
    const { signingDate: r = /* @__PURE__ */ new Date(), expiresIn: a = 3600, unsignableHeaders: s, unhoistableHeaders: o, signableHeaders: i, signingRegion: c, signingService: l } = n, u = await this.credentialProvider();
    this.validateResolvedCredentials(u);
    const d = c ?? await this.regionProvider(), { longDate: f, shortDate: p } = lc(r);
    if (a > MK)
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    const h = op(p, d, l ?? this.service), m = HK(Hv(e), { unhoistableHeaders: o });
    u.sessionToken && (m.query[K_] = u.sessionToken), m.query[_K] = ap, m.query[xK] = `${u.accessKeyId}/${h}`, m.query[G_] = f, m.query[kK] = a.toString(10);
    const g = Vv(m, s, i);
    return m.query[IK] = Uv(g), m.query[q_] = await this.getSignature(f, h, this.getSigningKey(u, d, p, l), this.createCanonicalRequest(m, g, await ip(e, this.sha256))), m;
  }
  async sign(e, n) {
    return typeof e == "string" ? this.signString(e, n) : e.headers && e.payload ? this.signEvent(e, n) : e.message ? this.signMessage(e, n) : this.signRequest(e, n);
  }
  async signEvent({ headers: e, payload: n }, { signingDate: r = /* @__PURE__ */ new Date(), priorSignature: a, signingRegion: s, signingService: o }) {
    const i = s ?? await this.regionProvider(), { shortDate: c, longDate: l } = lc(r), u = op(c, i, o ?? this.service), d = await ip({ headers: {}, body: n }, this.sha256), f = new this.sha256();
    f.update(e);
    const p = br(await f.digest()), h = [
      DK,
      l,
      u,
      a,
      p,
      d
    ].join(`
`);
    return this.signString(h, { signingDate: r, signingRegion: i, signingService: o });
  }
  async signMessage(e, { signingDate: n = /* @__PURE__ */ new Date(), signingRegion: r, signingService: a }) {
    return this.signEvent({
      headers: this.headerMarshaller.format(e.message.headers),
      payload: e.message.body
    }, {
      signingDate: n,
      signingRegion: r,
      signingService: a,
      priorSignature: e.priorSignature
    }).then((o) => ({ message: e.message, signature: o }));
  }
  async signString(e, { signingDate: n = /* @__PURE__ */ new Date(), signingRegion: r, signingService: a } = {}) {
    const s = await this.credentialProvider();
    this.validateResolvedCredentials(s);
    const o = r ?? await this.regionProvider(), { shortDate: i } = lc(n), c = new this.sha256(await this.getSigningKey(s, o, i, a));
    return c.update(Bi(e)), br(await c.digest());
  }
  async signRequest(e, { signingDate: n = /* @__PURE__ */ new Date(), signableHeaders: r, unsignableHeaders: a, signingRegion: s, signingService: o } = {}) {
    const i = await this.credentialProvider();
    this.validateResolvedCredentials(i);
    const c = s ?? await this.regionProvider(), l = Hv(e), { longDate: u, shortDate: d } = lc(n), f = op(d, c, o ?? this.service);
    l.headers[Y_] = u, i.sessionToken && (l.headers[NK] = i.sessionToken);
    const p = await ip(l, this.sha256);
    !zK(Nh, l.headers) && this.applyChecksum && (l.headers[Nh] = p);
    const h = Vv(l, a, r), m = await this.getSignature(u, f, this.getSigningKey(i, c, d, o), this.createCanonicalRequest(l, h, p));
    return l.headers[X_] = `${ap} Credential=${i.accessKeyId}/${f}, SignedHeaders=${Uv(h)}, Signature=${m}`, l;
  }
  createCanonicalRequest(e, n, r) {
    const a = Object.keys(n).sort();
    return `${e.method}
${this.getCanonicalPath(e)}
${LK(e)}
${a.map((s) => `${s}:${n[s]}`).join(`
`)}

${a.join(";")}
${r}`;
  }
  async createStringToSign(e, n, r) {
    const a = new this.sha256();
    a.update(Bi(r));
    const s = await a.digest();
    return `${ap}
${e}
${n}
${br(s)}`;
  }
  getCanonicalPath({ path: e }) {
    if (this.uriEscapePath) {
      const n = [];
      for (const s of e.split("/"))
        s?.length !== 0 && s !== "." && (s === ".." ? n.pop() : n.push(s));
      const r = `${e?.startsWith("/") ? "/" : ""}${n.join("/")}${n.length > 0 && e?.endsWith("/") ? "/" : ""}`;
      return encodeURIComponent(r).replace(/%2F/g, "/");
    }
    return e;
  }
  async getSignature(e, n, r, a) {
    const s = await this.createStringToSign(e, n, a), o = new this.sha256(await r);
    return o.update(Bi(s)), br(await o.digest());
  }
  getSigningKey(e, n, r, a) {
    return PK(this.sha256, e, r, n, a || this.service);
  }
  validateResolvedCredentials(e) {
    if (typeof e != "object" || typeof e.accessKeyId != "string" || typeof e.secretAccessKey != "string")
      throw new Error("Resolved credential object is not valid");
  }
}
const lc = (t) => {
  const e = jK(t).replace(/[\-:]/g, "");
  return {
    longDate: e,
    shortDate: e.slice(0, 8)
  };
}, Uv = (t) => Object.keys(t).sort().join(";"), GK = 3e5, qK = (t) => {
  const e = t.credentials ? KK(t.credentials) : t.credentialDefaultProvider(t), { signingEscapePath: n = !0, systemClockOffset: r = t.systemClockOffset || 0, sha256: a } = t;
  let s;
  return t.signer ? s = Br(t.signer) : t.regionInfoProvider ? s = () => Br(t.region)().then(async (o) => [
    await t.regionInfoProvider(o, {
      useFipsEndpoint: await t.useFipsEndpoint(),
      useDualstackEndpoint: await t.useDualstackEndpoint()
    }) || {},
    o
  ]).then(([o, i]) => {
    const { signingRegion: c, signingService: l } = o;
    t.signingRegion = t.signingRegion || c || i, t.signingName = t.signingName || l || t.serviceId;
    const u = {
      ...t,
      credentials: e,
      region: t.signingRegion,
      service: t.signingName,
      sha256: a,
      uriEscapePath: n
    }, d = t.signerConstructor || jv;
    return new d(u);
  }) : s = async (o) => {
    o = Object.assign({}, {
      name: "sigv4",
      signingName: t.signingName || t.defaultSigningName,
      signingRegion: await Br(t.region)(),
      properties: {}
    }, o);
    const i = o.signingRegion, c = o.signingName;
    t.signingRegion = t.signingRegion || i, t.signingName = t.signingName || c || t.serviceId;
    const l = {
      ...t,
      credentials: e,
      region: t.signingRegion,
      service: t.signingName,
      sha256: a,
      uriEscapePath: n
    }, u = t.signerConstructor || jv;
    return new u(l);
  }, {
    ...t,
    systemClockOffset: r,
    signingEscapePath: n,
    credentials: e,
    signer: s
  };
}, KK = (t) => typeof t == "function" ? M_(t, (e) => e.expiration !== void 0 && e.expiration.getTime() - Date.now() < GK, (e) => e.expiration !== void 0) : Br(t);
let XK = class Q_ {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new Q_({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = YK(e.query)), e;
  }
};
function YK(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
let ZK = class {
  constructor(e) {
    this.statusCode = e.statusCode, this.reason = e.reason, this.headers = e.headers || {}, this.body = e.body;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return typeof n.statusCode == "number" && typeof n.headers == "object";
  }
};
const ex = (t) => new Date(Date.now() + t), JK = (t, e) => Math.abs(ex(e).getTime() - t) >= 3e5, Gv = (t, e) => {
  const n = Date.parse(t);
  return JK(n, e) ? n - Date.now() : e;
}, QK = (t) => (e, n) => async function(r) {
  if (!XK.isInstance(r.request))
    return e(r);
  const a = n.endpointV2?.properties?.authSchemes?.[0], s = a?.name === "sigv4a" ? a?.signingRegionSet?.join(",") : void 0, o = await t.signer(a), i = await e({
    ...r,
    request: await o.sign(r.request, {
      signingDate: ex(t.systemClockOffset),
      signingRegion: s || n.signing_region,
      signingService: n.signing_service
    })
  }).catch((l) => {
    const u = l.ServerTime ?? qv(l.$response);
    throw u && (t.systemClockOffset = Gv(u, t.systemClockOffset)), l;
  }), c = qv(i.response);
  return c && (t.systemClockOffset = Gv(c, t.systemClockOffset)), i;
}, qv = (t) => ZK.isInstance(t) ? t.headers?.date ?? t.headers?.Date : void 0, eX = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: !0
}, tX = (t) => ({
  applyToStack: (e) => {
    e.addRelativeTo(QK(t), eX);
  }
});
function nX(t) {
  return {
    ...t,
    customUserAgent: typeof t.customUserAgent == "string" ? [[t.customUserAgent]] : t.customUserAgent
  };
}
const rX = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      name: "aws-cn",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws-us-gov",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      name: "aws-iso",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      name: "aws-iso-b",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      name: "aws-iso-e",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      name: "aws-iso-f",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
], aX = "1.1", tx = {
  partitions: rX,
  version: aX
};
let nx = tx, rx = "";
const sX = (t) => {
  const { partitions: e } = nx;
  for (const r of e) {
    const { regions: a, outputs: s } = r;
    for (const [o, i] of Object.entries(a))
      if (o === t)
        return {
          ...s,
          ...i
        };
  }
  for (const r of e) {
    const { regionRegex: a, outputs: s } = r;
    if (new RegExp(a).test(t))
      return {
        ...s
      };
  }
  const n = e.find((r) => r.id === "aws");
  if (!n)
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  return {
    ...n.outputs
  };
}, ax = (t, e = "") => {
  nx = t, rx = e;
}, oX = () => {
  ax(tx, "");
}, sx = () => rx, iX = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"), ox = (t) => iX.test(t) || t.startsWith("[") && t.endsWith("]"), gu = "endpoints";
function Ka(t) {
  return typeof t != "object" || t == null ? t : "ref" in t ? `$${Ka(t.ref)}` : "fn" in t ? `${t.fn}(${(t.argv || []).map(Ka).join(", ")})` : JSON.stringify(t, null, 2);
}
class dr extends Error {
  constructor(e) {
    super(e), this.name = "EndpointError";
  }
}
const uX = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"), xg = (t, e = !1) => {
  if (!e)
    return uX.test(t);
  const n = t.split(".");
  for (const r of n)
    if (!xg(r))
      return !1;
  return !0;
}, ix = (t, e = !1) => {
  if (e) {
    for (const n of t.split("."))
      if (!ix(n))
        return !1;
    return !0;
  }
  return !(!xg(t) || t.length < 3 || t.length > 63 || t !== t.toLowerCase() || ox(t));
}, cX = (t) => {
  const e = t.split(":");
  if (e.length < 6)
    return null;
  const [n, r, a, s, o, ...i] = e;
  return n !== "arn" || r === "" || a === "" || i[0] === "" ? null : {
    partition: r,
    service: a,
    region: s,
    accountId: o,
    resourceId: i[0].includes("/") ? i[0].split("/") : i
  };
}, lX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getUserAgentPrefix: sx,
  isVirtualHostableS3Bucket: ix,
  parseArn: cX,
  partition: sX,
  setPartitionInfo: ax,
  useDefaultPartitionInfo: oX
}, Symbol.toStringTag, { value: "Module" })), dX = (t, e) => t === e, fX = (t) => {
  const e = t.split("."), n = [];
  for (const r of e) {
    const a = r.indexOf("[");
    if (a !== -1) {
      if (r.indexOf("]") !== r.length - 1)
        throw new dr(`Path: '${t}' does not end with ']'`);
      const s = r.slice(a + 1, -1);
      if (Number.isNaN(parseInt(s)))
        throw new dr(`Invalid array index: '${s}' in path: '${t}'`);
      a !== 0 && n.push(r.slice(0, a)), n.push(s);
    } else
      n.push(r);
  }
  return n;
}, ux = (t, e) => fX(e).reduce((n, r) => {
  if (typeof n != "object")
    throw new dr(`Index '${r}' in '${e}' not found in '${JSON.stringify(t)}'`);
  return Array.isArray(n) ? n[parseInt(r)] : n[r];
}, t), pX = (t) => t != null, hX = (t) => !t;
var Kv;
(function(t) {
  t.AAAA = "AAAA", t.A = "A";
})(Kv || (Kv = {}));
const up = {
  [hu.HTTP]: 80,
  [hu.HTTPS]: 443
}, mX = (t) => {
  const e = (() => {
    try {
      if (t instanceof URL)
        return t;
      if (typeof t == "object" && "hostname" in t) {
        const { hostname: f, port: p, protocol: h = "", path: m = "", query: g = {} } = t, v = new URL(`${h}//${f}${p ? `:${p}` : ""}${m}`);
        return v.search = Object.entries(g).map(([b, w]) => `${b}=${w}`).join("&"), v;
      }
      return new URL(t);
    } catch {
      return null;
    }
  })();
  if (!e)
    return console.error(`Unable to parse ${JSON.stringify(t)} as a whatwg URL.`), null;
  const n = e.href, { host: r, hostname: a, pathname: s, protocol: o, search: i } = e;
  if (i)
    return null;
  const c = o.slice(0, -1);
  if (!Object.values(hu).includes(c))
    return null;
  const l = ox(a), u = n.includes(`${r}:${up[c]}`) || typeof t == "string" && t.includes(`${r}:${up[c]}`), d = `${r}${u ? `:${up[c]}` : ""}`;
  return {
    scheme: c,
    authority: d,
    path: s,
    normalizedPath: s.endsWith("/") ? s : `${s}/`,
    isIp: l
  };
}, gX = (t, e) => t === e, yX = (t, e, n, r) => e >= n || t.length < n ? null : r ? t.substring(t.length - n, t.length - e) : t.substring(e, n), vX = (t) => encodeURIComponent(t).replace(/[!*'()]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), bX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aws: lX,
  booleanEquals: dX,
  getAttr: ux,
  isSet: pX,
  isValidHostLabel: xg,
  not: hX,
  parseURL: mX,
  stringEquals: gX,
  substring: yX,
  uriEncode: vX
}, Symbol.toStringTag, { value: "Module" })), cx = (t, e) => {
  const n = [], r = {
    ...e.endpointParams,
    ...e.referenceRecord
  };
  let a = 0;
  for (; a < t.length; ) {
    const s = t.indexOf("{", a);
    if (s === -1) {
      n.push(t.slice(a));
      break;
    }
    n.push(t.slice(a, s));
    const o = t.indexOf("}", s);
    if (o === -1) {
      n.push(t.slice(s));
      break;
    }
    t[s + 1] === "{" && t[o + 1] === "}" && (n.push(t.slice(s + 1, o)), a = o + 2);
    const i = t.substring(s + 1, o);
    if (i.includes("#")) {
      const [c, l] = i.split("#");
      n.push(ux(r[c], l));
    } else
      n.push(r[i]);
    a = o + 1;
  }
  return n.join("");
}, wX = ({ ref: t }, e) => ({
  ...e.endpointParams,
  ...e.referenceRecord
})[t], Ef = (t, e, n) => {
  if (typeof t == "string")
    return cx(t, n);
  if (t.fn)
    return lx(t, n);
  if (t.ref)
    return wX(t, n);
  throw new dr(`'${e}': ${String(t)} is not a string, function or reference.`);
}, lx = ({ fn: t, argv: e }, n) => {
  const r = e.map((a) => ["boolean", "number"].includes(typeof a) ? a : Ef(a, "arg", n));
  return t.split(".").reduce((a, s) => a[s], bX)(...r);
}, SX = ({ assign: t, ...e }, n) => {
  if (t && t in n.referenceRecord)
    throw new dr(`'${t}' is already defined in Reference Record.`);
  const r = lx(e, n);
  return n.logger?.debug?.(gu, `evaluateCondition: ${Ka(e)} = ${Ka(r)}`), {
    result: r === "" ? !0 : !!r,
    ...t != null && { toAssign: { name: t, value: r } }
  };
}, Ig = (t = [], e) => {
  const n = {};
  for (const r of t) {
    const { result: a, toAssign: s } = SX(r, {
      ...e,
      referenceRecord: {
        ...e.referenceRecord,
        ...n
      }
    });
    if (!a)
      return { result: a };
    s && (n[s.name] = s.value, e.logger?.debug?.(gu, `assign: ${s.name} := ${Ka(s.value)}`));
  }
  return { result: !0, referenceRecord: n };
}, _X = (t, e) => Object.entries(t).reduce((n, [r, a]) => ({
  ...n,
  [r]: a.map((s) => {
    const o = Ef(s, "Header value entry", e);
    if (typeof o != "string")
      throw new dr(`Header '${r}' value '${o}' is not a string`);
    return o;
  })
}), {}), dx = (t, e) => {
  if (Array.isArray(t))
    return t.map((n) => dx(n, e));
  switch (typeof t) {
    case "string":
      return cx(t, e);
    case "object":
      if (t === null)
        throw new dr(`Unexpected endpoint property: ${t}`);
      return fx(t, e);
    case "boolean":
      return t;
    default:
      throw new dr(`Unexpected endpoint property type: ${typeof t}`);
  }
}, fx = (t, e) => Object.entries(t).reduce((n, [r, a]) => ({
  ...n,
  [r]: dx(a, e)
}), {}), xX = (t, e) => {
  const n = Ef(t, "Endpoint URL", e);
  if (typeof n == "string")
    try {
      return new URL(n);
    } catch (r) {
      throw console.error(`Failed to construct URL with ${n}`, r), r;
    }
  throw new dr(`Endpoint URL must be a string, got ${typeof n}`);
}, IX = (t, e) => {
  const { conditions: n, endpoint: r } = t, { result: a, referenceRecord: s } = Ig(n, e);
  if (!a)
    return;
  const o = {
    ...e,
    referenceRecord: { ...e.referenceRecord, ...s }
  }, { url: i, properties: c, headers: l } = r;
  return e.logger?.debug?.(gu, `Resolving endpoint from template: ${Ka(r)}`), {
    ...l != null && {
      headers: _X(l, o)
    },
    ...c != null && {
      properties: fx(c, o)
    },
    url: xX(i, o)
  };
}, kX = (t, e) => {
  const { conditions: n, error: r } = t, { result: a, referenceRecord: s } = Ig(n, e);
  if (a)
    throw new dr(Ef(r, "Error", {
      ...e,
      referenceRecord: { ...e.referenceRecord, ...s }
    }));
}, EX = (t, e) => {
  const { conditions: n, rules: r } = t, { result: a, referenceRecord: s } = Ig(n, e);
  if (a)
    return px(r, {
      ...e,
      referenceRecord: { ...e.referenceRecord, ...s }
    });
}, px = (t, e) => {
  for (const n of t)
    if (n.type === "endpoint") {
      const r = IX(n, e);
      if (r)
        return r;
    } else if (n.type === "error")
      kX(n, e);
    else if (n.type === "tree") {
      const r = EX(n, e);
      if (r)
        return r;
    } else
      throw new dr(`Unknown endpoint rule: ${n}`);
  throw new dr("Rules evaluation failed");
}, TX = (t, e) => {
  const { endpointParams: n, logger: r } = e, { parameters: a, rules: s } = t;
  e.logger?.debug?.(`${gu} Initial EndpointParams: ${Ka(n)}`);
  const o = Object.entries(a).filter(([, l]) => l.default != null).map(([l, u]) => [l, u.default]);
  if (o.length > 0)
    for (const [l, u] of o)
      n[l] = n[l] ?? u;
  const i = Object.entries(a).filter(([, l]) => l.required).map(([l]) => l);
  for (const l of i)
    if (n[l] == null)
      throw new dr(`Missing required parameter: '${l}'`);
  const c = px(s, { endpointParams: n, logger: r, referenceRecord: {} });
  if (e.endpointParams?.Endpoint)
    try {
      const l = new URL(e.endpointParams.Endpoint), { protocol: u, port: d } = l;
      c.url.protocol = u, c.url.port = d;
    } catch {
    }
  return e.logger?.debug?.(`${gu} Resolved endpoint: ${Ka(c)}`), c;
};
let CX = class hx {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new hx({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = NX(e.query)), e;
  }
};
function NX(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
const Xv = "user-agent", cp = "x-amz-user-agent", Yv = " ", lp = "/", AX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g, RX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g, Zv = "-", $X = (t) => (e, n) => async (r) => {
  const { request: a } = r;
  if (!CX.isInstance(a))
    return e(r);
  const { headers: s } = a, o = n?.userAgent?.map(dp) || [], i = (await t.defaultUserAgentProvider()).map(dp), c = t?.customUserAgent?.map(dp) || [], l = sx(), u = (l ? [l] : []).concat([...i, ...o, ...c]).join(Yv), d = [
    ...i.filter((f) => f.startsWith("aws-sdk-")),
    ...c
  ].join(Yv);
  return t.runtime !== "browser" ? (d && (s[cp] = s[cp] ? `${s[Xv]} ${d}` : d), s[Xv] = u) : s[cp] = u, e({
    ...r,
    request: a
  });
}, dp = (t) => {
  const e = t[0].split(lp).map((o) => o.replace(AX, Zv)).join(lp), n = t[1]?.replace(RX, Zv), r = e.indexOf(lp), a = e.substring(0, r);
  let s = e.substring(r + 1);
  return a === "api" && (s = s.toLowerCase()), [a, s, n].filter((o) => o && o.length > 0).reduce((o, i, c) => {
    switch (c) {
      case 0:
        return i;
      case 1:
        return `${o}/${i}`;
      default:
        return `${o}#${i}`;
    }
  }, "");
}, DX = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: !0
}, OX = (t) => ({
  applyToStack: (e) => {
    e.add($X(t), DX);
  }
}), FX = (t, e, n) => {
  let r = t;
  const a = {
    start() {
    },
    async transform(s, o) {
      try {
        const i = /* @__PURE__ */ new Date(), c = {
          ":date": { type: "timestamp", value: i }
        }, l = await e.sign({
          message: {
            body: s,
            headers: c
          },
          priorSignature: r
        }, {
          signingDate: i
        });
        r = l.signature;
        const u = n.encode({
          headers: {
            ...c,
            ":chunk-signature": {
              type: "binary",
              value: V_(l.signature)
            }
          },
          body: s
        });
        o.enqueue(u);
      } catch (i) {
        o.error(i);
      }
    }
  };
  return new TransformStream({ ...a });
};
class MX {
  constructor(e) {
    this.messageSigner = e.messageSigner, this.eventStreamCodec = new U_(e.utf8Encoder, e.utf8Decoder);
  }
  async handle(e, n, r = {}) {
    const a = n.request, { body: s, headers: o, query: i } = a;
    if (!(s instanceof ReadableStream))
      throw new Error("Eventstream payload must be a ReadableStream.");
    const c = new TransformStream();
    a.body = c.readable;
    let l;
    try {
      l = await e(n);
    } catch (h) {
      throw a.body.cancel(), h;
    }
    const d = ((o.authorization || "").match(/Signature=([\w]+)$/) || [])[1] || i && i["X-Amz-Signature"] || "", f = FX(d, await this.messageSigner(), this.eventStreamCodec);
    return s.pipeThrough(f).pipeThrough(c), l;
  }
}
const PX = (t) => new MX(t), BX = () => (t) => async (e) => {
  const n = {
    ...e.input
  }, r = await t(e), a = r.output;
  return n.SessionId && a.SessionId == null && (a.SessionId = n.SessionId), r;
}, LX = {
  step: "initialize",
  name: "injectSessionIdMiddleware",
  tags: ["WEBSOCKET", "EVENT_STREAM"],
  override: !0
};
let mx = class gx {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new gx({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = WX(e.query)), e;
  }
};
function WX(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
let zX = class {
  constructor(e) {
    this.statusCode = e.statusCode, this.reason = e.reason, this.headers = e.headers || {}, this.body = e.body;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return typeof n.statusCode == "number" && typeof n.headers == "object";
  }
};
const VX = (t, e) => (n) => (r) => {
  const { request: a } = r;
  if (mx.isInstance(a) && t.requestHandler.metadata?.handlerProtocol?.toLowerCase().includes("websocket")) {
    a.protocol = "wss:", a.method = "GET", a.path = `${a.path}-websocket`;
    const { headers: s } = a;
    delete s["Content-Type"], delete s["x-amz-content-sha256"];
    for (const o of Object.keys(s))
      if (o.indexOf(e.headerPrefix) === 0) {
        const i = o.replace(e.headerPrefix, "");
        a.query[i] = s[o];
      }
    s["x-amz-user-agent"] && (a.query["user-agent"] = s["x-amz-user-agent"]), a.headers = { host: s.host ?? a.hostname };
  }
  return n(r);
}, HX = {
  name: "websocketEndpointMiddleware",
  tags: ["WEBSOCKET", "EVENT_STREAM"],
  relation: "after",
  toMiddleware: "eventStreamHeaderMiddleware",
  override: !0
}, jX = (t, e) => ({
  applyToStack: (n) => {
    n.addRelativeTo(VX(t, e), HX), n.add(BX(), LX);
  }
}), yx = (t) => t.protocol === "ws:" || t.protocol === "wss:";
class UX {
  constructor(e) {
    this.signer = e.signer;
  }
  presign(e, n = {}) {
    return this.signer.presign(e, n);
  }
  async sign(e, n) {
    return mx.isInstance(e) && yx(e) ? {
      ...await this.signer.presign({ ...e, body: "" }, {
        ...n,
        expiresIn: 60,
        unsignableHeaders: new Set(Object.keys(e.headers).filter((a) => a !== "host"))
      }),
      body: e.body
    } : this.signer.sign(e, n);
  }
}
const GX = (t) => ({
  ...t,
  signer: async (e) => {
    const n = await t.signer(e);
    if (qX(n))
      return new UX({ signer: n });
    throw new Error("Expected WebsocketSignatureV4 signer, please check the client constructor.");
  }
}), qX = (t) => !!t;
function kg(t) {
  const e = [];
  for (let n of Object.keys(t).sort()) {
    const r = t[n];
    if (n = Es(n), Array.isArray(r))
      for (let a = 0, s = r.length; a < s; a++)
        e.push(`${n}=${Es(r[a])}`);
    else {
      let a = n;
      (r || typeof r == "string") && (a += `=${Es(r)}`), e.push(a);
    }
  }
  return e.join("&");
}
function KX(t) {
  const { port: e, query: n } = t;
  let { protocol: r, path: a, hostname: s } = t;
  r && r.slice(-1) !== ":" && (r += ":"), e && (s += `:${e}`), a && a.charAt(0) !== "/" && (a = `/${a}`);
  let o = n ? kg(n) : "";
  o && o[0] !== "?" && (o = `?${o}`);
  let i = "";
  if (t.username != null || t.password != null) {
    const l = t.username ?? "", u = t.password ?? "";
    i = `${l}:${u}@`;
  }
  let c = "";
  return t.fragment && (c = `#${t.fragment}`), `${r}//${i}${s}${a}${o}${c}`;
}
function XX(t) {
  let e = 0, n = 0, r = null, a = null;
  const s = (i) => {
    if (typeof i != "number")
      throw new Error("Attempted to allocate an event message where size was not a number: " + i);
    e = i, n = 4, r = new Uint8Array(i), new DataView(r.buffer).setUint32(0, i, !1);
  }, o = async function* () {
    const i = t[Symbol.asyncIterator]();
    for (; ; ) {
      const { value: c, done: l } = await i.next();
      if (l) {
        if (e)
          if (e === n)
            yield r;
          else
            throw new Error("Truncated event message received.");
        else
          return;
        return;
      }
      const u = c.length;
      let d = 0;
      for (; d < u; ) {
        if (!r) {
          const p = u - d;
          a || (a = new Uint8Array(4));
          const h = Math.min(4 - n, p);
          if (a.set(c.slice(d, d + h), n), n += h, d += h, n < 4)
            break;
          s(new DataView(a.buffer).getUint32(0, !1)), a = null;
        }
        const f = Math.min(e - n, u - d);
        r.set(c.slice(d, d + f), n), n += f, d += f, e && e === n && (yield r, r = null, e = 0, n = 0);
      }
    }
  };
  return {
    [Symbol.asyncIterator]: o
  };
}
function YX(t, e) {
  return async function(n) {
    const { value: r } = n.headers[":message-type"];
    if (r === "error") {
      const a = new Error(n.headers[":error-message"].value || "UnknownError");
      throw a.name = n.headers[":error-code"].value, a;
    } else if (r === "exception") {
      const a = n.headers[":exception-type"].value, s = { [a]: n }, o = await t(s);
      if (o.$unknown) {
        const i = new Error(e(n.body));
        throw i.name = a, i;
      }
      throw o[a];
    } else if (r === "event") {
      const a = {
        [n.headers[":event-type"].value]: n
      }, s = await t(a);
      return s.$unknown ? void 0 : s;
    } else
      throw Error(`Unrecognizable event type: ${n.headers[":event-type"].value}`);
  };
}
let ZX = class {
  constructor({ utf8Encoder: e, utf8Decoder: n }) {
    this.eventStreamCodec = new U_(e, n), this.utfEncoder = e;
  }
  deserialize(e, n) {
    const r = XX(e);
    return new bK({
      messageStream: new yK({ inputStream: r, decoder: this.eventStreamCodec }),
      deserializer: YX(n, this.utfEncoder)
    });
  }
  serialize(e, n) {
    return new vK({
      messageStream: new wK({ inputStream: e, serializer: n }),
      encoder: this.eventStreamCodec,
      includeEndFrame: !0
    });
  }
};
const Eg = (t) => ({
  [Symbol.asyncIterator]: async function* () {
    const e = t.getReader();
    try {
      for (; ; ) {
        const { done: n, value: r } = await e.read();
        if (n)
          return;
        yield r;
      }
    } finally {
      e.releaseLock();
    }
  }
}), Tg = (t) => {
  const e = t[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(n) {
      const { done: r, value: a } = await e.next();
      if (r)
        return n.close();
      n.enqueue(a);
    }
  });
};
class JX {
  constructor({ utf8Encoder: e, utf8Decoder: n }) {
    this.universalMarshaller = new ZX({
      utf8Decoder: n,
      utf8Encoder: e
    });
  }
  deserialize(e, n) {
    const r = QX(e) ? Eg(e) : e;
    return this.universalMarshaller.deserialize(r, n);
  }
  serialize(e, n) {
    const r = this.universalMarshaller.serialize(e, n);
    return typeof ReadableStream == "function" ? Tg(r) : r;
  }
}
const QX = (t) => typeof ReadableStream == "function" && t instanceof ReadableStream, eY = (t) => new JX(t);
let vx = class bx {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new bx({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = tY(e.query)), e;
  }
};
function tY(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
class nl {
  constructor(e) {
    this.statusCode = e.statusCode, this.reason = e.reason, this.headers = e.headers || {}, this.body = e.body;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return typeof n.statusCode == "number" && typeof n.headers == "object";
  }
}
function nY(t = 0) {
  return new Promise((e, n) => {
    t && setTimeout(() => {
      const r = new Error(`Request did not complete within ${t} ms`);
      r.name = "TimeoutError", n(r);
    }, t);
  });
}
const rY = {
  supported: typeof Request < "u" && "keepalive" in new Request("https://[::1]")
};
class Ou {
  static create(e) {
    return typeof e?.handle == "function" ? e : new Ou(e);
  }
  constructor(e) {
    typeof e == "function" ? this.configProvider = e().then((n) => n || {}) : (this.config = e ?? {}, this.configProvider = Promise.resolve(this.config));
  }
  destroy() {
  }
  async handle(e, { abortSignal: n } = {}) {
    this.config || (this.config = await this.configProvider);
    const r = this.config.requestTimeout, a = this.config.keepAlive === !0;
    if (n?.aborted) {
      const m = new Error("Request aborted");
      return m.name = "AbortError", Promise.reject(m);
    }
    let s = e.path;
    const o = kg(e.query || {});
    o && (s += `?${o}`), e.fragment && (s += `#${e.fragment}`);
    let i = "";
    if (e.username != null || e.password != null) {
      const m = e.username ?? "", g = e.password ?? "";
      i = `${m}:${g}@`;
    }
    const { port: c, method: l } = e, u = `${e.protocol}//${i}${e.hostname}${c ? `:${c}` : ""}${s}`, f = { body: l === "GET" || l === "HEAD" ? void 0 : e.body, headers: new Headers(e.headers), method: l };
    typeof AbortController < "u" && (f.signal = n), rY.supported && (f.keepalive = a);
    const p = new Request(u, f), h = [
      fetch(p).then((m) => {
        const g = m.headers, v = {};
        for (const w of g.entries())
          v[w[0]] = w[1];
        return m.body != null ? {
          response: new nl({
            headers: v,
            reason: m.statusText,
            statusCode: m.status,
            body: m.body
          })
        } : m.blob().then((w) => ({
          response: new nl({
            headers: v,
            reason: m.statusText,
            statusCode: m.status,
            body: w
          })
        }));
      }),
      nY(r)
    ];
    return n && h.push(new Promise((m, g) => {
      n.onabort = () => {
        const v = new Error("Request aborted");
        v.name = "AbortError", g(v);
      };
    })), Promise.race(h);
  }
  updateHttpClientConfig(e, n) {
    this.config = void 0, this.configProvider = this.configProvider.then((r) => (r[e] = n, r));
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
const Xa = {}, jo = new Array(64);
for (let t = 0, e = "A".charCodeAt(0), n = "Z".charCodeAt(0); t + e <= n; t++) {
  const r = String.fromCharCode(t + e);
  Xa[r] = t, jo[t] = r;
}
for (let t = 0, e = "a".charCodeAt(0), n = "z".charCodeAt(0); t + e <= n; t++) {
  const r = String.fromCharCode(t + e), a = t + 26;
  Xa[r] = a, jo[a] = r;
}
for (let t = 0; t < 10; t++) {
  Xa[t.toString(10)] = t + 52;
  const e = t.toString(10), n = t + 52;
  Xa[e] = n, jo[n] = e;
}
Xa["+"] = 62;
jo[62] = "+";
Xa["/"] = 63;
jo[63] = "/";
const xo = 6, Gi = 8, aY = 63, Cg = (t) => {
  let e = t.length / 4 * 3;
  t.slice(-2) === "==" ? e -= 2 : t.slice(-1) === "=" && e--;
  const n = new ArrayBuffer(e), r = new DataView(n);
  for (let a = 0; a < t.length; a += 4) {
    let s = 0, o = 0;
    for (let l = a, u = a + 3; l <= u; l++)
      if (t[l] !== "=") {
        if (!(t[l] in Xa))
          throw new TypeError(`Invalid character ${t[l]} in base64 string.`);
        s |= Xa[t[l]] << (u - l) * xo, o += xo;
      } else
        s >>= xo;
    const i = a / 4 * 3;
    s >>= o % Gi;
    const c = Math.floor(o / Gi);
    for (let l = 0; l < c; l++) {
      const u = (c - l - 1) * Gi;
      r.setUint8(i + l, (s & 255 << u) >> u);
    }
  }
  return new Uint8Array(n);
};
function wx(t) {
  let e;
  typeof t == "string" ? e = _u(t) : e = t;
  const n = typeof e == "object" && typeof e.length == "number", r = typeof e == "object" && typeof e.byteOffset == "number" && typeof e.byteLength == "number";
  if (!n && !r)
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  let a = "";
  for (let s = 0; s < e.length; s += 3) {
    let o = 0, i = 0;
    for (let l = s, u = Math.min(s + 3, e.length); l < u; l++)
      o |= e[l] << (u - l - 1) * Gi, i += Gi;
    const c = Math.ceil(i / xo);
    o <<= c * xo - i;
    for (let l = 1; l <= c; l++) {
      const u = (c - l) * xo;
      a += jo[(o & aY << u) >> u];
    }
    a += "==".slice(0, 4 - c);
  }
  return a;
}
const sY = (t) => typeof Blob == "function" && t instanceof Blob ? oY(t) : iY(t);
async function oY(t) {
  const e = await uY(t), n = Cg(e);
  return new Uint8Array(n);
}
async function iY(t) {
  let e = new Uint8Array(0);
  const n = t.getReader();
  let r = !1;
  for (; !r; ) {
    const { done: a, value: s } = await n.read();
    if (s) {
      const o = e;
      e = new Uint8Array(o.length + s.length), e.set(o), e.set(s, o.length);
    }
    r = a;
  }
  return e;
}
function uY(t) {
  return new Promise((e, n) => {
    const r = new FileReader();
    r.onloadend = () => {
      if (r.readyState !== 2)
        return n(new Error("Reader aborted too early"));
      const a = r.result ?? "", s = a.indexOf(","), o = s > -1 ? s + 1 : a.length;
      e(a.substring(o));
    }, r.onabort = () => n(new Error("Read aborted")), r.onerror = () => n(r.error), r.readAsDataURL(t);
  });
}
const cY = 2e3;
class lY {
  constructor(e, n = new Ou()) {
    this.metadata = {
      handlerProtocol: "websocket/h1.1"
    }, this.sockets = {}, this.httpHandler = n, typeof e == "function" ? this.configPromise = e().then((r) => r ?? {}) : this.configPromise = Promise.resolve(e ?? {});
  }
  destroy() {
    for (const [e, n] of Object.entries(this.sockets)) {
      for (const r of n)
        r.close(1e3, "Socket closed through destroy() call");
      delete this.sockets[e];
    }
  }
  async handle(e) {
    if (!yx(e))
      return this.httpHandler.handle(e);
    const n = KX(e), r = new WebSocket(n);
    this.sockets[n] || (this.sockets[n] = []), this.sockets[n].push(r), r.binaryType = "arraybuffer";
    const { connectionTimeout: a = cY } = await this.configPromise;
    await this.waitForReady(r, a);
    const { body: s } = e, o = dY(s), i = this.connect(r, o), c = fY(i);
    return {
      response: new zX({
        statusCode: 200,
        body: c
      })
    };
  }
  removeNotUsableSockets(e) {
    this.sockets[e] = (this.sockets[e] ?? []).filter((n) => ![WebSocket.CLOSING, WebSocket.CLOSED].includes(n.readyState));
  }
  waitForReady(e, n) {
    return new Promise((r, a) => {
      const s = setTimeout(() => {
        this.removeNotUsableSockets(e.url), a({
          $metadata: {
            httpStatusCode: 500
          }
        });
      }, n);
      e.onopen = () => {
        clearTimeout(s), r();
      };
    });
  }
  connect(e, n) {
    let r, a = !1, s = () => {
    }, o = () => {
    };
    e.onmessage = (l) => {
      o({
        done: !1,
        value: new Uint8Array(l.data)
      });
    }, e.onerror = (l) => {
      a = !0, e.close(), s(l);
    }, e.onclose = () => {
      this.removeNotUsableSockets(e.url), !a && (r ? s(r) : o({
        done: !0,
        value: void 0
      }));
    };
    const i = {
      [Symbol.asyncIterator]: () => ({
        next: () => new Promise((l, u) => {
          o = l, s = u;
        })
      })
    };
    return (async () => {
      try {
        for await (const l of n)
          e.send(l);
      } catch (l) {
        r = l;
      } finally {
        e.close(1e3);
      }
    })(), i;
  }
}
const dY = (t) => t[Symbol.asyncIterator] ? t : pY(t) ? Eg(t) : {
  [Symbol.asyncIterator]: async function* () {
    yield t;
  }
}, fY = (t) => typeof ReadableStream == "function" ? Tg(t) : t, pY = (t) => typeof ReadableStream == "function" && t instanceof ReadableStream;
var Jv;
(function(t) {
  t.ENV = "env", t.CONFIG = "shared config entry";
})(Jv || (Jv = {}));
const hY = !1, mY = !1, Sx = (t) => typeof t == "string" && (t.startsWith("fips-") || t.endsWith("-fips")), Qv = (t) => Sx(t) ? ["fips-aws-global", "aws-fips"].includes(t) ? "us-east-1" : t.replace(/fips-(dkr-|prod-)?|-fips/, "") : t, gY = (t) => {
  const { region: e, useFipsEndpoint: n } = t;
  if (!e)
    throw new Error("Region is missing");
  return {
    ...t,
    region: async () => {
      if (typeof e == "string")
        return Qv(e);
      const r = await e();
      return Qv(r);
    },
    useFipsEndpoint: async () => {
      const r = typeof e == "string" ? e : await e();
      return Sx(r) ? !0 : typeof n != "function" ? Promise.resolve(!!n) : n();
    }
  };
}, yY = (t) => ({
  ...t,
  eventStreamMarshaller: t.eventStreamSerdeProvider(t)
}), eb = "content-length";
function vY(t) {
  return (e) => async (n) => {
    const r = n.request;
    if (vx.isInstance(r)) {
      const { body: a, headers: s } = r;
      if (a && Object.keys(s).map((o) => o.toLowerCase()).indexOf(eb) === -1)
        try {
          const o = t(a);
          r.headers = {
            ...r.headers,
            [eb]: String(o)
          };
        } catch {
        }
    }
    return e({
      ...n,
      request: r
    });
  };
}
const bY = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: !0
}, wY = (t) => ({
  applyToStack: (e) => {
    e.add(vY(t.bodyLengthChecker), bY);
  }
}), SY = async (t) => {
  const e = t?.Bucket || "";
  if (typeof t.Bucket == "string" && (t.Bucket = e.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), EY(e)) {
    if (t.ForcePathStyle === !0)
      throw new Error("Path-style addressing cannot be used with ARN buckets");
  } else
    (!kY(e) || e.indexOf(".") !== -1 && !String(t.Endpoint).startsWith("http:") || e.toLowerCase() !== e || e.length < 3) && (t.ForcePathStyle = !0);
  return t.DisableMultiRegionAccessPoints && (t.disableMultiRegionAccessPoints = !0, t.DisableMRAP = !0), t;
}, _Y = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, xY = /(\d+\.){3}\d+/, IY = /\.\./, kY = (t) => _Y.test(t) && !xY.test(t) && !IY.test(t), EY = (t) => {
  const [e, n, r, a, s, o] = t.split(":"), i = e === "arn" && t.split(":").length >= 6, c = [e, n, r, s, o].filter(Boolean).length === 5;
  if (i && !c)
    throw new Error(`Invalid ARN: ${t} was an invalid ARN.`);
  return e === "arn" && !!n && !!r && !!s && !!o;
}, TY = (t, e, n) => {
  const r = async () => {
    const a = n[t] ?? n[e];
    return typeof a == "function" ? a() : a;
  };
  return t === "credentialScope" || e === "CredentialScope" ? async () => {
    const a = typeof n.credentials == "function" ? await n.credentials() : n.credentials;
    return a?.credentialScope ?? a?.CredentialScope;
  } : t === "endpoint" || e === "endpoint" ? async () => {
    const a = await r();
    if (a && typeof a == "object") {
      if ("url" in a)
        return a.url.href;
      if ("hostname" in a) {
        const { protocol: s, hostname: o, port: i, path: c } = a;
        return `${s}//${o}${i ? ":" + i : ""}${c}`;
      }
    }
    return a;
  } : r;
}, CY = async (t) => {
};
function NY(t) {
  const e = {};
  if (t = t.replace(/^\?/, ""), t)
    for (const n of t.split("&")) {
      let [r, a = null] = n.split("=");
      r = decodeURIComponent(r), a && (a = decodeURIComponent(a)), r in e ? Array.isArray(e[r]) ? e[r].push(a) : e[r] = [e[r], a] : e[r] = a;
    }
  return e;
}
const rl = (t) => {
  if (typeof t == "string")
    return rl(new URL(t));
  const { hostname: e, pathname: n, port: r, protocol: a, search: s } = t;
  let o;
  return s && (o = NY(s)), {
    hostname: e,
    port: r ? parseInt(r) : void 0,
    protocol: a,
    path: n,
    query: o
  };
}, _x = (t) => typeof t == "object" ? "url" in t ? rl(t.url) : t : rl(t), AY = async (t, e, n, r) => {
  if (!n.endpoint) {
    const o = await CY(n.serviceId || "");
    o && (n.endpoint = () => Promise.resolve(_x(o)));
  }
  const a = await RY(t, e, n);
  if (typeof n.endpointProvider != "function")
    throw new Error("config.endpointProvider is not set.");
  return n.endpointProvider(a, r);
}, RY = async (t, e, n) => {
  const r = {}, a = e?.getEndpointParameterInstructions?.() || {};
  for (const [s, o] of Object.entries(a))
    switch (o.type) {
      case "staticContextParams":
        r[s] = o.value;
        break;
      case "contextParams":
        r[s] = t[o.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        r[s] = await TY(o.name, s, n)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(o));
    }
  return Object.keys(a).length === 0 && Object.assign(r, n), String(n.serviceId).toLowerCase() === "s3" && await SY(r), r;
}, $Y = ({ config: t, instructions: e }) => (n, r) => async (a) => {
  const s = await AY(a.input, {
    getEndpointParameterInstructions() {
      return e;
    }
  }, { ...t }, r);
  r.endpointV2 = s, r.authSchemes = s.properties?.authSchemes;
  const o = r.authSchemes?.[0];
  if (o) {
    r.signing_region = o.signingRegion, r.signing_service = o.signingName;
    const c = SK(r)?.selectedHttpAuthScheme?.httpAuthOption;
    c && (c.signingProperties = Object.assign(c.signingProperties || {}, {
      signing_region: o.signingRegion,
      signingRegion: o.signingRegion,
      signing_service: o.signingName,
      signingName: o.signingName,
      signingRegionSet: o.signingRegionSet
    }, o.properties));
  }
  return n({
    ...a
  });
}, DY = (t, e) => (n, r) => async (a) => {
  const { response: s } = await n(a);
  try {
    const o = await e(s, t);
    return {
      response: s,
      output: o
    };
  } catch (o) {
    if (Object.defineProperty(o, "$response", {
      value: s
    }), !("$metadata" in o)) {
      const i = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
      o.message += `
  ` + i, typeof o.$responseBodyText < "u" && o.$response && (o.$response.body = o.$responseBodyText);
    }
    throw o;
  }
}, OY = (t, e) => (n, r) => async (a) => {
  const s = r.endpointV2?.url && t.urlParser ? async () => t.urlParser(r.endpointV2.url) : t.endpoint;
  if (!s)
    throw new Error("No valid endpoint provider available.");
  const o = await e(a.input, { ...t, endpoint: s });
  return n({
    ...a,
    request: o
  });
}, FY = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: !0
}, xx = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: !0
};
function MY(t, e, n) {
  return {
    applyToStack: (r) => {
      r.add(DY(t, n), FY), r.add(OY(t, e), xx);
    }
  };
}
const PY = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: !0,
  relation: "before",
  toMiddleware: xx.name
}, BY = (t, e) => ({
  applyToStack: (n) => {
    n.addRelativeTo($Y({
      config: t,
      instructions: e
    }), PY);
  }
}), LY = (t) => {
  const e = t.tls ?? !0, { endpoint: n } = t, r = n != null ? async () => _x(await Br(n)()) : void 0;
  return {
    ...t,
    endpoint: r,
    tls: e,
    isCustomEndpoint: !!n,
    useDualstackEndpoint: Br(t.useDualstackEndpoint ?? !1),
    useFipsEndpoint: Br(t.useFipsEndpoint ?? !1)
  };
};
var Do;
(function(t) {
  t.STANDARD = "standard", t.ADAPTIVE = "adaptive";
})(Do || (Do = {}));
const al = 3, WY = Do.STANDARD, zY = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
], VY = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], HY = [500, 502, 503, 504], jY = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], UY = (t) => t.$metadata?.clockSkewCorrected, Ix = (t) => t.$metadata?.httpStatusCode === 429 || zY.includes(t.name) || t.$retryable?.throttling == !0, kx = (t) => UY(t) || VY.includes(t.name) || jY.includes(t?.code || "") || HY.includes(t.$metadata?.httpStatusCode || 0), GY = (t) => {
  if (t.$metadata?.httpStatusCode !== void 0) {
    const e = t.$metadata.httpStatusCode;
    return 500 <= e && e <= 599 && !kx(t);
  }
  return !1;
};
class qY {
  constructor(e) {
    this.currentCapacity = 0, this.enabled = !1, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = e?.beta ?? 0.7, this.minCapacity = e?.minCapacity ?? 1, this.minFillRate = e?.minFillRate ?? 0.5, this.scaleConstant = e?.scaleConstant ?? 0.4, this.smooth = e?.smooth ?? 0.8;
    const n = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = n, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(e) {
    if (this.enabled) {
      if (this.refillTokenBucket(), e > this.currentCapacity) {
        const n = (e - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise((r) => setTimeout(r, n));
      }
      this.currentCapacity = this.currentCapacity - e;
    }
  }
  refillTokenBucket() {
    const e = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = e;
      return;
    }
    const n = (e - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + n), this.lastTimestamp = e;
  }
  updateClientSendingRate(e) {
    let n;
    if (this.updateMeasuredRate(), Ix(e)) {
      const a = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
      this.lastMaxRate = a, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), n = this.cubicThrottle(a), this.enableTokenBucket();
    } else
      this.calculateTimeWindow(), n = this.cubicSuccess(this.getCurrentTimeInSeconds());
    const r = Math.min(n, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(r);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(e) {
    return this.getPrecise(e * this.beta);
  }
  cubicSuccess(e) {
    return this.getPrecise(this.scaleConstant * Math.pow(e - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = !0;
  }
  updateTokenBucketRate(e) {
    this.refillTokenBucket(), this.fillRate = Math.max(e, this.minFillRate), this.maxCapacity = Math.max(e, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const e = this.getCurrentTimeInSeconds(), n = Math.floor(e * 2) / 2;
    if (this.requestCount++, n > this.lastTxRateBucket) {
      const r = this.requestCount / (n - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(r * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = n;
    }
  }
  getPrecise(e) {
    return parseFloat(e.toFixed(8));
  }
}
const Ah = 100, Ex = 20 * 1e3, KY = 500, tb = 500, XY = 5, YY = 10, ZY = 1, JY = "amz-sdk-invocation-id", QY = "amz-sdk-request", eZ = () => {
  let t = Ah;
  return {
    computeNextBackoffDelay: (r) => Math.floor(Math.min(Ex, Math.random() * 2 ** r * t)),
    setDelayBase: (r) => {
      t = r;
    }
  };
}, nb = ({ retryDelay: t, retryCount: e, retryCost: n }) => ({
  getRetryCount: () => e,
  getRetryDelay: () => Math.min(Ex, t),
  getRetryCost: () => n
});
class Tx {
  constructor(e) {
    this.maxAttempts = e, this.mode = Do.STANDARD, this.capacity = tb, this.retryBackoffStrategy = eZ(), this.maxAttemptsProvider = typeof e == "function" ? e : async () => e;
  }
  async acquireInitialRetryToken(e) {
    return nb({
      retryDelay: Ah,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(e, n) {
    const r = await this.getMaxAttempts();
    if (this.shouldRetry(e, n, r)) {
      const a = n.errorType;
      this.retryBackoffStrategy.setDelayBase(a === "THROTTLING" ? KY : Ah);
      const s = this.retryBackoffStrategy.computeNextBackoffDelay(e.getRetryCount()), o = n.retryAfterHint ? Math.max(n.retryAfterHint.getTime() - Date.now() || 0, s) : s, i = this.getCapacityCost(a);
      return this.capacity -= i, nb({
        retryDelay: o,
        retryCount: e.getRetryCount() + 1,
        retryCost: i
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(e) {
    this.capacity = Math.max(tb, this.capacity + (e.getRetryCost() ?? ZY));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch {
      return console.warn(`Max attempts provider could not resolve. Using default of ${al}`), al;
    }
  }
  shouldRetry(e, n, r) {
    return e.getRetryCount() + 1 < r && this.capacity >= this.getCapacityCost(n.errorType) && this.isRetryableError(n.errorType);
  }
  getCapacityCost(e) {
    return e === "TRANSIENT" ? YY : XY;
  }
  isRetryableError(e) {
    return e === "THROTTLING" || e === "TRANSIENT";
  }
}
class tZ {
  constructor(e, n) {
    this.maxAttemptsProvider = e, this.mode = Do.ADAPTIVE;
    const { rateLimiter: r } = n ?? {};
    this.rateLimiter = r ?? new qY(), this.standardRetryStrategy = new Tx(e);
  }
  async acquireInitialRetryToken(e) {
    return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(e);
  }
  async refreshRetryTokenForRetry(e, n) {
    return this.rateLimiter.updateClientSendingRate(n), this.standardRetryStrategy.refreshRetryTokenForRetry(e, n);
  }
  recordSuccess(e) {
    this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(e);
  }
}
var dc, nZ = new Uint8Array(16);
function rZ() {
  if (!dc && (dc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !dc))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return dc(nZ);
}
const aZ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function sZ(t) {
  return typeof t == "string" && aZ.test(t);
}
var Sn = [];
for (var fp = 0; fp < 256; ++fp)
  Sn.push((fp + 256).toString(16).substr(1));
function oZ(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = (Sn[t[e + 0]] + Sn[t[e + 1]] + Sn[t[e + 2]] + Sn[t[e + 3]] + "-" + Sn[t[e + 4]] + Sn[t[e + 5]] + "-" + Sn[t[e + 6]] + Sn[t[e + 7]] + "-" + Sn[t[e + 8]] + Sn[t[e + 9]] + "-" + Sn[t[e + 10]] + Sn[t[e + 11]] + Sn[t[e + 12]] + Sn[t[e + 13]] + Sn[t[e + 14]] + Sn[t[e + 15]]).toLowerCase();
  if (!sZ(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
function iZ(t, e, n) {
  t = t || {};
  var r = t.random || (t.rng || rZ)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
    n = n || 0;
    for (var a = 0; a < 16; ++a)
      e[n + a] = r[a];
    return e;
  }
  return oZ(r);
}
const uZ = (t) => t instanceof Error ? t : t instanceof Object ? Object.assign(new Error(), t) : typeof t == "string" ? new Error(t) : new Error(`AWS SDK error wrapper for ${t}`), cZ = (t) => {
  const { retryStrategy: e } = t, n = Br(t.maxAttempts ?? al);
  return {
    ...t,
    maxAttempts: n,
    retryStrategy: async () => e || (await Br(t.retryMode)() === Do.ADAPTIVE ? new tZ(n) : new Tx(n))
  };
};
class Cx {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
const gs = (t, e) => {
  const n = [];
  if (t && n.push(t), e)
    for (const r of e)
      n.push(r);
  return n;
}, Ra = (t, e) => `${t || "anonymous"}${e && e.length > 0 ? ` (a.k.a. ${e.join(",")})` : ""}`, sl = () => {
  let t = [], e = [], n = !1;
  const r = /* @__PURE__ */ new Set(), a = (d) => d.sort((f, p) => rb[p.step] - rb[f.step] || ab[p.priority || "normal"] - ab[f.priority || "normal"]), s = (d) => {
    let f = !1;
    const p = (h) => {
      const m = gs(h.name, h.aliases);
      if (m.includes(d)) {
        f = !0;
        for (const g of m)
          r.delete(g);
        return !1;
      }
      return !0;
    };
    return t = t.filter(p), e = e.filter(p), f;
  }, o = (d) => {
    let f = !1;
    const p = (h) => {
      if (h.middleware === d) {
        f = !0;
        for (const m of gs(h.name, h.aliases))
          r.delete(m);
        return !1;
      }
      return !0;
    };
    return t = t.filter(p), e = e.filter(p), f;
  }, i = (d) => (t.forEach((f) => {
    d.add(f.middleware, { ...f });
  }), e.forEach((f) => {
    d.addRelativeTo(f.middleware, { ...f });
  }), d.identifyOnResolve?.(u.identifyOnResolve()), d), c = (d) => {
    const f = [];
    return d.before.forEach((p) => {
      p.before.length === 0 && p.after.length === 0 ? f.push(p) : f.push(...c(p));
    }), f.push(d), d.after.reverse().forEach((p) => {
      p.before.length === 0 && p.after.length === 0 ? f.push(p) : f.push(...c(p));
    }), f;
  }, l = (d = !1) => {
    const f = [], p = [], h = {};
    return t.forEach((g) => {
      const v = {
        ...g,
        before: [],
        after: []
      };
      for (const b of gs(v.name, v.aliases))
        h[b] = v;
      f.push(v);
    }), e.forEach((g) => {
      const v = {
        ...g,
        before: [],
        after: []
      };
      for (const b of gs(v.name, v.aliases))
        h[b] = v;
      p.push(v);
    }), p.forEach((g) => {
      if (g.toMiddleware) {
        const v = h[g.toMiddleware];
        if (v === void 0) {
          if (d)
            return;
          throw new Error(`${g.toMiddleware} is not found when adding ${Ra(g.name, g.aliases)} middleware ${g.relation} ${g.toMiddleware}`);
        }
        g.relation === "after" && v.after.push(g), g.relation === "before" && v.before.push(g);
      }
    }), a(f).map(c).reduce((g, v) => (g.push(...v), g), []);
  }, u = {
    add: (d, f = {}) => {
      const { name: p, override: h, aliases: m } = f, g = {
        step: "initialize",
        priority: "normal",
        middleware: d,
        ...f
      }, v = gs(p, m);
      if (v.length > 0) {
        if (v.some((b) => r.has(b))) {
          if (!h)
            throw new Error(`Duplicate middleware name '${Ra(p, m)}'`);
          for (const b of v) {
            const w = t.findIndex((I) => I.name === b || I.aliases?.some((E) => E === b));
            if (w === -1)
              continue;
            const S = t[w];
            if (S.step !== g.step || g.priority !== S.priority)
              throw new Error(`"${Ra(S.name, S.aliases)}" middleware with ${S.priority} priority in ${S.step} step cannot be overridden by "${Ra(p, m)}" middleware with ${g.priority} priority in ${g.step} step.`);
            t.splice(w, 1);
          }
        }
        for (const b of v)
          r.add(b);
      }
      t.push(g);
    },
    addRelativeTo: (d, f) => {
      const { name: p, override: h, aliases: m } = f, g = {
        middleware: d,
        ...f
      }, v = gs(p, m);
      if (v.length > 0) {
        if (v.some((b) => r.has(b))) {
          if (!h)
            throw new Error(`Duplicate middleware name '${Ra(p, m)}'`);
          for (const b of v) {
            const w = e.findIndex((I) => I.name === b || I.aliases?.some((E) => E === b));
            if (w === -1)
              continue;
            const S = e[w];
            if (S.toMiddleware !== g.toMiddleware || S.relation !== g.relation)
              throw new Error(`"${Ra(S.name, S.aliases)}" middleware ${S.relation} "${S.toMiddleware}" middleware cannot be overridden by "${Ra(p, m)}" middleware ${g.relation} "${g.toMiddleware}" middleware.`);
            e.splice(w, 1);
          }
        }
        for (const b of v)
          r.add(b);
      }
      e.push(g);
    },
    clone: () => i(sl()),
    use: (d) => {
      d.applyToStack(u);
    },
    remove: (d) => typeof d == "string" ? s(d) : o(d),
    removeByTag: (d) => {
      let f = !1;
      const p = (h) => {
        const { tags: m, name: g, aliases: v } = h;
        if (m && m.includes(d)) {
          const b = gs(g, v);
          for (const w of b)
            r.delete(w);
          return f = !0, !1;
        }
        return !0;
      };
      return t = t.filter(p), e = e.filter(p), f;
    },
    concat: (d) => {
      const f = i(sl());
      return f.use(d), f.identifyOnResolve(n || f.identifyOnResolve() || (d.identifyOnResolve?.() ?? !1)), f;
    },
    applyToStack: i,
    identify: () => l(!0).map((d) => {
      const f = d.step ?? d.relation + " " + d.toMiddleware;
      return Ra(d.name, d.aliases) + " - " + f;
    }),
    identifyOnResolve(d) {
      return typeof d == "boolean" && (n = d), n;
    },
    resolve: (d, f) => {
      for (const p of l().map((h) => h.middleware).reverse())
        d = p(d, f);
      return n && console.log(u.identify()), d;
    }
  };
  return u;
}, rb = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
}, ab = {
  high: 3,
  normal: 2,
  low: 1
};
class lZ {
  constructor(e) {
    this.middlewareStack = sl(), this.config = e;
  }
  send(e, n, r) {
    const a = typeof n != "function" ? n : void 0, s = typeof n == "function" ? n : r, o = e.resolveMiddleware(this.middlewareStack, this.config, a);
    if (s)
      o(e).then((i) => s(null, i.output), (i) => s(i)).catch(() => {
      });
    else
      return o(e).then((i) => i.output);
  }
  destroy() {
    this.config.requestHandler.destroy && this.config.requestHandler.destroy();
  }
}
function dZ(t, e = "utf-8") {
  return e === "base64" ? wx(t) : qh(t);
}
function fZ(t, e) {
  return e === "base64" ? As.mutate(Cg(t)) : As.mutate(_u(t));
}
class As extends Uint8Array {
  static fromString(e, n = "utf-8") {
    switch (typeof e) {
      case "string":
        return fZ(e, n);
      default:
        throw new Error(`Unsupported conversion from ${typeof e} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(e) {
    return Object.setPrototypeOf(e, As.prototype), e;
  }
  transformToString(e = "utf-8") {
    return dZ(this, e);
  }
}
const pZ = async (t = new Uint8Array(), e) => {
  if (t instanceof Uint8Array)
    return As.mutate(t);
  if (!t)
    return As.mutate(new Uint8Array());
  const n = e.streamCollector(t);
  return As.mutate(await n);
};
class Nx {
  constructor() {
    this.middlewareStack = sl();
  }
  static classBuilder() {
    return new hZ();
  }
  resolveMiddlewareWithContext(e, n, r, { middlewareFn: a, clientName: s, commandName: o, inputFilterSensitiveLog: i, outputFilterSensitiveLog: c, smithyContext: l, additionalContext: u, CommandCtor: d }) {
    for (const g of a.bind(this)(d, e, n, r))
      this.middlewareStack.use(g);
    const f = e.concat(this.middlewareStack), { logger: p } = n, h = {
      logger: p,
      clientName: s,
      commandName: o,
      inputFilterSensitiveLog: i,
      outputFilterSensitiveLog: c,
      [Ih]: {
        ...l
      },
      ...u
    }, { requestHandler: m } = n;
    return f.resolve((g) => m.handle(g.request, r || {}), h);
  }
}
class hZ {
  constructor() {
    this._init = () => {
    }, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (e) => e, this._outputFilterSensitiveLog = (e) => e, this._serializer = null, this._deserializer = null;
  }
  init(e) {
    this._init = e;
  }
  ep(e) {
    return this._ep = e, this;
  }
  m(e) {
    return this._middlewareFn = e, this;
  }
  s(e, n, r = {}) {
    return this._smithyContext = {
      service: e,
      operation: n,
      ...r
    }, this;
  }
  c(e = {}) {
    return this._additionalContext = e, this;
  }
  n(e, n) {
    return this._clientName = e, this._commandName = n, this;
  }
  f(e = (r) => r, n = (r) => r) {
    return this._inputFilterSensitiveLog = e, this._outputFilterSensitiveLog = n, this;
  }
  ser(e) {
    return this._serializer = e, this;
  }
  de(e) {
    return this._deserializer = e, this;
  }
  build() {
    const e = this;
    let n;
    return n = class extends Nx {
      static getEndpointParameterInstructions() {
        return e._ep;
      }
      constructor(...[r]) {
        super(), this.serialize = e._serializer, this.deserialize = e._deserializer, this.input = r ?? {}, e._init(this);
      }
      resolveMiddleware(r, a, s) {
        return this.resolveMiddlewareWithContext(r, a, s, {
          CommandCtor: n,
          middlewareFn: e._middlewareFn,
          clientName: e._clientName,
          commandName: e._commandName,
          inputFilterSensitiveLog: e._inputFilterSensitiveLog,
          outputFilterSensitiveLog: e._outputFilterSensitiveLog,
          smithyContext: e._smithyContext,
          additionalContext: e._additionalContext
        });
      }
    };
  }
}
const mZ = (t) => {
  if (t != null) {
    if (typeof t == "string") {
      const e = parseFloat(t);
      if (!Number.isNaN(e))
        return String(e) !== String(t) && Rx.warn(Ax(`Expected number but observed string: ${t}`)), e;
    }
    if (typeof t == "number")
      return t;
    throw new TypeError(`Expected number, got ${typeof t}: ${t}`);
  }
}, gZ = Math.ceil(2 ** 127 * (2 - 2 ** -23)), yZ = (t) => {
  const e = mZ(t);
  if (e !== void 0 && !Number.isNaN(e) && e !== 1 / 0 && e !== -1 / 0 && Math.abs(e) > gZ)
    throw new TypeError(`Expected 32-bit float, got ${t}`);
  return e;
}, vZ = (t) => {
  if (t != null) {
    if (Number.isInteger(t) && !Number.isNaN(t))
      return t;
    throw new TypeError(`Expected integer, got ${typeof t}: ${t}`);
  }
}, bZ = (t) => wZ(t, 32), wZ = (t, e) => {
  const n = vZ(t);
  if (n !== void 0 && SZ(n, e) !== n)
    throw new TypeError(`Expected ${e}-bit integer, got ${t}`);
  return n;
}, SZ = (t, e) => {
  switch (e) {
    case 32:
      return Int32Array.of(t)[0];
    case 16:
      return Int16Array.of(t)[0];
    case 8:
      return Int8Array.of(t)[0];
  }
}, _Z = (t) => {
  if (t == null)
    return;
  if (typeof t == "object" && !Array.isArray(t))
    return t;
  const e = Array.isArray(t) ? "array" : typeof t;
  throw new TypeError(`Expected object, got ${e}: ${t}`);
}, qn = (t) => {
  if (t != null) {
    if (typeof t == "string")
      return t;
    if (["boolean", "number", "bigint"].includes(typeof t))
      return Rx.warn(Ax(`Expected string, got ${typeof t}: ${t}`)), String(t);
    throw new TypeError(`Expected string, got ${typeof t}: ${t}`);
  }
}, xZ = (t) => {
  if (t == null)
    return;
  const e = _Z(t), n = Object.entries(e).filter(([, r]) => r != null).map(([r]) => r);
  if (n.length === 0)
    throw new TypeError("Unions must have exactly one non-null member. None were found.");
  if (n.length > 1)
    throw new TypeError(`Unions must have exactly one non-null member. Keys ${n} were not null.`);
  return e;
}, Nn = (t) => typeof t == "string" ? IZ(t) : yZ(t), IZ = (t) => {
  switch (t) {
    case "NaN":
      return NaN;
    case "Infinity":
      return 1 / 0;
    case "-Infinity":
      return -1 / 0;
    default:
      throw new Error(`Unable to parse float value: ${t}`);
  }
}, Ax = (t) => String(new TypeError(t).stack || t).split(`
`).slice(0, 5).filter((e) => !e.includes("stackTraceWarning")).join(`
`), Rx = {
  warn: console.warn
};
class Ng extends Error {
  constructor(e) {
    super(e.message), Object.setPrototypeOf(this, Ng.prototype), this.name = e.name, this.$fault = e.$fault, this.$metadata = e.$metadata;
  }
}
const rs = (t, e = {}) => {
  Object.entries(e).filter(([, r]) => r !== void 0).forEach(([r, a]) => {
    (t[r] == null || t[r] === "") && (t[r] = a);
  });
  const n = t.message || t.Message || "UnknownError";
  return t.message = n, delete t.Message, t;
}, kZ = ({ output: t, parsedBody: e, exceptionCtor: n, errorCode: r }) => {
  const a = TZ(t), s = a.httpStatusCode ? a.httpStatusCode + "" : void 0, o = new n({
    name: e?.code || e?.Code || r || s || "UnknownError",
    $fault: "client",
    $metadata: a
  });
  throw rs(o, e);
}, EZ = (t) => ({ output: e, parsedBody: n, errorCode: r }) => {
  kZ({ output: e, parsedBody: n, exceptionCtor: t, errorCode: r });
}, TZ = (t) => ({
  httpStatusCode: t.statusCode,
  requestId: t.headers["x-amzn-requestid"] ?? t.headers["x-amzn-request-id"] ?? t.headers["x-amz-request-id"],
  extendedRequestId: t.headers["x-amz-id-2"],
  cfId: t.headers["x-amz-cf-id"]
}), CZ = (t) => {
  switch (t) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
}, NZ = (t) => {
  const e = [];
  for (const n in tl) {
    const r = tl[n];
    t[r] !== void 0 && e.push({
      algorithmId: () => r,
      checksumConstructor: () => t[r]
    });
  }
  return {
    _checksumAlgorithms: e,
    addChecksumAlgorithm(n) {
      this._checksumAlgorithms.push(n);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
}, AZ = (t) => {
  const e = {};
  return t.checksumAlgorithms().forEach((n) => {
    e[n.algorithmId()] = n.checksumConstructor();
  }), e;
}, RZ = (t) => {
  let e = t.retryStrategy;
  return {
    setRetryStrategy(n) {
      e = n;
    },
    retryStrategy() {
      return e;
    }
  };
}, $Z = (t) => {
  const e = {};
  return e.retryStrategy = t.retryStrategy(), e;
}, DZ = (t) => ({
  ...NZ(t),
  ...RZ(t)
}), OZ = (t) => ({
  ...AZ(t),
  ...$Z(t)
}), Rh = function() {
  const t = Object.getPrototypeOf(this).constructor, e = Function.bind.apply(String, [null, ...arguments]), n = new e();
  return Object.setPrototypeOf(n, t.prototype), n;
};
Rh.prototype = Object.create(String.prototype, {
  constructor: {
    value: Rh,
    enumerable: !1,
    writable: !0,
    configurable: !0
  }
});
Object.setPrototypeOf(Rh, String);
function ta(t, e, n) {
  let r, a, s;
  if (typeof e > "u" && typeof n > "u")
    r = {}, s = t;
  else {
    if (r = t, typeof e == "function")
      return a = e, s = n, FZ(r, a, s);
    s = e;
  }
  for (const o of Object.keys(s)) {
    if (!Array.isArray(s[o])) {
      r[o] = s[o];
      continue;
    }
    $x(r, null, s, o);
  }
  return r;
}
const fn = (t, e) => {
  const n = {};
  for (const r in e)
    $x(n, t, e, r);
  return n;
}, FZ = (t, e, n) => ta(t, Object.entries(n).reduce((r, [a, s]) => (Array.isArray(s) ? r[a] = s : typeof s == "function" ? r[a] = [e, s()] : r[a] = [e, s], r), {})), $x = (t, e, n, r) => {
  if (e !== null) {
    let o = n[r];
    typeof o == "function" && (o = [, o]);
    const [i = MZ, c = PZ, l = r] = o;
    (typeof i == "function" && i(e[l]) || typeof i != "function" && i) && (t[r] = c(e[l]));
    return;
  }
  let [a, s] = n[r];
  if (typeof s == "function") {
    let o;
    const i = a === void 0 && (o = s()) != null, c = typeof a == "function" && !!a(void 0) || typeof a != "function" && !!a;
    i ? t[r] = o : c && (t[r] = s());
  } else {
    const o = a === void 0 && s != null, i = typeof a == "function" && !!a(s) || typeof a != "function" && !!a;
    (o || i) && (t[r] = s);
  }
}, MZ = (t) => t != null, PZ = (t) => t, fc = (t) => {
  if (t !== t)
    return "NaN";
  switch (t) {
    case 1 / 0:
      return "Infinity";
    case -1 / 0:
      return "-Infinity";
    default:
      return t;
  }
}, yu = (t) => {
  if (t == null)
    return {};
  if (Array.isArray(t))
    return t.filter((e) => e != null).map(yu);
  if (typeof t == "object") {
    const e = {};
    for (const n of Object.keys(t))
      t[n] != null && (e[n] = yu(t[n]));
    return e;
  }
  return t;
}, BZ = (t) => t?.body instanceof ReadableStream, LZ = (t) => (e, n) => async (r) => {
  let a = await t.retryStrategy();
  const s = await t.maxAttempts();
  if (WZ(a)) {
    a = a;
    let o = await a.acquireInitialRetryToken(n.partition_id), i = new Error(), c = 0, l = 0;
    const { request: u } = r, d = vx.isInstance(u);
    for (d && (u.headers[JY] = iZ()); ; )
      try {
        d && (u.headers[QY] = `attempt=${c + 1}; max=${s}`);
        const { response: f, output: p } = await e(r);
        return a.recordSuccess(o), p.$metadata.attempts = c + 1, p.$metadata.totalRetryDelay = l, { response: f, output: p };
      } catch (f) {
        const p = zZ(f);
        if (i = uZ(f), d && BZ(u))
          throw (n.logger instanceof Cx ? console : n.logger)?.warn("An error was encountered in a non-retryable streaming request."), i;
        try {
          o = await a.refreshRetryTokenForRetry(o, p);
        } catch {
          throw i.$metadata || (i.$metadata = {}), i.$metadata.attempts = c + 1, i.$metadata.totalRetryDelay = l, i;
        }
        c = o.getRetryCount();
        const h = o.getRetryDelay();
        l += h, await new Promise((m) => setTimeout(m, h));
      }
  } else
    return a = a, a?.mode && (n.userAgent = [...n.userAgent || [], ["cfg/retry-mode", a.mode]]), a.retry(e, r);
}, WZ = (t) => typeof t.acquireInitialRetryToken < "u" && typeof t.refreshRetryTokenForRetry < "u" && typeof t.recordSuccess < "u", zZ = (t) => {
  const e = {
    error: t,
    errorType: VZ(t)
  }, n = UZ(t.$response);
  return n && (e.retryAfterHint = n), e;
}, VZ = (t) => Ix(t) ? "THROTTLING" : kx(t) ? "TRANSIENT" : GY(t) ? "SERVER_ERROR" : "CLIENT_ERROR", HZ = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: !0
}, jZ = (t) => ({
  applyToStack: (e) => {
    e.add(LZ(t), HZ);
  }
}), UZ = (t) => {
  if (!nl.isInstance(t))
    return;
  const e = Object.keys(t.headers).find((s) => s.toLowerCase() === "retry-after");
  if (!e)
    return;
  const n = t.headers[e], r = Number(n);
  return Number.isNaN(r) ? new Date(n) : new Date(r * 1e3);
}, GZ = (t) => ({
  ...t,
  useDualstackEndpoint: t.useDualstackEndpoint ?? !1,
  useFipsEndpoint: t.useFipsEndpoint ?? !1,
  defaultSigningName: "rekognition"
}), qZ = "@aws-sdk/client-rekognitionstreaming", KZ = "AWS SDK for JavaScript Rekognitionstreaming Client for Node.js, Browser and React Native", XZ = "3.398.0", YZ = {
  build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
  "build:cjs": "tsc -p tsconfig.cjs.json",
  "build:docs": "typedoc",
  "build:es": "tsc -p tsconfig.es.json",
  "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
  "build:types": "tsc -p tsconfig.types.json",
  "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
  clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
  "extract:docs": "api-extractor run --local",
  "generate:client": "node ../../scripts/generate-clients/single-service --solo rekognitionstreaming"
}, ZZ = "./dist-cjs/index.js", JZ = "./dist-types/index.d.ts", QZ = "./dist-es/index.js", eJ = !1, tJ = {
  "@aws-crypto/sha256-browser": "3.0.0",
  "@aws-crypto/sha256-js": "3.0.0",
  "@aws-sdk/client-sts": "3.398.0",
  "@aws-sdk/credential-provider-node": "3.398.0",
  "@aws-sdk/eventstream-handler-node": "3.398.0",
  "@aws-sdk/middleware-eventstream": "3.398.0",
  "@aws-sdk/middleware-host-header": "3.398.0",
  "@aws-sdk/middleware-logger": "3.398.0",
  "@aws-sdk/middleware-recursion-detection": "3.398.0",
  "@aws-sdk/middleware-signing": "3.398.0",
  "@aws-sdk/middleware-user-agent": "3.398.0",
  "@aws-sdk/middleware-websocket": "3.398.0",
  "@aws-sdk/types": "3.398.0",
  "@aws-sdk/util-endpoints": "3.398.0",
  "@aws-sdk/util-user-agent-browser": "3.398.0",
  "@aws-sdk/util-user-agent-node": "3.398.0",
  "@smithy/config-resolver": "^2.0.5",
  "@smithy/eventstream-serde-browser": "^2.0.5",
  "@smithy/eventstream-serde-config-resolver": "^2.0.5",
  "@smithy/eventstream-serde-node": "^2.0.5",
  "@smithy/fetch-http-handler": "^2.0.5",
  "@smithy/hash-node": "^2.0.5",
  "@smithy/invalid-dependency": "^2.0.5",
  "@smithy/middleware-content-length": "^2.0.5",
  "@smithy/middleware-endpoint": "^2.0.5",
  "@smithy/middleware-retry": "^2.0.5",
  "@smithy/middleware-serde": "^2.0.5",
  "@smithy/middleware-stack": "^2.0.0",
  "@smithy/node-config-provider": "^2.0.5",
  "@smithy/node-http-handler": "^2.0.5",
  "@smithy/protocol-http": "^2.0.5",
  "@smithy/smithy-client": "^2.0.5",
  "@smithy/types": "^2.2.2",
  "@smithy/url-parser": "^2.0.5",
  "@smithy/util-base64": "^2.0.0",
  "@smithy/util-body-length-browser": "^2.0.0",
  "@smithy/util-body-length-node": "^2.1.0",
  "@smithy/util-defaults-mode-browser": "^2.0.5",
  "@smithy/util-defaults-mode-node": "^2.0.5",
  "@smithy/util-retry": "^2.0.0",
  "@smithy/util-utf8": "^2.0.0",
  tslib: "^2.5.0"
}, nJ = {
  "@smithy/service-client-documentation-generator": "^2.0.0",
  "@tsconfig/node14": "1.0.3",
  "@types/node": "^14.14.31",
  concurrently: "7.0.0",
  "downlevel-dts": "0.10.1",
  rimraf: "3.0.2",
  typedoc: "0.23.23",
  typescript: "~4.9.5"
}, rJ = {
  node: ">=14.0.0"
}, aJ = {
  "<4.0": {
    "dist-types/*": [
      "dist-types/ts3.4/*"
    ]
  }
}, sJ = [
  "dist-*/**"
], oJ = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
}, iJ = "Apache-2.0", uJ = {
  "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
}, cJ = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-rekognitionstreaming", lJ = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-rekognitionstreaming"
}, dJ = {
  name: qZ,
  description: KZ,
  version: XZ,
  scripts: YZ,
  main: ZZ,
  types: JZ,
  module: QZ,
  sideEffects: eJ,
  dependencies: tJ,
  devDependencies: nJ,
  engines: rJ,
  typesVersions: aJ,
  files: sJ,
  author: oJ,
  license: iJ,
  browser: uJ,
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: cJ,
  repository: lJ
};
var Dx = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var $h = function(t, e) {
  return $h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (n[a] = r[a]);
  }, $h(t, e);
};
function fJ(t, e) {
  $h(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Dh = function() {
  return Dh = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Dh.apply(this, arguments);
};
function pJ(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function hJ(t, e, n, r) {
  var a = arguments.length, s = a < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var i = t.length - 1; i >= 0; i--)
      (o = t[i]) && (s = (a < 3 ? o(s) : a > 3 ? o(e, n, s) : o(e, n)) || s);
  return a > 3 && s && Object.defineProperty(e, n, s), s;
}
function mJ(t, e) {
  return function(n, r) {
    e(n, r, t);
  };
}
function gJ(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function yJ(t, e, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function i(u) {
      try {
        l(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      u.done ? s(u.value) : a(u.value).then(i, c);
    }
    l((r = r.apply(t, e || [])).next());
  });
}
function vJ(t, e) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, o;
  return o = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function i(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, a && (s = l[0] & 2 ? a.return : l[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, l[1])).done)
          return s;
        switch (a = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return n.label++, { value: l[1], done: !1 };
          case 5:
            n.label++, a = l[1], l = [0];
            continue;
          case 7:
            l = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              n = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              n.label = l[1];
              break;
            }
            if (l[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = l;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(l);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        l = e.call(t, n);
      } catch (u) {
        l = [6, u], a = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function bJ(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}
function wJ(t, e) {
  for (var n in t)
    n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n]);
}
function Oh(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Ox(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), a, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (i) {
    o = { error: i };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function SJ() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(Ox(arguments[e]));
  return t;
}
function _J() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), a = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, i = s.length; o < i; o++, a++)
      r[a] = s[o];
  return r;
}
function vu(t) {
  return this instanceof vu ? (this.v = t, this) : new vu(t);
}
function xJ(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), a, s = [];
  return a = {}, o("next"), o("throw"), o("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function o(f) {
    r[f] && (a[f] = function(p) {
      return new Promise(function(h, m) {
        s.push([f, p, h, m]) > 1 || i(f, p);
      });
    });
  }
  function i(f, p) {
    try {
      c(r[f](p));
    } catch (h) {
      d(s[0][3], h);
    }
  }
  function c(f) {
    f.value instanceof vu ? Promise.resolve(f.value.v).then(l, u) : d(s[0][2], f);
  }
  function l(f) {
    i("next", f);
  }
  function u(f) {
    i("throw", f);
  }
  function d(f, p) {
    f(p), s.shift(), s.length && i(s[0][0], s[0][1]);
  }
}
function IJ(t) {
  var e, n;
  return e = {}, r("next"), r("throw", function(a) {
    throw a;
  }), r("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function r(a, s) {
    e[a] = t[a] ? function(o) {
      return (n = !n) ? { value: vu(t[a](o)), done: a === "return" } : s ? s(o) : o;
    } : s;
  }
}
function kJ(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Oh == "function" ? Oh(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = t[s] && function(o) {
      return new Promise(function(i, c) {
        o = t[s](o), a(i, c, o.done, o.value);
      });
    };
  }
  function a(s, o, i, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: i });
    }, o);
  }
}
function EJ(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function TJ(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return e.default = t, e;
}
function CJ(t) {
  return t && t.__esModule ? t : { default: t };
}
function NJ(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function AJ(t, e, n) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, n), n;
}
const RJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return Dh;
  },
  __asyncDelegator: IJ,
  __asyncGenerator: xJ,
  __asyncValues: kJ,
  __await: vu,
  __awaiter: yJ,
  __classPrivateFieldGet: NJ,
  __classPrivateFieldSet: AJ,
  __createBinding: bJ,
  __decorate: hJ,
  __exportStar: wJ,
  __extends: fJ,
  __generator: vJ,
  __importDefault: CJ,
  __importStar: TJ,
  __makeTemplateObject: EJ,
  __metadata: gJ,
  __param: mJ,
  __read: Ox,
  __rest: pJ,
  __spread: SJ,
  __spreadArrays: _J,
  __values: Oh
}, Symbol.toStringTag, { value: "Module" })), $J = /* @__PURE__ */ _a(RJ);
var vi = {}, bi = {}, wi = {}, sb;
function DJ() {
  if (sb)
    return wi;
  sb = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.isEmptyData = void 0;
  function t(e) {
    return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
  }
  return wi.isEmptyData = t, wi;
}
var pp = {}, ob;
function Fx() {
  return ob || (ob = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.EMPTY_DATA_SHA_256 = t.SHA_256_HMAC_ALGO = t.SHA_256_HASH = void 0, t.SHA_256_HASH = { name: "SHA-256" }, t.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: t.SHA_256_HASH
    }, t.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }(pp)), pp;
}
const OJ = {};
function FJ() {
  return typeof window < "u" ? window : typeof self < "u" ? self : OJ;
}
const MJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  locateWindow: FJ
}, Symbol.toStringTag, { value: "Module" })), Ag = /* @__PURE__ */ _a(MJ);
var ib;
function Mx() {
  if (ib)
    return bi;
  ib = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.Sha256 = void 0;
  var t = DJ(), e = Fx(), n = m0, r = Ag, a = (
    /** @class */
    function() {
      function i(c) {
        this.secret = c, this.reset();
      }
      return i.prototype.update = function(c) {
        var l = this;
        (0, t.isEmptyData)(c) || (this.operation = this.operation.then(function(u) {
          return u.onerror = function() {
            l.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, u.process(o(c)), u;
        }), this.operation.catch(function() {
        }));
      }, i.prototype.digest = function() {
        return this.operation.then(function(c) {
          return new Promise(function(l, u) {
            c.onerror = function() {
              u(new Error("Error encountered finalizing hash"));
            }, c.oncomplete = function() {
              c.result && l(new Uint8Array(c.result)), u(new Error("Error encountered finalizing hash"));
            }, c.finish();
          });
        });
      }, i.prototype.reset = function() {
        this.secret ? (this.operation = s(this.secret).then(function(c) {
          return (0, r.locateWindow)().msCrypto.subtle.sign(e.SHA_256_HMAC_ALGO, c);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, r.locateWindow)().msCrypto.subtle.digest("SHA-256"));
      }, i;
    }()
  );
  bi.Sha256 = a;
  function s(i) {
    return new Promise(function(c, l) {
      var u = (0, r.locateWindow)().msCrypto.subtle.importKey("raw", o(i), e.SHA_256_HMAC_ALGO, !1, ["sign"]);
      u.oncomplete = function() {
        u.result && c(u.result), l(new Error("ImportKey completed without importing key."));
      }, u.onerror = function() {
        l(new Error("ImportKey failed to import key."));
      };
    });
  }
  function o(i) {
    return typeof i == "string" ? (0, n.fromUtf8)(i) : ArrayBuffer.isView(i) ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(i);
  }
  return bi;
}
var Si = {}, ub;
function Px() {
  if (ub)
    return Si;
  ub = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.Sha256 = void 0;
  var t = xu(), e = Fx(), n = Ag, r = (
    /** @class */
    function() {
      function a(s) {
        this.toHash = new Uint8Array(0), this.secret = s, this.reset();
      }
      return a.prototype.update = function(s) {
        if (!(0, t.isEmptyData)(s)) {
          var o = (0, t.convertToBuffer)(s), i = new Uint8Array(this.toHash.byteLength + o.byteLength);
          i.set(this.toHash, 0), i.set(o, this.toHash.byteLength), this.toHash = i;
        }
      }, a.prototype.digest = function() {
        var s = this;
        return this.key ? this.key.then(function(o) {
          return (0, n.locateWindow)().crypto.subtle.sign(e.SHA_256_HMAC_ALGO, o, s.toHash).then(function(i) {
            return new Uint8Array(i);
          });
        }) : (0, t.isEmptyData)(this.toHash) ? Promise.resolve(e.EMPTY_DATA_SHA_256) : Promise.resolve().then(function() {
          return (0, n.locateWindow)().crypto.subtle.digest(e.SHA_256_HASH, s.toHash);
        }).then(function(o) {
          return Promise.resolve(new Uint8Array(o));
        });
      }, a.prototype.reset = function() {
        var s = this;
        this.toHash = new Uint8Array(0), this.secret && this.secret !== void 0 && (this.key = new Promise(function(o, i) {
          (0, n.locateWindow)().crypto.subtle.importKey("raw", (0, t.convertToBuffer)(s.secret), e.SHA_256_HMAC_ALGO, !1, ["sign"]).then(o, i);
        }), this.key.catch(function() {
        }));
      }, a;
    }()
  );
  return Si.Sha256 = r, Si;
}
var hp = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Fh = function(t, e) {
  return Fh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (n[a] = r[a]);
  }, Fh(t, e);
};
function PJ(t, e) {
  Fh(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Mh = function() {
  return Mh = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Mh.apply(this, arguments);
};
function BJ(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function LJ(t, e, n, r) {
  var a = arguments.length, s = a < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var i = t.length - 1; i >= 0; i--)
      (o = t[i]) && (s = (a < 3 ? o(s) : a > 3 ? o(e, n, s) : o(e, n)) || s);
  return a > 3 && s && Object.defineProperty(e, n, s), s;
}
function WJ(t, e) {
  return function(n, r) {
    e(n, r, t);
  };
}
function zJ(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function VJ(t, e, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function i(u) {
      try {
        l(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      u.done ? s(u.value) : a(u.value).then(i, c);
    }
    l((r = r.apply(t, e || [])).next());
  });
}
function HJ(t, e) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, o;
  return o = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function i(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, a && (s = l[0] & 2 ? a.return : l[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, l[1])).done)
          return s;
        switch (a = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return n.label++, { value: l[1], done: !1 };
          case 5:
            n.label++, a = l[1], l = [0];
            continue;
          case 7:
            l = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              n = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              n.label = l[1];
              break;
            }
            if (l[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = l;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(l);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        l = e.call(t, n);
      } catch (u) {
        l = [6, u], a = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function jJ(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}
function UJ(t, e) {
  for (var n in t)
    n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n]);
}
function Ph(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Bx(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), a, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (i) {
    o = { error: i };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function GJ() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(Bx(arguments[e]));
  return t;
}
function qJ() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), a = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, i = s.length; o < i; o++, a++)
      r[a] = s[o];
  return r;
}
function bu(t) {
  return this instanceof bu ? (this.v = t, this) : new bu(t);
}
function KJ(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), a, s = [];
  return a = {}, o("next"), o("throw"), o("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function o(f) {
    r[f] && (a[f] = function(p) {
      return new Promise(function(h, m) {
        s.push([f, p, h, m]) > 1 || i(f, p);
      });
    });
  }
  function i(f, p) {
    try {
      c(r[f](p));
    } catch (h) {
      d(s[0][3], h);
    }
  }
  function c(f) {
    f.value instanceof bu ? Promise.resolve(f.value.v).then(l, u) : d(s[0][2], f);
  }
  function l(f) {
    i("next", f);
  }
  function u(f) {
    i("throw", f);
  }
  function d(f, p) {
    f(p), s.shift(), s.length && i(s[0][0], s[0][1]);
  }
}
function XJ(t) {
  var e, n;
  return e = {}, r("next"), r("throw", function(a) {
    throw a;
  }), r("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function r(a, s) {
    e[a] = t[a] ? function(o) {
      return (n = !n) ? { value: bu(t[a](o)), done: a === "return" } : s ? s(o) : o;
    } : s;
  }
}
function YJ(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Ph == "function" ? Ph(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = t[s] && function(o) {
      return new Promise(function(i, c) {
        o = t[s](o), a(i, c, o.done, o.value);
      });
    };
  }
  function a(s, o, i, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: i });
    }, o);
  }
}
function ZJ(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function JJ(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return e.default = t, e;
}
function QJ(t) {
  return t && t.__esModule ? t : { default: t };
}
function eQ(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function tQ(t, e, n) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, n), n;
}
const nQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return Mh;
  },
  __asyncDelegator: XJ,
  __asyncGenerator: KJ,
  __asyncValues: YJ,
  __await: bu,
  __awaiter: VJ,
  __classPrivateFieldGet: eQ,
  __classPrivateFieldSet: tQ,
  __createBinding: jJ,
  __decorate: LJ,
  __exportStar: UJ,
  __extends: PJ,
  __generator: HJ,
  __importDefault: QJ,
  __importStar: JJ,
  __makeTemplateObject: ZJ,
  __metadata: zJ,
  __param: WJ,
  __read: Bx,
  __rest: BJ,
  __spread: GJ,
  __spreadArrays: qJ,
  __values: Ph
}, Symbol.toStringTag, { value: "Module" })), Lx = /* @__PURE__ */ _a(nQ);
var Nr = {}, cb;
function rQ() {
  if (cb)
    return Nr;
  cb = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.supportsZeroByteGCM = Nr.supportsSubtleCrypto = Nr.supportsSecureRandom = Nr.supportsWebCrypto = void 0;
  var t = Lx, e = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function n(o) {
    if (r(o) && typeof o.crypto.subtle == "object") {
      var i = o.crypto.subtle;
      return a(i);
    }
    return !1;
  }
  Nr.supportsWebCrypto = n;
  function r(o) {
    if (typeof o == "object" && typeof o.crypto == "object") {
      var i = o.crypto.getRandomValues;
      return typeof i == "function";
    }
    return !1;
  }
  Nr.supportsSecureRandom = r;
  function a(o) {
    return o && e.every(function(i) {
      return typeof o[i] == "function";
    });
  }
  Nr.supportsSubtleCrypto = a;
  function s(o) {
    return t.__awaiter(this, void 0, void 0, function() {
      var i, c;
      return t.__generator(this, function(l) {
        switch (l.label) {
          case 0:
            if (!a(o))
              return [2, !1];
            l.label = 1;
          case 1:
            return l.trys.push([1, 4, , 5]), [4, o.generateKey({ name: "AES-GCM", length: 128 }, !1, ["encrypt"])];
          case 2:
            return i = l.sent(), [4, o.encrypt({
              name: "AES-GCM",
              iv: new Uint8Array(Array(12)),
              additionalData: new Uint8Array(Array(16)),
              tagLength: 128
            }, i, new Uint8Array(0))];
          case 3:
            return c = l.sent(), [2, c.byteLength === 16];
          case 4:
            return l.sent(), [2, !1];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  return Nr.supportsZeroByteGCM = s, Nr;
}
var lb;
function aQ() {
  return lb || (lb = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Lx;
    e.__exportStar(rQ(), t);
  }(hp)), hp;
}
var mp = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Bh = function(t, e) {
  return Bh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (n[a] = r[a]);
  }, Bh(t, e);
};
function sQ(t, e) {
  Bh(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Lh = function() {
  return Lh = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Lh.apply(this, arguments);
};
function oQ(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function iQ(t, e, n, r) {
  var a = arguments.length, s = a < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var i = t.length - 1; i >= 0; i--)
      (o = t[i]) && (s = (a < 3 ? o(s) : a > 3 ? o(e, n, s) : o(e, n)) || s);
  return a > 3 && s && Object.defineProperty(e, n, s), s;
}
function uQ(t, e) {
  return function(n, r) {
    e(n, r, t);
  };
}
function cQ(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function lQ(t, e, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function i(u) {
      try {
        l(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      u.done ? s(u.value) : a(u.value).then(i, c);
    }
    l((r = r.apply(t, e || [])).next());
  });
}
function dQ(t, e) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, o;
  return o = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function i(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, a && (s = l[0] & 2 ? a.return : l[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, l[1])).done)
          return s;
        switch (a = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return n.label++, { value: l[1], done: !1 };
          case 5:
            n.label++, a = l[1], l = [0];
            continue;
          case 7:
            l = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              n = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              n.label = l[1];
              break;
            }
            if (l[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = l;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(l);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        l = e.call(t, n);
      } catch (u) {
        l = [6, u], a = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function fQ(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}
function pQ(t, e) {
  for (var n in t)
    n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n]);
}
function Wh(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Wx(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), a, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (i) {
    o = { error: i };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function hQ() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(Wx(arguments[e]));
  return t;
}
function mQ() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), a = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, i = s.length; o < i; o++, a++)
      r[a] = s[o];
  return r;
}
function wu(t) {
  return this instanceof wu ? (this.v = t, this) : new wu(t);
}
function gQ(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), a, s = [];
  return a = {}, o("next"), o("throw"), o("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function o(f) {
    r[f] && (a[f] = function(p) {
      return new Promise(function(h, m) {
        s.push([f, p, h, m]) > 1 || i(f, p);
      });
    });
  }
  function i(f, p) {
    try {
      c(r[f](p));
    } catch (h) {
      d(s[0][3], h);
    }
  }
  function c(f) {
    f.value instanceof wu ? Promise.resolve(f.value.v).then(l, u) : d(s[0][2], f);
  }
  function l(f) {
    i("next", f);
  }
  function u(f) {
    i("throw", f);
  }
  function d(f, p) {
    f(p), s.shift(), s.length && i(s[0][0], s[0][1]);
  }
}
function yQ(t) {
  var e, n;
  return e = {}, r("next"), r("throw", function(a) {
    throw a;
  }), r("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function r(a, s) {
    e[a] = t[a] ? function(o) {
      return (n = !n) ? { value: wu(t[a](o)), done: a === "return" } : s ? s(o) : o;
    } : s;
  }
}
function vQ(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Wh == "function" ? Wh(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = t[s] && function(o) {
      return new Promise(function(i, c) {
        o = t[s](o), a(i, c, o.done, o.value);
      });
    };
  }
  function a(s, o, i, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: i });
    }, o);
  }
}
function bQ(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function wQ(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return e.default = t, e;
}
function SQ(t) {
  return t && t.__esModule ? t : { default: t };
}
function _Q(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function xQ(t, e, n) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, n), n;
}
const IQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return Lh;
  },
  __asyncDelegator: yQ,
  __asyncGenerator: gQ,
  __asyncValues: vQ,
  __await: wu,
  __awaiter: lQ,
  __classPrivateFieldGet: _Q,
  __classPrivateFieldSet: xQ,
  __createBinding: fQ,
  __decorate: iQ,
  __exportStar: pQ,
  __extends: sQ,
  __generator: dQ,
  __importDefault: SQ,
  __importStar: wQ,
  __makeTemplateObject: bQ,
  __metadata: cQ,
  __param: uQ,
  __read: Wx,
  __rest: oQ,
  __spread: hQ,
  __spreadArrays: mQ,
  __values: Wh
}, Symbol.toStringTag, { value: "Module" })), kQ = /* @__PURE__ */ _a(IQ);
var gp = {}, db;
function EQ() {
  return db || (db = 1, Object.defineProperty(gp, "__esModule", { value: !0 })), gp;
}
var yp = {}, fb;
function TQ() {
  return fb || (fb = 1, Object.defineProperty(yp, "__esModule", { value: !0 })), yp;
}
var vp = {}, pb;
function CQ() {
  return pb || (pb = 1, Object.defineProperty(vp, "__esModule", { value: !0 })), vp;
}
var bp = {}, hb;
function NQ() {
  return hb || (hb = 1, Object.defineProperty(bp, "__esModule", { value: !0 })), bp;
}
var _i = {}, mb;
function AQ() {
  if (mb)
    return _i;
  mb = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.isMsWindow = void 0;
  var t = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function e(r) {
    return "MSInputMethodContext" in r && "msCrypto" in r;
  }
  function n(r) {
    if (e(r) && r.msCrypto.subtle !== void 0) {
      var a = r.msCrypto, s = a.getRandomValues, o = a.subtle;
      return t.map(function(i) {
        return o[i];
      }).concat(s).every(function(i) {
        return typeof i == "function";
      });
    }
    return !1;
  }
  return _i.isMsWindow = n, _i;
}
var gb;
function RQ() {
  return gb || (gb = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = kQ;
    e.__exportStar(EQ(), t), e.__exportStar(TQ(), t), e.__exportStar(CQ(), t), e.__exportStar(NQ(), t), e.__exportStar(AQ(), t);
  }(mp)), mp;
}
var yb;
function $Q() {
  if (yb)
    return vi;
  yb = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.Sha256 = void 0;
  var t = Mx(), e = Px(), n = d0, r = aQ(), a = RQ(), s = Ag, o = xu(), i = (
    /** @class */
    function() {
      function c(l) {
        (0, r.supportsWebCrypto)((0, s.locateWindow)()) ? this.hash = new e.Sha256(l) : (0, a.isMsWindow)((0, s.locateWindow)()) ? this.hash = new t.Sha256(l) : this.hash = new n.Sha256(l);
      }
      return c.prototype.update = function(l, u) {
        this.hash.update((0, o.convertToBuffer)(l));
      }, c.prototype.digest = function() {
        return this.hash.digest();
      }, c.prototype.reset = function() {
        this.hash.reset();
      }, c;
    }()
  );
  return vi.Sha256 = i, vi;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.WebCryptoSha256 = t.Ie11Sha256 = void 0;
  var e = $J;
  e.__exportStar($Q(), t);
  var n = Mx();
  Object.defineProperty(t, "Ie11Sha256", { enumerable: !0, get: function() {
    return n.Sha256;
  } });
  var r = Px();
  Object.defineProperty(t, "WebCryptoSha256", { enumerable: !0, get: function() {
    return r.Sha256;
  } });
})(Dx);
const DQ = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, zx = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, Jt = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, zn = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, Da = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class ie {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(e, n) {
    const r = n.match(e);
    return r && r.length > 0 && r[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(e, n) {
    const r = n.match(e);
    return r && r.length > 1 && r[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(e, n, r) {
    if (e.test(n))
      return r;
  }
  static getWindowsVersionName(e) {
    switch (e) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(e) {
    const n = e.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), n[0] === 10)
      switch (n[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(e) {
    const n = e.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), !(n[0] === 1 && n[1] < 5)) {
      if (n[0] === 1 && n[1] < 6)
        return "Cupcake";
      if (n[0] === 1 && n[1] >= 6)
        return "Donut";
      if (n[0] === 2 && n[1] < 2)
        return "Eclair";
      if (n[0] === 2 && n[1] === 2)
        return "Froyo";
      if (n[0] === 2 && n[1] > 2)
        return "Gingerbread";
      if (n[0] === 3)
        return "Honeycomb";
      if (n[0] === 4 && n[1] < 1)
        return "Ice Cream Sandwich";
      if (n[0] === 4 && n[1] < 4)
        return "Jelly Bean";
      if (n[0] === 4 && n[1] >= 4)
        return "KitKat";
      if (n[0] === 5)
        return "Lollipop";
      if (n[0] === 6)
        return "Marshmallow";
      if (n[0] === 7)
        return "Nougat";
      if (n[0] === 8)
        return "Oreo";
      if (n[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(e) {
    return e.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(e, n, r = !1) {
    const a = ie.getVersionPrecision(e), s = ie.getVersionPrecision(n);
    let o = Math.max(a, s), i = 0;
    const c = ie.map([e, n], (l) => {
      const u = o - ie.getVersionPrecision(l), d = l + new Array(u + 1).join(".0");
      return ie.map(d.split("."), (f) => new Array(20 - f.length).join("0") + f).reverse();
    });
    for (r && (i = o - Math.min(a, s)), o -= 1; o >= i; ) {
      if (c[0][o] > c[1][o])
        return 1;
      if (c[0][o] === c[1][o]) {
        if (o === i)
          return 0;
        o -= 1;
      } else if (c[0][o] < c[1][o])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(e, n) {
    const r = [];
    let a;
    if (Array.prototype.map)
      return Array.prototype.map.call(e, n);
    for (a = 0; a < e.length; a += 1)
      r.push(n(e[a]));
    return r;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(e, n) {
    let r, a;
    if (Array.prototype.find)
      return Array.prototype.find.call(e, n);
    for (r = 0, a = e.length; r < a; r += 1) {
      const s = e[r];
      if (n(s, r))
        return s;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(e, ...n) {
    const r = e;
    let a, s;
    if (Object.assign)
      return Object.assign(e, ...n);
    for (a = 0, s = n.length; a < s; a += 1) {
      const o = n[a];
      typeof o == "object" && o !== null && Object.keys(o).forEach((c) => {
        r[c] = o[c];
      });
    }
    return e;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(e) {
    return DQ[e];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(e) {
    return zx[e] || "";
  }
}
const Ct = /version\/(\d+(\.?_?\d+)+)/i, OQ = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(t) {
      const e = {
        name: "Googlebot"
      }, n = ie.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, n = ie.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(t) {
      const e = {
        name: "Samsung Internet for Android"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/Whale/i],
    describe(t) {
      const e = {
        name: "NAVER Whale Browser"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(t) {
      const e = {
        name: "MZ Browser"
      }, n = ie.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/focus/i],
    describe(t) {
      const e = {
        name: "Focus"
      }, n = ie.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/swing/i],
    describe(t) {
      const e = {
        name: "Swing"
      }, n = ie.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/coast/i],
    describe(t) {
      const e = {
        name: "Opera Coast"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(t) {
      const e = {
        name: "Opera Touch"
      }, n = ie.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/yabrowser/i],
    describe(t) {
      const e = {
        name: "Yandex Browser"
      }, n = ie.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(t) {
      const e = {
        name: "UC Browser"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(t) {
      const e = {
        name: "Maxthon"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/epiphany/i],
    describe(t) {
      const e = {
        name: "Epiphany"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/puffin/i],
    describe(t) {
      const e = {
        name: "Puffin"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/sleipnir/i],
    describe(t) {
      const e = {
        name: "Sleipnir"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/k-meleon/i],
    describe(t) {
      const e = {
        name: "K-Meleon"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/micromessenger/i],
    describe(t) {
      const e = {
        name: "WeChat"
      }, n = ie.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(t) {
      const e = {
        name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser"
      }, n = ie.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/msie|trident/i],
    describe(t) {
      const e = {
        name: "Internet Explorer"
      }, n = ie.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/\sedg\//i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, n = ie.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, n = ie.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/vivaldi/i],
    describe(t) {
      const e = {
        name: "Vivaldi"
      }, n = ie.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/seamonkey/i],
    describe(t) {
      const e = {
        name: "SeaMonkey"
      }, n = ie.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/sailfish/i],
    describe(t) {
      const e = {
        name: "Sailfish"
      }, n = ie.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/silk/i],
    describe(t) {
      const e = {
        name: "Amazon Silk"
      }, n = ie.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/phantom/i],
    describe(t) {
      const e = {
        name: "PhantomJS"
      }, n = ie.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/slimerjs/i],
    describe(t) {
      const e = {
        name: "SlimerJS"
      }, n = ie.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = {
        name: "BlackBerry"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = {
        name: "WebOS Browser"
      }, n = ie.getFirstMatch(Ct, t) || ie.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/bada/i],
    describe(t) {
      const e = {
        name: "Bada"
      }, n = ie.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/tizen/i],
    describe(t) {
      const e = {
        name: "Tizen"
      }, n = ie.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/qupzilla/i],
    describe(t) {
      const e = {
        name: "QupZilla"
      }, n = ie.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(t) {
      const e = {
        name: "Firefox"
      }, n = ie.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/electron/i],
    describe(t) {
      const e = {
        name: "Electron"
      }, n = ie.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(t) {
      const e = {
        name: "Miui"
      }, n = ie.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/chromium/i],
    describe(t) {
      const e = {
        name: "Chromium"
      }, n = ie.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) || ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(t) {
      const e = {
        name: "Chrome"
      }, n = ie.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/GSA/i],
    describe(t) {
      const e = {
        name: "Google Search"
      }, n = ie.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Android Browser */
  {
    test(t) {
      const e = !t.test(/like android/i), n = t.test(/android/i);
      return e && n;
    },
    describe(t) {
      const e = {
        name: "Android Browser"
      }, n = ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(t) {
      const e = {
        name: "PlayStation 4"
      }, n = ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(t) {
      const e = {
        name: "Safari"
      }, n = ie.getFirstMatch(Ct, t);
      return n && (e.version = n), e;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(t) {
      const e = /^(.*)\/(.*) /, n = /^(.*)\/(.*)[ \t]\((.*)/, a = t.search("\\(") !== -1 ? n : e;
      return {
        name: ie.getFirstMatch(a, t),
        version: ie.getSecondMatch(a, t)
      };
    }
  }
], FQ = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(t) {
      const e = ie.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
      return {
        name: zn.Roku,
        version: e
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(t) {
      const e = ie.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
      return {
        name: zn.WindowsPhone,
        version: e
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(t) {
      const e = ie.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t), n = ie.getWindowsVersionName(e);
      return {
        name: zn.Windows,
        version: e,
        versionName: n
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(t) {
      const e = {
        name: zn.iOS
      }, n = ie.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
      return n && (e.version = n), e;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(t) {
      const e = ie.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(/[_\s]/g, "."), n = ie.getMacOSVersionName(e), r = {
        name: zn.MacOS,
        version: e
      };
      return n && (r.versionName = n), r;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(t) {
      const e = ie.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t).replace(/[_\s]/g, ".");
      return {
        name: zn.iOS,
        version: e
      };
    }
  },
  /* Android */
  {
    test(t) {
      const e = !t.test(/like android/i), n = t.test(/android/i);
      return e && n;
    },
    describe(t) {
      const e = ie.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t), n = ie.getAndroidVersionName(e), r = {
        name: zn.Android,
        version: e
      };
      return n && (r.versionName = n), r;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = ie.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t), n = {
        name: zn.WebOS
      };
      return e && e.length && (n.version = e), n;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = ie.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) || ie.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) || ie.getFirstMatch(/\bbb(\d+)/i, t);
      return {
        name: zn.BlackBerry,
        version: e
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(t) {
      const e = ie.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
      return {
        name: zn.Bada,
        version: e
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(t) {
      const e = ie.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: zn.Tizen,
        version: e
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: zn.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: zn.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(t) {
      const e = ie.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: zn.PlayStation4,
        version: e
      };
    }
  }
], MQ = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(t) {
      const e = ie.getFirstMatch(/(can-l01)/i, t) && "Nova", n = {
        type: Jt.mobile,
        vendor: "Huawei"
      };
      return e && (n.model = e), n;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: Jt.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: Jt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: Jt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: Jt.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: Jt.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: Jt.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(t) {
      const e = t.test(/ipod|iphone/i), n = t.test(/like (ipod|iphone)/i);
      return e && !n;
    },
    describe(t) {
      const e = ie.getFirstMatch(/(ipod|iphone)/i, t);
      return {
        type: Jt.mobile,
        vendor: "Apple",
        model: e
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: Jt.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: Jt.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(t) {
      return t.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: Jt.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(t) {
      return t.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: Jt.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(t) {
      return t.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: Jt.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(t) {
      const e = Number(String(t.getOSVersion()).split(".")[0]);
      return t.getOSName(!0) === "android" && e >= 3;
    },
    describe() {
      return {
        type: Jt.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(t) {
      return t.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: Jt.mobile
      };
    }
  },
  /* desktop */
  {
    test(t) {
      return t.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: Jt.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(t) {
      return t.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: Jt.desktop
      };
    }
  },
  /* Linux */
  {
    test(t) {
      return t.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: Jt.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(t) {
      return t.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: Jt.tv
      };
    }
  },
  /* Roku */
  {
    test(t) {
      return t.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: Jt.tv
      };
    }
  }
], PQ = [
  /* EdgeHTML */
  {
    test(t) {
      return t.getBrowserName(!0) === "microsoft edge";
    },
    describe(t) {
      if (/\sedg\//i.test(t))
        return {
          name: Da.Blink
        };
      const n = ie.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
      return {
        name: Da.EdgeHTML,
        version: n
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(t) {
      const e = {
        name: Da.Trident
      }, n = ie.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Presto */
  {
    test(t) {
      return t.test(/presto/i);
    },
    describe(t) {
      const e = {
        name: Da.Presto
      }, n = ie.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Gecko */
  {
    test(t) {
      const e = t.test(/gecko/i), n = t.test(/like gecko/i);
      return e && !n;
    },
    describe(t) {
      const e = {
        name: Da.Gecko
      }, n = ie.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: Da.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(t) {
      const e = {
        name: Da.WebKit
      }, n = ie.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  }
];
class vb {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(e, n = !1) {
    if (e == null || e === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e, this.parsedResult = {}, n !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(e) {
    return e.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const e = ie.find(OQ, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(e) {
    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const e = ie.find(FQ, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS — macOS, Windows, Linux, etc.
   */
  getOSName(e) {
    const { name: n } = this.getOS();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(e = !1) {
    const { type: n } = this.getPlatform();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const e = ie.find(MQ, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(e) {
    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const e = ie.find(PQ, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return ie.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(e) {
    const n = {};
    let r = 0;
    const a = {};
    let s = 0;
    if (Object.keys(e).forEach((i) => {
      const c = e[i];
      typeof c == "string" ? (a[i] = c, s += 1) : typeof c == "object" && (n[i] = c, r += 1);
    }), r > 0) {
      const i = Object.keys(n), c = ie.find(i, (u) => this.isOS(u));
      if (c) {
        const u = this.satisfies(n[c]);
        if (u !== void 0)
          return u;
      }
      const l = ie.find(
        i,
        (u) => this.isPlatform(u)
      );
      if (l) {
        const u = this.satisfies(n[l]);
        if (u !== void 0)
          return u;
      }
    }
    if (s > 0) {
      const i = Object.keys(a), c = ie.find(i, (l) => this.isBrowser(l, !0));
      if (c !== void 0)
        return this.compareVersion(a[c]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(e, n = !1) {
    const r = this.getBrowserName().toLowerCase();
    let a = e.toLowerCase();
    const s = ie.getBrowserTypeByAlias(a);
    return n && s && (a = s.toLowerCase()), a === r;
  }
  compareVersion(e) {
    let n = [0], r = e, a = !1;
    const s = this.getBrowserVersion();
    if (typeof s == "string")
      return e[0] === ">" || e[0] === "<" ? (r = e.substr(1), e[1] === "=" ? (a = !0, r = e.substr(2)) : n = [], e[0] === ">" ? n.push(1) : n.push(-1)) : e[0] === "=" ? r = e.substr(1) : e[0] === "~" && (a = !0, r = e.substr(1)), n.indexOf(
        ie.compareVersions(s, r, a)
      ) > -1;
  }
  isOS(e) {
    return this.getOSName(!0) === String(e).toLowerCase();
  }
  isPlatform(e) {
    return this.getPlatformType(!0) === String(e).toLowerCase();
  }
  isEngine(e) {
    return this.getEngineName(!0) === String(e).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(e, n = !1) {
    return this.isBrowser(e, n) || this.isOS(e) || this.isPlatform(e);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(e = []) {
    return e.some((n) => this.is(n));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Vx {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(e, n = !1) {
    if (typeof e != "string")
      throw new Error("UserAgent should be a string");
    return new vb(e, n);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(e) {
    return new vb(e).getResult();
  }
  static get BROWSER_MAP() {
    return zx;
  }
  static get ENGINE_MAP() {
    return Da;
  }
  static get OS_MAP() {
    return zn;
  }
  static get PLATFORMS_MAP() {
    return Jt;
  }
}
const BQ = ({ serviceId: t, clientVersion: e }) => async () => {
  const n = typeof window < "u" && window?.navigator?.userAgent ? Vx.parse(window.navigator.userAgent) : void 0, r = [
    ["aws-sdk-js", e],
    ["ua", "2.0"],
    [`os/${n?.os?.name || "other"}`, n?.os?.version],
    ["lang/js"],
    ["md/browser", `${n?.browser?.name ?? "unknown"}_${n?.browser?.version ?? "unknown"}`]
  ];
  return t && r.push([`api/${t}`, e]), r;
}, LQ = (t) => () => Promise.reject(t), bb = typeof TextEncoder == "function" ? new TextEncoder() : null, WQ = (t) => {
  if (typeof t == "string") {
    if (bb)
      return bb.encode(t).byteLength;
    let e = t.length;
    for (let n = e - 1; n >= 0; n--) {
      const r = t.charCodeAt(n);
      r > 127 && r <= 2047 ? e++ : r > 2047 && r <= 65535 && (e += 2), r >= 56320 && r <= 57343 && n--;
    }
    return e;
  } else {
    if (typeof t.byteLength == "number")
      return t.byteLength;
    if (typeof t.size == "number")
      return t.size;
  }
  throw new Error(`Body Length computation failed for ${t}`);
}, Hx = "required", pa = "fn", ha = "argv", Uo = "ref", wb = "isSet", Wn = "tree", so = "error", xi = "endpoint", Rg = "PartitionResult", Sb = { [Hx]: !1, type: "String" }, _b = { [Hx]: !0, default: !1, type: "Boolean" }, xb = { [Uo]: "Endpoint" }, jx = { [pa]: "booleanEquals", [ha]: [{ [Uo]: "UseFIPS" }, !0] }, Ux = { [pa]: "booleanEquals", [ha]: [{ [Uo]: "UseDualStack" }, !0] }, qr = {}, Ib = { [pa]: "booleanEquals", [ha]: [!0, { [pa]: "getAttr", [ha]: [{ [Uo]: Rg }, "supportsFIPS"] }] }, kb = { [pa]: "booleanEquals", [ha]: [!0, { [pa]: "getAttr", [ha]: [{ [Uo]: Rg }, "supportsDualStack"] }] }, Eb = [jx], Tb = [Ux], Cb = [{ [Uo]: "Region" }], zQ = { version: "1.0", parameters: { Region: Sb, UseDualStack: _b, UseFIPS: _b, Endpoint: Sb }, rules: [{ conditions: [{ [pa]: wb, [ha]: [xb] }], type: Wn, rules: [{ conditions: Eb, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: so }, { type: Wn, rules: [{ conditions: Tb, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: so }, { endpoint: { url: xb, properties: qr, headers: qr }, type: xi }] }] }, { type: Wn, rules: [{ conditions: [{ [pa]: wb, [ha]: Cb }], type: Wn, rules: [{ conditions: [{ [pa]: "aws.partition", [ha]: Cb, assign: Rg }], type: Wn, rules: [{ conditions: [jx, Ux], type: Wn, rules: [{ conditions: [Ib, kb], type: Wn, rules: [{ type: Wn, rules: [{ endpoint: { url: "https://streaming-rekognition-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: qr, headers: qr }, type: xi }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: so }] }, { conditions: Eb, type: Wn, rules: [{ conditions: [Ib], type: Wn, rules: [{ type: Wn, rules: [{ endpoint: { url: "https://streaming-rekognition-fips.{Region}.{PartitionResult#dnsSuffix}", properties: qr, headers: qr }, type: xi }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: so }] }, { conditions: Tb, type: Wn, rules: [{ conditions: [kb], type: Wn, rules: [{ type: Wn, rules: [{ endpoint: { url: "https://streaming-rekognition.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: qr, headers: qr }, type: xi }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: so }] }, { type: Wn, rules: [{ endpoint: { url: "https://streaming-rekognition.{Region}.{PartitionResult#dnsSuffix}", properties: qr, headers: qr }, type: xi }] }] }] }, { error: "Invalid Configuration: Missing Region", type: so }] }] }, VQ = zQ, HQ = (t, e = {}) => TX(VQ, {
  endpointParams: t,
  logger: e.logger
}), jQ = (t) => ({
  apiVersion: "2022-05-30",
  base64Decoder: t?.base64Decoder ?? Cg,
  base64Encoder: t?.base64Encoder ?? wx,
  disableHostPrefix: t?.disableHostPrefix ?? !1,
  endpointProvider: t?.endpointProvider ?? HQ,
  extensions: t?.extensions ?? [],
  logger: t?.logger ?? new Cx(),
  serviceId: t?.serviceId ?? "RekognitionStreaming",
  urlParser: t?.urlParser ?? rl,
  utf8Decoder: t?.utf8Decoder ?? _u,
  utf8Encoder: t?.utf8Encoder ?? qh
}), UQ = ["in-region", "cross-region", "mobile", "standard", "legacy"], GQ = ({ defaultsMode: t } = {}) => M_(async () => {
  const e = typeof t == "function" ? await t() : t;
  switch (e?.toLowerCase()) {
    case "auto":
      return Promise.resolve(qQ() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(e?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${UQ.join(", ")}, got ${e}`);
  }
}), qQ = () => {
  const e = (typeof window < "u" && window?.navigator?.userAgent ? Vx.parse(window.navigator.userAgent) : void 0)?.platform?.type;
  return e === "tablet" || e === "mobile";
}, KQ = (t) => {
  const e = GQ(t), n = () => e().then(CZ), r = jQ(t);
  return {
    ...r,
    ...t,
    runtime: "browser",
    defaultsMode: e,
    bodyLengthChecker: t?.bodyLengthChecker ?? WQ,
    credentialDefaultProvider: t?.credentialDefaultProvider ?? ((a) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: t?.defaultUserAgentProvider ?? BQ({ serviceId: r.serviceId, clientVersion: dJ.version }),
    eventStreamPayloadHandlerProvider: t?.eventStreamPayloadHandlerProvider ?? PX,
    eventStreamSerdeProvider: t?.eventStreamSerdeProvider ?? eY,
    maxAttempts: t?.maxAttempts ?? al,
    region: t?.region ?? LQ("Region is missing"),
    requestHandler: t?.requestHandler ?? new lY(n, new Ou(n)),
    retryMode: t?.retryMode ?? (async () => (await n()).retryMode || WY),
    sha256: t?.sha256 ?? Dx.Sha256,
    streamCollector: t?.streamCollector ?? sY,
    useDualstackEndpoint: t?.useDualstackEndpoint ?? (() => Promise.resolve(hY)),
    useFipsEndpoint: t?.useFipsEndpoint ?? (() => Promise.resolve(mY))
  };
}, XQ = (t) => t, YQ = (t, e) => {
  const n = {
    ...XQ(DZ(t))
  };
  return e.forEach((r) => r.configure(n)), {
    ...t,
    ...OZ(n)
  };
};
class ZQ extends lZ {
  constructor(...[e]) {
    const n = KQ(e || {}), r = GZ(n), a = gY(r), s = LY(a), o = cZ(s), i = o, c = qK(i), l = yq(c), u = GX(l), d = nX(u), f = yY(d), p = YQ(f, e?.extensions || []);
    super(p), this.config = p, this.middlewareStack.use(jZ(this.config)), this.middlewareStack.use(wY(this.config)), this.middlewareStack.use(Cq(this.config)), this.middlewareStack.use(Rq(this.config)), this.middlewareStack.use(Bq(this.config)), this.middlewareStack.use(tX(this.config)), this.middlewareStack.use(OX(this.config));
  }
  destroy() {
    super.destroy();
  }
}
class na extends Ng {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, na.prototype);
  }
}
class $g extends na {
  constructor(e) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...e
    }), this.name = "AccessDeniedException", this.$fault = "client", Object.setPrototypeOf(this, $g.prototype), this.Message = e.Message, this.Code = e.Code;
  }
}
var zh;
(function(t) {
  t.visit = (e, n) => e.FaceMovementAndLightChallenge !== void 0 ? n.FaceMovementAndLightChallenge(e.FaceMovementAndLightChallenge) : n._(e.$unknown[0], e.$unknown[1]);
})(zh || (zh = {}));
class Dg extends na {
  constructor(e) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...e
    }), this.name = "InternalServerException", this.$fault = "server", Object.setPrototypeOf(this, Dg.prototype), this.Message = e.Message, this.Code = e.Code;
  }
}
var Vh;
(function(t) {
  t.visit = (e, n) => e.VideoEvent !== void 0 ? n.VideoEvent(e.VideoEvent) : e.ClientSessionInformationEvent !== void 0 ? n.ClientSessionInformationEvent(e.ClientSessionInformationEvent) : n._(e.$unknown[0], e.$unknown[1]);
})(Vh || (Vh = {}));
var Nb;
(function(t) {
  t.visit = (e, n) => e.FaceMovementAndLightChallenge !== void 0 ? n.FaceMovementAndLightChallenge(e.FaceMovementAndLightChallenge) : n._(e.$unknown[0], e.$unknown[1]);
})(Nb || (Nb = {}));
class Og extends na {
  constructor(e) {
    super({
      name: "ServiceQuotaExceededException",
      $fault: "client",
      ...e
    }), this.name = "ServiceQuotaExceededException", this.$fault = "client", Object.setPrototypeOf(this, Og.prototype), this.Message = e.Message, this.Code = e.Code;
  }
}
class Fg extends na {
  constructor(e) {
    super({
      name: "ServiceUnavailableException",
      $fault: "server",
      ...e
    }), this.name = "ServiceUnavailableException", this.$fault = "server", Object.setPrototypeOf(this, Fg.prototype), this.Message = e.Message, this.Code = e.Code;
  }
}
class Mg extends na {
  constructor(e) {
    super({
      name: "ThrottlingException",
      $fault: "client",
      ...e
    }), this.name = "ThrottlingException", this.$fault = "client", Object.setPrototypeOf(this, Mg.prototype), this.Message = e.Message, this.Code = e.Code;
  }
}
class Pg extends na {
  constructor(e) {
    super({
      name: "ValidationException",
      $fault: "client",
      ...e
    }), this.name = "ValidationException", this.$fault = "client", Object.setPrototypeOf(this, Pg.prototype), this.Message = e.Message, this.Code = e.Code;
  }
}
var Ab;
(function(t) {
  t.visit = (e, n) => e.ServerSessionInformationEvent !== void 0 ? n.ServerSessionInformationEvent(e.ServerSessionInformationEvent) : e.DisconnectionEvent !== void 0 ? n.DisconnectionEvent(e.DisconnectionEvent) : e.ValidationException !== void 0 ? n.ValidationException(e.ValidationException) : e.InternalServerException !== void 0 ? n.InternalServerException(e.InternalServerException) : e.ThrottlingException !== void 0 ? n.ThrottlingException(e.ThrottlingException) : e.ServiceQuotaExceededException !== void 0 ? n.ServiceQuotaExceededException(e.ServiceQuotaExceededException) : e.ServiceUnavailableException !== void 0 ? n.ServiceUnavailableException(e.ServiceUnavailableException) : n._(e.$unknown[0], e.$unknown[1]);
})(Ab || (Ab = {}));
class Bg extends na {
  constructor(e) {
    super({
      name: "SessionNotFoundException",
      $fault: "client",
      ...e
    }), this.name = "SessionNotFoundException", this.$fault = "client", Object.setPrototypeOf(this, Bg.prototype), this.Message = e.Message, this.Code = e.Code;
  }
}
const JQ = (t) => ({
  ...t,
  ...t.LivenessRequestStream && { LivenessRequestStream: "STREAMING_CONTENT" }
}), QQ = (t) => ({
  ...t,
  ...t.LivenessResponseStream && { LivenessResponseStream: "STREAMING_CONTENT" }
});
class Lg {
  constructor(e) {
    this.method = e.method || "GET", this.hostname = e.hostname || "localhost", this.port = e.port, this.query = e.query || {}, this.headers = e.headers || {}, this.body = e.body, this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:", this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/", this.username = e.username, this.password = e.password, this.fragment = e.fragment;
  }
  static isInstance(e) {
    if (!e)
      return !1;
    const n = e;
    return "method" in n && "protocol" in n && "hostname" in n && "path" in n && typeof n.query == "object" && typeof n.headers == "object";
  }
  clone() {
    const e = new Lg({
      ...this,
      headers: { ...this.headers }
    });
    return e.query && (e.query = eee(e.query)), e;
  }
}
function eee(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return {
      ...e,
      [n]: Array.isArray(r) ? [...r] : r
    };
  }, {});
}
const tee = async (t, e) => {
  const { hostname: n, protocol: r = "https", port: a, path: s } = await e.endpoint(), o = ta({}, Dee, {
    "x-amz-rekognition-streaming-liveness-session-id": t.SessionId,
    "x-amz-rekognition-streaming-liveness-video-width": t.VideoWidth,
    "x-amz-rekognition-streaming-liveness-video-height": t.VideoHeight,
    "x-amz-rekognition-streaming-liveness-challenge-versions": t.ChallengeVersions
  }), i = `${s?.endsWith("/") ? s.slice(0, -1) : s || ""}/start-face-liveness-session`;
  let c;
  return t.LivenessRequestStream !== void 0 && (c = iee(t.LivenessRequestStream, e)), new Lg({
    protocol: r,
    hostname: n,
    port: a,
    method: "POST",
    headers: o,
    path: i,
    body: c
  });
}, nee = async (t, e) => {
  if (t.statusCode !== 200 && t.statusCode >= 300)
    return ree(t, e);
  const n = ta({
    $metadata: as(t),
    SessionId: [, t.headers["x-amz-rekognition-streaming-liveness-session-id"]]
  }), r = t.body;
  return n.LivenessResponseStream = lee(r, e), n;
}, ree = async (t, e) => {
  const n = {
    ...t,
    body: await Oee(t.body, e)
  }, r = Fee(t, n.body);
  switch (r) {
    case "AccessDeniedException":
    case "com.amazonaws.rekognitionstreaming#AccessDeniedException":
      throw await see(n);
    case "InternalServerException":
    case "com.amazonaws.rekognitionstreaming#InternalServerException":
      throw await Gx(n);
    case "ServiceQuotaExceededException":
    case "com.amazonaws.rekognitionstreaming#ServiceQuotaExceededException":
      throw await qx(n);
    case "ServiceUnavailableException":
    case "com.amazonaws.rekognitionstreaming#ServiceUnavailableException":
      throw await Kx(n);
    case "SessionNotFoundException":
    case "com.amazonaws.rekognitionstreaming#SessionNotFoundException":
      throw await oee(n);
    case "ThrottlingException":
    case "com.amazonaws.rekognitionstreaming#ThrottlingException":
      throw await Xx(n);
    case "ValidationException":
    case "com.amazonaws.rekognitionstreaming#ValidationException":
      throw await Yx(n);
    default:
      const a = n.body;
      return aee({
        output: t,
        parsedBody: a,
        errorCode: r
      });
  }
}, aee = EZ(na), see = async (t, e) => {
  const n = ta({}), r = t.body, a = fn(r, {
    Code: qn,
    Message: qn
  });
  Object.assign(n, a);
  const s = new $g({
    $metadata: as(t),
    ...n
  });
  return rs(s, t.body);
}, Gx = async (t, e) => {
  const n = ta({}), r = t.body, a = fn(r, {
    Code: qn,
    Message: qn
  });
  Object.assign(n, a);
  const s = new Dg({
    $metadata: as(t),
    ...n
  });
  return rs(s, t.body);
}, qx = async (t, e) => {
  const n = ta({}), r = t.body, a = fn(r, {
    Code: qn,
    Message: qn
  });
  Object.assign(n, a);
  const s = new Og({
    $metadata: as(t),
    ...n
  });
  return rs(s, t.body);
}, Kx = async (t, e) => {
  const n = ta({}), r = t.body, a = fn(r, {
    Code: qn,
    Message: qn
  });
  Object.assign(n, a);
  const s = new Fg({
    $metadata: as(t),
    ...n
  });
  return rs(s, t.body);
}, oee = async (t, e) => {
  const n = ta({}), r = t.body, a = fn(r, {
    Code: qn,
    Message: qn
  });
  Object.assign(n, a);
  const s = new Bg({
    $metadata: as(t),
    ...n
  });
  return rs(s, t.body);
}, Xx = async (t, e) => {
  const n = ta({}), r = t.body, a = fn(r, {
    Code: qn,
    Message: qn
  });
  Object.assign(n, a);
  const s = new Mg({
    $metadata: as(t),
    ...n
  });
  return rs(s, t.body);
}, Yx = async (t, e) => {
  const n = ta({}), r = t.body, a = fn(r, {
    Code: qn,
    Message: qn
  });
  Object.assign(n, a);
  const s = new Pg({
    $metadata: as(t),
    ...n
  });
  return rs(s, t.body);
}, iee = (t, e) => {
  const n = (r) => Vh.visit(r, {
    VideoEvent: (a) => cee(a, e),
    ClientSessionInformationEvent: (a) => uee(a, e),
    _: (a) => a
  });
  return e.eventStreamMarshaller.serialize(t, n);
}, uee = (t, e) => {
  const n = {
    ":event-type": { type: "string", value: "ClientSessionInformationEvent" },
    ":message-type": { type: "string", value: "event" },
    ":content-type": { type: "string", value: "application/json" }
  };
  let r = new Uint8Array();
  return r = bee(t), r = e.utf8Decoder(JSON.stringify(r)), { headers: n, body: r };
}, cee = (t, e) => {
  const n = {
    ":event-type": { type: "string", value: "VideoEvent" },
    ":message-type": { type: "string", value: "event" },
    ":content-type": { type: "string", value: "application/json" }
  };
  let r = new Uint8Array();
  return r = xee(t, e), r = e.utf8Decoder(JSON.stringify(r)), { headers: n, body: r };
}, lee = (t, e) => e.eventStreamMarshaller.deserialize(t, async (n) => n.ServerSessionInformationEvent != null ? {
  ServerSessionInformationEvent: await pee(n.ServerSessionInformationEvent, e)
} : n.DisconnectionEvent != null ? {
  DisconnectionEvent: await dee(n.DisconnectionEvent, e)
} : n.ValidationException != null ? {
  ValidationException: await yee(n.ValidationException, e)
} : n.InternalServerException != null ? {
  InternalServerException: await fee(n.InternalServerException, e)
} : n.ThrottlingException != null ? {
  ThrottlingException: await gee(n.ThrottlingException, e)
} : n.ServiceQuotaExceededException != null ? {
  ServiceQuotaExceededException: await hee(n.ServiceQuotaExceededException, e)
} : n.ServiceUnavailableException != null ? {
  ServiceUnavailableException: await mee(n.ServiceUnavailableException, e)
} : { $unknown: t }), dee = async (t, e) => {
  const n = {}, r = await ss(t.body, e);
  return Object.assign(n, yu(r)), n;
}, fee = async (t, e) => {
  const n = {
    ...t,
    body: await ss(t.body, e)
  };
  return Gx(n);
}, pee = async (t, e) => {
  const n = {}, r = await ss(t.body, e);
  return Object.assign(n, Aee(r)), n;
}, hee = async (t, e) => {
  const n = {
    ...t,
    body: await ss(t.body, e)
  };
  return qx(n);
}, mee = async (t, e) => {
  const n = {
    ...t,
    body: await ss(t.body, e)
  };
  return Kx(n);
}, gee = async (t, e) => {
  const n = {
    ...t,
    body: await ss(t.body, e)
  };
  return Xx(n);
}, yee = async (t, e) => {
  const n = {
    ...t,
    body: await ss(t.body, e)
  };
  return Yx(n);
}, Zx = (t, e) => fn(t, {
  Height: fc,
  Left: fc,
  Top: fc,
  Width: fc
}), vee = (t, e) => zh.visit(t, {
  FaceMovementAndLightChallenge: (n) => ({
    FaceMovementAndLightChallenge: wee(n)
  }),
  _: (n, r) => ({ name: r })
}), bee = (t, e) => fn(t, {
  Challenge: (n) => vee(n)
}), wee = (t, e) => fn(t, {
  ChallengeId: [],
  ColorDisplayed: yu,
  InitialFace: (n) => See(n),
  TargetFace: (n) => _ee(n),
  VideoEndTimestamp: [],
  VideoStartTimestamp: []
}), See = (t, e) => fn(t, {
  BoundingBox: (n) => Zx(n),
  InitialFaceDetectedTimestamp: []
}), _ee = (t, e) => fn(t, {
  BoundingBox: (n) => Zx(n),
  FaceDetectedInTargetPositionEndTimestamp: [],
  FaceDetectedInTargetPositionStartTimestamp: []
}), xee = (t, e) => fn(t, {
  TimestampMillis: [],
  VideoChunk: e.base64Encoder
}), Iee = (t, e) => fn(t, {
  BlazeFaceDetectionThreshold: Nn,
  FaceDistanceThreshold: Nn,
  FaceDistanceThresholdMax: Nn,
  FaceDistanceThresholdMin: Nn,
  FaceIouHeightThreshold: Nn,
  FaceIouWidthThreshold: Nn,
  OvalFitTimeout: bZ,
  OvalHeightWidthRatio: Nn,
  OvalIouHeightThreshold: Nn,
  OvalIouThreshold: Nn,
  OvalIouWidthThreshold: Nn
}), kee = (t, e) => fn(t, {
  DownscrollDuration: Nn,
  FlatDisplayDuration: Nn,
  FreshnessColor: yu
}), Eee = (t, e) => (t || []).filter((r) => r != null).map((r) => kee(r)), Tee = (t, e) => fn(t, {
  ChallengeConfig: (n) => Iee(n),
  ColorSequences: (n) => Eee(n),
  LightChallengeType: qn,
  OvalParameters: (n) => Cee(n)
}), Cee = (t, e) => fn(t, {
  CenterX: Nn,
  CenterY: Nn,
  Height: Nn,
  Width: Nn
}), Nee = (t, e) => t.FaceMovementAndLightChallenge != null ? {
  FaceMovementAndLightChallenge: Tee(t.FaceMovementAndLightChallenge)
} : { $unknown: Object.entries(t)[0] }, Aee = (t, e) => fn(t, {
  SessionInformation: (n) => Ree(n)
}), Ree = (t, e) => fn(t, {
  Challenge: (n) => Nee(xZ(n))
}), as = (t) => ({
  httpStatusCode: t.statusCode,
  requestId: t.headers["x-amzn-requestid"] ?? t.headers["x-amzn-request-id"] ?? t.headers["x-amz-request-id"],
  extendedRequestId: t.headers["x-amz-id-2"],
  cfId: t.headers["x-amz-cf-id"]
}), $ee = (t, e) => pZ(t, e).then((n) => e.utf8Encoder(n)), Dee = (t) => t != null && t !== "" && (!Object.getOwnPropertyNames(t).includes("length") || t.length != 0) && (!Object.getOwnPropertyNames(t).includes("size") || t.size != 0), ss = (t, e) => $ee(t, e).then((n) => n.length ? JSON.parse(n) : {}), Oee = async (t, e) => {
  const n = await ss(t, e);
  return n.message = n.message ?? n.Message, n;
}, Fee = (t, e) => {
  const n = (s, o) => Object.keys(s).find((i) => i.toLowerCase() === o.toLowerCase()), r = (s) => {
    let o = s;
    return typeof o == "number" && (o = o.toString()), o.indexOf(",") >= 0 && (o = o.split(",")[0]), o.indexOf(":") >= 0 && (o = o.split(":")[0]), o.indexOf("#") >= 0 && (o = o.split("#")[1]), o;
  }, a = n(t.headers, "x-amzn-errortype");
  if (a !== void 0)
    return r(t.headers[a]);
  if (e.code !== void 0)
    return r(e.code);
  if (e.__type !== void 0)
    return r(e.__type);
};
class Wg extends Nx {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(e) {
    super(), this.input = e;
  }
  resolveMiddleware(e, n, r) {
    this.middlewareStack.use(MY(n, this.serialize, this.deserialize)), this.middlewareStack.use(BY(n, Wg.getEndpointParameterInstructions())), this.middlewareStack.use(xq(n)), this.middlewareStack.use(jX(n, { headerPrefix: "x-amz-rekognition-streaming-liveness-" }));
    const a = e.concat(this.middlewareStack), { logger: s } = n, c = {
      logger: s,
      clientName: "RekognitionStreamingClient",
      commandName: "StartFaceLivenessSessionCommand",
      inputFilterSensitiveLog: JQ,
      outputFilterSensitiveLog: QQ
    }, { requestHandler: l } = n;
    return a.resolve((u) => l.handle(u.request, r || {}), c);
  }
  serialize(e, n) {
    return tee(e, n);
  }
  deserialize(e, n) {
    return nee(e, n);
  }
}
var Mee = "3.0.13", Pee = "ui-react-liveness/".concat(Mee), Bee = function() {
  return Pee;
};
function Lee(t) {
  const { port: e, query: n } = t;
  let { protocol: r, path: a, hostname: s } = t;
  r && r.slice(-1) !== ":" && (r += ":"), e && (s += `:${e}`), a && a.charAt(0) !== "/" && (a = `/${a}`);
  let o = n ? kg(n) : "";
  o && o[0] !== "?" && (o = `?${o}`);
  let i = "";
  if (t.username != null || t.password != null) {
    const l = t.username ?? "", u = t.password ?? "";
    i = `${l}:${u}@`;
  }
  let c = "";
  return t.fragment && (c = `#${t.fragment}`), `${r}//${i}${s}${a}${o}${c}`;
}
var Wee = 2e3, zee = function(t) {
  return t.protocol === "ws:" || t.protocol === "wss:";
}, Vee = function(t) {
  return typeof ReadableStream == "function" && t instanceof ReadableStream;
}, Hee = function(t) {
  var e;
  return t[Symbol.asyncIterator] ? t : Vee(t) ? Eg(t) : (e = {}, e[Symbol.asyncIterator] = function() {
    return r0(this, arguments, function() {
      return tt(this, function(n) {
        switch (n.label) {
          case 0:
            return [4, Or(t)];
          case 1:
            return [4, n.sent()];
          case 2:
            return n.sent(), [
              2
              /*return*/
            ];
        }
      });
    });
  }, e);
}, jee = function(t) {
  return typeof ReadableStream == "function" ? Tg(t) : t;
}, Uee = (
  /** @class */
  function() {
    function t(e, n) {
      n === void 0 && (n = new Ou()), this.metadata = {
        handlerProtocol: "websocket/h1.1"
      }, this.sockets = {}, this.utf8decoder = new TextDecoder(), this.httpHandler = n, typeof e == "function" ? this.configPromise = e().then(function(r) {
        return r ?? {};
      }) : this.configPromise = Promise.resolve(e ?? {});
    }
    return t.prototype.destroy = function() {
      for (var e = 0, n = Object.entries(this.sockets); e < n.length; e++) {
        for (var r = n[e], a = r[0], s = r[1], o = 0, i = s; o < i.length; o++) {
          var c = i[o];
          c.close(1e3, "Socket closed through destroy() call");
        }
        delete this.sockets[a];
      }
    }, t.prototype.handle = function(e) {
      return ot(this, void 0, void 0, function() {
        var n, r, a, s, o, i, c, l;
        return tt(this, function(u) {
          switch (u.label) {
            case 0:
              return zee(e) ? (n = Lee(e), r = new WebSocket(n), this.sockets[n] || (this.sockets[n] = []), this.sockets[n].push(r), r.binaryType = "arraybuffer", [4, this.configPromise]) : [2, this.httpHandler.handle(e)];
            case 1:
              return a = u.sent().connectionTimeout, s = a === void 0 ? Wee : a, [4, this.waitForReady(r, s)];
            case 2:
              return u.sent(), o = e.body, i = Hee(o), c = this.connect(r, i), l = jee(c), [2, {
                response: new nl({
                  statusCode: 200,
                  // indicates connection success
                  body: l
                })
              }];
          }
        });
      });
    }, t.prototype.removeNotUsableSockets = function(e) {
      var n;
      this.sockets[e] = ((n = this.sockets[e]) !== null && n !== void 0 ? n : []).filter(function(r) {
        return ![WebSocket.CLOSING, WebSocket.CLOSED].includes(r.readyState);
      });
    }, t.prototype.waitForReady = function(e, n) {
      var r = this;
      return new Promise(function(a, s) {
        var o = setTimeout(function() {
          r.removeNotUsableSockets(e.url), s({
            $metadata: {
              httpStatusCode: 500
            }
          });
        }, n);
        e.onopen = function() {
          clearTimeout(o), a();
        };
      });
    }, t.prototype.connect = function(e, n) {
      var r, a = this, s = void 0, o = !1, i = function() {
      }, c = function() {
      };
      e.onmessage = function(d) {
        c({
          done: !1,
          value: new Uint8Array(d.data)
        });
      }, e.onerror = function(d) {
        o = !0, e.close(), i(d);
      }, e.onclose = function() {
        a.removeNotUsableSockets(e.url), !o && (s ? i(s) : c({
          done: !0,
          value: void 0
          // unchecked because done=true.
        }));
      };
      var l = (r = {}, r[Symbol.asyncIterator] = function() {
        return {
          next: function() {
            return new Promise(function(d, f) {
              c = d, i = f;
            });
          }
        };
      }, r), u = function() {
        return ot(a, void 0, void 0, function() {
          var d, f, p, h, m, g, v, b, w, S, I, E, T;
          return tt(this, function(R) {
            switch (R.label) {
              case 0:
                R.trys.push([0, 13, 14, 15]), R.label = 1;
              case 1:
                R.trys.push([1, 6, 7, 12]), d = !0, f = a0(n), R.label = 2;
              case 2:
                return [4, f.next()];
              case 3:
                if (p = R.sent(), S = p.done, !!S)
                  return [3, 5];
                if (T = p.value, d = !1, h = T, m = this.utf8decoder.decode(h), m.includes("closeCode"))
                  return g = m.match(/"closeCode":([0-9]*)/), g && (v = g[1], e.close(parseInt(v))), [3, 4];
                e.send(h), R.label = 4;
              case 4:
                return d = !0, [3, 2];
              case 5:
                return [3, 12];
              case 6:
                return b = R.sent(), I = { error: b }, [3, 12];
              case 7:
                return R.trys.push([7, , 10, 11]), !d && !S && (E = f.return) ? [4, E.call(f)] : [3, 9];
              case 8:
                R.sent(), R.label = 9;
              case 9:
                return [3, 11];
              case 10:
                if (I)
                  throw I.error;
                return [
                  7
                  /*endfinally*/
                ];
              case 11:
                return [
                  7
                  /*endfinally*/
                ];
              case 12:
                return [3, 15];
              case 13:
                return w = R.sent(), s = w, [3, 15];
              case 14:
                return e.close(co.SUCCESS_CODE), [
                  7
                  /*endfinally*/
                ];
              case 15:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      return u(), l;
    }, t;
  }()
), Gee = 1e3;
function qee(t) {
  return t.arrayBuffer !== void 0;
}
function Kee(t) {
  return t.Challenge !== void 0;
}
function Xee(t) {
  return t.code !== void 0;
}
var Yee = (
  /** @class */
  function() {
    function t(e) {
      var n = e.sessionId, r = e.region, a = e.stream, s = e.videoEl, o = e.credentialProvider, i = e.endpointOverride;
      this.sessionId = n, this.region = r, this._stream = a, this.videoEl = s, this.videoRecorder = new gq(a), this.credentialProvider = o, this.endpointOverride = i, this.initPromise = this.init();
    }
    return t.prototype.getResponseStream = function() {
      return ot(this, void 0, void 0, function() {
        return tt(this, function(e) {
          switch (e.label) {
            case 0:
              return [4, this.initPromise];
            case 1:
              return e.sent(), [2, this.responseStream];
          }
        });
      });
    }, t.prototype.startRecordingLivenessVideo = function() {
      this.videoRecorder.start(Gee);
    }, t.prototype.sendClientInfo = function(e) {
      this.videoRecorder.dispatch(new MessageEvent("clientSesssionInfo", {
        data: { clientInfo: e }
      }));
    }, t.prototype.stopVideo = function() {
      return ot(this, void 0, void 0, function() {
        return tt(this, function(e) {
          switch (e.label) {
            case 0:
              return [4, this.videoRecorder.stop()];
            case 1:
              return e.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.dispatchStopVideoEvent = function() {
      this.videoRecorder.dispatch(new Event("stopVideo"));
    }, t.prototype.endStreamWithCode = function(e) {
      return ot(this, void 0, void 0, function() {
        return tt(this, function(n) {
          switch (n.label) {
            case 0:
              return this.videoRecorder.getState() !== "recording" ? [3, 2] : [4, this.stopVideo()];
            case 1:
              n.sent(), n.label = 2;
            case 2:
              return this.videoRecorder.dispatch(new MessageEvent("endStreamWithCode", {
                data: { code: e }
              })), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.init = function() {
      var e;
      return ot(this, void 0, void 0, function() {
        var n, r, a, s, o;
        return tt(this, function(i) {
          switch (i.label) {
            case 0:
              return (e = this.credentialProvider) !== null && e !== void 0 ? (r = e, [3, 3]) : [3, 1];
            case 1:
              return [4, i0()];
            case 2:
              r = i.sent().credentials, i.label = 3;
            case 3:
              if (n = r, !n)
                throw new Error("No credentials");
              return a = {
                credentials: n,
                region: this.region,
                customUserAgent: "".concat(YI(), " ").concat(Bee()),
                requestHandler: new Uee({
                  connectionTimeout: 1e4
                })
              }, this.endpointOverride && (s = this.endpointOverride, a.endpointProvider = function() {
                var c = new URL(s);
                return { url: c };
              }), this._client = new ZQ(a), o = this, [4, this.startLivenessVideoConnection()];
            case 4:
              return o.responseStream = i.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.getAsyncGeneratorFromReadableStream = function(e) {
      var n = this;
      return this._reader = e.getReader(), function() {
        return r0(this, arguments, function() {
          var r, a, s, o, i;
          return tt(this, function(c) {
            switch (c.label) {
              case 0:
                return [4, Or(n._reader.read())];
              case 1:
                return r = c.sent(), a = r.done, s = r.value, a ? [4, Or(void 0)] : [3, 3];
              case 2:
                return [2, c.sent()];
              case 3:
                return s !== "stopVideo" ? [3, 6] : [4, Or({
                  VideoEvent: {
                    VideoChunk: [],
                    TimestampMillis: Date.now()
                  }
                })];
              case 4:
                return [4, c.sent()];
              case 5:
                return c.sent(), [3, 17];
              case 6:
                return qee(s) ? [4, Or(s.arrayBuffer())] : [3, 11];
              case 7:
                return o = c.sent(), i = new Uint8Array(o), i.length > 0 ? [4, Or({
                  VideoEvent: {
                    VideoChunk: i,
                    TimestampMillis: Date.now()
                  }
                })] : [3, 10];
              case 8:
                return [4, c.sent()];
              case 9:
                c.sent(), c.label = 10;
              case 10:
                return [3, 17];
              case 11:
                return Kee(s) ? [4, Or({
                  ClientSessionInformationEvent: {
                    Challenge: s.Challenge
                  }
                })] : [3, 14];
              case 12:
                return [4, c.sent()];
              case 13:
                return c.sent(), [3, 17];
              case 14:
                return Xee(s) ? [4, Or({
                  VideoEvent: {
                    VideoChunk: [],
                    TimestampMillis: { closeCode: s.code }
                  }
                })] : [3, 17];
              case 15:
                return [4, c.sent()];
              case 16:
                c.sent(), c.label = 17;
              case 17:
                return [3, 0];
              case 18:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    }, t.prototype.startLivenessVideoConnection = function() {
      return ot(this, void 0, void 0, function() {
        var e, n;
        return tt(this, function(r) {
          switch (r.label) {
            case 0:
              return e = this.getAsyncGeneratorFromReadableStream(this.videoRecorder.videoStream)(), [4, this._client.send(new Wg({
                ChallengeVersions: "FaceMovementAndLightChallenge_1.0.0",
                SessionId: this.sessionId,
                LivenessRequestStream: e,
                VideoWidth: this.videoEl.videoWidth.toString(),
                VideoHeight: this.videoEl.videoHeight.toString()
              }))];
            case 1:
              return n = r.sent(), [2, n.LivenessResponseStream];
          }
        });
      });
    }, t;
  }()
), Zee = 10, Rr;
(function(t) {
  t.SCROLLING = "SCROLLING", t.FLAT = "FLAT";
})(Rr || (Rr = {}));
var Jee = (
  /** @class */
  function() {
    function t(e, n) {
      this.context = e, this.freshnessColorsSequence = n, this.isFirstTick = !0;
    }
    return t.prototype.displayColorTick = function() {
      return ot(this, void 0, void 0, function() {
        var e = this;
        return tt(this, function(n) {
          return [2, new Promise(function(r, a) {
            setTimeout(function() {
              e.displayNextColorTick(r, a);
            }, Math.min(Zee));
          })];
        });
      });
    }, t.prototype.init = function() {
      this.stageIndex = 0, this.currColorIndex = 0, this.currColorSequence = this.freshnessColorsSequence[0], this.prevColorSequence = this.freshnessColorsSequence[0], this.stage = Rr.FLAT, this.timeLastFlatOrScrollChange = Date.now(), this.timeLastFaceMatchChecked = Date.now();
    }, t.prototype.displayNextColorTick = function(e, n) {
      var r = this.context.freshnessColorAssociatedParams.freshnessColorEl, a = this.context.ovalAssociatedParams, s = a.ovalDetails, o = a.scaleFactor, i = this.context.videoAssociatedParams.videoEl, c = Date.now();
      this.isFirstTick && (this.init(), this.isFirstTick = !1, this.sendColorStartTime({
        tickStartTime: c,
        currColor: this.currColorSequence.color,
        prevColor: this.currColorSequence.color,
        currColorIndex: this.stageIndex
      }));
      var l = c - this.timeLastFlatOrScrollChange;
      if (r.style.display = "block", (this.stage === Rr.FLAT && l >= this.currColorSequence.flatDisplayDuration || this.stage === Rr.SCROLLING && l >= this.currColorSequence.downscrollDuration) && (this.incrementStageIndex(c), l = 0), this.currColorIndex < this.freshnessColorsSequence.length) {
        var u = l / (this.stage === Rr.SCROLLING ? this.currColorSequence.downscrollDuration : this.currColorSequence.flatDisplayDuration);
        QE({
          overlayCanvas: r,
          prevColor: this.prevColorSequence.color,
          nextColor: this.currColorSequence.color,
          videoEl: i,
          ovalDetails: s,
          heightFraction: u,
          scaleFactor: o
        }), e(!1);
      } else
        r.style.display = "none", e(!0);
    }, t.prototype.incrementStageIndex = function(e) {
      if (this.stageIndex += 1, this.prevColorSequence = this.freshnessColorsSequence[this.currColorIndex], this.stage === Rr.FLAT)
        this.currColorIndex += 1, this.stage = Rr.SCROLLING;
      else if (this.stage === Rr.SCROLLING) {
        var n = this.freshnessColorsSequence[this.currColorIndex];
        n.flatDisplayDuration > 0 ? this.stage = Rr.FLAT : (this.stage = Rr.SCROLLING, this.currColorIndex += 1);
      }
      this.currColorSequence = this.freshnessColorsSequence[this.currColorIndex], this.timeLastFlatOrScrollChange = Date.now(), this.currColorSequence && this.sendColorStartTime({
        tickStartTime: e,
        currColor: this.currColorSequence.color,
        prevColor: this.prevColorSequence.color,
        currColorIndex: this.stageIndex
      });
    }, t.prototype.sendColorStartTime = function(e) {
      var n = e.tickStartTime, r = e.currColor, a = e.prevColor, s = e.currColorIndex, o = this.context, i = o.livenessStreamProvider, c = o.challengeId;
      i.sendClientInfo({
        Challenge: {
          FaceMovementAndLightChallenge: {
            ChallengeId: c,
            ColorDisplayed: {
              CurrentColor: { RGB: Py(r) },
              PreviousColor: { RGB: Py(a) },
              SequenceNumber: s,
              CurrentColorStartTimestamp: n
            }
          }
        }
      });
    }, t;
  }()
);
let Rb = (t = 21) => {
  let e = "", n = crypto.getRandomValues(new Uint8Array(t));
  for (; t--; ) {
    let r = n[t] & 63;
    r < 36 ? e += r.toString(36) : r < 62 ? e += (r - 26).toString(36).toUpperCase() : r < 63 ? e += "_" : e += "-";
  }
  return e;
};
var Qee = function(t) {
  return !!t?.ServerSessionInformationEvent;
}, ete = function(t) {
  return !!t?.DisconnectionEvent;
}, tte = function(t) {
  return !!t?.ValidationException;
}, nte = function(t) {
  return !!t?.InternalServerException;
}, rte = function(t) {
  return !!t?.ThrottlingException;
}, ate = function(t) {
  return !!t?.ServiceQuotaExceededException;
}, ste = function(t) {
  var e = t, n = e.message, r = e.name;
  return r === "InvalidSignatureException" && n.includes("valid region");
}, ol = {
  width: {
    min: 320,
    ideal: 640
  },
  height: {
    min: 240,
    ideal: 480
  },
  frameRate: { min: 15, ideal: 30, max: 30 },
  facingMode: "user"
}, ote = 1e3, ite = 7e3, Jx, Qx = "AmplifyLivenessCameraId";
function ute() {
  return localStorage.getItem(Qx);
}
function $b(t) {
  localStorage.setItem(Qx, t);
}
var cte = RE({
  id: "livenessMachine",
  initial: "cameraCheck",
  predictableActionArguments: !0,
  context: {
    challengeId: Rb(),
    maxFailedAttempts: 0,
    // Set to 0 for now as we are not allowing front end based retries for streaming
    failedAttempts: 0,
    componentProps: void 0,
    serverSessionInformation: void 0,
    videoAssociatedParams: {
      videoConstraints: ol,
      selectableDevices: []
    },
    ovalAssociatedParams: void 0,
    faceMatchAssociatedParams: {
      illuminationState: void 0,
      faceMatchState: void 0,
      /**
       * faceMatchPercentage is a starting point we set as a baseline
       * for what we want our progress bar to visually start at. This correlates
       * to the formula we use to calculate the faceMatchPercentage
       * in getFaceMatchStateInLivenessOval
       */
      faceMatchPercentage: 25,
      currentDetectedFace: void 0,
      startFace: void 0,
      endFace: void 0,
      initialFaceMatchTime: void 0
    },
    freshnessColorAssociatedParams: {
      freshnessColorEl: void 0,
      freshnessColors: [],
      freshnessColorsComplete: !1,
      freshnessColorDisplay: void 0
    },
    errorState: void 0,
    livenessStreamProvider: void 0,
    responseStreamActorRef: void 0,
    shouldDisconnect: !1,
    faceMatchStateBeforeStart: void 0,
    isFaceFarEnoughBeforeRecording: void 0,
    isRecordingStopped: !1
  },
  on: {
    CANCEL: "userCancel",
    TIMEOUT: {
      target: "retryableTimeout",
      actions: "updateErrorStateForTimeout"
    },
    SET_SESSION_INFO: {
      internal: !0,
      actions: "updateSessionInfo"
    },
    DISCONNECT_EVENT: {
      internal: !0,
      actions: "updateShouldDisconnect"
    },
    SET_DOM_AND_CAMERA_DETAILS: {
      actions: "setDOMAndCameraDetails"
    },
    UPDATE_DEVICE_AND_STREAM: {
      actions: "updateDeviceAndStream"
    },
    SERVER_ERROR: {
      target: "error",
      actions: "updateErrorStateForServer"
    },
    RUNTIME_ERROR: {
      target: "error"
    },
    MOBILE_LANDSCAPE_WARNING: {
      target: "mobileLandscapeWarning",
      actions: "updateErrorStateForServer"
    }
  },
  states: {
    cameraCheck: {
      entry: ["resetErrorState"],
      invoke: {
        src: "checkVirtualCameraAndGetStream",
        onDone: {
          target: "waitForDOMAndCameraDetails",
          actions: ["updateVideoMediaStream"]
        },
        onError: {
          target: "permissionDenied"
        }
      }
    },
    waitForDOMAndCameraDetails: {
      after: {
        0: {
          target: "start",
          cond: "hasDOMAndCameraDetails"
        },
        10: { target: "waitForDOMAndCameraDetails" }
      }
    },
    start: {
      entry: ["drawStaticOval", "initializeFaceDetector"],
      always: [
        {
          target: "detectFaceBeforeStart",
          cond: "shouldSkipStartScreen"
        }
      ],
      on: {
        BEGIN: "detectFaceBeforeStart"
      }
    },
    detectFaceBeforeStart: {
      invoke: {
        src: "detectFace",
        onDone: {
          target: "checkFaceDetectedBeforeStart",
          actions: ["updateFaceMatchBeforeStartDetails"]
        }
      }
    },
    checkFaceDetectedBeforeStart: {
      after: {
        0: {
          target: "detectFaceDistanceBeforeRecording",
          cond: "hasSingleFaceBeforeStart"
        },
        100: { target: "detectFaceBeforeStart" }
      }
    },
    detectFaceDistanceBeforeRecording: {
      invoke: {
        src: "detectFaceDistance",
        onDone: {
          target: "checkFaceDistanceBeforeRecording",
          actions: ["updateFaceDistanceBeforeRecording"]
        }
      }
    },
    checkFaceDistanceBeforeRecording: {
      after: {
        0: {
          target: "initializeLivenessStream",
          cond: "hasEnoughFaceDistanceBeforeRecording"
        },
        100: { target: "detectFaceDistanceBeforeRecording" }
      }
    },
    initializeLivenessStream: {
      invoke: {
        src: "openLivenessStreamConnection",
        onDone: {
          target: "notRecording",
          actions: [
            "updateLivenessStreamProvider",
            "spawnResponseStreamActor"
          ]
        }
      }
    },
    notRecording: {
      initial: "waitForSessionInfo",
      states: {
        waitForSessionInfo: {
          after: {
            0: {
              target: "#livenessMachine.recording",
              cond: "hasServerSessionInfo"
            },
            100: { target: "waitForSessionInfo" }
          }
        }
      }
    },
    recording: {
      entry: ["clearErrorState", "startRecording"],
      initial: "ovalDrawing",
      states: {
        ovalDrawing: {
          entry: ["sendTimeoutAfterOvalDrawingDelay"],
          invoke: {
            src: "detectInitialFaceAndDrawOval",
            onDone: {
              target: "checkFaceDetected",
              actions: [
                "updateOvalAndFaceDetailsPostDraw",
                "sendTimeoutAfterOvalMatchDelay"
              ]
            },
            onError: {
              target: "#livenessMachine.error",
              actions: "updateErrorStateForRuntime"
            }
          }
        },
        checkFaceDetected: {
          after: {
            0: {
              target: "checkRecordingStarted",
              cond: "hasSingleFace"
            },
            100: { target: "ovalDrawing" }
          }
        },
        checkRecordingStarted: {
          after: {
            0: {
              target: "ovalMatching",
              cond: "hasRecordingStarted",
              actions: ["updateRecordingStartTimestampMs"]
            },
            100: { target: "checkRecordingStarted" }
          }
        },
        ovalMatching: {
          entry: ["cancelOvalDrawingTimeout"],
          invoke: {
            src: "detectFaceAndMatchOval",
            onDone: {
              target: "checkMatch",
              actions: "updateFaceDetailsPostMatch"
            }
          }
        },
        checkMatch: {
          after: {
            0: {
              target: "flashFreshnessColors",
              cond: "hasFaceMatchedInOvalWithMinTime",
              actions: [
                "updateEndFaceMatch",
                "setupFlashFreshnessColors",
                "cancelOvalMatchTimeout",
                "cancelOvalDrawingTimeout"
              ]
            },
            0.1: {
              target: "ovalMatching",
              cond: "hasFaceMatchedInOval",
              actions: "setFaceMatchTimeAndStartFace"
            },
            1: {
              target: "ovalMatching",
              cond: "hasNotFaceMatchedInOval"
            }
          }
        },
        flashFreshnessColors: {
          invoke: {
            src: "flashColors",
            onDone: [
              {
                target: "success",
                cond: "hasFreshnessColorShown"
              },
              {
                target: "flashFreshnessColors",
                actions: "updateFreshnessDetails"
              }
            ]
          }
        },
        success: {
          entry: ["stopRecording"],
          type: "final"
        }
      },
      onDone: "uploading"
    },
    uploading: {
      initial: "pending",
      states: {
        pending: {
          entry: ["sendTimeoutAfterWaitingForDisconnect", "pauseVideoStream"],
          invoke: {
            src: "stopVideo",
            onDone: "waitForDisconnectEvent",
            onError: {
              target: "#livenessMachine.error",
              actions: "updateErrorStateForRuntime"
            }
          }
        },
        waitForDisconnectEvent: {
          after: {
            0: {
              target: "getLivenessResult",
              cond: "getShouldDisconnect"
            },
            100: { target: "waitForDisconnectEvent" }
          }
        },
        getLivenessResult: {
          entry: ["cancelWaitForDisconnectTimeout", "freezeStream"],
          invoke: {
            src: "getLiveness",
            onError: {
              target: "#livenessMachine.error",
              actions: "updateErrorStateForServer"
            }
          }
        }
      }
    },
    retryableTimeout: {
      entry: "updateFailedAttempts",
      always: [
        {
          target: "timeout",
          cond: "shouldTimeoutOnFailedAttempts"
        },
        { target: "notRecording" }
      ]
    },
    permissionDenied: {
      entry: "callUserPermissionDeniedCallback",
      on: {
        RETRY_CAMERA_CHECK: "cameraCheck"
      }
    },
    mobileLandscapeWarning: {
      entry: "callMobileLandscapeWarningCallback",
      always: [{ target: "error" }]
    },
    timeout: {
      entry: ["cleanUpResources", "callUserTimeoutCallback", "freezeStream"]
    },
    error: {
      entry: [
        "cleanUpResources",
        "callErrorCallback",
        "cancelOvalDrawingTimeout",
        "cancelWaitForDisconnectTimeout",
        "cancelOvalMatchTimeout",
        "freezeStream"
      ]
    },
    userCancel: {
      entry: ["cleanUpResources", "callUserCancelCallback", "resetContext"],
      always: [{ target: "cameraCheck" }]
    }
  }
}, {
  actions: {
    spawnResponseStreamActor: xt({
      responseStreamActorRef: function() {
        return EE(lte);
      }
    }),
    updateFailedAttempts: xt({
      failedAttempts: function(t) {
        return t.failedAttempts + 1;
      }
    }),
    updateVideoMediaStream: xt({
      videoAssociatedParams: function(t, e) {
        var n, r, a;
        return _e(_e({}, t.videoAssociatedParams), { videoMediaStream: (n = e.data) === null || n === void 0 ? void 0 : n.stream, selectedDeviceId: (r = e.data) === null || r === void 0 ? void 0 : r.selectedDeviceId, selectableDevices: (a = e.data) === null || a === void 0 ? void 0 : a.selectableDevices });
      }
    }),
    initializeFaceDetector: xt({
      ovalAssociatedParams: function(t) {
        var e = t.componentProps, n = e.config, r = n.faceModelUrl, a = n.binaryPath, s = new mq(a, r);
        return s.triggerModelLoading(), _e(_e({}, t.ovalAssociatedParams), { faceDetector: s });
      }
    }),
    updateLivenessStreamProvider: xt({
      livenessStreamProvider: function(t, e) {
        var n;
        return (n = e.data) === null || n === void 0 ? void 0 : n.livenessStreamProvider;
      }
    }),
    setDOMAndCameraDetails: xt({
      videoAssociatedParams: function(t, e) {
        var n, r, a;
        return _e(_e({}, t.videoAssociatedParams), { videoEl: (n = e.data) === null || n === void 0 ? void 0 : n.videoEl, canvasEl: (r = e.data) === null || r === void 0 ? void 0 : r.canvasEl, isMobile: (a = e.data) === null || a === void 0 ? void 0 : a.isMobile });
      },
      freshnessColorAssociatedParams: function(t, e) {
        var n;
        return _e(_e({}, t.freshnessColorAssociatedParams), { freshnessColorEl: (n = e.data) === null || n === void 0 ? void 0 : n.freshnessColorEl });
      }
    }),
    updateDeviceAndStream: xt({
      videoAssociatedParams: function(t, e) {
        var n, r, a;
        return $b((n = e.data) === null || n === void 0 ? void 0 : n.newDeviceId), _e(_e({}, t.videoAssociatedParams), { selectedDeviceId: (r = e.data) === null || r === void 0 ? void 0 : r.newDeviceId, videoMediaStream: (a = e.data) === null || a === void 0 ? void 0 : a.newStream });
      }
    }),
    drawStaticOval: function(t) {
      var e = t.videoAssociatedParams, n = e.canvasEl, r = e.videoEl, a = e.videoMediaStream;
      Lp(n, r, a);
    },
    updateRecordingStartTimestampMs: xt({
      videoAssociatedParams: function(t) {
        var e = t.challengeId, n = t.videoAssociatedParams, r = t.ovalAssociatedParams, a = t.livenessStreamProvider, s = a.videoRecorder, o = s.recordingStartApiTimestamp, i = s.recorderStartTimestamp, c = n.videoMediaStream, l = r.initialFace, u = Math.round(0.73 * (i - o) + o), d = c.getTracks()[0].getSettings(), f = d.width, p = d.height, h = f - l.left - l.width;
        return t.livenessStreamProvider.sendClientInfo({
          Challenge: {
            FaceMovementAndLightChallenge: {
              ChallengeId: e,
              VideoStartTimestamp: u,
              InitialFace: {
                InitialFaceDetectedTimestamp: l.timestampMs,
                BoundingBox: Gf({
                  deviceHeight: p,
                  deviceWidth: f,
                  height: l.height,
                  width: l.width,
                  top: l.top,
                  left: h
                })
              }
            }
          }
        }), _e(_e({}, t.videoAssociatedParams), { recordingStartTimestampMs: u });
      }
    }),
    startRecording: xt({
      videoAssociatedParams: function(t) {
        if (!t.serverSessionInformation)
          throw new Error("Session information was not received from response stream");
        return t.livenessStreamProvider.videoRecorder && t.livenessStreamProvider.videoRecorder.getState() !== "recording" && t.livenessStreamProvider.startRecordingLivenessVideo(), _e({}, t.videoAssociatedParams);
      }
    }),
    stopRecording: function(t) {
    },
    updateFaceMatchBeforeStartDetails: xt({
      faceMatchStateBeforeStart: function(t, e) {
        return e.data.faceMatchState;
      }
    }),
    updateFaceDistanceBeforeRecording: xt({
      isFaceFarEnoughBeforeRecording: function(t, e) {
        return e.data.isFaceFarEnoughBeforeRecording;
      }
    }),
    updateFaceDistanceWhileLoading: xt({
      isFaceFarEnoughBeforeRecording: function(t, e) {
        return e.data.isFaceFarEnoughBeforeRecording;
      },
      errorState: function(t, e) {
        var n;
        return (n = e.data) === null || n === void 0 ? void 0 : n.error;
      }
    }),
    updateOvalAndFaceDetailsPostDraw: xt({
      ovalAssociatedParams: function(t, e) {
        return _e(_e({}, t.ovalAssociatedParams), { initialFace: e.data.initialFace, ovalDetails: e.data.ovalDetails, scaleFactor: e.data.scaleFactor });
      },
      faceMatchAssociatedParams: function(t, e) {
        return _e(_e({}, t.faceMatchAssociatedParams), { faceMatchState: e.data.faceMatchState, illuminationState: e.data.illuminationState });
      }
    }),
    updateFaceDetailsPostMatch: xt({
      faceMatchAssociatedParams: function(t, e) {
        return _e(_e({}, t.faceMatchAssociatedParams), { faceMatchState: e.data.faceMatchState, faceMatchPercentage: e.data.faceMatchPercentage, illuminationState: e.data.illuminationState, currentDetectedFace: e.data.detectedFace });
      }
    }),
    updateEndFaceMatch: xt({
      faceMatchAssociatedParams: function(t) {
        return _e(_e({}, t.faceMatchAssociatedParams), { endFace: t.faceMatchAssociatedParams.currentDetectedFace });
      }
    }),
    setFaceMatchTimeAndStartFace: xt({
      faceMatchAssociatedParams: function(t) {
        return _e(_e({}, t.faceMatchAssociatedParams), { startFace: t.faceMatchAssociatedParams.startFace === void 0 ? t.faceMatchAssociatedParams.currentDetectedFace : t.faceMatchAssociatedParams.startFace, initialFaceMatchTime: t.faceMatchAssociatedParams.initialFaceMatchTime === void 0 ? Date.now() : t.faceMatchAssociatedParams.initialFaceMatchTime });
      }
    }),
    resetErrorState: xt({
      errorState: function(t) {
      }
    }),
    updateErrorStateForTimeout: xt({
      errorState: function(t, e) {
        var n;
        return ((n = e.data) === null || n === void 0 ? void 0 : n.errorState) || lt.TIMEOUT;
      }
    }),
    updateErrorStateForRuntime: xt({
      errorState: function(t, e) {
        var n;
        return ((n = e.data) === null || n === void 0 ? void 0 : n.errorState) || lt.RUNTIME_ERROR;
      }
    }),
    updateErrorStateForServer: xt({
      errorState: function(t) {
        return lt.SERVER_ERROR;
      }
    }),
    clearErrorState: xt({
      errorState: function(t) {
      }
    }),
    updateSessionInfo: xt({
      serverSessionInformation: function(t, e) {
        return e.data.sessionInfo;
      }
    }),
    updateShouldDisconnect: xt({
      shouldDisconnect: function(t) {
        return !0;
      }
    }),
    updateFreshnessDetails: xt({
      freshnessColorAssociatedParams: function(t, e) {
        return _e(_e({}, t.freshnessColorAssociatedParams), { freshnessColorsComplete: e.data.freshnessColorsComplete });
      }
    }),
    setupFlashFreshnessColors: xt({
      freshnessColorAssociatedParams: function(t) {
        var e = t.serverSessionInformation, n = tT(e), r = new Jee(t, n);
        return _e(_e({}, t.freshnessColorAssociatedParams), { freshnessColorDisplay: r });
      }
    }),
    // timeouts
    sendTimeoutAfterOvalDrawingDelay: Ti({ type: "TIMEOUT" }, {
      delay: 5e3,
      id: "ovalDrawingTimeout"
    }),
    cancelOvalDrawingTimeout: Ci("ovalDrawingTimeout"),
    sendTimeoutAfterOvalMatchDelay: Ti({ type: "TIMEOUT" }, {
      delay: function(t) {
        var e, n, r, a;
        return ((a = (r = (n = (e = t.serverSessionInformation) === null || e === void 0 ? void 0 : e.Challenge) === null || n === void 0 ? void 0 : n.FaceMovementAndLightChallenge) === null || r === void 0 ? void 0 : r.ChallengeConfig) === null || a === void 0 ? void 0 : a.OvalFitTimeout) || ite;
      },
      id: "ovalMatchTimeout"
    }),
    cancelOvalMatchTimeout: Ci("ovalMatchTimeout"),
    sendTimeoutAfterWaitingForDisconnect: Ti({
      type: "TIMEOUT",
      data: { errorState: lt.SERVER_ERROR }
    }, {
      delay: 2e4,
      id: "waitForDisconnectTimeout"
    }),
    cancelWaitForDisconnectTimeout: Ci("waitForDisconnectTimeout"),
    sendTimeoutAfterFaceDistanceDelay: Ti({
      type: "RUNTIME_ERROR",
      data: new Error("Avoid moving closer during countdown and ensure only one face is in front of camera.")
    }, {
      delay: 0,
      id: "faceDistanceTimeout"
    }),
    cancelFaceDistanceTimeout: Ci("faceDistanceTimeout"),
    // callbacks
    callUserPermissionDeniedCallback: xt({
      errorState: function(t, e) {
        var n, r, a;
        e.data.message.includes("15 fps") ? a = lt.CAMERA_FRAMERATE_ERROR : a = lt.CAMERA_ACCESS_ERROR;
        var s = e.data.message || e.data.Message, o = new Error(s), i = {
          state: a,
          error: o
        };
        return (r = (n = t.componentProps).onError) === null || r === void 0 || r.call(n, i), a;
      }
    }),
    callMobileLandscapeWarningCallback: xt({
      errorState: function(t) {
        return lt.MOBILE_LANDSCAPE_ERROR;
      }
    }),
    callUserCancelCallback: function(t) {
      return ot(void 0, void 0, void 0, function() {
        var e, n;
        return tt(this, function(r) {
          return (n = (e = t.componentProps).onUserCancel) === null || n === void 0 || n.call(e), [
            2
            /*return*/
          ];
        });
      });
    },
    callUserTimeoutCallback: function(t) {
      return ot(void 0, void 0, void 0, function() {
        var e, n, r, a;
        return tt(this, function(s) {
          return e = new Error("Client Timeout"), e.name = t.errorState, n = {
            state: t.errorState,
            error: e
          }, (a = (r = t.componentProps).onError) === null || a === void 0 || a.call(r, n), [
            2
            /*return*/
          ];
        });
      });
    },
    callErrorCallback: function(t, e) {
      return ot(void 0, void 0, void 0, function() {
        var n, r, a, s;
        return tt(this, function(o) {
          return n = {
            state: t.errorState,
            error: ((r = e.data) === null || r === void 0 ? void 0 : r.error) || e.data
          }, (s = (a = t.componentProps).onError) === null || s === void 0 || s.call(a, n), [
            2
            /*return*/
          ];
        });
      });
    },
    cleanUpResources: function(t) {
      return ot(void 0, void 0, void 0, function() {
        var e, n, r;
        return tt(this, function(a) {
          switch (a.label) {
            case 0:
              return e = t.freshnessColorAssociatedParams.freshnessColorEl, e && (e.style.display = "none"), n = co.DEFAULT_ERROR_CODE, t.errorState === lt.TIMEOUT ? n = co.FACE_FIT_TIMEOUT : t.errorState === lt.RUNTIME_ERROR ? n = co.RUNTIME_ERROR : t.errorState === lt.FACE_DISTANCE_ERROR || t.errorState === lt.MULTIPLE_FACES_ERROR ? n = co.USER_ERROR_DURING_CONNECTION : t.errorState === void 0 && (n = co.USER_CANCEL), [4, (r = t.livenessStreamProvider) === null || r === void 0 ? void 0 : r.endStreamWithCode(n)];
            case 1:
              return a.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    },
    freezeStream: function(t) {
      return ot(void 0, void 0, void 0, function() {
        var e, n, r;
        return tt(this, function(a) {
          return e = t.videoAssociatedParams, n = e.videoMediaStream, r = e.videoEl, t.isRecordingStopped = !0, r?.pause(), n?.getTracks().forEach(function(s) {
            s.stop();
          }), [
            2
            /*return*/
          ];
        });
      });
    },
    pauseVideoStream: function(t) {
      return ot(void 0, void 0, void 0, function() {
        var e;
        return tt(this, function(n) {
          return e = t.videoAssociatedParams.videoEl, t.isRecordingStopped = !0, e.pause(), [
            2
            /*return*/
          ];
        });
      });
    },
    resetContext: xt({
      challengeId: Rb(),
      maxFailedAttempts: 0,
      // Set to 0 for now as we are not allowing front end based retries for streaming
      failedAttempts: 0,
      componentProps: function(t) {
        return t.componentProps;
      },
      serverSessionInformation: function(t) {
      },
      videoAssociatedParams: function(t) {
        return {
          videoConstraints: ol
        };
      },
      ovalAssociatedParams: function(t) {
      },
      errorState: function(t) {
      },
      livenessStreamProvider: function(t) {
      },
      responseStreamActorRef: function(t) {
      },
      shouldDisconnect: !1,
      faceMatchStateBeforeStart: function(t) {
      },
      isFaceFarEnoughBeforeRecording: function(t) {
      },
      isRecordingStopped: !1
    })
  },
  guards: {
    shouldTimeoutOnFailedAttempts: function(t) {
      return t.failedAttempts >= t.maxFailedAttempts;
    },
    hasFaceMatchedInOvalWithMinTime: function(t) {
      var e = t.faceMatchAssociatedParams, n = e.faceMatchState, r = e.initialFaceMatchTime, a = Date.now() - r, s = n === nt.MATCHED && a >= ote;
      return s;
    },
    hasFaceMatchedInOval: function(t) {
      return t.faceMatchAssociatedParams.faceMatchState === nt.MATCHED;
    },
    hasNotFaceMatchedInOval: function(t) {
      return t.faceMatchAssociatedParams.faceMatchState !== nt.MATCHED;
    },
    hasSingleFace: function(t) {
      return t.faceMatchAssociatedParams.faceMatchState === nt.FACE_IDENTIFIED;
    },
    hasSingleFaceBeforeStart: function(t) {
      return t.faceMatchStateBeforeStart === nt.FACE_IDENTIFIED;
    },
    hasEnoughFaceDistanceBeforeRecording: function(t) {
      return t.isFaceFarEnoughBeforeRecording;
    },
    hasNotEnoughFaceDistanceBeforeRecording: function(t) {
      return !t.isFaceFarEnoughBeforeRecording;
    },
    hasLivenessCheckSucceeded: function(t, e, n) {
      return n.state.event.data.isLive;
    },
    hasFreshnessColorShown: function(t) {
      return t.freshnessColorAssociatedParams.freshnessColorsComplete;
    },
    hasServerSessionInfo: function(t) {
      return t.serverSessionInformation !== void 0;
    },
    hasDOMAndCameraDetails: function(t) {
      return t.videoAssociatedParams.videoEl !== void 0 && t.videoAssociatedParams.canvasEl !== void 0 && t.freshnessColorAssociatedParams.freshnessColorEl !== void 0;
    },
    getShouldDisconnect: function(t) {
      return !!t.shouldDisconnect;
    },
    hasRecordingStarted: function(t) {
      return t.livenessStreamProvider.videoRecorder.firstChunkTimestamp !== void 0;
    },
    shouldSkipStartScreen: function(t) {
      var e;
      return !!(!((e = t.componentProps) === null || e === void 0) && e.disableStartScreen);
    }
  },
  services: {
    checkVirtualCameraAndGetStream: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a, s, o, i, c, l, u;
        return tt(this, function(d) {
          switch (d.label) {
            case 0:
              return e = t.videoAssociatedParams.videoConstraints, n = ute(), [4, navigator.mediaDevices.getUserMedia({
                video: _e(_e({}, e), n ? { deviceId: n } : {}),
                audio: !1
              })];
            case 1:
              return r = d.sent(), [4, navigator.mediaDevices.enumerateDevices()];
            case 2:
              if (a = d.sent(), s = a.filter(function(f) {
                return f.kind === "videoinput";
              }).filter(function(f) {
                return !YE(f);
              }), !s.length)
                throw new Error("No real video devices found");
              if (o = r.getTracks().filter(function(f) {
                var p = f.getSettings();
                return p.frameRate >= 15;
              }), o.length < 1)
                throw new Error("No camera found with more than 15 fps");
              return i = o[0].getSettings().deviceId, c = s.some(function(f) {
                return f.deviceId === i;
              }), l = i, u = r, c ? [3, 4] : (l = s[0].deviceId, [4, navigator.mediaDevices.getUserMedia({
                video: _e(_e({}, e), { deviceId: { exact: s[0].deviceId } }),
                audio: !1
              })]);
            case 3:
              u = d.sent(), d.label = 4;
            case 4:
              return $b(l), [2, {
                stream: u,
                selectedDeviceId: i,
                selectableDevices: s
              }];
          }
        });
      });
    },
    openLivenessStreamConnection: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a, s;
        return tt(this, function(o) {
          return e = t.componentProps.config, n = e, r = n.credentialProvider, a = n.endpointOverride, s = new Yee({
            sessionId: t.componentProps.sessionId,
            region: t.componentProps.region,
            stream: t.videoAssociatedParams.videoMediaStream,
            videoEl: t.videoAssociatedParams.videoEl,
            credentialProvider: r,
            endpointOverride: a
          }), Jx = s.getResponseStream(), [2, { livenessStreamProvider: s }];
        });
      });
    },
    detectFace: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a;
        return tt(this, function(s) {
          switch (s.label) {
            case 0:
              e = t.videoAssociatedParams.videoEl, n = t.ovalAssociatedParams.faceDetector, s.label = 1;
            case 1:
              return s.trys.push([1, 3, , 4]), [4, n.modelLoadingPromise];
            case 2:
              return s.sent(), [3, 4];
            case 3:
              return r = s.sent(), console.log({ err: r }), [3, 4];
            case 4:
              return [4, nT(n, e)];
            case 5:
              return a = s.sent(), [2, { faceMatchState: a }];
          }
        });
      });
    },
    detectFaceDistance: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a, s, o, i, c, l, u, d;
        return tt(this, function(f) {
          switch (f.label) {
            case 0:
              return e = t.isFaceFarEnoughBeforeRecording, n = t.videoAssociatedParams, r = n.videoEl, a = n.videoMediaStream, s = n.isMobile, o = t.ovalAssociatedParams.faceDetector, i = a.getTracks()[0].getSettings(), c = i.width, l = i.height, u = Bp({
                width: c,
                height: l
              }), [4, By({
                faceDetector: o,
                videoEl: r,
                ovalDetails: u,
                reduceThreshold: e,
                // if this is the second face distance check reduce the threshold
                isMobile: s
              })];
            case 1:
              return d = f.sent().isDistanceBelowThreshold, [2, { isFaceFarEnoughBeforeRecording: d }];
          }
        });
      });
    },
    detectFaceDistanceWhileLoading: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a, s, o, i, c, l, u, d, f, p;
        return tt(this, function(h) {
          switch (h.label) {
            case 0:
              return e = t.isFaceFarEnoughBeforeRecording, n = t.videoAssociatedParams, r = n.videoEl, a = n.videoMediaStream, s = n.isMobile, o = t.ovalAssociatedParams.faceDetector, i = a.getTracks()[0].getSettings(), c = i.width, l = i.height, u = Bp({
                width: c,
                height: l
              }), [4, By({
                faceDetector: o,
                videoEl: r,
                ovalDetails: u,
                reduceThreshold: e,
                // if this is the second face distance check reduce the threshold
                isMobile: s
              })];
            case 1:
              return d = h.sent(), f = d.isDistanceBelowThreshold, p = d.error, [2, { isFaceFarEnoughBeforeRecording: f, error: p }];
          }
        });
      });
    },
    detectInitialFaceAndDrawOval: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a, s, o, i, c, l, u, d, f, p, h, m, g, v, b;
        return tt(this, function(w) {
          switch (w.label) {
            case 0:
              e = t.serverSessionInformation, n = t.livenessStreamProvider, r = t.videoAssociatedParams, a = r.videoEl, s = r.canvasEl, o = r.isMobile, i = t.ovalAssociatedParams.faceDetector, w.label = 1;
            case 1:
              return w.trys.push([1, 4, , 5]), [4, i.modelLoadingPromise];
            case 2:
              return w.sent(), [4, n.videoRecorder.recorderStarted];
            case 3:
              return w.sent(), [3, 5];
            case 4:
              return c = w.sent(), console.log({ err: c }), [3, 5];
            case 5:
              return [4, i.detectFaces(a)];
            case 6:
              switch (l = w.sent(), l.length) {
                case 0: {
                  d = nt.CANT_IDENTIFY, f = My(a);
                  break;
                }
                case 1: {
                  d = nt.FACE_IDENTIFIED, u = l[0];
                  break;
                }
                default: {
                  d = nt.TOO_MANY;
                  break;
                }
              }
              return u ? (p = a.getBoundingClientRect(), h = p.width, m = p.height, o ? (s.width = window.innerWidth, s.height = window.innerHeight) : (s.width = h, s.height = m), g = h / a.videoWidth, v = qE({
                sessionInformation: e,
                videoWidth: a.width
              }), b = Wp(u, v), u.top = b.top, u.left = b.left, u.height = b.bottom - b.top, u.width = b.right - b.left, W0({
                canvas: s,
                oval: v,
                scaleFactor: g,
                videoEl: a
              }), [2, {
                faceMatchState: d,
                ovalDetails: v,
                scaleFactor: g,
                initialFace: u
              }]) : [2, { faceMatchState: d, illuminationState: f }];
          }
        });
      });
    },
    detectFaceAndMatchOval: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a, s, o, i, c, l, u, d, f, p, h, m, g, v;
        return tt(this, function(b) {
          switch (b.label) {
            case 0:
              return e = t.serverSessionInformation, n = t.videoAssociatedParams.videoEl, r = t.ovalAssociatedParams, a = r.faceDetector, s = r.ovalDetails, o = r.initialFace, [4, a.detectFaces(n)];
            case 1:
              switch (i = b.sent(), l = 0, f = Wp(o, s), p = B0(s).ovalBoundingBox, h = L0(f, p), i.length) {
                case 0: {
                  c = nt.CANT_IDENTIFY, d = My(n);
                  break;
                }
                case 1: {
                  u = i[0], m = XE(u, s, h, e), g = m.faceMatchState, v = m.faceMatchPercentage, c = g, l = v;
                  break;
                }
                default: {
                  c = nt.TOO_MANY;
                  break;
                }
              }
              return [2, {
                faceMatchState: c,
                faceMatchPercentage: l,
                illuminationState: d,
                detectedFace: u
              }];
          }
        });
      });
    },
    flashColors: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a;
        return tt(this, function(s) {
          switch (s.label) {
            case 0:
              return e = t.freshnessColorAssociatedParams, n = e.freshnessColorsComplete, r = e.freshnessColorDisplay, n ? [
                2
                /*return*/
              ] : [4, r.displayColorTick()];
            case 1:
              return a = s.sent(), [2, { freshnessColorsComplete: a }];
          }
        });
      });
    },
    stopVideo: function(t) {
      return ot(this, void 0, void 0, function() {
        var e, n, r, a, s, o, i, c, l, u, d, f, p, h;
        return tt(this, function(m) {
          switch (m.label) {
            case 0:
              return e = t.challengeId, n = t.livenessStreamProvider, r = t.videoAssociatedParams.videoMediaStream, a = t.ovalAssociatedParams, s = a.initialFace, o = a.ovalDetails, i = t.faceMatchAssociatedParams, c = i.startFace, l = i.endFace, u = r.getTracks()[0].getSettings(), d = u.width, f = u.height, p = d - s.left - s.width, [4, n.stopVideo()];
            case 1:
              if (m.sent(), h = {
                Challenge: {
                  FaceMovementAndLightChallenge: {
                    ChallengeId: e,
                    InitialFace: {
                      InitialFaceDetectedTimestamp: s.timestampMs,
                      BoundingBox: Gf({
                        deviceHeight: f,
                        deviceWidth: d,
                        height: s.height,
                        width: s.width,
                        top: s.top,
                        left: p
                      })
                    },
                    TargetFace: {
                      FaceDetectedInTargetPositionStartTimestamp: c.timestampMs,
                      FaceDetectedInTargetPositionEndTimestamp: l.timestampMs,
                      BoundingBox: Gf({
                        deviceHeight: f,
                        deviceWidth: d,
                        height: o.height,
                        width: o.width,
                        top: o.centerY - o.height / 2,
                        left: o.centerX - o.width / 2
                      })
                    },
                    VideoEndTimestamp: n.videoRecorder.recorderEndTimestamp
                  }
                }
              }, n.videoRecorder.getVideoChunkSize() === 0)
                throw new Error("Video chunks not recorded successfully.");
              return n.sendClientInfo(h), [4, n.dispatchStopVideoEvent()];
            case 2:
              return m.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    },
    getLiveness: function(t) {
      return ot(this, void 0, void 0, function() {
        var e;
        return tt(this, function(n) {
          switch (n.label) {
            case 0:
              return e = t.componentProps.onAnalysisComplete, [4, e()];
            case 1:
              return n.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }
  }
}), lte = function(t) {
  return ot(void 0, void 0, void 0, function() {
    var e, n, r, a, s, o, i, c, l, u, d, f;
    return tt(this, function(p) {
      switch (p.label) {
        case 0:
          return p.trys.push([0, 14, , 15]), [4, Jx];
        case 1:
          e = p.sent(), p.label = 2;
        case 2:
          p.trys.push([2, 7, 8, 13]), n = !0, r = a0(e), p.label = 3;
        case 3:
          return [4, r.next()];
        case 4:
          if (a = p.sent(), l = a.done, !!l)
            return [3, 6];
          f = a.value, n = !1, s = f, Qee(s) ? t({
            type: "SET_SESSION_INFO",
            data: {
              sessionInfo: s.ServerSessionInformationEvent.SessionInformation
            }
          }) : ete(s) ? t({ type: "DISCONNECT_EVENT" }) : tte(s) ? t({
            type: "SERVER_ERROR",
            data: { error: _e({}, s.ValidationException) }
          }) : nte(s) ? t({
            type: "SERVER_ERROR",
            data: { error: _e({}, s.InternalServerException) }
          }) : rte(s) ? t({
            type: "SERVER_ERROR",
            data: { error: _e({}, s.ThrottlingException) }
          }) : ate(s) && t({
            type: "SERVER_ERROR",
            data: { error: _e({}, s.ServiceQuotaExceededException) }
          }), p.label = 5;
        case 5:
          return n = !0, [3, 3];
        case 6:
          return [3, 13];
        case 7:
          return o = p.sent(), u = { error: o }, [3, 13];
        case 8:
          return p.trys.push([8, , 11, 12]), !n && !l && (d = r.return) ? [4, d.call(r)] : [3, 10];
        case 9:
          p.sent(), p.label = 10;
        case 10:
          return [3, 12];
        case 11:
          if (u)
            throw u.error;
          return [
            7
            /*endfinally*/
          ];
        case 12:
          return [
            7
            /*endfinally*/
          ];
        case 13:
          return [3, 15];
        case 14:
          return i = p.sent(), c = i, ste(i) && (c = new Error("Invalid region in FaceLivenessDetector or credentials are scoped to the wrong region.")), c instanceof Error && t({
            type: "SERVER_ERROR",
            data: { error: c }
          }), [3, 15];
        case 15:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}, dte = typeof $n == "object" && $n && $n.Object === Object && $n, fte = dte, pte = fte, hte = typeof self == "object" && self && self.Object === Object && self, mte = pte || hte || Function("return this")(), gte = mte, yte = gte, vte = yte.Symbol, zg = vte, Db = zg, e3 = Object.prototype, bte = e3.hasOwnProperty, wte = e3.toString, Ii = Db ? Db.toStringTag : void 0;
function Ste(t) {
  var e = bte.call(t, Ii), n = t[Ii];
  try {
    t[Ii] = void 0;
    var r = !0;
  } catch {
  }
  var a = wte.call(t);
  return r && (e ? t[Ii] = n : delete t[Ii]), a;
}
var _te = Ste, xte = Object.prototype, Ite = xte.toString;
function kte(t) {
  return Ite.call(t);
}
var Ete = kte, Ob = zg, Tte = _te, Cte = Ete, Nte = "[object Null]", Ate = "[object Undefined]", Fb = Ob ? Ob.toStringTag : void 0;
function Rte(t) {
  return t == null ? t === void 0 ? Ate : Nte : Fb && Fb in Object(t) ? Tte(t) : Cte(t);
}
var $te = Rte, Dte = Array.isArray, Ote = Dte;
function Fte(t) {
  return t != null && typeof t == "object";
}
var Mte = Fte;
function Fu(t) {
  return t != null && !Array.isArray(t) && typeof t == "object";
}
function Oo(t) {
  return typeof t == "string" || typeof t == "object" && Object.prototype.toString.call(t) === "[object String]";
}
function Su(t, e) {
  return t != null && Object.prototype.hasOwnProperty.call(t, e);
}
const Qr = (t, e) => e ? `${t}--${e}` : "", Rs = (t, e, n) => n ? `${t}--${e}` : "";
function Pte(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, a = Array(r); ++n < r; )
    a[n] = e(t[n], n, t);
  return a;
}
var Bte = Pte, Lte = $te, Wte = Mte, zte = "[object Symbol]";
function Vte(t) {
  return typeof t == "symbol" || Wte(t) && Lte(t) == zte;
}
var Hte = Vte, Mb = zg, jte = Bte, Ute = Ote, Gte = Hte, qte = 1 / 0, Pb = Mb ? Mb.prototype : void 0, Bb = Pb ? Pb.toString : void 0;
function t3(t) {
  if (typeof t == "string")
    return t;
  if (Ute(t))
    return jte(t, t3) + "";
  if (Gte(t))
    return Bb ? Bb.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -qte ? "-0" : e;
}
var Kte = t3, Xte = Kte;
function Yte(t) {
  return t == null ? "" : Xte(t);
}
var n3 = Yte;
function Zte(t) {
  return t.toLowerCase();
}
var Jte = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g], Qte = /[^A-Z0-9]+/gi;
function Go(t, e) {
  e === void 0 && (e = {});
  for (var n = e.splitRegexp, r = n === void 0 ? Jte : n, a = e.stripRegexp, s = a === void 0 ? Qte : a, o = e.transform, i = o === void 0 ? Zte : o, c = e.delimiter, l = c === void 0 ? " " : c, u = Lb(Lb(t, r, "$1\0$2"), s, "\0"), d = 0, f = u.length; u.charAt(d) === "\0"; )
    d++;
  for (; u.charAt(f - 1) === "\0"; )
    f--;
  return u.slice(d, f).split("\0").map(i).join(l);
}
function Lb(t, e, n) {
  return e instanceof RegExp ? t.replace(e, n) : e.reduce(function(r, a) {
    return r.replace(a, n);
  }, t);
}
function Vg(t, e) {
  var n = t.charAt(0), r = t.substr(1).toLowerCase();
  return e > 0 && n >= "0" && n <= "9" ? "_" + n + r : "" + n.toUpperCase() + r;
}
function r3(t) {
  return t.charAt(0).toUpperCase() + t.slice(1).toLowerCase();
}
function a3(t, e) {
  return e === void 0 && (e = {}), Go(t, _e({ delimiter: "", transform: Vg }, e));
}
function s3(t, e) {
  return e === 0 ? t.toLowerCase() : Vg(t, e);
}
function ene(t, e) {
  return e === 0 ? t.toLowerCase() : r3(t);
}
function tne(t, e) {
  return e === void 0 && (e = {}), a3(t, _e({ transform: s3 }, e));
}
function o3(t) {
  return t.charAt(0).toUpperCase() + t.substr(1);
}
function i3(t) {
  return o3(t.toLowerCase());
}
function u3(t, e) {
  return e === void 0 && (e = {}), Go(t, _e({ delimiter: " ", transform: i3 }, e));
}
function nne(t) {
  return t.toUpperCase();
}
function rne(t, e) {
  return e === void 0 && (e = {}), Go(t, _e({ delimiter: "_", transform: nne }, e));
}
function Tf(t, e) {
  return e === void 0 && (e = {}), Go(t, _e({ delimiter: "." }, e));
}
function ane(t, e) {
  return e === void 0 && (e = {}), u3(t, _e({ delimiter: "-" }, e));
}
function sne(t, e) {
  return e === void 0 && (e = {}), Tf(t, _e({ delimiter: "-" }, e));
}
function one(t, e) {
  return e === void 0 && (e = {}), Tf(t, _e({ delimiter: "/" }, e));
}
function c3(t, e) {
  var n = t.toLowerCase();
  return e === 0 ? o3(n) : n;
}
function ine(t, e) {
  return e === void 0 && (e = {}), Go(t, _e({ delimiter: " ", transform: c3 }, e));
}
function une(t, e) {
  return e === void 0 && (e = {}), Tf(t, _e({ delimiter: "_" }, e));
}
const cne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  camelCase: tne,
  camelCaseTransform: s3,
  camelCaseTransformMerge: ene,
  capitalCase: u3,
  capitalCaseTransform: i3,
  constantCase: rne,
  dotCase: Tf,
  headerCase: ane,
  noCase: Go,
  paramCase: sne,
  pascalCase: a3,
  pascalCaseTransform: Vg,
  pascalCaseTransformMerge: r3,
  pathCase: one,
  sentenceCase: ine,
  sentenceCaseTransform: c3,
  snakeCase: une
}, Symbol.toStringTag, { value: "Module" })), lne = /* @__PURE__ */ _a(cne), xc = lne, dne = function(t, e, n) {
  return Object.keys(t || {}).reduce((r, a) => {
    let s = t[a];
    return e(r, s, a, t);
  }, n);
}, wp = function(t, e) {
  Object.keys(t || {}).forEach((n) => {
    let r = t[n];
    e(r, n);
  });
}, fne = function(t) {
  return Object.assign(new t.constructor(), t);
}, il = function(t) {
  if (t == null || typeof t != "object")
    return t;
  if (t instanceof Array)
    return t.reduce((e, n, r) => (e[r] = il(n), e), []);
  if (t instanceof Object)
    return Object.keys(t || {}).reduce((e, n) => (e[n] = il(t[n]), e), {});
}, l3 = function(t) {
  const e = typeof t;
  return t != null && (e === "object" || e === "function");
}, pne = function(t) {
  return typeof t == "string" || t instanceof String;
}, hne = function(t) {
  return Array.isArray(t);
}, mne = function(t) {
  return [Object, Array].includes((t || {}).constructor) && !Object.entries(t || {}).length;
};
function gne(t) {
  if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(t) === null)
    return !0;
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e;
}
const yne = function(t, e) {
  if (typeof e != "function")
    throw "filter is not a function";
  return typeof t > "u" ? [] : t.filter(e);
}, vne = function() {
  let t = Array.prototype.slice.call(arguments);
  return t.unshift({}), Object.assign(...t);
}, bne = function(t, ...e) {
  var n = new Set(e);
  for (let r = t.length - 1; r >= 0; r--)
    n.has(t[r]) && t.splice(r, 1);
}, wne = function(t) {
  return [...new Set(t)];
}, Sne = function(t) {
  return t ? t[0].toUpperCase() + t.substr(1) : "";
}, d3 = function(t, e) {
  return l3(e) ? Object.keys(e).every((n) => d3(t[n], e[n])) : t == e;
}, _ne = function(t) {
  let e = il(t);
  return (r) => d3(r, e);
}, xne = {
  transform: xc.camelCaseTransformMerge
}, Ine = function(t, e) {
  return (n, r) => t(n, Object.assign({}, xne, e, r));
};
var f3 = {
  each: wp,
  forEach: wp,
  forIn: wp,
  keys: Object.keys,
  clone: fne,
  cloneDeep: il,
  extend: Object.assign,
  isString: pne,
  isArray: hne,
  isObject: l3,
  isPlainObject: gne,
  isEmpty: mne,
  filter: yne,
  reduce: dne,
  assign: vne,
  upperFirst: Sne,
  camelCase: Ine(xc.camelCase),
  snakeCase: xc.snakeCase,
  kebabCase: xc.paramCase,
  pull: bne,
  matches: _ne,
  unique: wne
}, pc = f3;
function p3(t, e, n) {
  if (t == null)
    return {};
  var r, a, s, o, i, c, l = t[0] || {}, u = 1, d = t.length;
  for (n = n || [], typeof l != "object" && (l = {}); u < d; u++)
    if ((i = t[u]) != null) {
      for (o in i)
        if (i.hasOwnProperty(o) && o !== "__proto__" && (r = l[o], s = i[o], l !== s))
          if (s && (pc.isPlainObject(s) || (a = pc.isArray(s)))) {
            a ? (a = !1, c = r && pc.isArray(r) ? r : []) : c = r && pc.isPlainObject(r) ? r : {};
            var f = n.slice(0);
            f.push(o), l[o] = p3([c, s], e, f);
          } else
            s !== void 0 && (r != null && typeof e == "function" && e({ target: l, copy: i, path: n, key: o }), l[o] = s);
    }
  return l;
}
var kne = p3;
const Ene = /* @__PURE__ */ Vs(kne);
var Wb = f3;
function h3(t, e) {
  e = e || [];
  for (var n in t)
    t.hasOwnProperty(n) && (Wb.isPlainObject(t[n]) && "value" in t[n] ? e.push(t[n]) : Wb.isPlainObject(t[n]) && h3(t[n], e));
  return e;
}
var Tne = h3;
const zb = /* @__PURE__ */ Vs(Tne), m3 = {
  small: { value: "1px" },
  medium: { value: "2px" },
  large: { value: "3px" }
}, g3 = {
  red: {
    10: { value: "hsl(0, 75%, 95%)" },
    20: { value: "hsl(0, 75%, 85%)" },
    40: { value: "hsl(0, 75%, 75%)" },
    60: { value: "hsl(0, 50%, 50%)" },
    80: { value: "hsl(0, 95%, 30%)" },
    90: { value: "hsl(0, 100%, 20%)" },
    100: { value: "hsl(0, 100%, 15%)" }
  },
  orange: {
    10: { value: "hsl(30, 75%, 95%)" },
    20: { value: "hsl(30, 75%, 85%)" },
    40: { value: "hsl(30, 75%, 75%)" },
    60: { value: "hsl(30, 50%, 50%)" },
    80: { value: "hsl(30, 95%, 30%)" },
    90: { value: "hsl(30, 100%, 20%)" },
    100: { value: "hsl(30, 100%, 15%)" }
  },
  yellow: {
    10: { value: "hsl(60, 75%, 95%)" },
    20: { value: "hsl(60, 75%, 85%)" },
    40: { value: "hsl(60, 75%, 75%)" },
    60: { value: "hsl(60, 50%, 50%)" },
    80: { value: "hsl(60, 95%, 30%)" },
    90: { value: "hsl(60, 100%, 20%)" },
    100: { value: "hsl(60, 100%, 15%)" }
  },
  green: {
    10: { value: "hsl(130, 60%, 95%)" },
    20: { value: "hsl(130, 60%, 90%)" },
    40: { value: "hsl(130, 44%, 63%)" },
    60: { value: "hsl(130, 43%, 46%)" },
    80: { value: "hsl(130, 33%, 37%)" },
    90: { value: "hsl(130, 27%, 29%)" },
    100: { value: "hsl(130, 22%, 23%)" }
  },
  teal: {
    10: { value: "hsl(190, 75%, 95%)" },
    20: { value: "hsl(190, 75%, 85%)" },
    40: { value: "hsl(190, 70%, 70%)" },
    60: { value: "hsl(190, 50%, 50%)" },
    80: { value: "hsl(190, 95%, 30%)" },
    90: { value: "hsl(190, 100%, 20%)" },
    100: { value: "hsl(190, 100%, 15%)" }
  },
  blue: {
    10: { value: "hsl(220, 95%, 95%)" },
    20: { value: "hsl(220, 85%, 85%)" },
    40: { value: "hsl(220, 70%, 70%)" },
    60: { value: "hsl(220, 50%, 50%)" },
    80: { value: "hsl(220, 95%, 30%)" },
    90: { value: "hsl(220, 100%, 20%)" },
    100: { value: "hsl(220, 100%, 15%)" }
  },
  purple: {
    10: { value: "hsl(300, 95%, 95%)" },
    20: { value: "hsl(300, 85%, 85%)" },
    40: { value: "hsl(300, 70%, 70%)" },
    60: { value: "hsl(300, 50%, 50%)" },
    80: { value: "hsl(300, 95%, 30%)" },
    90: { value: "hsl(300, 100%, 20%)" },
    100: { value: "hsl(300, 100%, 15%)" }
  },
  pink: {
    10: { value: "hsl(340, 95%, 95%)" },
    20: { value: "hsl(340, 90%, 85%)" },
    40: { value: "hsl(340, 70%, 70%)" },
    60: { value: "hsl(340, 50%, 50%)" },
    80: { value: "hsl(340, 95%, 30%)" },
    90: { value: "hsl(340, 100%, 20%)" },
    100: { value: "hsl(340, 100%, 15%)" }
  },
  neutral: {
    10: { value: "hsl(210, 5%, 98%)" },
    20: { value: "hsl(210, 5%, 94%)" },
    40: { value: "hsl(210, 5%, 87%)" },
    60: { value: "hsl(210, 10%, 58%)" },
    80: { value: "hsl(210, 10%, 40%)" },
    90: { value: "hsl(210, 25%, 25%)" },
    100: { value: "hsl(210, 50%, 10%)" }
  },
  primary: {
    10: { value: "{colors.teal.10.value}" },
    20: { value: "{colors.teal.20.value}" },
    40: { value: "{colors.teal.40.value}" },
    60: { value: "{colors.teal.60.value}" },
    80: { value: "{colors.teal.80.value}" },
    90: { value: "{colors.teal.90.value}" },
    100: { value: "{colors.teal.100.value}" }
  },
  secondary: {
    10: { value: "{colors.purple.10.value}" },
    20: { value: "{colors.purple.20.value}" },
    40: { value: "{colors.purple.40.value}" },
    60: { value: "{colors.purple.60.value}" },
    80: { value: "{colors.purple.80.value}" },
    90: { value: "{colors.purple.90.value}" },
    100: { value: "{colors.purple.100.value}" }
  },
  font: {
    primary: { value: "{colors.neutral.100.value}" },
    secondary: { value: "{colors.neutral.90.value}" },
    tertiary: { value: "{colors.neutral.80.value}" },
    disabled: { value: "{colors.neutral.60.value}" },
    inverse: { value: "{colors.white.value}" },
    interactive: { value: "{colors.primary.80.value}" },
    // Hover and Focus colors are intentionally different colors.
    // This allows users to distinguish between the current keyboard focus
    // and the location of their pointer
    hover: { value: "{colors.primary.90.value}" },
    // Focus color is set to 100 to ensure enough contrast for accessibility
    focus: { value: "{colors.primary.100.value}" },
    active: { value: "{colors.primary.100.value}" },
    info: { value: "{colors.blue.90.value}" },
    warning: { value: "{colors.orange.90.value}" },
    error: { value: "{colors.red.90.value}" },
    success: { value: "{colors.green.90.value}" }
  },
  background: {
    primary: { value: "{colors.white.value}" },
    secondary: { value: "{colors.neutral.10.value}" },
    tertiary: { value: "{colors.neutral.20.value}" },
    quaternary: { value: "{colors.neutral.60.value}" },
    disabled: { value: "{colors.background.tertiary.value}" },
    info: { value: "{colors.blue.10.value}" },
    warning: { value: "{colors.orange.10.value}" },
    error: { value: "{colors.red.10.value}" },
    success: { value: "{colors.green.10.value}" }
  },
  border: {
    primary: { value: "{colors.neutral.60.value}" },
    secondary: { value: "{colors.neutral.40.value}" },
    tertiary: { value: "{colors.neutral.20.value}" },
    disabled: { value: "{colors.border.tertiary.value}" },
    pressed: { value: "{colors.primary.100.value}" },
    // Focus color is set to 100 to ensure enough contrast for accessibility
    focus: { value: "{colors.primary.100.value}" },
    error: { value: "{colors.red.80.value}" },
    info: { value: "{colors.blue.80.value}" },
    success: { value: "{colors.green.80.value}" },
    warning: { value: "{colors.orange.80.value}" }
  },
  shadow: {
    primary: { value: "hsla(210, 50%, 10%, 0.25)" },
    secondary: { value: "hsla(210, 50%, 10%, 0.15)" },
    tertiary: { value: "hsla(210, 50%, 10%, 0.05)" }
  },
  overlay: {
    5: { value: "hsla(0, 0%, 0%, 0.05)" },
    10: { value: "hsla(0, 0%, 0%, 0.1)" },
    20: { value: "hsla(0, 0%, 0%, 0.2)" },
    30: { value: "hsla(0, 0%, 0%, 0.3)" },
    40: { value: "hsla(0, 0%, 0%, 0.4)" },
    50: { value: "hsla(0, 0%, 0%, 0.5)" },
    60: { value: "hsla(0, 0%, 0%, 0.6)" },
    70: { value: "hsla(0, 0%, 0%, 0.7)" },
    80: { value: "hsla(0, 0%, 0%, 0.8)" },
    90: { value: "hsla(0, 0%, 0%, 0.9)" }
  },
  black: { value: "hsl(0, 0%, 0%)" },
  white: { value: "hsl(0, 0%, 100%)" },
  transparent: { value: "transparent" }
}, Cne = {
  // Default styles
  alignItems: { value: "center" },
  justifyContent: { value: "space-between" },
  color: { value: "{colors.font.primary.value}" },
  backgroundColor: { value: "{colors.background.tertiary.value}" },
  paddingBlock: { value: "{space.small.value}" },
  paddingInline: { value: "{space.medium.value}" },
  icon: {
    size: { value: "{fontSizes.xl.value}" }
  },
  heading: {
    fontSize: { value: "{fontSizes.medium.value}" },
    fontWeight: { value: "{fontWeights.bold.value}" }
  },
  // Variations
  info: {
    color: { value: "{colors.font.info.value}" },
    backgroundColor: { value: "{colors.background.info.value}" }
  },
  error: {
    color: { value: "{colors.font.error.value}" },
    backgroundColor: { value: "{colors.background.error.value}" }
  },
  warning: {
    color: { value: "{colors.font.warning.value}" },
    backgroundColor: { value: "{colors.background.warning.value}" }
  },
  success: {
    color: { value: "{colors.font.success.value}" },
    backgroundColor: { value: "{colors.background.success.value}" }
  }
}, Nne = {
  menu: {
    width: { value: "100%" },
    marginBlockStart: { value: "{space.xxxs}" },
    backgroundColor: { value: "{colors.background.primary}" },
    borderColor: { value: "{colors.border.primary}" },
    borderWidth: { value: "{borderWidths.small}" },
    borderStyle: { value: "solid" },
    borderRadius: { value: "{radii.small}" },
    options: {
      display: { value: "flex" },
      flexDirection: { value: "column" },
      maxHeight: { value: "300px" }
    },
    option: {
      backgroundColor: { value: "{colors.background.primary}" },
      color: { value: "currentcolor" },
      cursor: { value: "pointer" },
      transitionDuration: { value: "{time.short}" },
      transitionProperty: { value: "background-color, color" },
      transitionTimingFunction: { value: "ease" },
      _active: {
        backgroundColor: { value: "{colors.primary.80}" },
        color: { value: "{colors.white}" }
      }
    },
    _empty: {
      display: { value: "flex" }
    },
    _loading: {
      alignItems: { value: "center" },
      display: { value: "flex" },
      gap: { value: "{space.xxxs}" }
    },
    spaceShared: {
      paddingBlock: { value: "{space.xs}" },
      paddingInline: { value: "{space.small}" }
    }
  }
}, Ane = {
  maxWidth: { value: "60rem" },
  modal: {
    width: { value: "{space.relative.full}" },
    height: { value: "{space.relative.full}" },
    backgroundColor: { value: "{colors.overlay.50.value}" },
    top: { value: "{space.zero}" },
    left: { value: "{space.zero}" }
  },
  container: {
    widthMax: { value: "30rem" }
  },
  router: {
    borderWidth: { value: "{borderWidths.small.value}" },
    borderStyle: { value: "solid" },
    borderColor: { value: "{colors.border.primary.value}" },
    backgroundColor: { value: "{colors.background.primary.value}" },
    boxShadow: { value: "{shadows.medium.value}" }
  },
  footer: {
    paddingBottom: { value: "{space.medium.value}" }
  },
  form: {
    padding: { value: "{space.xl.value}" }
  },
  state: {
    inactive: {
      backgroundColor: { value: "{colors.background.secondary.value}" }
    }
  },
  orContainer: {
    color: { value: "{colors.neutral.80.value}" },
    orLine: {
      backgroundColor: { value: "{colors.background.primary.value}" }
    }
  }
}, Rne = {
  // Default styles
  color: { value: "{colors.font.primary.value}" },
  lineHeight: { value: 1 },
  fontWeight: { value: "{fontWeights.semibold.value}" },
  fontSize: { value: "{fontSizes.small.value}" },
  textAlign: { value: "center" },
  paddingVertical: { value: "{space.xs.value}" },
  paddingHorizontal: { value: "{space.small.value}" },
  backgroundColor: { value: "{colors.background.tertiary.value}" },
  // An arbitrarily large value to ensure that the left and right sides of the badge are perfectly rounded for any size variation
  borderRadius: { value: "{radii.xl.value}" },
  // Variations
  info: {
    color: { value: "{colors.font.info.value}" },
    backgroundColor: { value: "{colors.background.info.value}" }
  },
  warning: {
    color: { value: "{colors.font.warning.value}" },
    backgroundColor: { value: "{colors.background.warning.value}" }
  },
  success: {
    color: { value: "{colors.font.success.value}" },
    backgroundColor: { value: "{colors.background.success.value}" }
  },
  error: {
    color: { value: "{colors.font.error.value}" },
    backgroundColor: { value: "{colors.background.error.value}" }
  },
  // Sizes
  small: {
    fontSize: { value: "{fontSizes.xs.value}" },
    paddingVertical: { value: "{space.xxs.value}" },
    paddingHorizontal: { value: "{space.xs.value}" }
  },
  // medium is the default size
  large: {
    fontSize: { value: "{fontSizes.medium.value}" },
    paddingVertical: { value: "{space.small.value}" },
    paddingHorizontal: { value: "{space.medium.value}" }
  }
}, $ne = {
  flexDirection: { value: "row" },
  flexWrap: { value: "wrap" },
  gap: { value: "0" },
  color: { value: "{colors.font.tertiary}" },
  item: {
    flexDirection: { value: "row" },
    color: { value: "inherit" },
    fontSize: { value: "inherit" },
    alignItems: { value: "center" },
    lineHeight: { value: "1" }
  },
  separator: {
    color: { value: "inherit" },
    fontSize: { value: "inherit" },
    paddingInline: { value: "{space.xxs}" }
  },
  link: {
    color: { value: "{components.link.color}" },
    fontSize: { value: "inherit" },
    fontWeight: { value: "normal" },
    textDecoration: { value: "none" },
    paddingInline: { value: "{space.xs}" },
    paddingBlock: { value: "{space.xxs}" },
    current: {
      color: { value: "inherit" },
      fontSize: { value: "inherit" },
      fontWeight: { value: "normal" },
      textDecoration: { value: "none" }
    }
  }
}, Dne = {
  // shared styles
  fontWeight: { value: "{fontWeights.bold.value}" },
  transitionDuration: {
    value: "{components.fieldcontrol.transitionDuration.value}"
  },
  fontSize: { value: "{components.fieldcontrol.fontSize.value}" },
  lineHeight: { value: "{components.fieldcontrol.lineHeight.value}" },
  paddingBlockStart: {
    value: "{components.fieldcontrol.paddingBlockStart.value}"
  },
  paddingBlockEnd: {
    value: "{components.fieldcontrol.paddingBlockEnd.value}"
  },
  paddingInlineStart: {
    value: "{components.fieldcontrol.paddingInlineStart.value}"
  },
  paddingInlineEnd: {
    value: "{components.fieldcontrol.paddingInlineEnd.value}"
  },
  backgroundColor: { value: "transparent" },
  borderColor: { value: "{components.fieldcontrol.borderColor.value}" },
  borderWidth: { value: "{components.fieldcontrol.borderWidth.value}" },
  borderStyle: { value: "{components.fieldcontrol.borderStyle.value}" },
  borderRadius: { value: "{components.fieldcontrol.borderRadius.value}" },
  color: { value: "{colors.font.primary.value}" },
  _hover: {
    color: { value: "{colors.font.focus.value}" },
    backgroundColor: { value: "{colors.primary.10.value}" },
    borderColor: { value: "{colors.primary.60.value}" }
  },
  _focus: {
    color: { value: "{colors.font.focus.value}" },
    backgroundColor: { value: "{colors.primary.10.value}" },
    borderColor: { value: "{colors.border.focus.value}" },
    boxShadow: { value: "{components.fieldcontrol._focus.boxShadow.value}" }
  },
  _active: {
    color: { value: "{colors.font.active.value}" },
    backgroundColor: { value: "{colors.primary.20.value}" },
    borderColor: { value: "{colors.primary.100.value}" }
  },
  _loading: {
    color: { value: "{colors.font.disabled.value}" },
    backgroundColor: { value: "transparent" },
    borderColor: { value: "{colors.border.tertiary.value}" }
  },
  _disabled: {
    color: { value: "{colors.font.disabled.value}" },
    backgroundColor: { value: "transparent" },
    borderColor: { value: "{colors.border.tertiary.value}" }
  },
  // variations
  outlined: {
    info: {
      borderColor: { value: "{colors.blue.60.value}" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.blue.100}" },
      _hover: {
        borderColor: { value: "{colors.blue.60.value}" },
        backgroundColor: { value: "{colors.blue.10.value}" },
        color: { value: "{colors.blue.100.value}" }
      },
      _focus: {
        borderColor: { value: "{colors.blue.100.value}" },
        backgroundColor: { value: "{colors.blue.10.value}" },
        color: { value: "{colors.blue.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.info._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "{colors.blue.100.value}" },
        backgroundColor: { value: "{colors.blue.20.value}" },
        color: { value: "{colors.blue.100.value}" }
      }
    },
    warning: {
      borderColor: { value: "{colors.orange.60.value}" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.orange.100}" },
      _hover: {
        borderColor: { value: "{colors.orange.60.value}" },
        backgroundColor: { value: "{colors.orange.10.value}" },
        color: { value: "{colors.orange.100.value}" }
      },
      _focus: {
        borderColor: { value: "{colors.orange.100.value}" },
        backgroundColor: { value: "{colors.orange.10.value}" },
        color: { value: "{colors.orange.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.warning._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "{colors.orange.100.value}" },
        backgroundColor: { value: "{colors.orange.20.value}" },
        color: { value: "{colors.orange.100.value}" }
      }
    },
    success: {
      borderColor: { value: "{colors.green.60.value}" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.green.100}" },
      _hover: {
        borderColor: { value: "{colors.green.60.value}" },
        backgroundColor: { value: "{colors.green.10.value}" },
        color: { value: "{colors.green.100.value}" }
      },
      _focus: {
        borderColor: { value: "{colors.green.100.value}" },
        backgroundColor: { value: "{colors.green.10.value}" },
        color: { value: "{colors.green.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.success._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "{colors.green.100.value}" },
        backgroundColor: { value: "{colors.green.20.value}" },
        color: { value: "{colors.green.100.value}" }
      }
    },
    error: {
      borderColor: { value: "{colors.red.80.value}" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.red.100}" },
      _hover: {
        borderColor: { value: "{colors.red.80.value}" },
        backgroundColor: { value: "{colors.red.10.value}" },
        color: { value: "{colors.red.100.value}" }
      },
      _focus: {
        borderColor: { value: "{colors.red.100.value}" },
        backgroundColor: { value: "{colors.red.10.value}" },
        color: { value: "{colors.red.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol._error._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "{colors.red.100.value}" },
        backgroundColor: { value: "{colors.red.20.value}" },
        color: { value: "{colors.red.100.value}" }
      }
    },
    overlay: {
      borderColor: { value: "{colors.overlay.60.value}" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.font.primary.value}" },
      _hover: {
        borderColor: { value: "{colors.overlay.60.value}" },
        backgroundColor: { value: "{colors.overlay.5.value}" },
        color: { value: "{colors.neutral.90.value}" }
      },
      _focus: {
        borderColor: { value: "{colors.overlay.90.value}" },
        backgroundColor: { value: "{colors.overlay.5.value}" },
        color: { value: "{colors.neutral.90.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.overlay._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "{colors.overlay.90.value}" },
        backgroundColor: { value: "{colors.overlay.10.value}" },
        color: { value: "{colors.neutral.100.value}" }
      }
    }
  },
  primary: {
    borderColor: { value: "transparent" },
    borderWidth: { value: "{borderWidths.small.value}" },
    borderStyle: { value: "solid" },
    backgroundColor: { value: "{colors.primary.80.value}" },
    color: { value: "{colors.font.inverse.value}" },
    _disabled: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.background.disabled.value}" },
      color: { value: "{colors.font.disabled.value}" }
    },
    _loading: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.background.disabled.value}" },
      color: { value: "{colors.font.disabled.value}" }
    },
    _hover: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.primary.90.value}" },
      color: { value: "{colors.font.inverse.value}" }
    },
    _focus: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.primary.90.value}" },
      color: { value: "{colors.font.inverse.value}" },
      boxShadow: { value: "{components.fieldcontrol._focus.boxShadow.value}" }
    },
    _active: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.primary.100.value}" },
      color: { value: "{colors.font.inverse.value}" }
    },
    info: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.blue.80}" },
      color: { value: "{colors.font.inverse.value}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.blue.90.value}" },
        color: { value: "{colors.font.inverse.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.blue.90.value}" },
        color: { value: "{colors.font.inverse.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.info._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.blue.100.value}" },
        color: { value: "{colors.font.inverse.value}" }
      }
    },
    warning: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.orange.80}" },
      color: { value: "{colors.font.inverse.value}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.orange.90.value}" },
        color: { value: "{colors.font.inverse.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.orange.90.value}" },
        color: { value: "{colors.font.inverse.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.overlay._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.orange.100.value}" },
        color: { value: "{colors.font.inverse.value}" }
      }
    },
    error: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.red.80}" },
      color: { value: "{colors.font.inverse.value}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.red.90.value}" },
        color: { value: "{colors.font.inverse.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.red.90.value}" },
        color: { value: "{colors.font.inverse.value}" },
        boxShadow: {
          value: "{components.fieldcontrol._error._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.red.100.value}" },
        color: { value: "{colors.font.inverse.value}" }
      }
    },
    success: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.green.80}" },
      color: { value: "{colors.font.inverse.value}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.green.90.value}" },
        color: { value: "{colors.font.inverse.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.green.90.value}" },
        color: { value: "{colors.font.inverse.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.success._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.green.100.value}" },
        color: { value: "{colors.font.inverse.value}" }
      }
    },
    overlay: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.overlay.70}" },
      color: { value: "{colors.font.inverse.value}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.overlay.90.value}" },
        color: { value: "{colors.font.inverse.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.overlay.90.value}" },
        color: { value: "{colors.font.inverse.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.overlay._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.overlay.90.value}" },
        color: { value: "{colors.font.inverse.value}" }
      }
    }
  },
  menu: {
    borderWidth: { value: "{space.zero.value}" },
    backgroundColor: { value: "transparent" },
    justifyContent: { value: "start" },
    // Focus and hover styles are identical for menu variation
    // because for Menu primitive, menu items are forced to be focused even
    // for mouse interactions, making it impossible to distinguish the two interactions
    _hover: {
      color: { value: "{colors.font.inverse.value}" },
      backgroundColor: { value: "{colors.primary.80.value}" }
    },
    _focus: {
      color: { value: "{colors.font.inverse.value}" },
      backgroundColor: { value: "{colors.primary.80.value}" }
    },
    _active: {
      color: { value: "{colors.font.inverse.value}" },
      backgroundColor: { value: "{colors.primary.90.value}" }
    },
    _disabled: {
      color: { value: "{colors.font.disabled.value}" }
    }
  },
  link: {
    backgroundColor: { value: "transparent" },
    borderColor: { value: "transparent" },
    borderWidth: { value: "{borderWidths.small.value}" },
    color: { value: "{colors.font.interactive.value}" },
    _hover: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.primary.10.value}" },
      color: { value: "{colors.font.hover.value}" }
    },
    _focus: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.primary.10.value}" },
      color: { value: "{colors.font.focus.value}" },
      boxShadow: { value: "{components.fieldcontrol._focus.boxShadow.value}" }
    },
    _active: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.primary.20.value}" },
      color: { value: "{colors.font.active.value}" }
    },
    _disabled: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.font.disabled.value}" }
    },
    _loading: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.font.disabled.value}" }
    },
    info: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.blue.100}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.blue.10.value}" },
        color: { value: "{colors.blue.90.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.blue.10.value}" },
        color: { value: "{colors.blue.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.info._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.blue.20.value}" },
        color: { value: "{colors.blue.100.value}" }
      }
    },
    warning: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.orange.100}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.orange.10.value}" },
        color: { value: "{colors.orange.90.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.orange.10.value}" },
        color: { value: "{colors.orange.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.warning._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.orange.20.value}" },
        color: { value: "{colors.orange.100.value}" }
      }
    },
    success: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.green.100}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.green.10.value}" },
        color: { value: "{colors.green.90.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.green.10.value}" },
        color: { value: "{colors.green.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.success._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.green.20.value}" },
        color: { value: "{colors.green.100.value}" }
      }
    },
    error: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.red.100}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.red.10.value}" },
        color: { value: "{colors.red.90.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.red.10.value}" },
        color: { value: "{colors.red.100.value}" },
        boxShadow: {
          value: "{components.fieldcontrol._error._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.red.20.value}" },
        color: { value: "{colors.red.100.value}" }
      }
    },
    overlay: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.neutral.100}" },
      _hover: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.overlay.5.value}" },
        color: { value: "{colors.overlay.80.value}" }
      },
      _focus: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.overlay.5.value}" },
        color: { value: "{colors.overlay.90.value}" },
        boxShadow: {
          value: "{components.fieldcontrol.overlay._focus.boxShadow.value}"
        }
      },
      _active: {
        borderColor: { value: "transparent" },
        backgroundColor: { value: "{colors.overlay.10.value}" },
        color: { value: "{colors.overlay.90.value}" }
      }
    }
  },
  warning: {
    backgroundColor: { value: "transparent" },
    borderColor: { value: "{colors.red.60}" },
    borderWidth: { value: "{borderWidths.small}" },
    color: { value: "{colors.red.60}" },
    _hover: {
      borderColor: { value: "{colors.red.80}" },
      backgroundColor: { value: "{colors.red.10}" },
      color: { value: "{colors.font.error}" }
    },
    _focus: {
      borderColor: { value: "{colors.red.80}" },
      backgroundColor: { value: "{colors.red.10}" },
      color: { value: "{colors.red.80}" },
      boxShadow: { value: "{components.fieldcontrol._error._focus.boxShadow}" }
    },
    _active: {
      borderColor: { value: "{colors.red.100}" },
      backgroundColor: { value: "{colors.red.20}" },
      color: { value: "{colors.red.100}" }
    },
    _disabled: {
      borderColor: { value: "{colors.border.tertiary}" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.font.disabled}" }
    },
    _loading: {
      borderColor: { value: "{colors.border.tertiary}" },
      backgroundColor: { value: "transparent" },
      color: { value: "{colors.font.disabled}" }
    }
  },
  destructive: {
    borderColor: { value: "transparent" },
    borderWidth: { value: "{borderWidths.small}" },
    borderStyle: { value: "solid" },
    backgroundColor: { value: "{colors.red.60}" },
    color: { value: "{colors.font.inverse}" },
    _disabled: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.background.disabled}" },
      color: { value: "{colors.font.disabled}" }
    },
    _loading: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.background.disabled}" },
      color: { value: "{colors.font.disabled}" }
    },
    _hover: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.red.80}" },
      color: { value: "{colors.font.inverse}" }
    },
    _focus: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.red.80}" },
      color: { value: "{colors.font.inverse}" },
      boxShadow: { value: "{components.fieldcontrol._error._focus.boxShadow}" }
    },
    _active: {
      borderColor: { value: "transparent" },
      backgroundColor: { value: "{colors.red.100}" },
      color: { value: "{colors.font.inverse}" }
    }
  },
  // sizes
  small: {
    fontSize: { value: "{components.fieldcontrol.small.fontSize.value}" },
    paddingBlockStart: {
      value: "{components.fieldcontrol.small.paddingBlockStart.value}"
    },
    paddingBlockEnd: {
      value: "{components.fieldcontrol.small.paddingBlockEnd.value}"
    },
    paddingInlineStart: {
      value: "{components.fieldcontrol.small.paddingInlineStart.value}"
    },
    paddingInlineEnd: {
      value: "{components.fieldcontrol.small.paddingInlineEnd.value}"
    }
  },
  large: {
    fontSize: { value: "{components.fieldcontrol.large.fontSize.value}" },
    paddingBlockStart: {
      value: "{components.fieldcontrol.large.paddingBlockStart.value}"
    },
    paddingBlockEnd: {
      value: "{components.fieldcontrol.large.paddingBlockEnd.value}"
    },
    paddingInlineStart: {
      value: "{components.fieldcontrol.large.paddingInlineStart.value}"
    },
    paddingInlineEnd: {
      value: "{components.fieldcontrol.large.paddingInlineEnd.value}"
    }
  },
  loaderWrapper: {
    alignItems: {
      value: "center"
    },
    gap: {
      value: "{space.xs.value}"
    }
  }
}, One = {
  backgroundColor: { value: "{colors.background.primary.value}" },
  borderRadius: { value: "{radii.xs.value}" },
  borderWidth: { value: "0" },
  borderStyle: { value: "solid" },
  borderColor: { value: "transparent" },
  boxShadow: { value: "none" },
  padding: { value: "{space.medium.value}" },
  outlined: {
    backgroundColor: { value: "{components.card.backgroundColor.value}" },
    borderRadius: { value: "{radii.xs.value}" },
    borderWidth: { value: "{borderWidths.small.value}" },
    borderStyle: { value: "solid" },
    borderColor: { value: "{colors.border.primary.value}" },
    boxShadow: { value: "{components.card.boxShadow.value}" }
  },
  elevated: {
    backgroundColor: { value: "{components.card.backgroundColor.value}" },
    borderRadius: { value: "{radii.xs.value}" },
    borderWidth: { value: "0" },
    borderStyle: { value: "solid" },
    borderColor: { value: "transparent" },
    boxShadow: { value: "{shadows.medium.value}" }
  }
}, Fne = {
  cursor: { value: "pointer" },
  alignItems: { value: "center" },
  _disabled: {
    cursor: {
      value: "not-allowed"
    }
  },
  button: {
    position: { value: "relative" },
    alignItems: { value: "center" },
    justifyContent: { value: "center" },
    color: { value: "{colors.font.inverse.value}" },
    before: {
      width: { value: "100%" },
      height: { value: "100%" },
      borderWidth: { value: "{borderWidths.medium.value}" },
      borderRadius: { value: "20%" },
      borderStyle: { value: "solid" },
      borderColor: { value: "{colors.border.primary.value}" }
    },
    _focus: {
      outlineColor: { value: "{colors.transparent.value}" },
      outlineStyle: { value: "solid" },
      outlineWidth: { value: "{outlineWidths.medium.value}" },
      outlineOffset: { value: "{outlineOffsets.medium.value}" },
      borderColor: { value: "{colors.border.focus.value}" },
      boxShadow: { value: "{components.fieldcontrol._focus.boxShadow.value}" }
    },
    _disabled: {
      borderColor: { value: "{colors.border.disabled.value}" }
    },
    _error: {
      borderColor: { value: "{colors.border.error.value}" },
      _focus: {
        borderColor: { value: "{colors.border.error.value}" },
        boxShadow: {
          value: "{components.fieldcontrol._error._focus.boxShadow.value}"
        }
      }
    }
  },
  icon: {
    backgroundColor: { value: "{colors.primary.80.value}" },
    borderRadius: { value: "20%" },
    opacity: { value: "{opacities.0.value}" },
    transform: { value: "scale(0)" },
    transitionProperty: { value: "all" },
    transitionDuration: { value: "{time.short.value}" },
    transitionTimingFunction: { value: "ease-in-out" },
    _checked: {
      opacity: { value: "{opacities.100.value}" },
      transform: { value: "scale(1)" },
      _disabled: {
        backgroundColor: { value: "{colors.background.disabled.value}" }
      }
    },
    _indeterminate: {
      opacity: { value: "{opacities.100.value}" },
      transform: { value: "scale(1)" },
      _disabled: {
        backgroundColor: { value: "{colors.background.disabled.value}" }
      }
    }
  },
  label: {
    color: { value: "{components.text.color.value}" },
    _disabled: {
      color: {
        value: "{colors.font.disabled.value}"
      }
    }
  }
}, Mne = {
  alignItems: { value: "flex-start" },
  alignContent: { value: "center" },
  flexDirection: { value: "column" },
  justifyContent: { value: "center" }
}, Pne = {
  pagination: {
    current: {
      color: { value: "{components.pagination.current.color}" },
      backgroundColor: {
        value: "{components.pagination.current.backgroundColor}"
      }
    },
    button: {
      color: { value: "{components.pagination.button.color}" },
      _hover: {
        backgroundColor: {
          value: "{components.pagination.button.hover.backgroundColor}"
        },
        color: { value: "{components.pagination.button.hover.color}" }
      },
      _disabled: {
        color: { value: "{components.pagination.button.disabled.color}" }
      }
    }
  },
  search: {
    input: {
      color: { value: "{components.searchfield.color}" }
    },
    button: {
      color: { value: "{components.searchfield.button.color}" },
      _active: {
        backgroundColor: {
          value: "{components.searchfield.button._active.backgroundColor}"
        },
        borderColor: {
          value: "{components.searchfield.button._active.borderColor}"
        },
        color: { value: "{components.searchfield.button._active.color}" }
      },
      _disabled: {
        backgroundColor: {
          value: "{components.searchfield.button._disabled.backgroundColor}"
        },
        borderColor: {
          value: "{components.searchfield.button._disabled.borderColor}"
        },
        color: {
          value: "{components.searchfield.button._disabled.color}"
        }
      },
      _focus: {
        backgroundColor: {
          value: "{components.searchfield.button._focus.backgroundColor}"
        },
        borderColor: {
          value: "{components.searchfield.button._focus.borderColor}"
        },
        color: { value: "{components.searchfield.button._focus.color}" }
      },
      _hover: {
        backgroundColor: {
          value: "{components.searchfield.button._hover.backgroundColor}"
        },
        borderColor: {
          value: "{components.searchfield.button._hover.borderColor}"
        },
        color: { value: "{components.searchfield.button._hover.color}" }
      }
    }
  }
}, Bne = {
  fontSize: { value: "{fontSizes.xs}" },
  gap: { value: "{space.relative.medium}" },
  svg: {
    path: {
      fill: {
        value: "{colors.font.primary}"
      }
    }
  },
  toolTip: {
    bottom: { value: "{space.large}" },
    color: { value: "{colors.teal.100}" },
    fontSize: { value: "{fontSizes.xxs}" }
  }
}, Lne = {
  height: {
    value: "{space.relative.full.value}"
  }
}, Wne = {
  borderStyle: { value: "solid" },
  borderColor: { value: "{colors.border.primary.value}" },
  borderWidth: { value: "{borderWidths.medium.value}" },
  label: {
    color: { value: "{colors.font.tertiary.value}" },
    paddingInline: { value: "{space.medium.value}" },
    fontSize: { value: "{fontSizes.small.value}" },
    backgroundColor: { value: "{colors.background.primary.value}" }
  },
  small: {
    borderWidth: { value: "{borderWidths.small.value}" }
  },
  large: {
    borderWidth: { value: "{borderWidths.large.value}" }
  },
  opacity: {
    value: "{opacities.60.value}"
  }
}, zne = {
  backgroundColor: { value: "{colors.background.primary}" },
  borderRadius: { value: "{radii.small}" },
  borderColor: { value: "{colors.border.primary}" },
  borderStyle: { value: "dashed" },
  borderWidth: { value: "{borderWidths.small}" },
  color: { value: "{colors.font.primary}" },
  gap: { value: "{space.small}" },
  paddingBlock: { value: "{space.xl}" },
  paddingInline: { value: "{space.large}" },
  textAlign: { value: "center" },
  _active: {
    backgroundColor: { value: "{colors.primary.10}" },
    borderRadius: { value: "{components.dropzone.borderRadius}" },
    borderColor: { value: "{colors.border.pressed}" },
    borderStyle: { value: "{components.dropzone.borderStyle}" },
    borderWidth: { value: "{components.dropzone.borderWidth}" },
    color: { value: "{colors.font.primary}" }
  },
  _disabled: {
    backgroundColor: { value: "{colors.background.disabled}" },
    borderRadius: { value: "{components.dropzone.borderRadius}" },
    borderColor: { value: "{colors.border.disabled}" },
    borderStyle: { value: "{components.dropzone.borderStyle}" },
    borderWidth: { value: "{components.dropzone.borderWidth}" },
    color: { value: "{colors.font.disabled}" }
  },
  accepted: {
    backgroundColor: { value: "{colors.background.success}" },
    borderRadius: { value: "{components.dropzone.borderRadius}" },
    borderColor: { value: "{colors.border.success}" },
    borderStyle: { value: "{components.dropzone.borderStyle}" },
    borderWidth: { value: "{components.dropzone.borderWidth}" },
    color: { value: "{colors.font.success}" }
  },
  rejected: {
    backgroundColor: { value: "{colors.background.error}" },
    borderRadius: { value: "{components.dropzone.borderRadius}" },
    borderColor: { value: "{colors.border.pressed}" },
    borderStyle: { value: "{components.dropzone.borderStyle}" },
    borderWidth: { value: "{components.dropzone.borderWidth}" },
    color: { value: "{colors.font.error}" }
  }
}, Vne = {
  backgroundColor: { value: "{colors.background.primary.value}" },
  item: {
    borderColor: { value: "{colors.border.secondary.value}" },
    borderWidth: { value: "{borderWidths.small.value}" },
    borderStyle: { value: "solid" },
    borderRadius: { value: "{radii.small.value}" },
    trigger: {
      alignItems: { value: "center" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      color: { value: "inherit" },
      gap: { value: "{space.small.value}" },
      justifyContent: { value: "space-between" },
      paddingBlock: { value: "{space.xs.value}" },
      paddingInline: { value: "{space.small.value}" },
      _hover: {
        color: { value: "inherit" },
        backgroundColor: { value: "{colors.overlay.5.value}" }
      },
      _focus: {
        borderColor: { value: "{colors.border.focus.value}" },
        boxShadow: {
          value: {
            offsetX: "0",
            offsetY: "0",
            blurRadius: "0",
            spreadRadius: "2px",
            color: "{colors.border.focus.value}"
          }
        }
      }
    },
    content: {
      color: { value: "inherit" },
      paddingInline: { value: "{space.small.value}" },
      paddingBlockEnd: { value: "{space.small.value}" },
      paddingBlockStart: { value: "{space.xxxs.value}" }
    },
    icon: {
      color: { value: "{colors.font.tertiary.value}" },
      transitionDuration: { value: "{time.medium.value}" },
      transitionTimingFunction: { value: "cubic-bezier(0.87, 0, 0.13, 1)" }
    }
  }
}, Hne = {
  // default styles
  gap: { value: "{space.xs.value}" },
  fontSize: { value: "{fontSizes.medium.value}" },
  flexDirection: { value: "column" },
  // Adjust base fontSize and gap for small and large sizes
  small: {
    gap: { value: "{space.xxxs.value}" },
    fontSize: { value: "{fontSizes.small.value}" }
  },
  large: {
    gap: { value: "{space.small.value}" },
    fontSize: { value: "{fontSizes.large.value}" }
  },
  label: {
    color: { value: "{colors.font.secondary.value}" }
  }
}, jne = {
  borderStyle: { value: "solid" },
  borderColor: { value: "{colors.border.primary.value}" },
  borderWidth: { value: "{borderWidths.small.value}" },
  borderRadius: { value: "{radii.small.value}" },
  color: { value: "{colors.font.primary.value}" },
  paddingBlockStart: {
    value: "{space.xs.value}"
  },
  paddingBlockEnd: {
    value: "{space.xs.value}"
  },
  paddingInlineStart: {
    value: "{space.medium.value}"
  },
  paddingInlineEnd: {
    value: "{space.medium.value}"
  },
  fontSize: { value: "{components.field.fontSize.value}" },
  lineHeight: { value: "{lineHeights.medium.value}" },
  transitionDuration: { value: "{time.medium.value}" },
  outlineColor: { value: "{colors.transparent.value}" },
  outlineStyle: { value: "solid" },
  outlineWidth: { value: "{outlineWidths.medium.value}" },
  outlineOffset: { value: "{outlineOffsets.medium.value}" },
  small: {
    fontSize: { value: "{components.field.small.fontSize.value}" },
    paddingBlockStart: {
      value: "{space.xxs.value}"
    },
    paddingBlockEnd: {
      value: "{space.xxs.value}"
    },
    paddingInlineStart: {
      value: "{space.small.value}"
    },
    paddingInlineEnd: {
      value: "{space.small.value}"
    }
  },
  large: {
    fontSize: { value: "{components.field.large.fontSize.value}" },
    paddingBlockStart: {
      value: "{space.xs.value}"
    },
    paddingBlockEnd: {
      value: "{space.xs.value}"
    },
    paddingInlineStart: {
      value: "{space.medium.value}"
    },
    paddingInlineEnd: {
      value: "{space.medium.value}"
    }
  },
  quiet: {
    borderStyle: { value: "none" },
    borderInlineStart: { value: "none" },
    borderInlineEnd: { value: "none" },
    borderBlockStart: { value: "none" },
    borderRadius: { value: "0" },
    _focus: {
      borderBlockEndColor: { value: "transparent" },
      boxShadow: {
        value: "{components.fieldcontrol._focus.boxShadow.value}"
      }
    },
    _error: {
      borderBlockEndColor: { value: "{colors.border.error.value}" },
      _focus: {
        borderBlockEndColor: { value: "transparent" },
        boxShadow: {
          value: "{components.fieldcontrol._error._focus.boxShadow.value}"
        }
      }
    }
  },
  _focus: {
    // These focus styles have been calibrated to create
    // a highly visible focus indicator per WCAG 2.2 guidlines:
    // See: https://www.w3.org/TR/WCAG22/#focus-appearance
    //
    // Key features:
    // * Focus indicator area is at least the 2 CSS px perimeter around the component.
    // * Contrast between focused and unfocused area of contrast has a ratio of 3:1
    //
    // IMPORTANT: Must recalibrate if `colors.border.focus` are changed
    borderColor: { value: "{colors.border.focus.value}" },
    boxShadow: {
      value: {
        offsetX: "0px",
        offsetY: "0px",
        blurRadius: "0px",
        spreadRadius: "2px",
        color: "{colors.border.focus.value}"
      }
    }
  },
  _disabled: {
    color: { value: "{colors.font.disabled.value}" },
    cursor: { value: "not-allowed" },
    borderColor: { value: "{colors.transparent.value}" },
    backgroundColor: { value: "{colors.background.disabled.value}" }
  },
  _error: {
    borderColor: { value: "{colors.border.error.value}" },
    color: { value: "{colors.font.error.value}" },
    _focus: {
      boxShadow: {
        value: {
          offsetX: "0px",
          offsetY: "0px",
          blurRadius: "0px",
          spreadRadius: "2px",
          color: "{colors.border.error.value}"
        }
      }
    }
  },
  info: {
    _focus: {
      boxShadow: {
        value: {
          offsetX: "0px",
          offsetY: "0px",
          blurRadius: "0px",
          spreadRadius: "2px",
          color: "{colors.blue.100.value}"
        }
      }
    }
  },
  warning: {
    _focus: {
      boxShadow: {
        value: {
          offsetX: "0px",
          offsetY: "0px",
          blurRadius: "0px",
          spreadRadius: "2px",
          color: "{colors.orange.100.value}"
        }
      }
    }
  },
  success: {
    _focus: {
      boxShadow: {
        value: {
          offsetX: "0px",
          offsetY: "0px",
          blurRadius: "0px",
          spreadRadius: "2px",
          color: "{colors.green.100.value}"
        }
      }
    }
  },
  overlay: {
    _focus: {
      boxShadow: {
        value: {
          offsetX: "0px",
          offsetY: "0px",
          blurRadius: "0px",
          spreadRadius: "2px",
          color: "{colors.overlay.90.value}"
        }
      }
    }
  }
}, Une = {
  gap: { value: "{space.zero.value}" },
  vertical: {
    alignItems: { value: "center" }
  },
  outer: {
    alignItems: { value: "center" }
  }
}, Gne = {
  backgroundColor: { value: "transparent" },
  borderRadius: { value: "{radii.xs.value}" },
  flexDirection: {
    value: "column"
  },
  gap: { value: "{components.field.gap.value}" },
  legend: {
    color: { value: "{colors.font.primary.value}" },
    fontSize: { value: "{components.field.fontSize.value}" },
    fontWeight: { value: "{fontWeights.bold.value}" },
    lineHeight: { value: "{lineHeights.medium.value}" },
    small: {
      fontSize: "{components.field.small.fontSize.value}"
    },
    large: {
      fontSize: "{components.field.large.fontSize.value}"
    }
  },
  outlined: {
    padding: "{space.medium.value}",
    borderColor: "{colors.neutral.40.value}",
    borderWidth: "{borderWidths.small.value}",
    borderStyle: "solid",
    small: {
      padding: "{space.small.value}"
    },
    large: {
      padding: "{space.large.value}"
    }
  },
  small: {
    gap: "{components.field.small.gap.value}"
  },
  large: {
    gap: "{components.field.large.gap.value}"
  }
}, qne = {
  error: {
    color: { value: "{colors.font.error.value}" },
    fontSize: { value: "{fontSizes.small.value}" }
  },
  description: {
    color: { value: "{colors.font.secondary.value}" },
    fontStyle: { value: "italic" },
    fontSize: { value: "{fontSizes.small.value}" }
  }
}, Kne = {
  gap: { value: "{space.medium.value}" },
  justifyContent: { value: "normal" },
  alignItems: { value: "stretch" },
  alignContent: { value: "normal" },
  flexWrap: { value: "nowrap" }
}, Xne = {
  color: { value: "{colors.font.primary.value}" },
  lineHeight: { value: "{lineHeights.small.value}" },
  1: {
    fontSize: { value: "{fontSizes.xxxxl.value}" },
    fontWeight: { value: "{fontWeights.light.value}" }
  },
  2: {
    fontSize: { value: "{fontSizes.xxxl.value}" },
    fontWeight: { value: "{fontWeights.normal.value}" }
  },
  3: {
    fontSize: { value: "{fontSizes.xxl.value}" },
    fontWeight: { value: "{fontWeights.medium.value}" }
  },
  4: {
    fontSize: { value: "{fontSizes.xl.value}" },
    fontWeight: { value: "{fontWeights.semibold.value}" }
  },
  5: {
    fontSize: { value: "{fontSizes.large.value}" },
    fontWeight: { value: "{fontWeights.bold.value}" }
  },
  6: {
    fontSize: { value: "{fontSizes.medium.value}" },
    fontWeight: { value: "{fontWeights.extrabold.value}" }
  }
}, Yne = {
  highlighted: {
    fontWeight: { value: "{fontWeights.bold}" }
  }
}, Zne = {
  lineHeight: { value: 1 },
  height: { value: "1em" }
  // Should match height of parent container font-size
}, Jne = {
  color: { value: "{components.fieldcontrol.color.value}" },
  borderColor: { value: "{components.fieldcontrol.borderColor.value}" },
  fontSize: { value: "{components.fieldcontrol.fontSize.value}" },
  _focus: {
    borderColor: {
      value: "{components.fieldcontrol._focus.borderColor.value}"
    }
  }
}, Qne = {
  maxWidth: { value: "100%" },
  height: { value: "auto" },
  objectFit: { value: "initial" },
  objectPosition: { value: "initial" }
}, ere = {
  banner: {
    height: { value: "150px " },
    width: { value: "400px " }
  },
  button: {
    backgroundColor: { value: "#e8e8e8" },
    borderRadius: { value: "5px" },
    color: { value: "black" }
  },
  dialog: {
    height: { value: "50vh" },
    minHeight: { value: "400px" },
    minWidth: { value: "400px" },
    width: { value: "30vw" }
  },
  header: {
    fontSize: { value: "{fontSizes.medium.value}" },
    fontWeight: { value: "{fontWeights.extrabold.value}" }
  }
}, tre = {
  active: { color: { value: "{colors.font.active.value}" } },
  color: { value: "{colors.font.interactive.value}" },
  focus: { color: { value: "{colors.font.focus.value}" } },
  hover: { color: { value: "{colors.font.hover.value}" } },
  visited: { color: { value: "{colors.font.interactive.value}" } }
}, nre = {
  cameraModule: {
    backgroundColor: { value: "{colors.black}" }
  }
}, rre = {
  width: { value: "{fontSizes.medium.value}" },
  height: { value: "{fontSizes.medium.value}" },
  fontSize: { value: "{fontSizes.xs.value}" },
  strokeEmpty: { value: "{colors.neutral.20.value}" },
  strokeFilled: { value: "{colors.primary.80.value}" },
  strokeLinecap: { value: "round" },
  animationDuration: { value: "1s" },
  small: {
    width: { value: "{fontSizes.small.value}" },
    height: { value: "{fontSizes.small.value}" },
    fontSize: { value: "{fontSizes.xxs.value}" }
  },
  large: {
    width: { value: "{fontSizes.large.value}" },
    height: { value: "{fontSizes.large.value}" },
    fontSize: { value: "{fontSizes.small.value}" }
  },
  linear: {
    width: { value: "100%" },
    minWidth: { value: "5rem" },
    fontSize: { value: "{fontSizes.xxs.value}" },
    strokeWidth: { value: "{fontSizes.xxs.value}" },
    strokeFilled: { value: "{colors.primary.80.value}" },
    strokeEmpty: { value: "{colors.neutral.20.value}" },
    strokeLinecap: { value: "round" },
    animationDuration: { value: "1s" },
    small: {
      strokeWidth: { value: "{fontSizes.xxxs.value}" },
      fontSize: { value: "{fontSizes.xxxs.value}" }
    },
    large: {
      strokeWidth: { value: "{fontSizes.xs.value}" },
      fontSize: { value: "{fontSizes.xs.value}" }
    }
  },
  text: {
    fill: { value: "{colors.font.primary.value}" }
  }
}, are = {
  backgroundColor: { value: "{colors.background.primary.value}" },
  borderRadius: { value: "{radii.medium.value}" },
  borderWidth: { value: "{borderWidths.small.value}" },
  borderStyle: { value: "solid" },
  borderColor: { value: "{colors.border.primary.value}" },
  boxShadow: { value: "{shadows.large.value}" },
  flexDirection: { value: "column" },
  gap: { value: "{space.zero.value}" },
  maxWidth: { value: "30rem" },
  minWidth: { value: "14rem" },
  small: {
    width: { value: "{fontSizes.medium.value}" },
    height: { value: "{fontSizes.medium.value}" }
  },
  large: {
    width: { value: "{fontSizes.xxxl.value}" },
    height: { value: "{fontSizes.xxxl.value}" }
  },
  item: {
    minHeight: { value: "2.5rem" },
    paddingInlineStart: { value: "{space.medium.value}" },
    paddingInlineEnd: { value: "{space.medium.value}" }
  }
}, sre = {
  // Default styles
  alignItems: { value: "center" },
  backgroundColor: { value: "{colors.background.tertiary.value}" },
  borderColor: { value: "transparent" },
  borderStyle: { value: "solid" },
  borderWidth: { value: "{borderWidths.small.value}" },
  borderRadius: { value: "{radii.xs.value}" },
  color: { value: "{colors.font.primary.value}" },
  justifyContent: { value: "flex-start" },
  paddingBlock: { value: "{space.small.value}" },
  paddingInline: { value: "{space.medium.value}" },
  lineHeight: { value: "{lineHeights.small.value}" },
  icon: {
    size: { value: "{fontSizes.xl.value}" }
  },
  heading: {
    fontSize: { value: "{fontSizes.medium.value}" },
    fontWeight: { value: "{fontWeights.bold.value}" }
  },
  dismiss: {
    gap: { value: "{space.xxs.value}" }
  },
  // Variations
  plain: {
    color: { value: "{colors.font.primary.value}" },
    backgroundColor: { value: "{colors.background.primary.value}" },
    borderColor: { value: "transparent" },
    info: {
      color: { value: "{colors.font.info.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "transparent" }
    },
    error: {
      color: { value: "{colors.font.error.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "transparent" }
    },
    success: {
      color: { value: "{colors.font.success.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "transparent" }
    },
    warning: {
      color: { value: "{colors.font.warning.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "transparent" }
    }
  },
  outlined: {
    color: { value: "{colors.font.primary.value}" },
    backgroundColor: { value: "{colors.background.primary.value}" },
    borderColor: { value: "{colors.border.primary.value}" },
    info: {
      color: { value: "{colors.font.info.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "{colors.border.info.value}" }
    },
    error: {
      color: { value: "{colors.font.error.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "{colors.border.error.value}" }
    },
    success: {
      color: { value: "{colors.font.success.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "{colors.border.success.value}" }
    },
    warning: {
      color: { value: "{colors.font.warning.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "{colors.border.warning.value}" }
    }
  },
  filled: {
    color: { value: "{colors.font.primary.value}" },
    backgroundColor: { value: "{colors.background.secondary.value}" },
    borderColor: { value: "transparent" },
    info: {
      color: { value: "{colors.font.info.value}" },
      backgroundColor: { value: "{colors.background.info.value}" },
      borderColor: { value: "transparent" }
    },
    error: {
      color: { value: "{colors.font.error.value}" },
      backgroundColor: { value: "{colors.background.error.value}" },
      borderColor: { value: "transparent" }
    },
    success: {
      color: { value: "{colors.font.success.value}" },
      backgroundColor: { value: "{colors.background.success.value}" },
      borderColor: { value: "transparent" }
    },
    warning: {
      color: { value: "{colors.font.warning.value}" },
      backgroundColor: { value: "{colors.background.warning.value}" },
      borderColor: { value: "transparent" }
    }
  }
}, ore = {
  current: {
    alignItems: { value: "center" },
    justifyContent: { value: "center" },
    color: { value: "{colors.font.inverse.value}" },
    fontSize: { value: "{fontSizes.small.value}" },
    backgroundColor: { value: "{colors.overlay.40.value}" }
  },
  button: {
    color: { value: "{colors.font.primary.value}" },
    paddingInlineStart: { value: "{space.xxs.value}" },
    paddingInlineEnd: { value: "{space.xxs.value}" },
    transitionProperty: { value: "background-color" },
    transitionDuration: { value: "{time.medium.value}" },
    hover: {
      backgroundColor: { value: "{colors.overlay.10.value}" },
      color: { value: "{colors.font.primary.value}" }
    },
    disabled: {
      color: { value: "{colors.font.disabled.value}" }
    }
  },
  ellipsis: {
    alignItems: { value: "baseline" },
    justifyContent: { value: "center" },
    paddingInlineStart: { value: "{space.xs.value}" },
    paddingInlineEnd: { value: "{space.xs.value}" }
  },
  itemContainer: {
    marginLeft: { value: "{space.xxxs.value}" },
    marginRight: { value: "{space.xxxs.value}" }
  },
  itemShared: {
    height: { value: "{fontSizes.xxl.value}" },
    minWidth: { value: "{fontSizes.xxl.value}" },
    borderRadius: { value: "{fontSizes.medium.value}" }
  }
}, ire = {
  color: { value: "{components.fieldcontrol.color.value}" },
  button: {
    color: { value: "{components.button.color.value}" },
    _active: {
      backgroundColor: {
        value: "{components.button._active.backgroundColor.value}"
      },
      borderColor: { value: "{components.button._active.borderColor.value}" },
      color: { value: "{components.button._active.color.value}" }
    },
    _disabled: {
      backgroundColor: {
        value: "{components.button._disabled.backgroundColor.value}"
      },
      borderColor: {
        value: "{components.button._disabled.borderColor.value}"
      },
      color: { value: "{components.button._disabled.color.value}" }
    },
    _error: {
      color: { value: "{components.button.outlined.error.color.value}" },
      backgroundColor: {
        value: "{components.button.outlined.error.backgroundColor.value}"
      },
      borderColor: {
        value: "{components.button.outlined.error.borderColor.value}"
      },
      _active: {
        borderColor: {
          value: "{components.button.outlined.error._active.borderColor.value}"
        },
        backgroundColor: {
          value: "{components.button.outlined.error._active.backgroundColor.value}"
        },
        color: {
          value: "{components.button.outlined.error._active.color.value}"
        }
      },
      _focus: {
        borderColor: {
          value: "{components.button.outlined.error._focus.borderColor.value}"
        },
        backgroundColor: {
          value: "{components.button.outlined.error._focus.backgroundColor.value}"
        },
        color: {
          value: "{components.button.outlined.error._focus.color.value}"
        },
        boxShadow: {
          value: "{components.button.outlined.error._focus.boxShadow.value}"
        }
      },
      _hover: {
        borderColor: {
          value: "{components.button.outlined.error._hover.borderColor.value}"
        },
        backgroundColor: {
          value: "{components.button.outlined.error._hover.backgroundColor.value}"
        },
        color: {
          value: "{components.button.outlined.error._hover.color.value}"
        }
      }
    },
    _focus: {
      backgroundColor: {
        value: "{components.button._focus.backgroundColor.value}"
      },
      borderColor: { value: "{components.button._focus.borderColor.value}" },
      color: { value: "{components.button._focus.color.value}" }
    },
    _hover: {
      backgroundColor: {
        value: "{components.button._hover.backgroundColor.value}"
      },
      borderColor: { value: "{components.button._hover.borderColor.value}" },
      color: { value: "{components.button._hover.color.value}" }
    }
  }
}, ure = {
  color: { value: "{components.fieldcontrol.color}" },
  borderColor: { value: "{components.fieldcontrol.borderColor}" },
  fontSize: { value: "{components.fieldcontrol.fontSize}" },
  _focus: {
    borderColor: { value: "{components.fieldcontrol._focus.borderColor}" }
  }
}, cre = {
  borderRadius: { value: "{radii.small.value}" },
  transitionDuration: { value: "{time.long.value}" },
  startColor: { value: "{colors.background.secondary.value}" },
  endColor: { value: "{colors.background.tertiary.value}" },
  // sizes
  small: {
    height: { value: "{space.small.value}" }
  },
  default: {
    height: { value: "{space.medium.value}" }
  },
  large: {
    height: { value: "{space.large.value}" }
  }
}, lre = {
  alignItems: { value: "center" },
  justifyContent: { value: "flex-start" },
  gap: { value: "inherit" },
  _disabled: { cursor: { value: "not-allowed" } },
  button: {
    alignItems: { value: "center" },
    justifyContent: { value: "center" },
    width: { value: "{fontSizes.medium.value}" },
    height: { value: "{fontSizes.medium.value}" },
    boxSizing: { value: "border-box" },
    borderWidth: { value: "{borderWidths.medium.value}" },
    borderStyle: { value: "solid" },
    borderRadius: { value: "50%" },
    borderColor: { value: "{colors.border.primary.value}" },
    color: { value: "{colors.background.primary.value}" },
    backgroundColor: { value: "{colors.background.primary.value}" },
    transitionProperty: { value: "all" },
    transitionDuration: { value: "{time.medium.value}" },
    outlineColor: { value: "{colors.transparent.value}" },
    outlineStyle: { value: "solid" },
    outlineWidth: { value: "{outlineWidths.medium.value}" },
    outlineOffset: { value: "{outlineOffsets.medium.value}" },
    // We want the dot inside the border to be a border-width from the border
    padding: { value: "{borderWidths.medium.value}" },
    small: {
      width: { value: "{fontSizes.small.value}" },
      height: { value: "{fontSizes.small.value}" }
    },
    large: {
      width: { value: "{fontSizes.large.value}" },
      height: { value: "{fontSizes.large.value}" }
    },
    _checked: {
      color: {
        value: "{colors.primary.80.value}"
      },
      _disabled: { color: { value: "{colors.background.disabled.value}" } }
    },
    _focus: {
      borderColor: { value: "{colors.border.focus.value}" },
      boxShadow: { value: "{components.fieldcontrol._focus.boxShadow.value}" }
    },
    _error: {
      borderColor: { value: "{colors.border.error.value}" },
      _focus: {
        boxShadow: {
          value: "{components.fieldcontrol._error._focus.boxShadow.value}"
        }
      }
    },
    _disabled: {
      borderColor: { value: "{colors.border.disabled.value}" },
      backgroundColor: { value: "{colors.background.primary.value}" }
    }
  },
  label: {
    color: { value: "{components.text.color.value}" },
    _disabled: {
      color: {
        value: "{colors.font.disabled.value}"
      }
    }
  }
}, dre = {
  radio: {
    borderWidth: { value: "{components.radio.button.borderWidth}" },
    borderColor: { value: "{components.radio.button.borderColor}" },
    backgroundColor: { value: "{components.radio.button.backgroundColor}" },
    _checked: {
      color: { value: "{components.radio.button._checked.color}" }
    },
    label: {
      color: { value: "{components.radio.label.color}" }
    }
  },
  legend: {
    color: { value: "{components.fieldset.legend.color}" },
    fontWeight: { value: "{fontWeights.normal}" }
  }
}, fre = {
  large: { size: { value: "{fontSizes.xxxl.value}" } },
  default: { size: { value: "{fontSizes.xl.value}" } },
  small: { size: { value: "{fontSizes.small.value}" } },
  filled: { color: { value: "{colors.secondary.80.value}" } },
  empty: { color: { value: "{colors.background.tertiary.value}" } }
}, pre = {
  color: { value: "{components.fieldcontrol.color.value}" },
  button: {
    color: { value: "{components.button.color.value}" },
    backgroundColor: { value: "{colors.background.primary.value}" },
    _active: {
      backgroundColor: {
        value: "{components.button._active.backgroundColor.value}"
      },
      borderColor: { value: "{components.button._active.borderColor.value}" },
      color: { value: "{components.button._active.color.value}" }
    },
    _disabled: {
      backgroundColor: {
        value: "{components.button._disabled.backgroundColor.value}"
      },
      borderColor: {
        value: "{components.button._disabled.borderColor.value}"
      },
      color: { value: "{components.button._disabled.color.value}" }
    },
    _focus: {
      backgroundColor: {
        value: "{components.button._focus.backgroundColor.value}"
      },
      borderColor: { value: "{components.button._focus.borderColor.value}" },
      color: { value: "{components.button._focus.color.value}" }
    },
    _hover: {
      backgroundColor: {
        value: "{components.button._hover.backgroundColor.value}"
      },
      borderColor: { value: "{components.button._hover.borderColor.value}" },
      color: { value: "{components.button._hover.color.value}" }
    }
  }
}, hre = {
  color: { value: "{components.fieldcontrol.color}" },
  backgroundColor: { value: "{colors.background.primary.value}" },
  paddingInlineEnd: { value: "{space.xxl.value}" },
  _disabled: {
    color: { value: "{colors.font.disabled.value}" },
    backgroundColor: { value: "{colors.background.disabled.value}" }
  },
  // wrappers
  wrapper: {
    flex: { value: "1" },
    display: { value: "block" },
    position: { value: "relative" },
    cursor: { value: "pointer" }
  },
  iconWrapper: {
    alignItems: { value: "center" },
    position: { value: "absolute" },
    top: { value: "50%" },
    right: { value: "{space.medium.value}" },
    transform: { value: "translateY(-50%)" },
    pointerEvents: { value: "none" },
    small: {
      right: { value: "{space.xs.value}" }
    },
    large: {
      right: { value: "{space.medium.value}" }
    }
  },
  // It's important to test these option values on Chrome/FireFox/Edge
  // on Windows because they allow styling of the option element.
  // Chrome/Safari/Firefox on Mac uses the system ui.
  option: {
    backgroundColor: { value: "transparent" },
    color: { value: "{colors.font.primary.value}" },
    _disabled: {
      color: { value: "{colors.font.disabled.value}" },
      backgroundColor: {
        value: "transparent"
      }
    }
  },
  whiteSpace: { value: "nowrap" },
  minWidth: { value: "6.5rem" },
  small: {
    minWidth: { value: "5.5rem" },
    paddingInlineEnd: { value: "{space.xl.value}" }
  },
  large: {
    minWidth: { value: "7.5rem" },
    paddingInlineEnd: { value: "{space.xxl.value}" }
  },
  expanded: {
    paddingBlock: { value: "{space.xs.value}" },
    paddingInline: { value: "{space.small.value}" },
    option: {
      paddingBlock: { value: "{space.xs.value}" },
      paddingInline: { value: "{space.small.value}" }
    }
  }
}, mre = {
  borderColor: { value: "{components.fieldcontrol.borderColor}" },
  color: { value: "{components.fieldcontrol.color}" },
  flexDirection: {
    value: "column"
  },
  fontSize: { value: "{components.fieldcontrol.fontSize}" },
  _focus: {
    borderColor: { value: "{components.fieldcontrol._focus.borderColor}" }
  },
  label: {
    color: { value: "{components.field.label.color}" }
  }
}, gre = {
  paddingBlock: { value: "{space.xs.value}" },
  // The track is the thin background of the slider
  track: {
    backgroundColor: { value: "{colors.background.quaternary.value}" },
    borderRadius: { value: "9999px" },
    height: { value: "0.375rem" },
    minWidth: { value: "10rem" }
  },
  // The range is the filled part of the track
  range: {
    backgroundColor: { value: "{colors.primary.80.value}" },
    borderRadius: { value: "9999px" },
    _disabled: {
      backgroundColor: { value: "{colors.background.disabled.value}" }
    }
  },
  // The thumb is the circle above the track that the user drags
  thumb: {
    width: { value: "1.25rem" },
    height: { value: "1.25rem" },
    backgroundColor: { value: "{colors.background.primary.value}" },
    boxShadow: { value: "{shadows.small.value}" },
    borderRadius: { value: "50%" },
    borderWidth: { value: "{borderWidths.medium.value}" },
    borderColor: { value: "{colors.border.primary.value}" },
    borderStyle: { value: "solid" },
    _disabled: {
      backgroundColor: { value: "{colors.background.disabled.value}" },
      borderColor: { value: "transparent" },
      boxShadow: { value: "none" }
    },
    _hover: {
      backgroundColor: { value: "{colors.background.primary.value}" },
      borderColor: { value: "{colors.border.focus.value}" }
    },
    _focus: {
      borderColor: { value: "{colors.border.focus.value}" },
      boxShadow: { value: "{components.fieldcontrol._focus.boxShadow.value}" }
    }
  },
  small: {
    track: {
      height: { value: "0.25rem" }
    },
    thumb: {
      width: { value: "1rem" },
      height: { value: "1rem" }
    }
  },
  large: {
    track: {
      height: { value: "0.625rem" }
    },
    thumb: {
      width: { value: "1.5rem" },
      height: { value: "1.5rem" }
    }
  }
}, yre = {
  borderColor: { value: "{components.fieldcontrol.borderColor}" },
  flexDirection: { value: "column" },
  input: {
    color: { value: "{components.fieldcontrol.color}" },
    fontSize: { value: "{components.fieldcontrol.fontSize}" },
    textAlign: { value: "center" }
  },
  button: {
    color: { value: "{components.button.color}" },
    backgroundColor: { value: "{colors.transparent}" },
    _active: {
      color: { value: "{components.button._active.color}" },
      backgroundColor: { value: "{components.button._active.backgroundColor}" }
    },
    _focus: {
      color: { value: "{components.button._focus.color}" },
      backgroundColor: { value: "{components.button._focus.backgroundColor}" }
    },
    _disabled: {
      color: { value: "{components.button._disabled.color}" },
      backgroundColor: {
        value: "{components.fieldcontrol._disabled.backgroundColor}"
      }
    },
    _hover: {
      color: { value: "{components.button._hover.color}" },
      backgroundColor: { value: "{components.button._hover.backgroundColor}" }
    }
  }
}, vre = {
  dropzone: {
    backgroundColor: { value: "{colors.background.primary}" },
    borderRadius: { value: "{radii.small}" },
    borderColor: { value: "{colors.border.primary}" },
    borderStyle: { value: "dashed" },
    borderWidth: { value: "{borderWidths.small}" },
    gap: { value: "{space.small}" },
    paddingBlock: { value: "{space.xl}" },
    paddingInline: { value: "{space.large}" },
    textAlign: { value: "center" },
    _active: {
      backgroundColor: { value: "{colors.primary.10}" },
      borderRadius: {
        value: "{components.storagemanager.dropzone.borderRadius}"
      },
      borderColor: { value: "{colors.border.pressed}" },
      borderStyle: {
        value: "{components.storagemanager.dropzone.borderStyle}"
      },
      borderWidth: { value: "{borderWidths.medium}" }
    },
    icon: {
      color: { value: "{colors.border.primary}" },
      fontSize: { value: "{fontSizes.xxl}" }
    },
    text: {
      color: { value: "{colors.font.tertiary}" },
      fontSize: { value: "{fontSizes.medium}" },
      fontWeight: { value: "{fontWeights.bold}" }
    }
  },
  file: {
    backgroundColor: { value: "{colors.background.primary}" },
    borderRadius: { value: "{radii.small}" },
    borderColor: { value: "{colors.border.primary}" },
    borderStyle: { value: "solid" },
    borderWidth: { value: "{borderWidths.small}" },
    paddingBlock: { value: "{space.xs}" },
    paddingInline: { value: "{space.small}" },
    gap: { value: "{space.small}" },
    alignItems: { value: "baseline" },
    name: {
      fontSize: { value: "{fontSizes.medium}" },
      fontWeight: { value: "{fontWeights.bold}" },
      color: { value: "{colors.font.primary}" }
    },
    size: {
      fontSize: { value: "{fontSizes.small}" },
      fontWeight: { value: "{fontWeights.normal}" },
      color: { value: "{colors.font.tertiary}" }
    },
    image: {
      width: { value: "{space.xxl}" },
      height: { value: "{space.xxl}" },
      backgroundColor: { value: "{colors.background.secondary}" },
      color: { value: "{colors.font.tertiary}" },
      borderRadius: { value: "{radii.small}" }
    }
  },
  filelist: {
    flexDirection: { value: "column" },
    gap: { value: "{space.small}" }
  },
  loader: {
    strokeLinecap: { value: "round" },
    strokeEmpty: { value: "{colors.border.secondary}" },
    strokeFilled: { value: "{components.loader.strokeFilled}" },
    strokeWidth: { value: "{borderWidths.large}" }
  },
  previewer: {
    backgroundColor: { value: "{colors.background.primary}" },
    borderColor: { value: "{colors.border.primary}" },
    borderStyle: { value: "solid" },
    borderWidth: { value: "{borderWidths.small}" },
    borderRadius: { value: "{radii.small}" },
    paddingBlock: { value: "{space.zero}" },
    paddingInline: { value: "{space.zero}" },
    maxHeight: { value: "40rem" },
    maxWidth: { value: "auto" },
    text: {
      fontSize: { value: "{fontSizes.medium}" },
      fontWeight: { value: "{fontWeights.bold}" },
      color: { value: "{colors.font.primary}" }
    },
    body: {
      paddingBlock: { value: "{space.medium}" },
      paddingInline: { value: "{space.medium}" },
      gap: { value: "{space.small}" }
    },
    footer: {
      justifyContent: { value: "flex-end" }
    }
  }
}, bre = {
  // States
  _disabled: {
    opacity: { value: "{opacities.60.value}" }
  },
  _focused: {
    shadow: {
      value: "{components.fieldcontrol._focus.boxShadow.value}"
    }
  },
  // Sizes
  fontSize: { value: "{fontSizes.medium.value}" },
  large: {
    fontSize: { value: "{fontSizes.large.value}" }
  },
  small: {
    fontSize: { value: "{fontSizes.small.value}" }
  },
  // Child elements
  label: {
    padding: { value: "{space.xs.value}" }
  },
  thumb: {
    backgroundColor: { value: "{colors.background.primary.value}" },
    borderColor: { value: "transparent" },
    borderWidth: { value: "{borderWidths.small.value}" },
    borderStyle: { value: "solid" },
    borderRadius: { value: "{radii.xxxl.value}" },
    checked: {
      transform: { value: "{transforms.slideX.medium.value}" }
    },
    transition: {
      duration: { value: "{time.medium.value}" }
    },
    width: { value: "{space.relative.medium.value}" }
  },
  track: {
    backgroundColor: { value: "{colors.background.quaternary.value}" },
    borderRadius: { value: "{radii.xxxl.value}" },
    checked: {
      backgroundColor: { value: "{colors.primary.80.value}" }
    },
    height: { value: "{space.relative.medium.value}" },
    padding: { value: "{outlineWidths.medium.value}" },
    transition: {
      duration: { value: "{time.short.value}" }
    },
    width: { value: "{space.relative.xl.value}" },
    _error: {
      backgroundColor: { value: "{colors.background.error.value}" }
    }
  }
}, wre = {
  /**
   * Default table styles
   */
  borderCollapse: { value: "collapse" },
  display: { value: "table" },
  width: { value: "100%" },
  /**
   * Default table head styles
   */
  head: {
    display: { value: "table-header-group" },
    verticalAlign: { value: "middle" }
  },
  /**
   * Default table body styles
   */
  body: {
    display: { value: "table-row-group" },
    verticalAlign: { value: "middle" }
  },
  /**
   * Default table foot styles
   */
  foot: {
    display: { value: "table-footer-group" },
    verticalAlign: { value: "middle" }
  },
  /**
   * Default table row styles
   */
  row: {
    display: { value: "table-row" },
    verticalAlign: { value: "middle" },
    hover: {
      backgroundColor: { value: "{colors.background.tertiary.value}" }
    },
    striped: {
      backgroundColor: { value: "{colors.background.secondary.value}" }
    }
  },
  /**
   * Default table header cell styles
   */
  header: {
    borderColor: { value: "{colors.border.tertiary.value}" },
    borderStyle: { value: "solid" },
    borderWidth: { value: "{borderWidths.small.value}" },
    color: { value: "{colors.font.primary.value}" },
    display: { value: "table-cell" },
    fontSize: { value: "{fontSizes.medium.value}" },
    fontWeight: { value: "{fontWeights.bold.value}" },
    padding: { value: "{space.medium.value}" },
    verticalAlign: { value: "middle" },
    large: {
      fontSize: { value: "{fontSizes.large.value}" },
      padding: { value: "{space.large.value}" }
    },
    small: {
      fontSize: { value: "{fontSizes.small.value}" },
      padding: { value: "{space.xs.value}" }
    }
  },
  /**
   * Default table data cell styles
   */
  data: {
    borderColor: { value: "{colors.border.tertiary.value}" },
    borderStyle: { value: "solid" },
    borderWidth: { value: "{borderWidths.small.value}" },
    color: { value: "{colors.font.primary.value}" },
    display: { value: "table-cell" },
    fontSize: { value: "{fontSizes.medium.value}" },
    fontWeight: { value: "{fontWeights.normal.value}" },
    padding: { value: "{space.medium.value}" },
    verticalAlign: { value: "middle" },
    large: {
      fontSize: { value: "{fontSizes.large.value}" },
      padding: { value: "{space.large.value}" }
    },
    small: {
      fontSize: { value: "{fontSizes.small.value}" },
      padding: { value: "{space.xs.value}" }
    }
  },
  /**
   * Default table caption styles
   */
  caption: {
    captionSide: { value: "bottom" },
    color: { value: "{colors.font.primary.value}" },
    display: { value: "table-caption" },
    fontSize: { value: "{fontSizes.medium.value}" },
    textAlign: { value: "center" },
    wordBreak: { value: "break-all" },
    large: {
      fontSize: { value: "{fontSizes.large.value}" }
    },
    small: {
      fontSize: { value: "{fontSizes.small.value}" }
    }
  }
}, Sre = {
  backgroundColor: { value: "transparent" },
  borderColor: { value: "{colors.border.secondary.value}" },
  borderStyle: { value: "solid" },
  borderWidth: { value: "{borderWidths.medium.value}" },
  gap: { value: "0" },
  item: {
    backgroundColor: { value: "transparent" },
    borderColor: { value: "{colors.border.secondary.value}" },
    borderStyle: { value: "solid" },
    borderWidth: { value: "{borderWidths.medium.value}" },
    color: { value: "{colors.font.secondary.value}" },
    fontSize: { value: "{fontSizes.medium.value}" },
    fontWeight: { value: "{fontWeights.bold.value}" },
    paddingVertical: { value: "{space.small.value}" },
    paddingHorizontal: { value: "{space.medium.value}" },
    textAlign: { value: "center" },
    transitionDuration: { value: "{time.medium.value}" },
    _hover: {
      backgroundColor: { value: "transparent" },
      borderColor: { value: "{colors.border.focus.value}" },
      boxShadow: { value: "none" },
      color: { value: "{colors.font.hover.value}" }
    },
    _focus: {
      backgroundColor: { value: "transparent" },
      borderColor: { value: "{colors.border.focus.value}" },
      boxShadow: {
        value: {
          offsetX: "0px",
          offsetY: "0px",
          blurRadius: "0px",
          spreadRadius: "{borderWidths.medium}",
          color: "{colors.border.focus.value}"
        }
      },
      color: { value: "{colors.font.focus.value}" }
    },
    _active: {
      backgroundColor: { value: "transparent" },
      borderColor: { value: "{colors.font.interactive.value}" },
      boxShadow: { value: "none" },
      color: { value: "{colors.font.interactive.value}" }
    },
    _disabled: {
      backgroundColor: { value: "transparent" },
      borderColor: { value: "{colors.border.tertiary.value}" },
      boxShadow: { value: "none" },
      color: { value: "{colors.font.disabled.value}" }
    }
  },
  panel: {
    backgroundColor: { value: "transparent" },
    paddingInline: { value: "0" },
    paddingBlock: { value: "{space.small.value}" }
  }
}, _re = {
  // default styles
  color: { value: "{colors.font.primary.value}" },
  // variations
  primary: {
    color: { value: "{colors.font.primary.value}" }
  },
  secondary: {
    color: { value: "{colors.font.secondary.value}" }
  },
  tertiary: {
    color: { value: "{colors.font.tertiary.value}" }
  },
  error: {
    color: { value: "{colors.font.error.value}" }
  },
  warning: {
    color: { value: "{colors.font.warning.value}" }
  },
  success: {
    color: { value: "{colors.font.success.value}" }
  },
  info: {
    color: { value: "{colors.font.info.value}" }
  }
}, xre = {
  color: { value: "{components.fieldcontrol.color.value}" },
  borderColor: { value: "{components.fieldcontrol.borderColor.value}" },
  _focus: {
    borderColor: {
      value: "{components.fieldcontrol._focus.borderColor.value}"
    }
  }
}, Ire = {
  color: { value: "{components.fieldcontrol.color.value}" },
  borderColor: { value: "{components.fieldcontrol.borderColor.value}" },
  fontSize: { value: "{components.fieldcontrol.fontSize.value}" },
  _focus: {
    borderColor: {
      value: "{components.fieldcontrol._focus.borderColor.value}"
    }
  }
}, kre = {
  borderColor: { value: "{colors.border.primary.value}" },
  color: { value: "{colors.font.primary.value}" },
  _hover: {
    backgroundColor: { value: "{colors.overlay.10.value}" }
  },
  _focus: {
    borderColor: { value: "{colors.border.focus.value}" },
    color: { value: "{colors.font.primary.value}" }
  },
  _active: {
    backgroundColor: { value: "{colors.transparent.value}" }
  },
  _disabled: {
    backgroundColor: { value: "{colors.transparent.value}" },
    borderColor: { value: "{colors.border.disabled.value}" },
    color: { value: "{colors.font.disabled.value}" }
  },
  _pressed: {
    borderColor: { value: "{colors.border.pressed.value}" },
    color: { value: "{colors.font.primary.value}" },
    backgroundColor: { value: "{colors.overlay.20.value}" },
    _hover: {
      backgroundColor: { value: "{colors.overlay.30.value}" }
    }
  },
  primary: {
    backgroundColor: { value: "{colors.transparent.value}" },
    borderWidth: { value: "{borderWidths.small.value}" },
    _focus: {
      borderColor: { value: "{colors.border.focus.value}" },
      backgroundColor: { value: "{colors.transparent.value}" },
      boxShadow: { value: "{components.fieldcontrol._focus.boxShadow.value}" },
      color: { value: "{colors.font.primary.value}" }
    },
    _hover: {
      backgroundColor: { value: "{colors.overlay.10.value}" },
      color: { value: "{colors.font.primary.value}" }
    },
    _disabled: {
      borderColor: { value: "{colors.border.disabled.value}" },
      backgroundColor: { value: "{colors.background.disabled.value}" },
      color: { value: "{colors.font.disabled.value}" }
    },
    _pressed: {
      backgroundColor: { value: "{colors.primary.80.value}" },
      borderColor: { value: "{colors.primary.80.value}" },
      color: { value: "{colors.background.primary.value}" },
      _focus: {
        backgroundColor: {
          value: "{colors.border.focus.value}"
        },
        borderColor: { value: "{colors.border.focus.value}" },
        color: { value: "{colors.background.primary.value}" }
      },
      _hover: {
        borderColor: { value: "{colors.primary.60.value}" },
        backgroundColor: {
          value: "{colors.primary.60.value}"
        },
        boxShadow: { value: "{colors.primary.60.value}" },
        color: { value: "{colors.background.primary.value}" }
      }
    }
  },
  link: {
    backgroundColor: { value: "{colors.transparent.value}" },
    color: { value: "{colors.overlay.50.value}" },
    _hover: {
      backgroundColor: { value: "{colors.transparent.value}" },
      color: { value: "{colors.overlay.50.value}" }
    },
    _focus: {
      backgroundColor: { value: "{colors.transparent.value}" },
      color: { value: "{colors.overlay.50.value}" }
    },
    _disabled: {
      backgroundColor: { value: "{colors.transparent.value}" },
      color: { value: "{colors.font.disabled.value}" }
    },
    _pressed: {
      backgroundColor: { value: "{colors.transparent.value}" },
      color: { value: "{colors.overlay.90.value}" },
      _focus: {
        backgroundColor: { value: "{colors.transparent.value}" },
        color: { value: "{colors.overlay.90.value}" }
      },
      _hover: {
        color: { value: "{colors.overlay.90.value}" },
        backgroundColor: { value: "{colors.transparent.value}" }
      }
    }
  }
}, Ere = {
  alignItems: { value: "center" },
  alignContent: { value: "center" },
  justifyContent: { value: "flex-start" }
}, Tre = {
  accordion: Vne,
  alert: Cne,
  authenticator: Ane,
  autocomplete: Nne,
  badge: Rne,
  breadcrumbs: $ne,
  button: Dne,
  card: One,
  checkbox: Fne,
  checkboxfield: Mne,
  collection: Pne,
  copy: Bne,
  countrycodeselect: Lne,
  divider: Wne,
  dropzone: zne,
  field: Hne,
  fieldcontrol: jne,
  fieldgroup: Une,
  fieldmessages: qne,
  fieldset: Gne,
  flex: Kne,
  heading: Xne,
  icon: Zne,
  highlightmatch: Yne,
  image: Qne,
  inappmessaging: ere,
  input: Jne,
  link: tre,
  liveness: nre,
  loader: rre,
  menu: are,
  message: sre,
  pagination: ore,
  passwordfield: ire,
  phonenumberfield: ure,
  placeholder: cre,
  radio: lre,
  radiogroup: dre,
  rating: fre,
  searchfield: pre,
  select: hre,
  selectfield: mre,
  sliderfield: gre,
  stepperfield: yre,
  storagemanager: vre,
  switchfield: bre,
  table: wre,
  tabs: Sre,
  text: _re,
  textareafield: xre,
  textfield: Ire,
  togglebutton: kre,
  togglebuttongroup: Ere
}, Cre = {
  default: {
    variable: {
      value: `'InterVariable', 'Inter var', 'Inter', -apple-system, BlinkMacSystemFont,
        'Helvetica Neue', 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Open Sans',
        sans-serif`
    },
    static: {
      value: `'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue',
        'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif`
    }
  }
}, ia = {
  xxxs: { value: "0.375rem" },
  xxs: { value: "0.5rem" },
  xs: { value: "0.75rem" },
  small: { value: "0.875rem" },
  medium: { value: "1rem" },
  large: { value: "1.25rem" },
  xl: { value: "1.5rem" },
  xxl: { value: "2rem" },
  xxxl: { value: "2.5rem" },
  xxxxl: { value: "3rem" }
}, y3 = {
  hairline: { value: 100 },
  thin: { value: 200 },
  light: { value: 300 },
  normal: { value: 400 },
  medium: { value: 500 },
  semibold: { value: 600 },
  bold: { value: 700 },
  extrabold: { value: 800 },
  black: { value: 900 }
}, Nre = {
  small: { value: "1.25" },
  medium: { value: "1.5" },
  large: { value: "2" }
}, v3 = {
  0: { value: "0" },
  10: { value: "0.1" },
  20: { value: "0.2" },
  30: { value: "0.3" },
  40: { value: "0.4" },
  50: { value: "0.5" },
  60: { value: "0.6" },
  70: { value: "0.7" },
  80: { value: "0.8" },
  90: { value: "0.9" },
  100: { value: "1" }
}, Are = {
  small: { value: "1px" },
  medium: { value: "2px" },
  large: { value: "3px" }
}, Rre = {
  small: { value: "1px" },
  medium: { value: "2px" },
  large: { value: "3px" }
}, b3 = {
  xs: { value: "0.125rem" },
  small: { value: "0.25rem" },
  medium: { value: "0.5rem" },
  large: { value: "1rem" },
  xl: { value: "2rem" },
  xxl: { value: "4rem" },
  xxxl: { value: "8rem" }
}, $re = {
  small: {
    value: {
      offsetX: "0px",
      offsetY: "2px",
      blurRadius: "4px",
      color: "{colors.shadow.tertiary.value}"
    }
  },
  medium: {
    value: {
      offsetX: "0px",
      offsetY: "2px",
      blurRadius: "6px",
      color: "{colors.shadow.secondary.value}"
    }
  },
  large: {
    value: {
      offsetX: "0px",
      offsetY: "4px",
      blurRadius: "12px",
      color: "{colors.shadow.primary.value}"
    }
  }
}, ua = {
  zero: { value: "0" },
  xxxs: { value: "0.25rem" },
  xxs: { value: "0.375rem" },
  xs: { value: "0.5rem" },
  small: { value: "0.75rem" },
  medium: { value: "1rem" },
  large: { value: "1.5rem" },
  xl: { value: "2.0rem" },
  xxl: { value: "3.0rem" },
  xxxl: { value: "4.5rem" },
  relative: {
    //creating a second set of sizes using em which will be sized relative to a parent instead of the root
    xxxs: { value: "0.25em" },
    xxs: { value: "0.375em" },
    xs: { value: "0.5em" },
    small: { value: "0.75em" },
    medium: { value: "1em" },
    large: { value: "1.5em" },
    xl: { value: "2.0em" },
    xxl: { value: "3.0em" },
    xxxl: { value: "4.5em" },
    full: { value: "100%" }
  }
}, w3 = {
  short: { value: "100ms" },
  medium: { value: "250ms" },
  long: { value: "500ms" }
}, Dre = {
  // TODO: make this more generic and cross-platform
  slideX: {
    small: { value: "translateX(0.5em)" },
    medium: { value: "translateX(1em)" },
    large: { value: "translateX(2em)" }
  }
}, Ore = {
  components: Tre,
  borderWidths: m3,
  colors: g3,
  fonts: Cre,
  fontSizes: ia,
  fontWeights: y3,
  lineHeights: Nre,
  opacities: v3,
  outlineOffsets: Are,
  outlineWidths: Rre,
  radii: b3,
  shadows: $re,
  space: ua,
  time: w3,
  transforms: Dre
};
ia.xxs, ia.xs, ia.small, ia.medium, ia.large, ia.xl, ia.xxl, ia.xxxl, ua.xxxs, ua.xs, ua.small, ua.medium, ua.large, ua.xl, ua.xxl, ua.xxxl;
const Fre = {
  values: {
    base: 0,
    small: 480,
    medium: 768,
    large: 992,
    xl: 1280,
    xxl: 1536
  },
  defaultBreakpoint: "base"
}, S3 = {
  tokens: Ore,
  breakpoints: Fre,
  name: "default-theme"
};
function Mre(t, e, n, r) {
  var a = -1, s = t == null ? 0 : t.length;
  for (r && s && (n = t[++a]); ++a < s; )
    n = e(n, t[a], a, t);
  return n;
}
var Pre = Mre;
function Bre(t) {
  return function(e) {
    return t?.[e];
  };
}
var Lre = Bre, Wre = Lre, zre = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, Vre = Wre(zre), Hre = Vre, jre = Hre, Ure = n3, Gre = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, qre = "\\u0300-\\u036f", Kre = "\\ufe20-\\ufe2f", Xre = "\\u20d0-\\u20ff", Yre = qre + Kre + Xre, Zre = "[" + Yre + "]", Jre = RegExp(Zre, "g");
function Qre(t) {
  return t = Ure(t), t && t.replace(Gre, jre).replace(Jre, "");
}
var eae = Qre, tae = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function nae(t) {
  return t.match(tae) || [];
}
var rae = nae, aae = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function sae(t) {
  return aae.test(t);
}
var oae = sae, _3 = "\\ud800-\\udfff", iae = "\\u0300-\\u036f", uae = "\\ufe20-\\ufe2f", cae = "\\u20d0-\\u20ff", lae = iae + uae + cae, x3 = "\\u2700-\\u27bf", I3 = "a-z\\xdf-\\xf6\\xf8-\\xff", dae = "\\xac\\xb1\\xd7\\xf7", fae = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", pae = "\\u2000-\\u206f", hae = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", k3 = "A-Z\\xc0-\\xd6\\xd8-\\xde", mae = "\\ufe0e\\ufe0f", E3 = dae + fae + pae + hae, T3 = "['’]", Vb = "[" + E3 + "]", gae = "[" + lae + "]", C3 = "\\d+", yae = "[" + x3 + "]", N3 = "[" + I3 + "]", A3 = "[^" + _3 + E3 + C3 + x3 + I3 + k3 + "]", vae = "\\ud83c[\\udffb-\\udfff]", bae = "(?:" + gae + "|" + vae + ")", wae = "[^" + _3 + "]", R3 = "(?:\\ud83c[\\udde6-\\uddff]){2}", $3 = "[\\ud800-\\udbff][\\udc00-\\udfff]", ho = "[" + k3 + "]", Sae = "\\u200d", Hb = "(?:" + N3 + "|" + A3 + ")", _ae = "(?:" + ho + "|" + A3 + ")", jb = "(?:" + T3 + "(?:d|ll|m|re|s|t|ve))?", Ub = "(?:" + T3 + "(?:D|LL|M|RE|S|T|VE))?", D3 = bae + "?", O3 = "[" + mae + "]?", xae = "(?:" + Sae + "(?:" + [wae, R3, $3].join("|") + ")" + O3 + D3 + ")*", Iae = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", kae = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Eae = O3 + D3 + xae, Tae = "(?:" + [yae, R3, $3].join("|") + ")" + Eae, Cae = RegExp([
  ho + "?" + N3 + "+" + jb + "(?=" + [Vb, ho, "$"].join("|") + ")",
  _ae + "+" + Ub + "(?=" + [Vb, ho + Hb, "$"].join("|") + ")",
  ho + "?" + Hb + "+" + jb,
  ho + "+" + Ub,
  kae,
  Iae,
  C3,
  Tae
].join("|"), "g");
function Nae(t) {
  return t.match(Cae) || [];
}
var Aae = Nae, Rae = rae, $ae = oae, Dae = n3, Oae = Aae;
function Fae(t, e, n) {
  return t = Dae(t), e = n ? void 0 : e, e === void 0 ? $ae(t) ? Oae(t) : Rae(t) : t.match(e) || [];
}
var Mae = Fae, Pae = Pre, Bae = eae, Lae = Mae, Wae = "['’]", zae = RegExp(Wae, "g");
function Vae(t) {
  return function(e) {
    return Pae(Lae(Bae(e).replace(zae, "")), t, "");
  };
}
var Hae = Vae, jae = Hae, Uae = jae(function(t, e, n) {
  return t + (n ? "-" : "") + e.toLowerCase();
}), Gae = Uae;
const qae = /* @__PURE__ */ Vs(Gae), Kae = {
  opening_character: "{",
  closing_character: "}",
  separator: "."
};
var Xae = Kae;
const Yae = Xae;
function Zae(t = {}) {
  const e = Object.assign({}, Yae, t);
  return new RegExp(
    "\\" + e.opening_character + "([^" + e.closing_character + "]+)\\" + e.closing_character,
    "g"
  );
}
var Jae = Zae;
const Qae = Jae;
function F3(t, e = {}) {
  const n = e instanceof RegExp ? e : Qae(e);
  if (typeof t == "string")
    return n.test(t);
  if (typeof t == "object") {
    let r = !1;
    for (const a in t)
      if (t.hasOwnProperty(a)) {
        const s = t[a];
        if (F3(s, e)) {
          r = !0;
          break;
        }
      }
    return r;
  }
  return !1;
}
var ese = F3;
const tse = /* @__PURE__ */ Vs(ese), nse = "amplify", rse = [
  "offsetX",
  "offsetY",
  "blurRadius",
  "spreadRadius",
  "color"
];
function Gb(t) {
  if (!t)
    return "";
  if (tse(t)) {
    const e = t.replace(/\{|\}/g, "").replace(".value", "").split(".");
    return `var(--${Hg({ path: e })})`;
  }
  return t;
}
function ase(t) {
  const { value: e } = t;
  return Oo(e) ? Gb(e) : qb(e) ? rse.map((n) => Gb(
    // lookup property against `token` first for custom non-nested value, then lookup
    // property against `value` for design token value
    qb(t) ? t[n] : e[n]
  )).join(" ") : e;
}
function Hg({ path: t = [] }) {
  return `${qae([nse, ...t].join(" "))}`;
}
function jg(t) {
  return Fu(t) && Su(t, "value");
}
function qb(t) {
  return Fu(t) && Su(t, "offsetX");
}
function Hh({ tokens: t, path: e = [], setupToken: n }) {
  if (Su(t, "value"))
    return n({ token: t, path: e });
  const r = {};
  for (const a in t)
    if (Su(t, a)) {
      const s = t[a], o = Fu(s) ? s : { value: s };
      r[a] = Hh({
        tokens: o,
        path: e.concat(a),
        setupToken: n
      });
    }
  return r;
}
const Kb = ({ token: t, path: e }) => {
  const n = `--${Hg({ path: e })}`, { value: r } = t, a = ase(t);
  return { name: n, original: r, path: e, value: a, toString: () => `var(${n})` };
};
function Xb({ keys: t, value: e }) {
  return t.reduce((n, r) => ({
    ...n,
    [r]: { value: `{colors.${e}.${r}.value}` }
  }), {});
}
function M3(t, e = S3) {
  const n = Ene([{}, e, t]), { primaryColor: r, secondaryColor: a } = n;
  Oo(r) && (n.tokens.colors.primary = Xb({
    keys: Object.keys(n.tokens.colors[r]),
    value: r
  })), Oo(a) && (n.tokens.colors.secondary = Xb({
    keys: Object.keys(n.tokens.colors[a]),
    value: a
  }));
  const s = Hh({
    tokens: n.tokens,
    setupToken: Kb
  }), { breakpoints: o, name: i } = n;
  let c = `[data-amplify-theme="${i}"] {
` + zb(s).map((u) => `${u.name}: ${u.value};`).join(`
`) + `
}
`, l = [];
  return n.overrides && (l = n.overrides.map((u) => {
    const d = Hh({
      tokens: u.tokens,
      setupToken: Kb
    }), f = zb(d).map((p) => `${p.name}: ${p.value};`).join(`
`);
    if ("selector" in u && (c += `
${u.selector} {
${f}
}
`), "mediaQuery" in u && (c += `
@media (${u.mediaQuery}) {
  [data-amplify-theme="${i}"] {
    ${f}
  }
}
`), "breakpoint" in u) {
      const p = n.breakpoints.values[u.breakpoint];
      c += `
@media (min-width: ${p}px) {
  [data-amplify-theme="${i}"] {
    ${f}
  }
}
`;
    }
    return "colorMode" in u && (c += `
@media (prefers-color-scheme: ${u.colorMode}) {
          [data-amplify-theme="${i}"][data-amplify-color-mode="system"] {
            ${f}
            color-scheme: ${u.colorMode};
          }
        }
`, c += `
[data-amplify-theme="${i}"][data-amplify-color-mode="${u.colorMode}"] {
          ${f}
          color-scheme: ${u.colorMode};
        }
`), {
      ...u,
      tokens: d
    };
  })), {
    tokens: s,
    breakpoints: o,
    name: i,
    cssText: c,
    // keep overrides separate from base theme
    // this allows web platforms to use plain CSS scoped to a
    // selector and only override the CSS vars needed. This
    // means we could generate CSS at build-time in a postcss
    // plugin, or do it at runtime and inject the CSS into a
    // style tag.
    // This also allows RN to dynamically switch themes in a
    // provider.
    overrides: l
  };
}
const Fe = {
  Accordion: "amplify-accordion",
  AccordionItem: "amplify-accordion__item",
  AccordionItemTrigger: "amplify-accordion__item__trigger",
  AccordionItemContent: "amplify-accordion__item__content",
  AccordionItemIcon: "amplify-accordion__item__icon",
  Alert: "amplify-alert",
  AlertIcon: "amplify-alert__icon",
  AlertHeading: "amplify-alert__heading",
  AlertBody: "amplify-alert__body",
  AlertDismiss: "amplify-alert__dismiss",
  Autocomplete: "amplify-autocomplete",
  AutocompleteMenu: "amplify-autocomplete__menu",
  AutocompleteMenuEmpty: "amplify-autocomplete__menu--empty",
  AutocompleteMenuFooter: "amplify-autocomplete__menu__footer",
  AutocompleteMenuHeader: "amplify-autocomplete__menu__header",
  AutocompleteMenuLoading: "amplify-autocomplete__menu--loading",
  AutocompleteMenuOption: "amplify-autocomplete__menu__option",
  AutocompleteMenuOptions: "amplify-autocomplete__menu__options",
  Badge: "amplify-badge",
  Breadcrumbs: "amplify-breadcrumbs",
  BreadcrumbsList: "amplify-breadcrumbs__list",
  BreadcrumbsItem: "amplify-breadcrumbs__item",
  BreadcrumbsSeparator: "amplify-breadcrumbs__separator",
  BreadcrumbsLink: "amplify-breadcrumbs__link",
  Button: "amplify-button",
  ButtonGroup: "amplify-buttongroup",
  ButtonLoaderWrapper: "amplify-button__loader-wrapper",
  Card: "amplify-card",
  Checkbox: "amplify-checkbox",
  CheckboxButton: "amplify-checkbox__button",
  CheckboxIcon: "amplify-checkbox__icon",
  CheckboxInput: "amplify-checkbox__input",
  CheckboxLabel: "amplify-checkbox__label",
  CheckboxField: "amplify-checkboxfield",
  Collection: "amplify-collection",
  CollectionItems: "amplify-collection-items",
  CollectionSearch: "amplify-collection-search",
  CollectionPagination: "amplify-collection-pagination",
  CountryCodeSelect: "amplify-countrycodeselect",
  DialCodeSelect: "amplify-dialcodeselect",
  Divider: "amplify-divider",
  DividerLabel: "amplify-divider--label",
  DropZone: "amplify-dropzone",
  Field: "amplify-field",
  FieldDescription: "amplify-field__description",
  FieldErrorMessage: "amplify-field__error-message",
  FieldGroup: "amplify-field-group",
  FieldGroupControl: "amplify-field-group__control",
  FieldGroupOuterEnd: "amplify-field-group__outer-end",
  FieldGroupOuterStart: "amplify-field-group__outer-start",
  FieldGroupInnerEnd: "amplify-field-group__inner-end",
  FieldGroupInnerStart: "amplify-field-group__inner-start",
  FieldGroupIcon: "amplify-field-group__icon",
  FieldGroupIconButton: "amplify-field-group__icon-button",
  FieldGroupHasInnerEnd: "amplify-field-group--has-inner-end",
  FieldGroupHasInnerStart: "amplify-field-group--has-inner-start",
  FieldShowPassword: "amplify-field__show-password",
  FieldGroupFieldWrapper: "amplify-field-group__field-wrapper",
  Fieldset: "amplify-fieldset",
  FieldsetLegend: "amplify-fieldset__legend",
  Flex: "amplify-flex",
  Grid: "amplify-grid",
  Heading: "amplify-heading",
  HighlightMatch: "amplify-highlightmatch",
  HighlightMatchHighlighted: "amplify-highlightmatch__highlighted",
  Icon: "amplify-icon",
  Image: "amplify-image",
  Input: "amplify-input",
  Label: "amplify-label",
  Link: "amplify-link",
  Loader: "amplify-loader",
  LoaderLabel: "amplify-loader__label",
  MenuContent: "amplify-menu__content",
  MenuItem: "amplify-menu__content__item",
  MenuTrigger: "amplify-menu__trigger",
  MenuWrapper: "amplify-menu__wrapper",
  Message: "amplify-message",
  MessageIcon: "amplify-message__icon",
  MessageHeading: "amplify-message__heading",
  MessageBody: "amplify-message__body",
  MessageContent: "amplify-message__content",
  MessageDismiss: "amplify-message__dismiss",
  Pagination: "amplify-pagination",
  PaginationItem: "amplify-pagination__item",
  PasswordField: "amplify-passwordfield",
  PhoneNumberField: "amplify-phonenumberfield",
  Placeholder: "amplify-placeholder",
  Radio: "amplify-radio",
  RadioButton: "amplify-radio__button",
  RadioInput: "amplify-radio__input",
  RadioLabel: "amplify-radio__label",
  RadioGroupField: "amplify-radiogroupfield",
  RadioGroup: "amplify-radiogroup",
  Rating: "amplify-rating",
  RatingItem: "amplify-rating__item",
  RatingIcon: "amplify-rating__icon",
  RatingLabel: "amplify-rating__label",
  ScrollView: "amplify-scrollview",
  SearchField: "amplify-searchfield",
  SearchFieldClear: "amplify-searchfield__clear",
  SearchFieldSearch: "amplify-searchfield__search",
  Select: "amplify-select",
  SelectField: "amplify-selectfield",
  SelectWrapper: "amplify-select__wrapper",
  SelectIcon: "amplify-select__icon",
  SliderField: "amplify-sliderfield",
  SliderFieldGroup: "amplify-sliderfield__group",
  SliderFieldLabel: "amplify-sliderfield__label",
  SliderFieldRange: "amplify-sliderfield__range",
  SliderFieldRoot: "amplify-sliderfield__root",
  SliderFieldThumb: "amplify-sliderfield__thumb",
  SliderFieldTrack: "amplify-sliderfield__track",
  StepperField: "amplify-stepperfield",
  StepperFieldButtonDecrease: "amplify-stepperfield__button--decrease",
  StepperFieldButtonIncrease: "amplify-stepperfield__button--increase",
  StepperFieldInput: "amplify-stepperfield__input",
  StorageImage: "amplify-storageimage",
  StorageManager: "amplify-storagemanager",
  StorageManagerDropZone: "amplify-storagemanager__dropzone",
  StorageManagerDropZoneIcon: "amplify-storagemanager__dropzone__icon",
  StorageManagerDropZoneText: "amplify-storagemanager__dropzone__text",
  StorageManagerFilePicker: "amplify-storagemanager__file__picker",
  StorageManagerFile: "amplify-storagemanager__file",
  StorageManagerFileWrapper: "amplify-storagemanager__file__wrapper",
  StorageManagerFileList: "amplify-storagemanager__file__list",
  StorageManagerFileName: "amplify-storagemanager__file__name",
  StorageManagerFileSize: "amplify-storagemanager__file__size",
  StorageManagerFileInfo: "amplify-storagemanager__file__info",
  StorageManagerFileImage: "amplify-storagemanager__file__image",
  StorageManagerFileMain: "amplify-storagemanager__file__main",
  StorageManagerFileStatus: "amplify-storagemanager__file__status",
  StorageManagerLoader: "amplify-storagemanager__loader",
  StorageManagerPreviewer: "amplify-storagemanager__previewer",
  StorageManagerPreviewerText: "amplify-storagemanager__previewer__text",
  StorageManagerPreviewerActions: "amplify-storagemanager__previewer__actions",
  StorageManagerPreviewerFooter: "amplify-storagemanager__previewer__footer",
  SwitchField: "amplify-switchfield",
  SwitchLabel: "amplify-switch__label",
  SwitchThumb: "amplify-switch__thumb",
  SwitchTrack: "amplify-switch__track",
  SwitchWrapper: "amplify-switch__wrapper",
  Table: "amplify-table",
  TableCaption: "amplify-table__caption",
  TableBody: "amplify-table__body",
  TableTd: "amplify-table__td",
  TableTh: "amplify-table__th",
  TableFoot: "amplify-table__foot",
  TableHead: "amplify-table__head",
  TableRow: "amplify-table__row",
  Tabs: "amplify-tabs",
  TabsList: "amplify-tabs__list",
  TabsItem: "amplify-tabs__item",
  TabsPanel: "amplify-tabs__panel",
  Text: "amplify-text",
  Textarea: "amplify-textarea",
  TextAreaField: "amplify-textareafield",
  TextField: "amplify-textfield",
  ToggleButton: "amplify-togglebutton",
  ToggleButtonGroup: "amplify-togglebuttongroup",
  VisuallyHidden: "amplify-visually-hidden"
}, qt = (...t) => {
  const e = [];
  for (const n of t)
    if (n) {
      if (Oo(n)) {
        e.push(n);
        continue;
      }
      if (typeof n == "number") {
        e.push(n.toString());
        continue;
      }
      if (Array.isArray(n)) {
        e.push(qt(...n));
        continue;
      }
      if (Fu(n)) {
        if (n.toString !== Object.prototype.toString && n.toString() !== "[object Object]") {
          e.push(n.toString());
          continue;
        }
        for (const r in n)
          Su(n, r) && n[r] && e.push(r);
      }
    }
  return e.join(" ");
}, P3 = re.createContext({
  theme: M3(),
  colorMode: void 0
}), Ug = {
  alignContent: "alignContent",
  alignItems: "alignItems",
  alignSelf: "alignSelf",
  area: "gridArea",
  aspectRatio: "aspectRatio",
  autoColumns: "gridAutoColumns",
  autoFlow: "gridAutoFlow",
  autoRows: "gridAutoRows",
  backgroundColor: "backgroundColor",
  backgroundImage: "backgroundImage",
  basis: "flexBasis",
  border: "border",
  borderRadius: "borderRadius",
  borderColor: "borderColor",
  borderWidth: "borderWidth",
  borderStyle: "borderStyle",
  bottom: "bottom",
  boxShadow: "boxShadow",
  color: "color",
  column: "gridColumn",
  columnEnd: "gridColumnEnd",
  columnGap: "columnGap",
  columnSpan: "gridColumn",
  columnStart: "gridColumnStart",
  direction: "flexDirection",
  display: "display",
  flex: "flex",
  fontFamily: "fontFamily",
  fontSize: "fontSize",
  fontStyle: "fontStyle",
  fontWeight: "fontWeight",
  gap: "gap",
  grow: "flexGrow",
  height: "height",
  justifyContent: "justifyContent",
  left: "left",
  letterSpacing: "letterSpacing",
  lineHeight: "lineHeight",
  margin: "margin",
  marginBlock: "marginBlock",
  marginBlockEnd: "marginBlockEnd",
  marginBlockStart: "marginBlockStart",
  marginBottom: "marginBlockEnd",
  marginInline: "marginInline",
  marginInlineEnd: "marginInlineEnd",
  marginInlineStart: "marginInlineStart",
  marginLeft: "marginInlineStart",
  marginRight: "marginInlineEnd",
  marginTop: "marginBlockStart",
  maxHeight: "maxHeight",
  maxWidth: "maxWidth",
  minHeight: "minHeight",
  minWidth: "minWidth",
  objectFit: "objectFit",
  objectPosition: "objectPosition",
  opacity: "opacity",
  order: "order",
  overflow: "overflow",
  padding: "padding",
  paddingBlock: "paddingBlock",
  paddingBlockEnd: "paddingBlockEnd",
  paddingBlockStart: "paddingBlockStart",
  paddingBottom: "paddingBlockEnd",
  paddingInline: "paddingInline",
  paddingInlineEnd: "paddingInlineEnd",
  paddingInlineStart: "paddingInlineStart",
  paddingLeft: "paddingInlineStart",
  paddingRight: "paddingInlineEnd",
  paddingTop: "paddingBlockStart",
  position: "position",
  resize: "resize",
  right: "right",
  row: "gridRow",
  rowEnd: "gridRowEnd",
  rowGap: "rowGap",
  rowSpan: "gridRow",
  rowStart: "gridRowStart",
  shrink: "flexShrink",
  templateAreas: "gridTemplateAreas",
  templateColumns: "gridTemplateColumns",
  templateRows: "gridTemplateRows",
  textAlign: "textAlign",
  textDecoration: "textDecoration",
  textTransform: "textTransform",
  top: "top",
  transform: "transform",
  transformOrigin: "transformOrigin",
  width: "width",
  whiteSpace: "whiteSpace",
  wrap: "flexWrap"
}, jh = {
  backgroundColor: "colors",
  borderColor: "colors",
  borderWidth: "borderWidths",
  color: "colors",
  borderRadius: "radii",
  fontSize: "fontSizes",
  fontWeight: "fontWeights",
  fontFamily: "fonts",
  lineHeight: "lineHeights",
  opacity: "opacities",
  boxShadow: "shadows",
  transform: "transforms",
  left: "space",
  right: "space",
  top: "space",
  bottom: "space",
  height: "space",
  width: "space",
  letterSpacing: "space",
  margin: "space",
  marginBlock: "space",
  marginBlockEnd: "space",
  marginBlockStart: "space",
  marginInline: "space",
  marginInlineEnd: "space",
  marginInlineStart: "space",
  marginLeft: "space",
  marginRight: "space",
  marginTop: "space",
  marginBottom: "space",
  maxHeight: "space",
  maxWidth: "space",
  minHeight: "space",
  minWidth: "space",
  padding: "space",
  paddingBlock: "space",
  paddingBlockEnd: "space",
  paddingBlockStart: "space",
  paddingInline: "space",
  paddingInlineEnd: "space",
  paddingInlineStart: "space",
  paddingLeft: "space",
  paddingRight: "space",
  paddingTop: "space",
  paddingBottom: "space",
  gap: "space",
  columnGap: "space",
  rowGap: "space"
}, sse = (t) => t in jh, B3 = (t) => typeof t == "string" && t.length === 0, Yb = (t) => t == null || B3(t), Cf = (t) => Object.keys(t), Gg = (t, e, n) => {
  if (typeof e != "string")
    return e;
  if (e.includes(" "))
    return e.split(" ").map((r) => Gg(t, r, n)).join(" ");
  if (sse(t)) {
    const r = e.split("."), a = jh[t];
    let s = n[a];
    for (let o = 0; o < r.length; o++) {
      if (s) {
        s = s[r[o]];
        continue;
      }
      break;
    }
    return jg(s) ? `var(--${Hg({
      path: [jh[t], ...r]
    })})` : e;
  }
  return e;
}, ose = ({ breakpoint: t, breakpoints: e, values: n }) => {
  const r = n[t];
  if (r !== void 0)
    return r;
  const a = Cf(e).sort((o, i) => e[i] - e[o]), s = a.slice(a.indexOf(t));
  for (const o of s) {
    const i = n[o];
    if (i !== void 0)
      return i;
  }
  return null;
}, ise = (t) => Cf(t).reduce((e, n) => n in S3.breakpoints.values ? { ...e, [n]: t[n] } : e, {}), use = ({ breakpoint: t, breakpoints: e, values: n }) => {
  let r = {};
  const a = Cf(e).sort((s, o) => e[s] - e[o]);
  return Array.isArray(n) ? n.forEach((s, o) => {
    r[a[o]] = s;
  }) : typeof n == "object" && (r = ise(n)), ose({
    breakpoint: t,
    breakpoints: e,
    values: r
  });
}, cse = ({ breakpoints: t }) => {
  const e = Cf(t).sort((n, r) => t[r] - t[n]);
  return e.map((n, r) => {
    let a = "";
    const s = t[n], o = e[r - 1], i = o ? t[o] - 1 : null;
    return s >= 0 && (a = `(min-width: ${s}px)`), i !== null && (a && (a += " and "), a += `(max-width: ${i}px)`), {
      breakpoint: n,
      query: a,
      maxWidth: i,
      minWidth: s
    };
  });
}, lse = typeof window > "u" ? re.useEffect : re.useLayoutEffect, L3 = ({ breakpoints: t, defaultBreakpoint: e }) => {
  const r = typeof window < "u" && typeof window.matchMedia < "u" ? window.matchMedia : null, a = re.useMemo(() => cse({ breakpoints: t }), [t]), [s, o] = re.useState(e), i = re.useCallback((c, l) => {
    c && o(l);
  }, [o]);
  return lse(() => {
    if (!r)
      return;
    const c = a.map(({ query: l, breakpoint: u }) => {
      const d = r(l);
      i(d.matches, u);
      const f = (p) => {
        p.matches && o(u);
      };
      return d.addEventListener("change", f), () => d.removeEventListener("change", f);
    });
    return () => {
      c.forEach((l) => l());
    };
  }, [t, o, r, a]), re.useDebugValue(s, (c) => c), s;
}, dse = (t) => typeof t > "u" || typeof t.theme > "u" ? M3() : t.theme, qg = () => {
  const t = re.useContext(P3);
  return dse(t);
}, fse = () => re.useContext(P3).colorMode, pse = ({ value: t, propKey: e, tokens: n }) => jg(t) ? t.toString() : Oo(t) ? Oo(e) ? Gg(e, t, n) : t : null, hse = (t) => t === "auto" || typeof t == "number" && !isNaN(t) || typeof t == "string" && !isNaN(parseFloat(t)), Sp = (t) => t === "auto" ? "auto" : `span ${t}`, Zb = (t) => hse(t) ? Sp(t) : Array.isArray(t) ? t.map((e) => Sp(e)) : typeof t == "object" && t != null ? Object.entries(t).reduce((e, [n, r]) => ({ ...e, [n]: Sp(r) }), {}) : null, mse = (t) => {
  const { rowSpan: e, columnSpan: n, row: r, column: a, ...s } = t, { rowFromSpanValue: o, columnFromSpanValue: i } = re.useMemo(() => ({
    rowFromSpanValue: Zb(e),
    columnFromSpanValue: Zb(n)
  }), [e, n]);
  return {
    row: Yb(r) ? o : r,
    column: Yb(a) ? i : a,
    ...s
  };
}, gse = (t) => t in Ug, yse = ({ props: t = {}, style: e = {}, breakpoint: n, breakpoints: r, tokens: a }) => {
  const s = {};
  return Object.keys(t).filter((o) => t[o] !== null).forEach((o) => {
    if (gse(o)) {
      const i = t[o];
      if (!i || B3(i))
        return;
      const c = Ug[o];
      let l = "";
      jg(i) ? l = i.toString() : typeof i == "string" ? l = Gg(o, i, a) : typeof i == "number" ? l = i : typeof i == "object" && (l = pse({
        propKey: o,
        tokens: a,
        value: use({
          values: i,
          breakpoint: n,
          breakpoints: r
        })
      })), e = {
        ...e,
        [c]: l
      };
    } else
      typeof t[o] < "u" && (s[o] = t[o]);
  }), { propStyles: e, nonStyleProps: s };
}, vse = (t, e) => {
  const { breakpoints: { values: n, defaultBreakpoint: r }, tokens: a } = qg(), s = L3({
    breakpoints: n,
    defaultBreakpoint: r
  }), o = mse(t);
  return re.useMemo(() => yse({
    props: o,
    style: e,
    breakpoint: s,
    breakpoints: n,
    tokens: a
  }), [o, e, n, s, a]);
}, ra = (t) => re.forwardRef(t), bse = ({ as: t = "div", children: e, testId: n, ariaLabel: r, isDisabled: a, style: s, inert: o, ...i }, c) => {
  const { propStyles: l, nonStyleProps: u } = vse(i, s);
  return re.createElement(t, {
    "aria-label": r,
    "data-testid": n,
    disabled: a,
    ref: c,
    inert: o ? "" : null,
    style: l,
    ...u
  }, e);
}, yt = ra(bse);
yt.displayName = "View";
const ki = { minX: 0, minY: 0, width: 24, height: 24 }, wse = ({
  className: t,
  // as can be used to render other icon react components too
  as: e = "svg",
  fill: n = "currentColor",
  pathData: r,
  viewBox: a = ki,
  children: s,
  paths: o,
  ...i
}, c) => {
  const l = a.minX ? a.minX : ki.minX, u = a.minY ? a.minY : ki.minY, d = a.width ? a.width : ki.width, f = a.height ? a.height : ki.height;
  let p;
  return s && (p = s), o && (p = o.map((h, m) => re.createElement("path", { ...h, key: m }))), r && (p = re.createElement("path", { d: r, fill: n })), re.createElement(yt, { as: e, className: qt(Fe.Icon, t), ref: c, viewBox: `${l} ${u} ${d} ${f}`, ...i }, p);
}, W3 = ra(wse);
W3.displayName = "Icon";
const Sse = re.createContext({});
function z3(t) {
  const e = re.useContext(Sse);
  if (t && e)
    return e[t];
}
const _se = (t) => {
  const { className: e, ...n } = t;
  return re.createElement(
    yt,
    { as: "span", width: "1em", height: "1em", className: qt(Fe.Icon, e), ...n },
    re.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      re.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20ZM16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", fill: "currentColor" })
    )
  );
}, xse = (t) => {
  const { className: e, ...n } = t;
  return re.createElement(
    yt,
    { as: "span", width: "1em", height: "1em", className: qt(Fe.Icon, e), ...n },
    re.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      re.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM13 17H11V15H13V17ZM13 13H11V7H13V13Z", fill: "currentColor" })
    )
  );
}, Ise = (t) => {
  const { className: e, ...n } = t;
  return re.createElement(
    yt,
    { as: "span", width: "1em", height: "1em", className: qt(Fe.Icon, e), ...n },
    re.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      re.createElement("path", { d: "M11 7H13V9H11V7ZM11 11H13V17H11V11ZM12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20Z", fill: "currentColor" })
    )
  );
}, kse = (t) => {
  const { className: e, ...n } = t;
  return re.createElement(
    yt,
    { as: "span", width: "1em", height: "1em", className: qt(Fe.Icon, e), ...n },
    re.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      re.createElement("path", { d: "M1 21H23L12 2L1 21ZM13 18H11V16H13V18ZM13 14H11V10H13V14Z", fill: "currentColor" })
    )
  );
}, Kg = ({ variation: t, ariaHidden: e, ariaLabel: n, role: r }) => {
  const a = z3("alert");
  let s;
  switch (t) {
    case "info":
      s = a?.info ?? re.createElement(Ise, { "aria-hidden": e, "aria-label": n, role: r });
      break;
    case "error":
      s = a?.error ?? re.createElement(xse, { "aria-hidden": e, "aria-label": n, role: r });
      break;
    case "warning":
      s = a?.warning ?? re.createElement(kse, { "aria-hidden": e, "aria-label": n, role: r });
      break;
    case "success":
      s = a?.success ?? re.createElement(_se, { "aria-hidden": e, "aria-label": n, role: r });
      break;
  }
  return s ? re.createElement("span", { className: Fe.AlertIcon }, s) : null;
};
Kg.displayName = "AlertIcon";
const Ese = re.createContext({
  isFieldsetDisabled: !1
}), V3 = () => re.useContext(Ese), Tse = ({ className: t, children: e, ...n }, r) => re.createElement(yt, { className: qt(Fe.Flex, t), ref: r, ...n }, e), It = ra(Tse);
It.displayName = "Flex";
const Cse = "linear-empty", Nse = "linear-filled", Ase = "circular-empty", Rse = "circular-filled", Jb = 8, Uh = 42, hc = 2 * Uh * Math.PI, $se = ({ className: t, filledColor: e, emptyColor: n, size: r, variation: a, isDeterminate: s = !1, isPercentageTextHidden: o = !1, percentage: i = 0, ...c }, l) => {
  i = Math.min(i, 100), i = Math.max(i, 0);
  const u = `${i}%`, d = qt(Fe.Loader, Qr(Fe.Loader, r), Qr(Fe.Loader, a), Rs(Fe.Loader, "determinate", s), t), f = re.createElement(
    "g",
    null,
    re.createElement("line", { x1: "0", x2: "100%", y1: "50%", y2: "50%", style: { stroke: String(n) }, "data-testid": Cse }),
    re.createElement("line", { x1: "0", x2: s ? u : "100%", y1: "50%", y2: "50%", style: {
      // To get rid of the visible stroke linecap when percentage is 0
      stroke: s && i === 0 ? "none" : e ? String(e) : void 0
    }, "data-testid": Nse }),
    s ? re.createElement("text", {
      "aria-live": "polite",
      className: qt(Fe.LoaderLabel, o ? Fe.VisuallyHidden : null),
      // -1% offset makes the text position look nicest
      x: `${-1 + i}%`,
      y: "200%"
    }, u) : null
  ), p = re.createElement(
    "g",
    null,
    re.createElement("circle", { cx: "50%", cy: "50%", r: `${Uh}%`, strokeWidth: `${Jb}%`, style: { stroke: String(n) }, "data-testid": Ase }),
    re.createElement("circle", { cx: "50%", cy: "50%", r: `${Uh}%`, strokeWidth: `${Jb}%`, style: {
      stroke: String(e),
      strokeDasharray: s ? `${hc}% ${hc}%` : void 0,
      strokeDashoffset: s ? `${hc - hc * i / 100}%` : void 0
    }, "data-testid": Rse }),
    s ? re.createElement("text", {
      "aria-live": "polite",
      className: qt(Fe.LoaderLabel, o ? Fe.VisuallyHidden : null),
      // this x and y make text position look nicest
      x: "130%",
      y: "80%"
    }, u) : null
  );
  return re.createElement(yt, { as: "svg", className: d, ref: l, role: "img", ...c }, a === "linear" ? f : p);
}, Mu = ra($se);
Mu.displayName = "Loader";
const Dse = ["link", "primary", void 0], Ose = ({ className: t, children: e, colorTheme: n, isFullWidth: r = !1, isDisabled: a, isLoading: s, loadingText: o = "", size: i, type: c = "button", variation: l, ...u }, d) => {
  const f = Dse.includes(l) && n ? `${l ?? "outlined"}--${n}` : void 0, { isFieldsetDisabled: p } = V3(), h = p || (a ?? s ?? u.disabled), m = qt(Fe.Button, Fe.FieldGroupControl, Qr(Fe.Button, l), Qr(Fe.Button, f), Qr(Fe.Button, i), Rs(Fe.Button, "disabled", h), Rs(Fe.Button, "loading", s), Rs(Fe.Button, "fullwidth", r), t);
  return re.createElement(yt, { ref: d, as: "button", className: m, isDisabled: h, type: c, ...u }, s ? re.createElement(
    It,
    { as: "span", className: Fe.ButtonLoaderWrapper },
    re.createElement(Mu, { size: i }),
    o || null
  ) : e);
}, qo = ra(Ose);
qo.displayName = "Button";
const Fse = (t) => {
  const { className: e, size: n, ...r } = t;
  return re.createElement(
    yt,
    { as: "span", width: n ?? "1em", height: n ?? "1em", className: qt(Fe.Icon, e), ...r },
    re.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: n ? { width: n, height: n } : void 0 },
      re.createElement("path", { d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z", fill: "currentColor" })
    )
  );
}, Mse = ({ as: t = "p", className: e, children: n, isTruncated: r, variation: a, ...s }, o) => {
  const i = qt(Fe.Text, Qr(Fe.Text, a), Rs(Fe.Text, "truncated", r), e);
  return re.createElement(yt, { as: t, className: i, ref: o, ...s }, n);
}, Lr = ra(Mse);
Lr.displayName = "Text";
const Pse = "qa-field-description", H3 = ({ descriptiveText: t, labelHidden: e, ...n }) => t ? re.createElement(Lr, { "data-testid": Pse, className: qt(Fe.FieldDescription, {
  [Fe.VisuallyHidden]: e
}), ...n }, t) : null;
H3.displayName = "FieldDescription";
const j3 = ({ errorMessage: t, hasError: e, ...n }) => e && t ? re.createElement(Lr, { className: Fe.FieldErrorMessage, ...n }, t) : null;
j3.displayName = "FieldErrorMessage";
const Bse = ({ children: t, className: e, visuallyHidden: n, ...r }, a) => re.createElement(yt, { as: "label", className: qt(Fe.Label, e, {
  [Fe.VisuallyHidden]: n
}), ref: a, ...r }, t), Xg = ra(Bse);
Xg.displayName = "Label";
const Lse = globalThis?.document ? re.useLayoutEffect : () => {
}, Wse = "amplify-id", zse = (
  // disable eslint below to allow usage of casting React to `any`, which ensures that TS
  // does not get confused about the existence of `useId` in React 17 and below
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  re["useId".toString()] || (() => {
  })
);
let Vse = 0;
const Qb = (t) => {
  const [e, n] = re.useState(zse());
  return Lse(() => {
    t || n((r) => r ?? String(Vse++));
  }, [t]), t ?? (e ? `${Wse}-${e}` : "");
}, Hse = (t) => t in Ug, jse = (t) => {
  const e = {
    styleProps: {},
    rest: {}
  };
  return Object.keys(t).forEach((n) => {
    Hse(n) ? e.styleProps = {
      ...e.styleProps,
      [n]: t[n]
    } : e.rest = {
      ...e.rest,
      [n]: t[n]
    };
  }), e;
}, Use = ({ as: t = "span", children: e, className: n, ...r }, a) => re.createElement(yt, { as: t, className: qt(Fe.VisuallyHidden, n), ref: a, ...r }, e), Ic = ra(Use);
Ic.displayName = "VisuallyHidden";
const Gse = (t) => {
  const { className: e, ...n } = t;
  return re.createElement(
    yt,
    { as: "span", width: "1em", height: "1em", className: qt(Fe.Icon, e), ...n },
    re.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      re.createElement("path", { d: "M16.59 8.58984L12 13.1698L7.41 8.58984L6 9.99984L12 15.9998L18 9.99984L16.59 8.58984Z", fill: "currentColor" })
    )
  );
}, qse = ({ autoComplete: t, className: e, size: n, variation: r, value: a, defaultValue: s, hasError: o, icon: i, iconColor: c, children: l, placeholder: u, isDisabled: d, isRequired: f, isMultiple: p = !1, selectSize: h = 1, ...m }, g) => {
  const v = "", b = a === void 0 && s === void 0 && u, w = p || h > 1, S = qt(Fe.Select, Fe.FieldGroupControl, Qr(Fe.Select, n), Qr(Fe.Select, r), Rs(Fe.Select, "error", o), Rs(Fe.Select, "expanded", w), e), I = z3("select"), { isFieldsetDisabled: E } = V3();
  return re.createElement(
    yt,
    { className: Fe.SelectWrapper },
    re.createElement(
      yt,
      { "aria-invalid": o, as: "select", autoComplete: t, value: a, defaultValue: b ? v : s, isDisabled: E || d, multiple: p, size: h, required: f, className: S, ref: g, ...m },
      u && re.createElement("option", { value: "" }, u),
      l
    ),
    w ? null : re.createElement(It, { className: qt(Fe.SelectIcon, Qr(Fe.SelectIcon, n)), color: c }, i ?? I?.expand ?? re.createElement(Gse, null))
  );
}, U3 = ra(qse);
U3.displayName = "Select";
const Kse = ({ children: t, options: e }) => t ? (e?.length && console.warn("Amplify UI: <SelectField> component  defaults to rendering children over `options`. When using the `options` prop, omit children."), t) : e?.map((n, r) => re.createElement("option", { label: n, value: n, key: `${n}-${r}` }, n)), Xse = (t, e) => {
  const { children: n, className: r, descriptiveText: a, errorMessage: s, hasError: o = !1, id: i, label: c, labelHidden: l = !1, options: u, size: d, testId: f, inputStyles: p, ...h } = t, m = Qb(i), g = Qb(), v = a ? g : void 0, { styleProps: b, rest: w } = jse(h);
  return re.createElement(
    It,
    { className: qt(Fe.Field, Qr(Fe.Field, d), Fe.SelectField, r), testId: f, ...b },
    re.createElement(Xg, { htmlFor: m, visuallyHidden: l }, c),
    re.createElement(H3, { id: g, labelHidden: l, descriptiveText: a }),
    re.createElement(U3, { "aria-describedby": v, hasError: o, id: m, ref: e, size: d, ...w, ...p }, Kse({ children: n, options: u })),
    re.createElement(j3, { hasError: o, errorMessage: s })
  );
}, G3 = ra(Xse);
G3.displayName = "SelectField";
var q3 = pe.createContext(null);
function Yse(t) {
  var e = t.children, n = ul(t, ["children"]);
  return pe.createElement(q3.Provider, { value: n }, e);
}
function K3() {
  var t = pe.useContext(q3);
  if (t === null)
    throw new Error("useFaceLivenessDetector must be used within a FaceLivenessDetectorProvider");
  return t;
}
const Zse = () => {
  const { breakpoints: { values: t, defaultBreakpoint: e } } = qg();
  return L3({
    breakpoints: t,
    defaultBreakpoint: e
  });
};
function Nf() {
  var t = K3().service, e = LE(t);
  return e;
}
function Vn(t) {
  var e = K3().service;
  return VE(e, t);
}
function Jse(t) {
  var e = ol.height.ideal, n = ol.width.ideal, r = Va(null), a = Pa(e), s = a[0], o = a[1], i = Pa(n), c = i[0], l = i[1];
  return kc(function() {
    if (t) {
      Fu(r.current) && (r.current.srcObject = t);
      var u = t.getTracks()[0].getSettings(), d = u.height, f = u.width;
      o(d), l(f);
    }
    return function() {
      t && t.getTracks().forEach(function(p) {
        t.removeTrack(p), p.stop();
      });
    };
  }, [t]), {
    videoRef: r,
    videoHeight: s,
    videoWidth: c
  };
}
var Ve;
(function(t) {
  t.CameraModule = "amplify-liveness-camera-module", t.CancelContainer = "amplify-liveness-cancel-container", t.CancelButton = "amplify-liveness-cancel-button", t.CountdownContainer = "amplify-liveness-countdown-container", t.DescriptionBullet = "amplify-liveness-description-bullet", t.DescriptionBulletIndex = "amplify-liveness-description-bullet__index", t.DescriptionBulletIndexText = "amplify-liveness-description-bullet__index__text", t.DescriptionBulletMessage = "amplify-liveness-description-bullet__message", t.ErrorModal = "amplify-liveness-error-modal", t.ErrorModalHeading = "amplify-liveness-error-modal__heading", t.FadeOut = "amplify-liveness-fade-out", t.FreshnessCanvas = "amplify-liveness-freshness-canvas", t.InstructionList = "amplify-liveness-instruction-list", t.InstructionOverlay = "amplify-liveness-instruction-overlay", t.Hint = "amplify-liveness-hint", t.HintText = "amplify-liveness-hint__text", t.LandscapeErrorModal = "amplify-liveness-landscape-error-modal", t.LandscapeErrorModalButton = "amplify-liveness-landscape-error-modal__button", t.LandscapeErrorModalHeader = "amplify-liveness-landscape-error-modal__header", t.Loader = "amplify-liveness-loader", t.MatchIndicator = "amplify-liveness-match-indicator", t.OvalCanvas = "amplify-liveness-oval-canvas", t.OpaqueOverlay = "amplify-liveness-overlay-opaque", t.Overlay = "amplify-liveness-overlay", t.Popover = "amplify-liveness-popover", t.PopoverContainer = "amplify-liveness-popover__container", t.PopoverAnchor = "amplify-liveness-popover__anchor", t.PopoverAnchorSecondary = "amplify-liveness-popover__anchor-secondary", t.RecordingIconContainer = "amplify-liveness-recording-icon-container", t.RecordingIcon = "amplify-liveness-recording-icon", t.StartScreenCameraSelect = "amplify-liveness-start-screen-camera-select", t.StartScreenCameraSelectContainer = "amplify-liveness-start-screen-camera-select__container", t.StartScreenCameraWaiting = "amplify-liveness-start-screen-camera-waiting", t.StartScreenHeader = "amplify-liveness-start-screen-header", t.StartScreenHeaderBody = "amplify-liveness-start-screen-header__body", t.StartScreenHeaderHeading = "amplify-liveness-start-screen-header__heading", t.StartScreenWarning = "amplify-liveness-start-screen-warning", t.StartScreenInstructions = "amplify-liveness-start-screen-instructions", t.StartScreenInstructionsHeading = "amplify-liveness-start-screen-instructions__heading", t.Toast = "amplify-liveness-toast", t.ToastContainer = "amplify-liveness-toast__container", t.ToastMessage = "amplify-liveness-toast__message", t.Video = "amplify-liveness-video", t.VideoAnchor = "amplify-liveness-video-anchor";
})(Ve || (Ve = {}));
var X3 = function(t) {
  var e = t.ariaLabel, n = Nf(), r = n[0], a = n[1], s = r.done, o = function() {
    a({
      type: "CANCEL"
    });
  };
  return s ? null : pe.createElement(
    qo,
    { autoFocus: !0, variation: "link", onClick: o, size: "large", className: Ve.CancelButton, "aria-label": e },
    pe.createElement(Fse, { "aria-hidden": "true", "data-testid": "close-icon" })
  );
}, Af = function(t) {
  var e = t.variation, n = e === void 0 ? "default" : e, r = t.size, a = r === void 0 ? "medium" : r, s = t.children, o = t.isInitial, i = o === void 0 ? !1 : o, c = ul(t, ["variation", "size", "children", "isInitial"]), l = qg().tokens;
  return re.createElement(
    yt,
    _e({ className: "".concat(Ve.Toast, " ").concat(Ve.Toast, "--").concat(n, " ").concat(Ve.Toast, "--").concat(a) }, i && { backgroundColor: l.colors.background.primary }, c),
    re.createElement(
      It,
      { className: Ve.ToastContainer },
      re.createElement(It, _e({ className: Ve.ToastMessage }, i ? { color: l.colors.font.primary } : {}), s)
    )
  );
}, e0 = function(t) {
  var e = t.displayText;
  return re.createElement(
    Af,
    { "aria-live": "polite" },
    re.createElement(
      It,
      { className: Ve.HintText },
      re.createElement(Mu, null),
      re.createElement(yt, null, e)
    )
  );
}, Yg = function(t) {
  return t.context.errorState;
}, Qse = function(t) {
  return t.context.faceMatchAssociatedParams.faceMatchState;
}, eoe = function(t) {
  return t.context.faceMatchAssociatedParams.illuminationState;
}, toe = function(t) {
  return t.context.isFaceFarEnoughBeforeRecording;
}, noe = function(t) {
  return t.context.faceMatchStateBeforeStart;
}, roe = function(t) {
  var e;
  return (e = t.context.faceMatchAssociatedParams) === null || e === void 0 ? void 0 : e.faceMatchPercentage;
}, oo = function(t) {
  var e = t.text, n = t.isInitial, r = n === void 0 ? !1 : n;
  return re.createElement(
    Af,
    { size: "large", variation: "primary", isInitial: r },
    re.createElement(yt, { "aria-live": "assertive" }, e)
  );
}, aoe = function(t) {
  var e, n, r = t.hintDisplayText, a = Nf()[0], s = Vn(Yg), o = Vn(Qse), i = Vn(eoe), c = Vn(noe), l = Vn(toe), u = Vn(roe), d = a.matches("checkFaceDetectedBeforeStart") || a.matches("detectFaceBeforeStart"), f = a.matches("checkFaceDistanceBeforeRecording") || a.matches("detectFaceDistanceBeforeRecording"), p = a.matches("start") || a.matches("userCancel"), h = a.matches("recording"), m = a.matches("notRecording"), g = a.matches("uploading"), v = a.matches("checkSucceeded"), b = a.matches("checkFailed"), w = a.matches({
    recording: "flashFreshnessColors"
  }), S = (e = {}, e[nt.CANT_IDENTIFY] = r.hintCanNotIdentifyText, e[nt.FACE_IDENTIFIED] = r.hintTooFarText, e[nt.TOO_MANY] = r.hintTooManyFacesText, e[nt.TOO_CLOSE] = r.hintTooCloseText, e[nt.TOO_FAR] = r.hintTooFarText, e[nt.MATCHED] = r.hintHoldFaceForFreshnessText, e[nt.OFF_CENTER] = r.hintFaceOffCenterText, e), I = (n = {}, n[fa.BRIGHT] = r.hintIlluminationTooBrightText, n[fa.DARK] = r.hintIlluminationTooDarkText, n[fa.NORMAL] = r.hintIlluminationNormalText, n);
  if (p)
    return re.createElement(
      re.Fragment,
      null,
      re.createElement(Ic, { role: "alert" }, r.hintCenterFaceInstructionText),
      re.createElement(oo, { text: r.hintCenterFaceText, isInitial: !0 })
    );
  if (s ?? (b || v))
    return null;
  if (!h) {
    if (d)
      return c === nt.TOO_MANY ? re.createElement(oo, { text: r.hintTooManyFacesText }) : re.createElement(oo, { text: r.hintMoveFaceFrontOfCameraText });
    if (f && l === !1)
      return re.createElement(oo, { text: r.hintTooCloseText });
    if (m)
      return re.createElement(e0, { displayText: r.hintConnectingText });
    if (g)
      return re.createElement(
        re.Fragment,
        null,
        re.createElement(Ic, { "aria-live": "assertive" }, r.hintCheckCompleteText),
        re.createElement(e0, { displayText: r.hintVerifyingText })
      );
    if (i && i !== fa.NORMAL)
      return re.createElement(oo, { text: I[i] });
  }
  if (w)
    return re.createElement(oo, { text: r.hintHoldFaceForFreshnessText });
  if (h && !w) {
    var E = S[nt.TOO_FAR];
    (o === nt.TOO_CLOSE || o === nt.MATCHED) && (E = S[o]);
    var T = E;
    return o === nt.OFF_CENTER ? T = S[o] : (
      // If the face match percentage reaches 50% append it to the a11y label
      o === nt.TOO_FAR && u > 50 && (T = r.hintMatchIndicatorText)
    ), re.createElement(
      Af,
      { size: "large", variation: o === nt.TOO_CLOSE ? "error" : "primary" },
      re.createElement(Ic, { "aria-live": "assertive" }, T),
      re.createElement(yt, { "aria-label": T }, E)
    );
  }
  return null;
}, soe = function(t) {
  var e = t.percentage, n = t.initialPercentage, r = n === void 0 ? 25 : n, a = t.testId, s = pe.useState(r), o = s[0], i = s[1];
  pe.useEffect(function() {
    e < 0 ? i(0) : e > 100 ? i(100) : i(e);
  }, [e]);
  var c = {
    "--percentage": "".concat(o, "%")
  };
  return pe.createElement(
    "div",
    { className: Ve.MatchIndicator, "data-testid": a },
    pe.createElement("div", { className: "".concat(Ve.MatchIndicator, "__bar"), style: c, role: "progressbar", "aria-label": "MatchIndicator", "aria-valuenow": e, "aria-valuetext": "".concat(e, "% face fit") })
  );
}, Y3 = function(t) {
  var e = t.children, n = t.horizontal, r = n === void 0 ? "center" : n, a = t.vertical, s = a === void 0 ? "center" : a, o = t.className, i = ul(t, ["children", "horizontal", "vertical", "className"]);
  return re.createElement(It, _e({ className: "".concat(Ve.Overlay, " ").concat(o), alignItems: r, justifyContent: s }, i), e);
}, ooe = function(t) {
  var e = t.children;
  return pe.createElement(
    It,
    { className: Ve.RecordingIcon },
    pe.createElement(
      It,
      { "data-testid": "rec-icon", justifyContent: "center" },
      pe.createElement(
        W3,
        { viewBox: { width: 20, height: 20 }, width: "20", height: "20" },
        pe.createElement("circle", { cx: "10", cy: "10", r: "8", fill: "red" })
      )
    ),
    pe.createElement(Lr, { as: "span", fontWeight: "bold" }, e)
  );
}, Rf = {
  errorLabelText: "Error",
  timeoutHeaderText: "Time out",
  timeoutMessageText: "Face didn't fit inside oval in time limit. Try again and completely fill the oval with face in it.",
  faceDistanceHeaderText: "Forward movement detected",
  faceDistanceMessageText: "Avoid moving closer when connecting.",
  multipleFacesHeaderText: "Multiple faces detected",
  multipleFacesMessageText: "Ensure only one face is present in front of the camera when connecting.",
  clientHeaderText: "Client error",
  clientMessageText: "Check failed due to client issue",
  serverHeaderText: "Server issue",
  serverMessageText: "Cannot complete check due to server issue",
  landscapeHeaderText: "Landscape orientation not supported",
  landscapeMessageText: "Rotate your device to portrait (vertical) orientation.",
  portraitMessageText: "Ensure your device remains in portrait (vertical) orientation for the check’s duration.",
  tryAgainText: "Try again"
}, ioe = _e({ cameraMinSpecificationsHeadingText: "Camera does not meet minimum specifications", cameraMinSpecificationsMessageText: "Camera must support at least 320*240 resolution and 15 frames per second.", cameraNotFoundHeadingText: "Camera is not accessible.", cameraNotFoundMessageText: "Check that a camera is connected and there is not another application using the camera. You may have to go into settings to grant camera permissions and close out all instances of your browser and retry.", a11yVideoLabelText: "Webcam for liveness check", cancelLivenessCheckText: "Cancel Liveness check", goodFitCaptionText: "Good fit", goodFitAltText: "Ilustration of a person's face, perfectly fitting inside of an oval.", hintCenterFaceText: "Center your face", hintCenterFaceInstructionText: "Instruction: Before starting the check, make sure your camera is at the center top of your screen and center your face to the camera. When the check starts an oval will show up in the center. You will be prompted to move forward into the oval and then prompted to hold still. After holding still for a few seconds, you should hear check complete.", hintFaceOffCenterText: "Face is not in the oval, center your face to the camera.", hintMoveFaceFrontOfCameraText: "Move face in front of camera", hintTooManyFacesText: "Ensure only one face is in front of camera", hintFaceDetectedText: "Face detected", hintCanNotIdentifyText: "Move face in front of camera", hintTooCloseText: "Move back", hintTooFarText: "Move closer", hintConnectingText: "Connecting...", hintVerifyingText: "Verifying...", hintCheckCompleteText: "Check complete", hintIlluminationTooBrightText: "Move to dimmer area", hintIlluminationTooDarkText: "Move to brighter area", hintIlluminationNormalText: "Lighting conditions normal", hintHoldFaceForFreshnessText: "Hold still", hintMatchIndicatorText: "50% completed. Keep moving closer.", photosensitivityWarningBodyText: "This check flashes different colors. Use caution if you are photosensitive.", photosensitivityWarningHeadingText: "Photosensitivity warning", photosensitivityWarningInfoText: "Some people may experience epileptic seizures when exposed to colored lights. Use caution if you, or anyone in your family, have an epileptic condition.", photosensitivityWarningLabelText: "More information about photosensitivity", photosensitivyWarningBodyText: "This check flashes different colors. Use caution if you are photosensitive.", photosensitivyWarningHeadingText: "Photosensitivity warning", photosensitivyWarningInfoText: "Some people may experience epileptic seizures when exposed to colored lights. Use caution if you, or anyone in your family, have an epileptic condition.", photosensitivyWarningLabelText: "More information about photosensitivity", retryCameraPermissionsText: "Retry", recordingIndicatorText: "Rec", startScreenBeginCheckText: "Start Video", tooFarCaptionText: "Too far", tooFarAltText: "Illustration of a person's face inside of an oval; there is a gap between the perimeter of the face and the boundaries of the oval.", waitingCameraPermissionText: "Waiting for you to allow camera permission." }, Rf), uoe = function(t) {
  var e = t.error, n = t.displayText, r = n.errorLabelText, a = n.timeoutHeaderText, s = n.timeoutMessageText, o = n.faceDistanceHeaderText, i = n.faceDistanceMessageText, c = n.multipleFacesHeaderText, l = n.multipleFacesMessageText, u = n.clientHeaderText, d = n.clientMessageText, f = n.serverHeaderText, p = n.serverMessageText, h, m;
  switch (e) {
    case lt.TIMEOUT:
      h = a, m = s;
      break;
    case lt.FACE_DISTANCE_ERROR:
      h = o, m = i;
      break;
    case lt.MULTIPLE_FACES_ERROR:
      h = c, m = l;
      break;
    case lt.RUNTIME_ERROR:
      h = u, m = d;
      break;
    case lt.SERVER_ERROR:
    default:
      h = f, m = p;
  }
  return pe.createElement(
    pe.Fragment,
    null,
    pe.createElement(
      It,
      { className: Ve.ErrorModal },
      pe.createElement(Kg, { ariaLabel: r, role: "img", variation: "error" }),
      pe.createElement(Lr, { className: Ve.ErrorModalHeading, id: "amplify-liveness-error-heading" }, h)
    ),
    pe.createElement(Lr, { id: "amplify-liveness-error-message" }, m)
  );
}, coe = function(t) {
  var e = t.errorState, n = t.overrideErrorDisplayText, r = _e(_e({}, Rf), n);
  return e === lt.CAMERA_ACCESS_ERROR || e === lt.CAMERA_FRAMERATE_ERROR || e === lt.MOBILE_LANDSCAPE_ERROR ? null : uoe({
    error: e,
    displayText: r
  });
}, loe = function(t) {
  var e = t.children, n = t.onRetry, r = t.displayText, a = _e(_e({}, Rf), r), s = a.tryAgainText;
  return pe.createElement(
    Y3,
    { className: Ve.OpaqueOverlay },
    pe.createElement(
      Af,
      { "aria-labelledby": "amplify-liveness-error-heading", "aria-describedby": "amplify-liveness-error-message", role: "alertdialog" },
      e,
      pe.createElement(
        It,
        { justifyContent: "center" },
        pe.createElement(qo, { variation: "primary", type: "button", onClick: n }, s)
      )
    )
  );
}, Z3 = function(t) {
  var e = t.children, n = t.headingText, r = t.labelText, a = Zse(), s = Pa(!1), o = s[0], i = s[1], c = Va(null), l = a === "base";
  return kc(function() {
    function u(d) {
      o && c.current && !c.current.contains(d.target) && i(!1);
    }
    return document.addEventListener("mousedown", u), function() {
      document.removeEventListener("mousedown", u);
    };
  }, [c, o]), pe.createElement(
    "div",
    { className: Ve.Popover, ref: c },
    pe.createElement(
      qo,
      { "aria-controls": "photosensitivity-description", "aria-expanded": o, role: "alertdialog", "aria-label": r, "aria-describedby": "photosensitivity-description", colorTheme: "info", id: "popover-button", onClick: function() {
        return i(!o);
      }, testId: "popover-icon" },
      pe.createElement(Kg, { ariaHidden: !0, variation: "info" })
    ),
    o && pe.createElement(
      pe.Fragment,
      null,
      pe.createElement(It, { className: Ve.PopoverAnchor }),
      pe.createElement(It, { className: Ve.PopoverAnchorSecondary }),
      pe.createElement(It, { "aria-hidden": !o, "aria-label": n, className: Ve.PopoverContainer, "data-testid": "popover-text", id: "photosensitivity-description", left: l ? -190 : -108, role: "alertdialog" }, e)
    )
  );
};
Z3.displayName = "LivenessIconWithPopover";
var doe = function(t) {
  var e = t.bodyText, n = t.headingText, r = t.infoText, a = t.labelText;
  return pe.createElement(
    It,
    { className: "".concat(Fe.Alert, " ").concat(Ve.StartScreenWarning), style: { zIndex: "3" } },
    pe.createElement(
      yt,
      { flex: "1" },
      pe.createElement(yt, { className: Fe.AlertHeading }, n),
      pe.createElement(yt, { className: Fe.AlertBody }, e)
    ),
    pe.createElement(Z3, { labelText: a, headingText: n }, r)
  );
}, foe = function(t) {
  var e = t.recordingIndicatorText;
  return pe.createElement(
    yt,
    { className: Ve.RecordingIconContainer },
    pe.createElement(ooe, null, e)
  );
}, poe = function(t) {
  var e = t.cancelLivenessCheckText;
  return pe.createElement(
    yt,
    { className: Ve.CancelContainer },
    pe.createElement(X3, { ariaLabel: e })
  );
}, hoe = function(t) {
  var e;
  return (e = t.context.videoAssociatedParams) === null || e === void 0 ? void 0 : e.videoConstraints;
}, moe = function(t) {
  var e;
  return (e = t.context.videoAssociatedParams) === null || e === void 0 ? void 0 : e.videoMediaStream;
}, goe = function(t) {
  var e;
  return (e = t.context.faceMatchAssociatedParams) === null || e === void 0 ? void 0 : e.faceMatchPercentage;
}, yoe = function(t) {
  var e;
  return (e = t.context.faceMatchAssociatedParams) === null || e === void 0 ? void 0 : e.faceMatchState;
}, voe = function(t) {
  var e;
  return (e = t.context.videoAssociatedParams) === null || e === void 0 ? void 0 : e.selectedDeviceId;
}, boe = function(t) {
  var e;
  return (e = t.context.videoAssociatedParams) === null || e === void 0 ? void 0 : e.selectableDevices;
}, woe = pe.createElement(Mu, { size: "large", className: Ve.Loader, "data-testid": "centered-loader" }), Soe = [
  nt.TOO_FAR,
  nt.CANT_IDENTIFY,
  nt.FACE_IDENTIFIED,
  nt.OFF_CENTER
], _oe = pe.memo(soe), xoe = function(t) {
  var e = t.isMobileScreen, n = t.isRecordingStopped, r = t.instructionDisplayText, a = t.streamDisplayText, s = t.hintDisplayText, o = t.errorDisplayText, i = t.cameraDisplayText, c = t.components, l = t.testId, u = a.cancelLivenessCheckText, d = a.recordingIndicatorText, f = c ?? {}, p = f.ErrorView, h = p === void 0 ? loe : p, m = f.PhotosensitiveWarning, g = m === void 0 ? doe : m, v = Nf(), b = v[0], w = v[1], S = Vn(moe), I = Vn(hoe), E = Vn(voe), T = Vn(boe), R = Vn(goe), $ = Vn(yoe), D = Vn(Yg), M = fse(), z = Jse(S), F = z.videoRef, V = z.videoWidth, H = z.videoHeight, U = Va(null), Z = Va(null), q = Pa(!1), X = q[0], se = q[1], te = b.matches("cameraCheck"), ue = b.matches("waitForDOMAndCameraDetails"), ee = b.matches("start") || b.matches("userCancel"), ne = b.matches("detectFaceBeforeStart"), oe = b.matches("recording"), ge = b.matches("checkSucceeded"), be = b.matches({
    recording: "flashFreshnessColors"
  }), fe = Pa(V), we = fe[0], Re = fe[1], $e = Pa(H), Oe = $e[0], We = $e[1], Ue = Pa(function() {
    return V && H ? V / H : 0;
  }), je = Ue[0], Ne = Ue[1];
  pe.useEffect(function() {
    U?.current && F?.current && S && ee && Lp(U.current, F.current, S);
  }, [U, F, S, M, ee]), pe.useEffect(function() {
    var st = function(Zt) {
      Zt.matches && U?.current && F?.current && S && ee && Lp(U.current, F.current, S);
    }, St = window.matchMedia("(prefers-color-scheme: dark)"), Mt = window.matchMedia("(prefers-color-scheme: light)");
    return St.addEventListener("change", st), Mt.addEventListener("change", st), function() {
      St.removeEventListener("change", st), Mt.addEventListener("change", st);
    };
  }, [U, F, S, ee]), pe.useLayoutEffect(function() {
    X && w({
      type: "SET_DOM_AND_CAMERA_DETAILS",
      data: {
        videoEl: F.current,
        canvasEl: U.current,
        freshnessColorEl: Z.current,
        isMobile: e
      }
    }), F.current && (Re(F.current.videoWidth), We(F.current.videoHeight), Ne(F.current.videoWidth / F.current.videoHeight));
  }, [w, F, X, e]), pe.useEffect(function() {
    ne && KE({ canvas: U.current });
  }, [ne]);
  var et = pe.useMemo(function() {
    return pe.createElement(
      yt,
      { style: { visibility: ee ? "visible" : "hidden" } },
      pe.createElement(g, { bodyText: r.photosensitivityWarningBodyText, headingText: r.photosensitivityWarningHeadingText, infoText: r.photosensitivityWarningInfoText, labelText: r.photosensitivityWarningLabelText })
    );
  }, [g, r, ee]), Ye = function() {
    se(!0);
  }, ct = pe.useCallback(function() {
    w({
      type: "BEGIN"
    });
  }, [w]), at = pe.useCallback(function(st) {
    var St = st.target.value, Mt = function() {
      return ot(void 0, void 0, void 0, function() {
        var Zt;
        return tt(this, function(rn) {
          switch (rn.label) {
            case 0:
              return [4, navigator.mediaDevices.getUserMedia({
                video: _e(_e({}, I), { deviceId: { exact: St } }),
                audio: !1
              })];
            case 1:
              return Zt = rn.sent(), w({
                type: "UPDATE_DEVICE_AND_STREAM",
                data: { newDeviceId: St, newStream: Zt }
              }), [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Mt();
  }, [I, w]);
  if (te)
    return pe.createElement(
      It,
      { justifyContent: "center", className: Ve.StartScreenCameraWaiting },
      pe.createElement(Mu, { size: "large", className: Ve.Loader, "data-testid": "centered-loader", position: "unset" }),
      pe.createElement(Lr, { fontSize: "large", fontWeight: "bold", "data-testid": "waiting-camera-permission", className: "".concat(Ve.StartScreenCameraWaiting, "__text") }, i.waitingCameraPermissionText)
    );
  var Ht = e && !ee && !ue;
  return pe.createElement(
    pe.Fragment,
    null,
    et,
    pe.createElement(
      It,
      { className: qt(Ve.CameraModule, Ht && "".concat(Ve.CameraModule, "--mobile")), "data-testid": l, gap: "zero" },
      !X && woe,
      pe.createElement(
        Y3,
        { horizontal: "center", vertical: oe && !be ? "start" : "space-between", className: Ve.InstructionOverlay },
        oe && pe.createElement(foe, { recordingIndicatorText: d }),
        !ee && !ue && !ge && pe.createElement(poe, { cancelLivenessCheckText: u }),
        pe.createElement(
          It,
          { className: qt(Ve.Hint, Ht && "".concat(Ve.Hint, "--mobile")) },
          pe.createElement(aoe, { hintDisplayText: s })
        ),
        D && pe.createElement(h, { onRetry: function() {
          w({ type: "CANCEL" });
        }, displayText: o }, coe({
          errorState: D,
          overrideErrorDisplayText: o
        })),
        oe && !be && Soe.includes($) ? pe.createElement(_oe, { percentage: Math.ceil(R) }) : null
      ),
      pe.createElement(yt, { as: "canvas", ref: Z, className: Ve.FreshnessCanvas, hidden: !0 }),
      pe.createElement(
        yt,
        { className: Ve.VideoAnchor, style: {
          aspectRatio: "".concat(je)
        } },
        pe.createElement("video", { ref: F, muted: !0, autoPlay: !0, playsInline: !0, width: we, height: Oe, onCanPlay: Ye, "data-testid": "video", className: Ve.Video, "aria-label": i.a11yVideoLabelText }),
        pe.createElement(
          It,
          { className: qt(Ve.OvalCanvas, Ht && "".concat(Ve.OvalCanvas, "--mobile"), n && Ve.FadeOut) },
          pe.createElement(yt, { as: "canvas", ref: U })
        ),
        ee && !e && T && T.length > 1 && pe.createElement(
          It,
          { className: Ve.StartScreenCameraSelect },
          pe.createElement(
            yt,
            { className: Ve.StartScreenCameraSelectContainer },
            pe.createElement(Xg, { htmlFor: "amplify-liveness-camera-select", className: "".concat(Ve.StartScreenCameraSelect, "__label") }, "Camera:"),
            pe.createElement(G3, { id: "amplify-liveness-camera-select", label: "Camera", labelHidden: !0, value: E, onChange: at }, T?.map(function(st) {
              return pe.createElement("option", { value: st.deviceId, key: st.deviceId }, st.label);
            }))
          )
        )
      )
    ),
    ee && pe.createElement(
      It,
      { justifyContent: "center" },
      pe.createElement("button", { className: "amplify-button amplify-field-group__control amplify-button--primary", style: {
        backgroundColor: "var(--amplify-components-button-primary-background-color) !important"
      }, type: "button", onClick: ct }, r.startScreenBeginCheckText)
    )
  );
};
function Ioe() {
  return /Macintosh/i.test(navigator.userAgent) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 1;
}
function koe() {
  var t = (
    // Test Android/iPhone/iPad
    /Android|iPhone|iPad/i.test(navigator.userAgent) || Ioe()
  );
  return t;
}
function J3() {
  return window.matchMedia("(orientation: landscape)");
}
var Eoe = function(t) {
  var e = t.onRetry, n = t.header, r = t.portraitMessage, a = t.landscapeMessage, s = t.tryAgainText, o = re.useState(!0), i = o[0], c = o[1];
  return re.useLayoutEffect(function() {
    var l = J3();
    return c(l.matches), l.addEventListener("change", function(u) {
      c(u.matches);
    }), function() {
      l.removeEventListener("change", function(u) {
        return c(u.matches);
      });
    };
  }, []), re.createElement(
    It,
    { className: Ve.LandscapeErrorModal, height: i ? "auto" : 480 },
    re.createElement(Lr, { className: Ve.LandscapeErrorModalHeader }, n),
    re.createElement(Lr, null, i ? a : r),
    i ? null : re.createElement(
      It,
      { className: Ve.LandscapeErrorModalButton },
      re.createElement(qo, { variation: "primary", type: "button", onClick: e }, s)
    )
  );
}, t0 = "liveness-detector-check", Toe = 420, Coe = function(t) {
  return t.context.isRecordingStopped;
}, Noe = function(t) {
  var e = t.instructionDisplayText, n = t.hintDisplayText, r = t.cameraDisplayText, a = t.streamDisplayText, s = t.errorDisplayText, o = t.components, i = Nf(), c = i[0], l = i[1], u = Vn(Yg), d = Vn(Coe), f = c.matches("permissionDenied"), p = koe(), h = function() {
    l({ type: "RETRY_CAMERA_CHECK" });
  }, m = r.cameraMinSpecificationsHeadingText, g = r.cameraMinSpecificationsMessageText, v = r.cameraNotFoundHeadingText, b = r.cameraNotFoundMessageText, w = r.retryCameraPermissionsText, S = a.cancelLivenessCheckText;
  re.useLayoutEffect(function() {
    if (p) {
      var E = function(R) {
        R && l({ type: "MOBILE_LANDSCAPE_WARNING" });
      }, T = J3();
      return E(T.matches), T.addEventListener("change", function(R) {
        E(R.matches);
      }), function() {
        T.removeEventListener("change", function(R) {
          return E(R.matches);
        });
      };
    }
  }, [p, l]);
  var I = function() {
    if (u === lt.MOBILE_LANDSCAPE_ERROR) {
      var E = _e(_e({}, Rf), s), T = E.landscapeHeaderText, R = E.portraitMessageText, $ = E.landscapeMessageText, D = E.tryAgainText;
      return re.createElement(
        It,
        { backgroundColor: "background.primary", direction: "column", textAlign: "center", alignItems: "center", justifyContent: "center", position: "absolute", width: "100%" },
        re.createElement(Eoe, { header: T, portraitMessage: R, landscapeMessage: $, tryAgainText: D, onRetry: function() {
          l({
            type: "CANCEL"
          });
        } })
      );
    } else
      return f ? re.createElement(
        It,
        { backgroundColor: "background.primary", direction: "column", textAlign: "center", alignItems: "center", justifyContent: "center", width: "100%", height: 480 },
        re.createElement(Lr, { fontSize: "large", fontWeight: "bold" }, u === lt.CAMERA_FRAMERATE_ERROR ? m : v),
        re.createElement(Lr, { maxWidth: Toe }, u === lt.CAMERA_FRAMERATE_ERROR ? g : b),
        re.createElement(qo, { variation: "primary", type: "button", onClick: h }, w),
        re.createElement(
          yt,
          { position: "absolute", top: "medium", right: "medium" },
          re.createElement(X3, { ariaLabel: S })
        )
      ) : re.createElement(xoe, { isMobileScreen: p, isRecordingStopped: d, instructionDisplayText: e, streamDisplayText: a, hintDisplayText: n, errorDisplayText: s, cameraDisplayText: r, components: o });
  };
  return re.createElement(It, { direction: "column", position: "relative", testId: t0, className: t0, gap: "xl" }, I());
};
function Aoe(t) {
  var e = _e(_e({}, ioe), t), n = e.a11yVideoLabelText, r = e.cameraMinSpecificationsHeadingText, a = e.cameraMinSpecificationsMessageText, s = e.cameraNotFoundHeadingText, o = e.cameraNotFoundMessageText, i = e.cancelLivenessCheckText, c = e.clientHeaderText, l = e.clientMessageText, u = e.errorLabelText, d = e.hintCanNotIdentifyText, f = e.hintCenterFaceText, p = e.hintCenterFaceInstructionText, h = e.hintFaceOffCenterText, m = e.hintConnectingText, g = e.hintFaceDetectedText, v = e.hintHoldFaceForFreshnessText, b = e.hintIlluminationNormalText, w = e.hintIlluminationTooBrightText, S = e.hintIlluminationTooDarkText, I = e.hintMoveFaceFrontOfCameraText, E = e.hintTooManyFacesText, T = e.hintTooCloseText, R = e.hintTooFarText, $ = e.hintVerifyingText, D = e.hintCheckCompleteText, M = e.hintMatchIndicatorText, z = e.faceDistanceHeaderText, F = e.faceDistanceMessageText, V = e.goodFitCaptionText, H = e.goodFitAltText, U = e.landscapeHeaderText, Z = e.landscapeMessageText, q = e.multipleFacesHeaderText, X = e.multipleFacesMessageText, se = e.photosensitivityWarningBodyText, te = e.photosensitivityWarningHeadingText, ue = e.photosensitivityWarningInfoText, ee = e.photosensitivityWarningLabelText, ne = e.photosensitivyWarningBodyText, oe = e.photosensitivyWarningHeadingText, ge = e.photosensitivyWarningInfoText, be = e.photosensitivyWarningLabelText, fe = e.portraitMessageText, we = e.retryCameraPermissionsText, Re = e.recordingIndicatorText, $e = e.serverHeaderText, Oe = e.serverMessageText, We = e.startScreenBeginCheckText, Ue = e.timeoutHeaderText, je = e.timeoutMessageText, Ne = e.tooFarCaptionText, et = e.tooFarAltText, Ye = e.tryAgainText, ct = e.waitingCameraPermissionText, at = {
    hintMoveFaceFrontOfCameraText: I,
    hintTooManyFacesText: E,
    hintFaceDetectedText: g,
    hintCanNotIdentifyText: d,
    hintTooCloseText: T,
    hintTooFarText: R,
    hintConnectingText: m,
    hintVerifyingText: $,
    hintCheckCompleteText: D,
    hintIlluminationTooBrightText: w,
    hintIlluminationTooDarkText: S,
    hintIlluminationNormalText: b,
    hintHoldFaceForFreshnessText: v,
    hintCenterFaceText: f,
    hintCenterFaceInstructionText: p,
    hintFaceOffCenterText: h,
    hintMatchIndicatorText: M
  }, Ht = {
    cameraMinSpecificationsHeadingText: r,
    cameraMinSpecificationsMessageText: a,
    cameraNotFoundHeadingText: s,
    cameraNotFoundMessageText: o,
    retryCameraPermissionsText: we,
    waitingCameraPermissionText: ct,
    a11yVideoLabelText: n
  }, st = {
    photosensitivityWarningBodyText: se,
    photosensitivityWarningHeadingText: te,
    photosensitivityWarningInfoText: ue,
    photosensitivityWarningLabelText: ee,
    photosensitivyWarningBodyText: ne,
    photosensitivyWarningHeadingText: oe,
    photosensitivyWarningInfoText: ge,
    photosensitivyWarningLabelText: be,
    goodFitCaptionText: V,
    goodFitAltText: H,
    tooFarCaptionText: Ne,
    tooFarAltText: et,
    startScreenBeginCheckText: We
  }, St = {
    cancelLivenessCheckText: i,
    recordingIndicatorText: Re
  }, Mt = {
    errorLabelText: u,
    timeoutHeaderText: Ue,
    timeoutMessageText: je,
    faceDistanceHeaderText: z,
    faceDistanceMessageText: F,
    multipleFacesHeaderText: q,
    multipleFacesMessageText: X,
    clientHeaderText: c,
    clientMessageText: l,
    serverHeaderText: $e,
    serverMessageText: Oe,
    landscapeHeaderText: U,
    landscapeMessageText: Z,
    portraitMessageText: fe,
    tryAgainText: Ye
  };
  return {
    hintDisplayText: at,
    cameraDisplayText: Ht,
    instructionDisplayText: st,
    streamDisplayText: St,
    errorDisplayText: Mt
  };
}
var n0 = "liveness-detector";
function Roe(t) {
  var e = t.components, n = t.config, r = t.displayText, a = Va(null), s = Aoe(r), o = s.hintDisplayText, i = s.cameraDisplayText, c = s.instructionDisplayText, l = s.streamDisplayText, u = s.errorDisplayText, d = OE(cte, {
    devTools: process.env.NODE_ENV === "development",
    context: {
      componentProps: _e(_e({}, t), { config: n ?? {} })
    }
  });
  return pe.createElement(
    yt,
    { className: n0, testId: n0 },
    pe.createElement(
      Yse,
      { componentProps: t, service: d },
      pe.createElement(
        It,
        { direction: "column", ref: a },
        pe.createElement(Noe, { instructionDisplayText: c, hintDisplayText: o, cameraDisplayText: i, streamDisplayText: l, errorDisplayText: u, components: e })
      )
    )
  );
}
var $oe = function() {
  return ot(void 0, void 0, void 0, function() {
    var t;
    return tt(this, function(e) {
      switch (e.label) {
        case 0:
          return [4, i0()];
        case 1:
          if (t = e.sent().credentials, !t)
            throw new Error("No credentials provided");
          return [2, t];
      }
    });
  });
};
function Poe(t) {
  var e = t.config, n = ul(t, ["config"]);
  return re.createElement(Roe, _e({}, n, { config: _e({ credentialProvider: $oe }, e) }));
}
export {
  Poe as FaceLivenessDetector,
  Roe as FaceLivenessDetectorCore
};
